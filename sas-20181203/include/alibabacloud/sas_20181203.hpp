// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_SAS20181203_H_
#define ALIBABACLOUD_SAS20181203_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Sas20181203 {
class QueryIncidentTracingSubNodesCountRequest : public Darabonba::Model {
public:
  shared_ptr<vector<vector<string>>> vertexIdAndTypeList{};

  QueryIncidentTracingSubNodesCountRequest() {}

  explicit QueryIncidentTracingSubNodesCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vertexIdAndTypeList) {
      res["VertexIdAndTypeList"] = boost::any(*vertexIdAndTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VertexIdAndTypeList") != m.end() && !m["VertexIdAndTypeList"].empty()) {
      vector<vector<string>> toVec1;
      if (typeid(vector<boost::any>) == m["VertexIdAndTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VertexIdAndTypeList"]);
        for (auto item:vec1) {
          vector<string> toVec2;
          if (typeid(vector<boost::any>) == item.type()) {
            vector<boost::any> vec2 = boost::any_cast<vector<boost::any>>(item);
            for (auto item:vec2) {
               toVec2.push_back(boost::any_cast<string>(item));
            }
          }
           toVec1 = toVec2;
        }
      }
      vertexIdAndTypeList = make_shared<vector<vector<string>>>(toVec1);
    }
  }


  virtual ~QueryIncidentTracingSubNodesCountRequest() = default;
};
class AddCheckInstanceResultWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkGroupId{};
  shared_ptr<long> checkId{};
  shared_ptr<vector<string>> instanceIds{};

  AddCheckInstanceResultWhiteListRequest() {}

  explicit AddCheckInstanceResultWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkGroupId) {
      res["CheckGroupId"] = boost::any(*checkGroupId);
    }
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckGroupId") != m.end() && !m["CheckGroupId"].empty()) {
      checkGroupId = make_shared<string>(boost::any_cast<string>(m["CheckGroupId"]));
    }
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddCheckInstanceResultWhiteListRequest() = default;
};
class AddCheckInstanceResultWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> requestId{};

  AddCheckInstanceResultWhiteListResponseBody() {}

  explicit AddCheckInstanceResultWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCheckInstanceResultWhiteListResponseBody() = default;
};
class AddCheckInstanceResultWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCheckInstanceResultWhiteListResponseBody> body{};

  AddCheckInstanceResultWhiteListResponse() {}

  explicit AddCheckInstanceResultWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCheckInstanceResultWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCheckInstanceResultWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~AddCheckInstanceResultWhiteListResponse() = default;
};
class AddCheckResultWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> checkIds{};

  AddCheckResultWhiteListRequest() {}

  explicit AddCheckResultWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkIds) {
      res["CheckIds"] = boost::any(*checkIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckIds") != m.end() && !m["CheckIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CheckIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CheckIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      checkIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~AddCheckResultWhiteListRequest() = default;
};
class AddCheckResultWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> requestId{};

  AddCheckResultWhiteListResponseBody() {}

  explicit AddCheckResultWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCheckResultWhiteListResponseBody() = default;
};
class AddCheckResultWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCheckResultWhiteListResponseBody> body{};

  AddCheckResultWhiteListResponse() {}

  explicit AddCheckResultWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCheckResultWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCheckResultWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~AddCheckResultWhiteListResponse() = default;
};
class AddClientUserDefineRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> actionType{};
  shared_ptr<string> cmdline{};
  shared_ptr<string> filePath{};
  shared_ptr<string> IP{};
  shared_ptr<string> md5List{};
  shared_ptr<string> name{};
  shared_ptr<string> newFilePath{};
  shared_ptr<string> parentCmdline{};
  shared_ptr<string> parentProcPath{};
  shared_ptr<string> platform{};
  shared_ptr<long> port{};
  shared_ptr<string> portStr{};
  shared_ptr<string> procPath{};
  shared_ptr<string> registryContent{};
  shared_ptr<string> registryKey{};
  shared_ptr<long> type{};

  AddClientUserDefineRuleRequest() {}

  explicit AddClientUserDefineRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (cmdline) {
      res["Cmdline"] = boost::any(*cmdline);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (md5List) {
      res["Md5List"] = boost::any(*md5List);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newFilePath) {
      res["NewFilePath"] = boost::any(*newFilePath);
    }
    if (parentCmdline) {
      res["ParentCmdline"] = boost::any(*parentCmdline);
    }
    if (parentProcPath) {
      res["ParentProcPath"] = boost::any(*parentProcPath);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (portStr) {
      res["PortStr"] = boost::any(*portStr);
    }
    if (procPath) {
      res["ProcPath"] = boost::any(*procPath);
    }
    if (registryContent) {
      res["RegistryContent"] = boost::any(*registryContent);
    }
    if (registryKey) {
      res["RegistryKey"] = boost::any(*registryKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<long>(boost::any_cast<long>(m["ActionType"]));
    }
    if (m.find("Cmdline") != m.end() && !m["Cmdline"].empty()) {
      cmdline = make_shared<string>(boost::any_cast<string>(m["Cmdline"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("Md5List") != m.end() && !m["Md5List"].empty()) {
      md5List = make_shared<string>(boost::any_cast<string>(m["Md5List"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewFilePath") != m.end() && !m["NewFilePath"].empty()) {
      newFilePath = make_shared<string>(boost::any_cast<string>(m["NewFilePath"]));
    }
    if (m.find("ParentCmdline") != m.end() && !m["ParentCmdline"].empty()) {
      parentCmdline = make_shared<string>(boost::any_cast<string>(m["ParentCmdline"]));
    }
    if (m.find("ParentProcPath") != m.end() && !m["ParentProcPath"].empty()) {
      parentProcPath = make_shared<string>(boost::any_cast<string>(m["ParentProcPath"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("PortStr") != m.end() && !m["PortStr"].empty()) {
      portStr = make_shared<string>(boost::any_cast<string>(m["PortStr"]));
    }
    if (m.find("ProcPath") != m.end() && !m["ProcPath"].empty()) {
      procPath = make_shared<string>(boost::any_cast<string>(m["ProcPath"]));
    }
    if (m.find("RegistryContent") != m.end() && !m["RegistryContent"].empty()) {
      registryContent = make_shared<string>(boost::any_cast<string>(m["RegistryContent"]));
    }
    if (m.find("RegistryKey") != m.end() && !m["RegistryKey"].empty()) {
      registryKey = make_shared<string>(boost::any_cast<string>(m["RegistryKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~AddClientUserDefineRuleRequest() = default;
};
class AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> platform{};
  shared_ptr<string> switchId{};

  AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult() {}

  explicit AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (switchId) {
      res["SwitchId"] = boost::any(*switchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("SwitchId") != m.end() && !m["SwitchId"].empty()) {
      switchId = make_shared<string>(boost::any_cast<string>(m["SwitchId"]));
    }
  }


  virtual ~AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult() = default;
};
class AddClientUserDefineRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult> userDefineRuleAddResult{};

  AddClientUserDefineRuleResponseBody() {}

  explicit AddClientUserDefineRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userDefineRuleAddResult) {
      res["UserDefineRuleAddResult"] = userDefineRuleAddResult ? boost::any(userDefineRuleAddResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserDefineRuleAddResult") != m.end() && !m["UserDefineRuleAddResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserDefineRuleAddResult"].type()) {
        AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserDefineRuleAddResult"]));
        userDefineRuleAddResult = make_shared<AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult>(model1);
      }
    }
  }


  virtual ~AddClientUserDefineRuleResponseBody() = default;
};
class AddClientUserDefineRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddClientUserDefineRuleResponseBody> body{};

  AddClientUserDefineRuleResponse() {}

  explicit AddClientUserDefineRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddClientUserDefineRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddClientUserDefineRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddClientUserDefineRuleResponse() = default;
};
class AddInstallCodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> expiredDate{};
  shared_ptr<long> groupId{};
  shared_ptr<bool> onlyImage{};
  shared_ptr<string> os{};
  shared_ptr<string> vendorName{};

  AddInstallCodeRequest() {}

  explicit AddInstallCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiredDate) {
      res["ExpiredDate"] = boost::any(*expiredDate);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (onlyImage) {
      res["OnlyImage"] = boost::any(*onlyImage);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiredDate") != m.end() && !m["ExpiredDate"].empty()) {
      expiredDate = make_shared<long>(boost::any_cast<long>(m["ExpiredDate"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("OnlyImage") != m.end() && !m["OnlyImage"].empty()) {
      onlyImage = make_shared<bool>(boost::any_cast<bool>(m["OnlyImage"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
  }


  virtual ~AddInstallCodeRequest() = default;
};
class AddInstallCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddInstallCodeResponseBody() {}

  explicit AddInstallCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddInstallCodeResponseBody() = default;
};
class AddInstallCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddInstallCodeResponseBody> body{};

  AddInstallCodeResponse() {}

  explicit AddInstallCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddInstallCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddInstallCodeResponseBody>(model1);
      }
    }
  }


  virtual ~AddInstallCodeResponse() = default;
};
class AddPrivateRegistryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> extraParam{};
  shared_ptr<long> netType{};
  shared_ptr<string> password{};
  shared_ptr<long> protocolType{};
  shared_ptr<string> registryHostIp{};
  shared_ptr<string> registryRegionId{};
  shared_ptr<string> registryType{};
  shared_ptr<string> registryVersion{};
  shared_ptr<long> transPerHour{};
  shared_ptr<string> userName{};
  shared_ptr<string> vpcId{};

  AddPrivateRegistryRequest() {}

  explicit AddPrivateRegistryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (extraParam) {
      res["ExtraParam"] = boost::any(*extraParam);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (registryHostIp) {
      res["RegistryHostIp"] = boost::any(*registryHostIp);
    }
    if (registryRegionId) {
      res["RegistryRegionId"] = boost::any(*registryRegionId);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (registryVersion) {
      res["RegistryVersion"] = boost::any(*registryVersion);
    }
    if (transPerHour) {
      res["TransPerHour"] = boost::any(*transPerHour);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ExtraParam") != m.end() && !m["ExtraParam"].empty()) {
      extraParam = make_shared<string>(boost::any_cast<string>(m["ExtraParam"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<long>(boost::any_cast<long>(m["NetType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<long>(boost::any_cast<long>(m["ProtocolType"]));
    }
    if (m.find("RegistryHostIp") != m.end() && !m["RegistryHostIp"].empty()) {
      registryHostIp = make_shared<string>(boost::any_cast<string>(m["RegistryHostIp"]));
    }
    if (m.find("RegistryRegionId") != m.end() && !m["RegistryRegionId"].empty()) {
      registryRegionId = make_shared<string>(boost::any_cast<string>(m["RegistryRegionId"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("RegistryVersion") != m.end() && !m["RegistryVersion"].empty()) {
      registryVersion = make_shared<string>(boost::any_cast<string>(m["RegistryVersion"]));
    }
    if (m.find("TransPerHour") != m.end() && !m["TransPerHour"].empty()) {
      transPerHour = make_shared<long>(boost::any_cast<long>(m["TransPerHour"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AddPrivateRegistryRequest() = default;
};
class AddPrivateRegistryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> domainName{};
  shared_ptr<long> id{};
  shared_ptr<long> netType{};
  shared_ptr<string> password{};
  shared_ptr<long> protocolType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> registryHostIp{};
  shared_ptr<string> registryType{};
  shared_ptr<string> registryVersion{};
  shared_ptr<string> token{};
  shared_ptr<long> transPerHour{};
  shared_ptr<string> userName{};
  shared_ptr<string> vpcId{};

  AddPrivateRegistryResponseBodyData() {}

  explicit AddPrivateRegistryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (registryHostIp) {
      res["RegistryHostIp"] = boost::any(*registryHostIp);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (registryVersion) {
      res["RegistryVersion"] = boost::any(*registryVersion);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (transPerHour) {
      res["TransPerHour"] = boost::any(*transPerHour);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<long>(boost::any_cast<long>(m["NetType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<long>(boost::any_cast<long>(m["ProtocolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegistryHostIp") != m.end() && !m["RegistryHostIp"].empty()) {
      registryHostIp = make_shared<string>(boost::any_cast<string>(m["RegistryHostIp"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("RegistryVersion") != m.end() && !m["RegistryVersion"].empty()) {
      registryVersion = make_shared<string>(boost::any_cast<string>(m["RegistryVersion"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("TransPerHour") != m.end() && !m["TransPerHour"].empty()) {
      transPerHour = make_shared<long>(boost::any_cast<long>(m["TransPerHour"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AddPrivateRegistryResponseBodyData() = default;
};
class AddPrivateRegistryResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddPrivateRegistryResponseBodyData> data{};
  shared_ptr<string> requestId{};

  AddPrivateRegistryResponseBody() {}

  explicit AddPrivateRegistryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddPrivateRegistryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddPrivateRegistryResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPrivateRegistryResponseBody() = default;
};
class AddPrivateRegistryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPrivateRegistryResponseBody> body{};

  AddPrivateRegistryResponse() {}

  explicit AddPrivateRegistryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPrivateRegistryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPrivateRegistryResponseBody>(model1);
      }
    }
  }


  virtual ~AddPrivateRegistryResponse() = default;
};
class AddTagWithUuidRequest : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> uuidList{};

  AddTagWithUuidRequest() {}

  explicit AddTagWithUuidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      uuidList = make_shared<string>(boost::any_cast<string>(m["UuidList"]));
    }
  }


  virtual ~AddTagWithUuidRequest() = default;
};
class AddTagWithUuidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddTagWithUuidResponseBody() {}

  explicit AddTagWithUuidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddTagWithUuidResponseBody() = default;
};
class AddTagWithUuidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTagWithUuidResponseBody> body{};

  AddTagWithUuidResponse() {}

  explicit AddTagWithUuidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTagWithUuidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTagWithUuidResponseBody>(model1);
      }
    }
  }


  virtual ~AddTagWithUuidResponse() = default;
};
class AddUninstallClientsByUuidsRequest : public Darabonba::Model {
public:
  shared_ptr<string> callMethod{};
  shared_ptr<string> feedback{};
  shared_ptr<string> region{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuids{};

  AddUninstallClientsByUuidsRequest() {}

  explicit AddUninstallClientsByUuidsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callMethod) {
      res["CallMethod"] = boost::any(*callMethod);
    }
    if (feedback) {
      res["Feedback"] = boost::any(*feedback);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallMethod") != m.end() && !m["CallMethod"].empty()) {
      callMethod = make_shared<string>(boost::any_cast<string>(m["CallMethod"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["Feedback"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~AddUninstallClientsByUuidsRequest() = default;
};
class AddUninstallClientsByUuidsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddUninstallClientsByUuidsResponseBody() {}

  explicit AddUninstallClientsByUuidsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddUninstallClientsByUuidsResponseBody() = default;
};
class AddUninstallClientsByUuidsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddUninstallClientsByUuidsResponseBody> body{};

  AddUninstallClientsByUuidsResponse() {}

  explicit AddUninstallClientsByUuidsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddUninstallClientsByUuidsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddUninstallClientsByUuidsResponseBody>(model1);
      }
    }
  }


  virtual ~AddUninstallClientsByUuidsResponse() = default;
};
class AddVpcHoneyPotRequest : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};

  AddVpcHoneyPotRequest() {}

  explicit AddVpcHoneyPotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~AddVpcHoneyPotRequest() = default;
};
class AddVpcHoneyPotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddVpcHoneyPotResponseBody() {}

  explicit AddVpcHoneyPotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddVpcHoneyPotResponseBody() = default;
};
class AddVpcHoneyPotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddVpcHoneyPotResponseBody> body{};

  AddVpcHoneyPotResponse() {}

  explicit AddVpcHoneyPotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddVpcHoneyPotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddVpcHoneyPotResponseBody>(model1);
      }
    }
  }


  virtual ~AddVpcHoneyPotResponse() = default;
};
class AdvanceSecurityEventOperationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> ruleId{};

  AdvanceSecurityEventOperationsRequest() {}

  explicit AdvanceSecurityEventOperationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~AdvanceSecurityEventOperationsRequest() = default;
};
class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField : public Darabonba::Model {
public:
  shared_ptr<string> filedAliasName{};
  shared_ptr<string> filedName{};
  shared_ptr<string> markMisType{};
  shared_ptr<string> markMisValue{};
  shared_ptr<vector<string>> supportedMisType{};

  AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField() {}

  explicit AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filedAliasName) {
      res["FiledAliasName"] = boost::any(*filedAliasName);
    }
    if (filedName) {
      res["FiledName"] = boost::any(*filedName);
    }
    if (markMisType) {
      res["MarkMisType"] = boost::any(*markMisType);
    }
    if (markMisValue) {
      res["MarkMisValue"] = boost::any(*markMisValue);
    }
    if (supportedMisType) {
      res["SupportedMisType"] = boost::any(*supportedMisType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FiledAliasName") != m.end() && !m["FiledAliasName"].empty()) {
      filedAliasName = make_shared<string>(boost::any_cast<string>(m["FiledAliasName"]));
    }
    if (m.find("FiledName") != m.end() && !m["FiledName"].empty()) {
      filedName = make_shared<string>(boost::any_cast<string>(m["FiledName"]));
    }
    if (m.find("MarkMisType") != m.end() && !m["MarkMisType"].empty()) {
      markMisType = make_shared<string>(boost::any_cast<string>(m["MarkMisType"]));
    }
    if (m.find("MarkMisValue") != m.end() && !m["MarkMisValue"].empty()) {
      markMisValue = make_shared<string>(boost::any_cast<string>(m["MarkMisValue"]));
    }
    if (m.find("SupportedMisType") != m.end() && !m["SupportedMisType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedMisType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedMisType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedMisType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField() = default;
};
class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource : public Darabonba::Model {
public:
  shared_ptr<string> filedAliasName{};
  shared_ptr<string> filedName{};
  shared_ptr<string> markMisValue{};
  shared_ptr<vector<string>> supportedMisType{};

  AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource() {}

  explicit AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filedAliasName) {
      res["FiledAliasName"] = boost::any(*filedAliasName);
    }
    if (filedName) {
      res["FiledName"] = boost::any(*filedName);
    }
    if (markMisValue) {
      res["MarkMisValue"] = boost::any(*markMisValue);
    }
    if (supportedMisType) {
      res["SupportedMisType"] = boost::any(*supportedMisType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FiledAliasName") != m.end() && !m["FiledAliasName"].empty()) {
      filedAliasName = make_shared<string>(boost::any_cast<string>(m["FiledAliasName"]));
    }
    if (m.find("FiledName") != m.end() && !m["FiledName"].empty()) {
      filedName = make_shared<string>(boost::any_cast<string>(m["FiledName"]));
    }
    if (m.find("MarkMisValue") != m.end() && !m["MarkMisValue"].empty()) {
      markMisValue = make_shared<string>(boost::any_cast<string>(m["MarkMisValue"]));
    }
    if (m.find("SupportedMisType") != m.end() && !m["SupportedMisType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedMisType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedMisType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedMisType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource() = default;
};
class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse : public Darabonba::Model {
public:
  shared_ptr<vector<AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField>> markField{};
  shared_ptr<vector<AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource>> markFieldsSource{};
  shared_ptr<string> operationCode{};
  shared_ptr<string> operationParams{};
  shared_ptr<bool> userCanOperate{};

  AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse() {}

  explicit AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (markField) {
      vector<boost::any> temp1;
      for(auto item1:*markField){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MarkField"] = boost::any(temp1);
    }
    if (markFieldsSource) {
      vector<boost::any> temp1;
      for(auto item1:*markFieldsSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MarkFieldsSource"] = boost::any(temp1);
    }
    if (operationCode) {
      res["OperationCode"] = boost::any(*operationCode);
    }
    if (operationParams) {
      res["OperationParams"] = boost::any(*operationParams);
    }
    if (userCanOperate) {
      res["UserCanOperate"] = boost::any(*userCanOperate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MarkField") != m.end() && !m["MarkField"].empty()) {
      if (typeid(vector<boost::any>) == m["MarkField"].type()) {
        vector<AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MarkField"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        markField = make_shared<vector<AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField>>(expect1);
      }
    }
    if (m.find("MarkFieldsSource") != m.end() && !m["MarkFieldsSource"].empty()) {
      if (typeid(vector<boost::any>) == m["MarkFieldsSource"].type()) {
        vector<AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MarkFieldsSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        markFieldsSource = make_shared<vector<AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource>>(expect1);
      }
    }
    if (m.find("OperationCode") != m.end() && !m["OperationCode"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["OperationCode"]));
    }
    if (m.find("OperationParams") != m.end() && !m["OperationParams"].empty()) {
      operationParams = make_shared<string>(boost::any_cast<string>(m["OperationParams"]));
    }
    if (m.find("UserCanOperate") != m.end() && !m["UserCanOperate"].empty()) {
      userCanOperate = make_shared<bool>(boost::any_cast<bool>(m["UserCanOperate"]));
    }
  }


  virtual ~AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse() = default;
};
class AdvanceSecurityEventOperationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse>> securityEventOperationsResponse{};

  AdvanceSecurityEventOperationsResponseBody() {}

  explicit AdvanceSecurityEventOperationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEventOperationsResponse) {
      vector<boost::any> temp1;
      for(auto item1:*securityEventOperationsResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityEventOperationsResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEventOperationsResponse") != m.end() && !m["SecurityEventOperationsResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityEventOperationsResponse"].type()) {
        vector<AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityEventOperationsResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityEventOperationsResponse = make_shared<vector<AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse>>(expect1);
      }
    }
  }


  virtual ~AdvanceSecurityEventOperationsResponseBody() = default;
};
class AdvanceSecurityEventOperationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AdvanceSecurityEventOperationsResponseBody> body{};

  AdvanceSecurityEventOperationsResponse() {}

  explicit AdvanceSecurityEventOperationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AdvanceSecurityEventOperationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AdvanceSecurityEventOperationsResponseBody>(model1);
      }
    }
  }


  virtual ~AdvanceSecurityEventOperationsResponse() = default;
};
class BatchOperateCommonOverallConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<vector<string>> typeList{};

  BatchOperateCommonOverallConfigRequest() {}

  explicit BatchOperateCommonOverallConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (typeList) {
      res["TypeList"] = boost::any(*typeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("TypeList") != m.end() && !m["TypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      typeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchOperateCommonOverallConfigRequest() = default;
};
class BatchOperateCommonOverallConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchOperateCommonOverallConfigResponseBody() {}

  explicit BatchOperateCommonOverallConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchOperateCommonOverallConfigResponseBody() = default;
};
class BatchOperateCommonOverallConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchOperateCommonOverallConfigResponseBody> body{};

  BatchOperateCommonOverallConfigResponse() {}

  explicit BatchOperateCommonOverallConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchOperateCommonOverallConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchOperateCommonOverallConfigResponseBody>(model1);
      }
    }
  }


  virtual ~BatchOperateCommonOverallConfigResponse() = default;
};
class BindAuthToMachineRequest : public Darabonba::Model {
public:
  shared_ptr<long> authVersion{};
  shared_ptr<long> autoBind{};
  shared_ptr<vector<string>> bind{};
  shared_ptr<bool> bindAll{};
  shared_ptr<string> criteria{};
  shared_ptr<string> logicalExp{};
  shared_ptr<vector<string>> unBind{};

  BindAuthToMachineRequest() {}

  explicit BindAuthToMachineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authVersion) {
      res["AuthVersion"] = boost::any(*authVersion);
    }
    if (autoBind) {
      res["AutoBind"] = boost::any(*autoBind);
    }
    if (bind) {
      res["Bind"] = boost::any(*bind);
    }
    if (bindAll) {
      res["BindAll"] = boost::any(*bindAll);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (logicalExp) {
      res["LogicalExp"] = boost::any(*logicalExp);
    }
    if (unBind) {
      res["UnBind"] = boost::any(*unBind);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthVersion") != m.end() && !m["AuthVersion"].empty()) {
      authVersion = make_shared<long>(boost::any_cast<long>(m["AuthVersion"]));
    }
    if (m.find("AutoBind") != m.end() && !m["AutoBind"].empty()) {
      autoBind = make_shared<long>(boost::any_cast<long>(m["AutoBind"]));
    }
    if (m.find("Bind") != m.end() && !m["Bind"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Bind"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Bind"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bind = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BindAll") != m.end() && !m["BindAll"].empty()) {
      bindAll = make_shared<bool>(boost::any_cast<bool>(m["BindAll"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("LogicalExp") != m.end() && !m["LogicalExp"].empty()) {
      logicalExp = make_shared<string>(boost::any_cast<string>(m["LogicalExp"]));
    }
    if (m.find("UnBind") != m.end() && !m["UnBind"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UnBind"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UnBind"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      unBind = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BindAuthToMachineRequest() = default;
};
class BindAuthToMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> bindCount{};
  shared_ptr<long> insufficientCoreCount{};
  shared_ptr<long> insufficientEcsCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> resultCode{};
  shared_ptr<long> unBindCount{};

  BindAuthToMachineResponseBody() {}

  explicit BindAuthToMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindCount) {
      res["BindCount"] = boost::any(*bindCount);
    }
    if (insufficientCoreCount) {
      res["InsufficientCoreCount"] = boost::any(*insufficientCoreCount);
    }
    if (insufficientEcsCount) {
      res["InsufficientEcsCount"] = boost::any(*insufficientEcsCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (unBindCount) {
      res["UnBindCount"] = boost::any(*unBindCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindCount") != m.end() && !m["BindCount"].empty()) {
      bindCount = make_shared<long>(boost::any_cast<long>(m["BindCount"]));
    }
    if (m.find("InsufficientCoreCount") != m.end() && !m["InsufficientCoreCount"].empty()) {
      insufficientCoreCount = make_shared<long>(boost::any_cast<long>(m["InsufficientCoreCount"]));
    }
    if (m.find("InsufficientEcsCount") != m.end() && !m["InsufficientEcsCount"].empty()) {
      insufficientEcsCount = make_shared<long>(boost::any_cast<long>(m["InsufficientEcsCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<long>(boost::any_cast<long>(m["ResultCode"]));
    }
    if (m.find("UnBindCount") != m.end() && !m["UnBindCount"].empty()) {
      unBindCount = make_shared<long>(boost::any_cast<long>(m["UnBindCount"]));
    }
  }


  virtual ~BindAuthToMachineResponseBody() = default;
};
class BindAuthToMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindAuthToMachineResponseBody> body{};

  BindAuthToMachineResponse() {}

  explicit BindAuthToMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindAuthToMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindAuthToMachineResponseBody>(model1);
      }
    }
  }


  virtual ~BindAuthToMachineResponse() = default;
};
class CancelOnceTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  CancelOnceTaskRequest() {}

  explicit CancelOnceTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CancelOnceTaskRequest() = default;
};
class CancelOnceTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelOnceTaskResponseBody() {}

  explicit CancelOnceTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelOnceTaskResponseBody() = default;
};
class CancelOnceTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelOnceTaskResponseBody> body{};

  CancelOnceTaskResponse() {}

  explicit CancelOnceTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelOnceTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelOnceTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CancelOnceTaskResponse() = default;
};
class ChangeCheckConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<long>> standardIds{};
  shared_ptr<long> startTime{};

  ChangeCheckConfigRequest() {}

  explicit ChangeCheckConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (standardIds) {
      res["StandardIds"] = boost::any(*standardIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StandardIds") != m.end() && !m["StandardIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StandardIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StandardIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      standardIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ChangeCheckConfigRequest() = default;
};
class ChangeCheckConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ChangeCheckConfigResponseBody() {}

  explicit ChangeCheckConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeCheckConfigResponseBody() = default;
};
class ChangeCheckConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeCheckConfigResponseBody> body{};

  ChangeCheckConfigResponse() {}

  explicit ChangeCheckConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeCheckConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeCheckConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeCheckConfigResponse() = default;
};
class ChangeCheckCustomConfigRequestCustomConfigs : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> operation{};
  shared_ptr<string> value{};

  ChangeCheckCustomConfigRequestCustomConfigs() {}

  explicit ChangeCheckCustomConfigRequestCustomConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ChangeCheckCustomConfigRequestCustomConfigs() = default;
};
class ChangeCheckCustomConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<vector<ChangeCheckCustomConfigRequestCustomConfigs>> customConfigs{};
  shared_ptr<string> regionId{};

  ChangeCheckCustomConfigRequest() {}

  explicit ChangeCheckCustomConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (customConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*customConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomConfigs"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("CustomConfigs") != m.end() && !m["CustomConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomConfigs"].type()) {
        vector<ChangeCheckCustomConfigRequestCustomConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChangeCheckCustomConfigRequestCustomConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customConfigs = make_shared<vector<ChangeCheckCustomConfigRequestCustomConfigs>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ChangeCheckCustomConfigRequest() = default;
};
class ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs() {}

  explicit ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs() = default;
};
class ChangeCheckCustomConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs>> illegalCustomConfigs{};
  shared_ptr<string> requestId{};

  ChangeCheckCustomConfigResponseBody() {}

  explicit ChangeCheckCustomConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (illegalCustomConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*illegalCustomConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IllegalCustomConfigs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IllegalCustomConfigs") != m.end() && !m["IllegalCustomConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["IllegalCustomConfigs"].type()) {
        vector<ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IllegalCustomConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        illegalCustomConfigs = make_shared<vector<ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeCheckCustomConfigResponseBody() = default;
};
class ChangeCheckCustomConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeCheckCustomConfigResponseBody> body{};

  ChangeCheckCustomConfigResponse() {}

  explicit ChangeCheckCustomConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeCheckCustomConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeCheckCustomConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeCheckCustomConfigResponse() = default;
};
class CheckQuaraFileIdRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> quaraFileIds{};
  shared_ptr<string> uuid{};

  CheckQuaraFileIdRequest() {}

  explicit CheckQuaraFileIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (quaraFileIds) {
      res["QuaraFileIds"] = boost::any(*quaraFileIds);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QuaraFileIds") != m.end() && !m["QuaraFileIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QuaraFileIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QuaraFileIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      quaraFileIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~CheckQuaraFileIdRequest() = default;
};
class CheckQuaraFileIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CheckQuaraFileIdResponseBody() {}

  explicit CheckQuaraFileIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckQuaraFileIdResponseBody() = default;
};
class CheckQuaraFileIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckQuaraFileIdResponseBody> body{};

  CheckQuaraFileIdResponse() {}

  explicit CheckQuaraFileIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckQuaraFileIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckQuaraFileIdResponseBody>(model1);
      }
    }
  }


  virtual ~CheckQuaraFileIdResponse() = default;
};
class CheckSecurityEventIdRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> securityEventIds{};
  shared_ptr<string> uuid{};

  CheckSecurityEventIdRequest() {}

  explicit CheckSecurityEventIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityEventIds) {
      res["SecurityEventIds"] = boost::any(*securityEventIds);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityEventIds") != m.end() && !m["SecurityEventIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityEventIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityEventIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityEventIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~CheckSecurityEventIdRequest() = default;
};
class CheckSecurityEventIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CheckSecurityEventIdResponseBody() {}

  explicit CheckSecurityEventIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckSecurityEventIdResponseBody() = default;
};
class CheckSecurityEventIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckSecurityEventIdResponseBody> body{};

  CheckSecurityEventIdResponse() {}

  explicit CheckSecurityEventIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckSecurityEventIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckSecurityEventIdResponseBody>(model1);
      }
    }
  }


  virtual ~CheckSecurityEventIdResponse() = default;
};
class CheckUserHasEcsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  CheckUserHasEcsRequest() {}

  explicit CheckUserHasEcsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~CheckUserHasEcsRequest() = default;
};
class CheckUserHasEcsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CheckUserHasEcsResponseBody() {}

  explicit CheckUserHasEcsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckUserHasEcsResponseBody() = default;
};
class CheckUserHasEcsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckUserHasEcsResponseBody> body{};

  CheckUserHasEcsResponse() {}

  explicit CheckUserHasEcsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckUserHasEcsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckUserHasEcsResponseBody>(model1);
      }
    }
  }


  virtual ~CheckUserHasEcsResponse() = default;
};
class ConfirmVirusEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> operationAll{};
  shared_ptr<string> operationCode{};
  shared_ptr<string> operationRange{};

  ConfirmVirusEventsRequest() {}

  explicit ConfirmVirusEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationAll) {
      res["OperationAll"] = boost::any(*operationAll);
    }
    if (operationCode) {
      res["OperationCode"] = boost::any(*operationCode);
    }
    if (operationRange) {
      res["OperationRange"] = boost::any(*operationRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationAll") != m.end() && !m["OperationAll"].empty()) {
      operationAll = make_shared<long>(boost::any_cast<long>(m["OperationAll"]));
    }
    if (m.find("OperationCode") != m.end() && !m["OperationCode"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["OperationCode"]));
    }
    if (m.find("OperationRange") != m.end() && !m["OperationRange"].empty()) {
      operationRange = make_shared<string>(boost::any_cast<string>(m["OperationRange"]));
    }
  }


  virtual ~ConfirmVirusEventsRequest() = default;
};
class ConfirmVirusEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ConfirmVirusEventsResponseBody() {}

  explicit ConfirmVirusEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ConfirmVirusEventsResponseBody() = default;
};
class ConfirmVirusEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmVirusEventsResponseBody> body{};

  ConfirmVirusEventsResponse() {}

  explicit ConfirmVirusEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmVirusEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmVirusEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmVirusEventsResponse() = default;
};
class CreateAntiBruteForceRuleRequest : public Darabonba::Model {
public:
  shared_ptr<bool> defaultRule{};
  shared_ptr<long> failCount{};
  shared_ptr<long> forbiddenTime{};
  shared_ptr<string> name{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> span{};
  shared_ptr<vector<string>> uuidList{};

  CreateAntiBruteForceRuleRequest() {}

  explicit CreateAntiBruteForceRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultRule) {
      res["DefaultRule"] = boost::any(*defaultRule);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (forbiddenTime) {
      res["ForbiddenTime"] = boost::any(*forbiddenTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (span) {
      res["Span"] = boost::any(*span);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultRule") != m.end() && !m["DefaultRule"].empty()) {
      defaultRule = make_shared<bool>(boost::any_cast<bool>(m["DefaultRule"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("ForbiddenTime") != m.end() && !m["ForbiddenTime"].empty()) {
      forbiddenTime = make_shared<long>(boost::any_cast<long>(m["ForbiddenTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Span") != m.end() && !m["Span"].empty()) {
      span = make_shared<long>(boost::any_cast<long>(m["Span"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateAntiBruteForceRuleRequest() = default;
};
class CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};

  CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule() {}

  explicit CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule() = default;
};
class CreateAntiBruteForceRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule> createAntiBruteForceRule{};
  shared_ptr<string> requestId{};

  CreateAntiBruteForceRuleResponseBody() {}

  explicit CreateAntiBruteForceRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createAntiBruteForceRule) {
      res["CreateAntiBruteForceRule"] = createAntiBruteForceRule ? boost::any(createAntiBruteForceRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateAntiBruteForceRule") != m.end() && !m["CreateAntiBruteForceRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateAntiBruteForceRule"].type()) {
        CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateAntiBruteForceRule"]));
        createAntiBruteForceRule = make_shared<CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAntiBruteForceRuleResponseBody() = default;
};
class CreateAntiBruteForceRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntiBruteForceRuleResponseBody> body{};

  CreateAntiBruteForceRuleResponse() {}

  explicit CreateAntiBruteForceRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntiBruteForceRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntiBruteForceRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntiBruteForceRuleResponse() = default;
};
class CreateBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> policy{};
  shared_ptr<string> policyRegionId{};
  shared_ptr<string> policyVersion{};
  shared_ptr<vector<string>> uuidList{};

  CreateBackupPolicyRequest() {}

  explicit CreateBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (policyRegionId) {
      res["PolicyRegionId"] = boost::any(*policyRegionId);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Policy"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      policy = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("PolicyRegionId") != m.end() && !m["PolicyRegionId"].empty()) {
      policyRegionId = make_shared<string>(boost::any_cast<string>(m["PolicyRegionId"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateBackupPolicyRequest() = default;
};
class CreateBackupPolicyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> policyShrink{};
  shared_ptr<string> policyRegionId{};
  shared_ptr<string> policyVersion{};
  shared_ptr<vector<string>> uuidList{};

  CreateBackupPolicyShrinkRequest() {}

  explicit CreateBackupPolicyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policyShrink) {
      res["Policy"] = boost::any(*policyShrink);
    }
    if (policyRegionId) {
      res["PolicyRegionId"] = boost::any(*policyRegionId);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policyShrink = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PolicyRegionId") != m.end() && !m["PolicyRegionId"].empty()) {
      policyRegionId = make_shared<string>(boost::any_cast<string>(m["PolicyRegionId"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateBackupPolicyShrinkRequest() = default;
};
class CreateBackupPolicyResponseBodyBackupPolicy : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> status{};

  CreateBackupPolicyResponseBodyBackupPolicy() {}

  explicit CreateBackupPolicyResponseBodyBackupPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateBackupPolicyResponseBodyBackupPolicy() = default;
};
class CreateBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateBackupPolicyResponseBodyBackupPolicy> backupPolicy{};
  shared_ptr<string> requestId{};

  CreateBackupPolicyResponseBody() {}

  explicit CreateBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupPolicy) {
      res["BackupPolicy"] = backupPolicy ? boost::any(backupPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupPolicy") != m.end() && !m["BackupPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackupPolicy"].type()) {
        CreateBackupPolicyResponseBodyBackupPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackupPolicy"]));
        backupPolicy = make_shared<CreateBackupPolicyResponseBodyBackupPolicy>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBackupPolicyResponseBody() = default;
};
class CreateBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBackupPolicyResponseBody> body{};

  CreateBackupPolicyResponse() {}

  explicit CreateBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBackupPolicyResponse() = default;
};
class CreateContainerScanTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerIds{};
  shared_ptr<string> lang{};

  CreateContainerScanTaskRequest() {}

  explicit CreateContainerScanTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerIds) {
      res["ContainerIds"] = boost::any(*containerIds);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerIds") != m.end() && !m["ContainerIds"].empty()) {
      containerIds = make_shared<string>(boost::any_cast<string>(m["ContainerIds"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~CreateContainerScanTaskRequest() = default;
};
class CreateContainerScanTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> canCreate{};
  shared_ptr<long> collectTime{};
  shared_ptr<long> execTime{};
  shared_ptr<long> finishCount{};
  shared_ptr<long> progress{};
  shared_ptr<string> result{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<long> totalCount{};

  CreateContainerScanTaskResponseBodyData() {}

  explicit CreateContainerScanTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canCreate) {
      res["CanCreate"] = boost::any(*canCreate);
    }
    if (collectTime) {
      res["CollectTime"] = boost::any(*collectTime);
    }
    if (execTime) {
      res["ExecTime"] = boost::any(*execTime);
    }
    if (finishCount) {
      res["FinishCount"] = boost::any(*finishCount);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanCreate") != m.end() && !m["CanCreate"].empty()) {
      canCreate = make_shared<bool>(boost::any_cast<bool>(m["CanCreate"]));
    }
    if (m.find("CollectTime") != m.end() && !m["CollectTime"].empty()) {
      collectTime = make_shared<long>(boost::any_cast<long>(m["CollectTime"]));
    }
    if (m.find("ExecTime") != m.end() && !m["ExecTime"].empty()) {
      execTime = make_shared<long>(boost::any_cast<long>(m["ExecTime"]));
    }
    if (m.find("FinishCount") != m.end() && !m["FinishCount"].empty()) {
      finishCount = make_shared<long>(boost::any_cast<long>(m["FinishCount"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateContainerScanTaskResponseBodyData() = default;
};
class CreateContainerScanTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateContainerScanTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};

  CreateContainerScanTaskResponseBody() {}

  explicit CreateContainerScanTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateContainerScanTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateContainerScanTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateContainerScanTaskResponseBody() = default;
};
class CreateContainerScanTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateContainerScanTaskResponseBody> body{};

  CreateContainerScanTaskResponse() {}

  explicit CreateContainerScanTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateContainerScanTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateContainerScanTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateContainerScanTaskResponse() = default;
};
class CreateCustomBlockRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> blockIp{};
  shared_ptr<string> bound{};
  shared_ptr<long> expireTime{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuids{};

  CreateCustomBlockRecordRequest() {}

  explicit CreateCustomBlockRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockIp) {
      res["BlockIp"] = boost::any(*blockIp);
    }
    if (bound) {
      res["Bound"] = boost::any(*bound);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockIp") != m.end() && !m["BlockIp"].empty()) {
      blockIp = make_shared<string>(boost::any_cast<string>(m["BlockIp"]));
    }
    if (m.find("Bound") != m.end() && !m["Bound"].empty()) {
      bound = make_shared<string>(boost::any_cast<string>(m["Bound"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~CreateCustomBlockRecordRequest() = default;
};
class CreateCustomBlockRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateCustomBlockRecordResponseBody() {}

  explicit CreateCustomBlockRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomBlockRecordResponseBody() = default;
};
class CreateCustomBlockRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomBlockRecordResponseBody> body{};

  CreateCustomBlockRecordResponse() {}

  explicit CreateCustomBlockRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomBlockRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomBlockRecordResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomBlockRecordResponse() = default;
};
class CreateCycleTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> enable{};
  shared_ptr<long> firstDateStr{};
  shared_ptr<long> intervalPeriod{};
  shared_ptr<string> param{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> source{};
  shared_ptr<long> targetEndTime{};
  shared_ptr<long> targetStartTime{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};

  CreateCycleTaskRequest() {}

  explicit CreateCycleTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (firstDateStr) {
      res["FirstDateStr"] = boost::any(*firstDateStr);
    }
    if (intervalPeriod) {
      res["IntervalPeriod"] = boost::any(*intervalPeriod);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (targetEndTime) {
      res["TargetEndTime"] = boost::any(*targetEndTime);
    }
    if (targetStartTime) {
      res["TargetStartTime"] = boost::any(*targetStartTime);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<long>(boost::any_cast<long>(m["Enable"]));
    }
    if (m.find("FirstDateStr") != m.end() && !m["FirstDateStr"].empty()) {
      firstDateStr = make_shared<long>(boost::any_cast<long>(m["FirstDateStr"]));
    }
    if (m.find("IntervalPeriod") != m.end() && !m["IntervalPeriod"].empty()) {
      intervalPeriod = make_shared<long>(boost::any_cast<long>(m["IntervalPeriod"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TargetEndTime") != m.end() && !m["TargetEndTime"].empty()) {
      targetEndTime = make_shared<long>(boost::any_cast<long>(m["TargetEndTime"]));
    }
    if (m.find("TargetStartTime") != m.end() && !m["TargetStartTime"].empty()) {
      targetStartTime = make_shared<long>(boost::any_cast<long>(m["TargetStartTime"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~CreateCycleTaskRequest() = default;
};
class CreateCycleTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateCycleTaskResponseBody() {}

  explicit CreateCycleTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCycleTaskResponseBody() = default;
};
class CreateCycleTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCycleTaskResponseBody> body{};

  CreateCycleTaskResponse() {}

  explicit CreateCycleTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCycleTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCycleTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCycleTaskResponse() = default;
};
class CreateFileDetectRequest : public Darabonba::Model {
public:
  shared_ptr<string> hashKey{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> type{};

  CreateFileDetectRequest() {}

  explicit CreateFileDetectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hashKey) {
      res["HashKey"] = boost::any(*hashKey);
    }
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HashKey") != m.end() && !m["HashKey"].empty()) {
      hashKey = make_shared<string>(boost::any_cast<string>(m["HashKey"]));
    }
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CreateFileDetectRequest() = default;
};
class CreateFileDetectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> hashKey{};
  shared_ptr<string> requestId{};

  CreateFileDetectResponseBody() {}

  explicit CreateFileDetectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hashKey) {
      res["HashKey"] = boost::any(*hashKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HashKey") != m.end() && !m["HashKey"].empty()) {
      hashKey = make_shared<string>(boost::any_cast<string>(m["HashKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateFileDetectResponseBody() = default;
};
class CreateFileDetectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFileDetectResponseBody> body{};

  CreateFileDetectResponse() {}

  explicit CreateFileDetectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFileDetectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFileDetectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFileDetectResponse() = default;
};
class CreateFileDetectUploadUrlRequestHashKeyContextList : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> hashKey{};

  CreateFileDetectUploadUrlRequestHashKeyContextList() {}

  explicit CreateFileDetectUploadUrlRequestHashKeyContextList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (hashKey) {
      res["HashKey"] = boost::any(*hashKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("HashKey") != m.end() && !m["HashKey"].empty()) {
      hashKey = make_shared<string>(boost::any_cast<string>(m["HashKey"]));
    }
  }


  virtual ~CreateFileDetectUploadUrlRequestHashKeyContextList() = default;
};
class CreateFileDetectUploadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateFileDetectUploadUrlRequestHashKeyContextList>> hashKeyContextList{};
  shared_ptr<vector<string>> hashKeyList{};
  shared_ptr<long> type{};

  CreateFileDetectUploadUrlRequest() {}

  explicit CreateFileDetectUploadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hashKeyContextList) {
      vector<boost::any> temp1;
      for(auto item1:*hashKeyContextList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HashKeyContextList"] = boost::any(temp1);
    }
    if (hashKeyList) {
      res["HashKeyList"] = boost::any(*hashKeyList);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HashKeyContextList") != m.end() && !m["HashKeyContextList"].empty()) {
      if (typeid(vector<boost::any>) == m["HashKeyContextList"].type()) {
        vector<CreateFileDetectUploadUrlRequestHashKeyContextList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HashKeyContextList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFileDetectUploadUrlRequestHashKeyContextList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hashKeyContextList = make_shared<vector<CreateFileDetectUploadUrlRequestHashKeyContextList>>(expect1);
      }
    }
    if (m.find("HashKeyList") != m.end() && !m["HashKeyList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HashKeyList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HashKeyList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hashKeyList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CreateFileDetectUploadUrlRequest() = default;
};
class CreateFileDetectUploadUrlResponseBodyUploadUrlListContext : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  CreateFileDetectUploadUrlResponseBodyUploadUrlListContext() {}

  explicit CreateFileDetectUploadUrlResponseBodyUploadUrlListContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~CreateFileDetectUploadUrlResponseBodyUploadUrlListContext() = default;
};
class CreateFileDetectUploadUrlResponseBodyUploadUrlList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateFileDetectUploadUrlResponseBodyUploadUrlListContext> context{};
  shared_ptr<string> expire{};
  shared_ptr<bool> fileExist{};
  shared_ptr<string> hashKey{};
  shared_ptr<string> internalUrl{};
  shared_ptr<string> message{};
  shared_ptr<string> publicUrl{};

  CreateFileDetectUploadUrlResponseBodyUploadUrlList() {}

  explicit CreateFileDetectUploadUrlResponseBodyUploadUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (context) {
      res["Context"] = context ? boost::any(context->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (fileExist) {
      res["FileExist"] = boost::any(*fileExist);
    }
    if (hashKey) {
      res["HashKey"] = boost::any(*hashKey);
    }
    if (internalUrl) {
      res["InternalUrl"] = boost::any(*internalUrl);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (publicUrl) {
      res["PublicUrl"] = boost::any(*publicUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Context") != m.end() && !m["Context"].empty()) {
      if (typeid(map<string, boost::any>) == m["Context"].type()) {
        CreateFileDetectUploadUrlResponseBodyUploadUrlListContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Context"]));
        context = make_shared<CreateFileDetectUploadUrlResponseBodyUploadUrlListContext>(model1);
      }
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<string>(boost::any_cast<string>(m["Expire"]));
    }
    if (m.find("FileExist") != m.end() && !m["FileExist"].empty()) {
      fileExist = make_shared<bool>(boost::any_cast<bool>(m["FileExist"]));
    }
    if (m.find("HashKey") != m.end() && !m["HashKey"].empty()) {
      hashKey = make_shared<string>(boost::any_cast<string>(m["HashKey"]));
    }
    if (m.find("InternalUrl") != m.end() && !m["InternalUrl"].empty()) {
      internalUrl = make_shared<string>(boost::any_cast<string>(m["InternalUrl"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PublicUrl") != m.end() && !m["PublicUrl"].empty()) {
      publicUrl = make_shared<string>(boost::any_cast<string>(m["PublicUrl"]));
    }
  }


  virtual ~CreateFileDetectUploadUrlResponseBodyUploadUrlList() = default;
};
class CreateFileDetectUploadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<CreateFileDetectUploadUrlResponseBodyUploadUrlList>> uploadUrlList{};

  CreateFileDetectUploadUrlResponseBody() {}

  explicit CreateFileDetectUploadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadUrlList) {
      vector<boost::any> temp1;
      for(auto item1:*uploadUrlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UploadUrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadUrlList") != m.end() && !m["UploadUrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UploadUrlList"].type()) {
        vector<CreateFileDetectUploadUrlResponseBodyUploadUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UploadUrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFileDetectUploadUrlResponseBodyUploadUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uploadUrlList = make_shared<vector<CreateFileDetectUploadUrlResponseBodyUploadUrlList>>(expect1);
      }
    }
  }


  virtual ~CreateFileDetectUploadUrlResponseBody() = default;
};
class CreateFileDetectUploadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFileDetectUploadUrlResponseBody> body{};

  CreateFileDetectUploadUrlResponse() {}

  explicit CreateFileDetectUploadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFileDetectUploadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFileDetectUploadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFileDetectUploadUrlResponse() = default;
};
class CreateHoneypotRequest : public Darabonba::Model {
public:
  shared_ptr<string> honeypotImageId{};
  shared_ptr<string> honeypotImageName{};
  shared_ptr<string> honeypotName{};
  shared_ptr<string> meta{};
  shared_ptr<string> nodeId{};

  CreateHoneypotRequest() {}

  explicit CreateHoneypotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotImageId) {
      res["HoneypotImageId"] = boost::any(*honeypotImageId);
    }
    if (honeypotImageName) {
      res["HoneypotImageName"] = boost::any(*honeypotImageName);
    }
    if (honeypotName) {
      res["HoneypotName"] = boost::any(*honeypotName);
    }
    if (meta) {
      res["Meta"] = boost::any(*meta);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotImageId") != m.end() && !m["HoneypotImageId"].empty()) {
      honeypotImageId = make_shared<string>(boost::any_cast<string>(m["HoneypotImageId"]));
    }
    if (m.find("HoneypotImageName") != m.end() && !m["HoneypotImageName"].empty()) {
      honeypotImageName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageName"]));
    }
    if (m.find("HoneypotName") != m.end() && !m["HoneypotName"].empty()) {
      honeypotName = make_shared<string>(boost::any_cast<string>(m["HoneypotName"]));
    }
    if (m.find("Meta") != m.end() && !m["Meta"].empty()) {
      meta = make_shared<string>(boost::any_cast<string>(m["Meta"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~CreateHoneypotRequest() = default;
};
class CreateHoneypotResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> controlNodeName{};
  shared_ptr<string> honeypotId{};
  shared_ptr<string> honeypotImageDisplayName{};
  shared_ptr<string> honeypotImageName{};
  shared_ptr<string> honeypotName{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> presetId{};
  shared_ptr<vector<string>> state{};

  CreateHoneypotResponseBodyData() {}

  explicit CreateHoneypotResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (controlNodeName) {
      res["ControlNodeName"] = boost::any(*controlNodeName);
    }
    if (honeypotId) {
      res["HoneypotId"] = boost::any(*honeypotId);
    }
    if (honeypotImageDisplayName) {
      res["HoneypotImageDisplayName"] = boost::any(*honeypotImageDisplayName);
    }
    if (honeypotImageName) {
      res["HoneypotImageName"] = boost::any(*honeypotImageName);
    }
    if (honeypotName) {
      res["HoneypotName"] = boost::any(*honeypotName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (presetId) {
      res["PresetId"] = boost::any(*presetId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ControlNodeName") != m.end() && !m["ControlNodeName"].empty()) {
      controlNodeName = make_shared<string>(boost::any_cast<string>(m["ControlNodeName"]));
    }
    if (m.find("HoneypotId") != m.end() && !m["HoneypotId"].empty()) {
      honeypotId = make_shared<string>(boost::any_cast<string>(m["HoneypotId"]));
    }
    if (m.find("HoneypotImageDisplayName") != m.end() && !m["HoneypotImageDisplayName"].empty()) {
      honeypotImageDisplayName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageDisplayName"]));
    }
    if (m.find("HoneypotImageName") != m.end() && !m["HoneypotImageName"].empty()) {
      honeypotImageName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageName"]));
    }
    if (m.find("HoneypotName") != m.end() && !m["HoneypotName"].empty()) {
      honeypotName = make_shared<string>(boost::any_cast<string>(m["HoneypotName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PresetId") != m.end() && !m["PresetId"].empty()) {
      presetId = make_shared<string>(boost::any_cast<string>(m["PresetId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["State"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["State"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      state = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateHoneypotResponseBodyData() = default;
};
class CreateHoneypotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateHoneypotResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateHoneypotResponseBody() {}

  explicit CreateHoneypotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateHoneypotResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateHoneypotResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateHoneypotResponseBody() = default;
};
class CreateHoneypotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHoneypotResponseBody> body{};

  CreateHoneypotResponse() {}

  explicit CreateHoneypotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHoneypotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHoneypotResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHoneypotResponse() = default;
};
class CreateHoneypotNodeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allowHoneypotAccessInternet{};
  shared_ptr<long> availableProbeNum{};
  shared_ptr<string> nodeName{};
  shared_ptr<vector<string>> securityGroupProbeIpList{};

  CreateHoneypotNodeRequest() {}

  explicit CreateHoneypotNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowHoneypotAccessInternet) {
      res["AllowHoneypotAccessInternet"] = boost::any(*allowHoneypotAccessInternet);
    }
    if (availableProbeNum) {
      res["AvailableProbeNum"] = boost::any(*availableProbeNum);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (securityGroupProbeIpList) {
      res["SecurityGroupProbeIpList"] = boost::any(*securityGroupProbeIpList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowHoneypotAccessInternet") != m.end() && !m["AllowHoneypotAccessInternet"].empty()) {
      allowHoneypotAccessInternet = make_shared<bool>(boost::any_cast<bool>(m["AllowHoneypotAccessInternet"]));
    }
    if (m.find("AvailableProbeNum") != m.end() && !m["AvailableProbeNum"].empty()) {
      availableProbeNum = make_shared<long>(boost::any_cast<long>(m["AvailableProbeNum"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("SecurityGroupProbeIpList") != m.end() && !m["SecurityGroupProbeIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupProbeIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupProbeIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupProbeIpList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateHoneypotNodeRequest() = default;
};
class CreateHoneypotNodeResponseBodyHoneypotNode : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};

  CreateHoneypotNodeResponseBodyHoneypotNode() {}

  explicit CreateHoneypotNodeResponseBodyHoneypotNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~CreateHoneypotNodeResponseBodyHoneypotNode() = default;
};
class CreateHoneypotNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateHoneypotNodeResponseBodyHoneypotNode> honeypotNode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateHoneypotNodeResponseBody() {}

  explicit CreateHoneypotNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (honeypotNode) {
      res["HoneypotNode"] = honeypotNode ? boost::any(honeypotNode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HoneypotNode") != m.end() && !m["HoneypotNode"].empty()) {
      if (typeid(map<string, boost::any>) == m["HoneypotNode"].type()) {
        CreateHoneypotNodeResponseBodyHoneypotNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HoneypotNode"]));
        honeypotNode = make_shared<CreateHoneypotNodeResponseBodyHoneypotNode>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateHoneypotNodeResponseBody() = default;
};
class CreateHoneypotNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHoneypotNodeResponseBody> body{};

  CreateHoneypotNodeResponse() {}

  explicit CreateHoneypotNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHoneypotNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHoneypotNodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHoneypotNodeResponse() = default;
};
class CreateHoneypotPresetRequest : public Darabonba::Model {
public:
  shared_ptr<string> honeypotImageName{};
  shared_ptr<string> lang{};
  shared_ptr<string> meta{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> presetName{};

  CreateHoneypotPresetRequest() {}

  explicit CreateHoneypotPresetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotImageName) {
      res["HoneypotImageName"] = boost::any(*honeypotImageName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (meta) {
      res["Meta"] = boost::any(*meta);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (presetName) {
      res["PresetName"] = boost::any(*presetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotImageName") != m.end() && !m["HoneypotImageName"].empty()) {
      honeypotImageName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Meta") != m.end() && !m["Meta"].empty()) {
      meta = make_shared<string>(boost::any_cast<string>(m["Meta"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PresetName") != m.end() && !m["PresetName"].empty()) {
      presetName = make_shared<string>(boost::any_cast<string>(m["PresetName"]));
    }
  }


  virtual ~CreateHoneypotPresetRequest() = default;
};
class CreateHoneypotPresetResponseBodyHoneypotPreset : public Darabonba::Model {
public:
  shared_ptr<string> honeypotPresetId{};

  CreateHoneypotPresetResponseBodyHoneypotPreset() {}

  explicit CreateHoneypotPresetResponseBodyHoneypotPreset(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotPresetId) {
      res["HoneypotPresetId"] = boost::any(*honeypotPresetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotPresetId") != m.end() && !m["HoneypotPresetId"].empty()) {
      honeypotPresetId = make_shared<string>(boost::any_cast<string>(m["HoneypotPresetId"]));
    }
  }


  virtual ~CreateHoneypotPresetResponseBodyHoneypotPreset() = default;
};
class CreateHoneypotPresetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateHoneypotPresetResponseBodyHoneypotPreset> honeypotPreset{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateHoneypotPresetResponseBody() {}

  explicit CreateHoneypotPresetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (honeypotPreset) {
      res["HoneypotPreset"] = honeypotPreset ? boost::any(honeypotPreset->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HoneypotPreset") != m.end() && !m["HoneypotPreset"].empty()) {
      if (typeid(map<string, boost::any>) == m["HoneypotPreset"].type()) {
        CreateHoneypotPresetResponseBodyHoneypotPreset model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HoneypotPreset"]));
        honeypotPreset = make_shared<CreateHoneypotPresetResponseBodyHoneypotPreset>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateHoneypotPresetResponseBody() = default;
};
class CreateHoneypotPresetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHoneypotPresetResponseBody> body{};

  CreateHoneypotPresetResponse() {}

  explicit CreateHoneypotPresetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHoneypotPresetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHoneypotPresetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHoneypotPresetResponse() = default;
};
class CreateHoneypotProbeRequestHoneypotBindListBindPortList : public Darabonba::Model {
public:
  shared_ptr<bool> bindPort{};
  shared_ptr<long> endPort{};
  shared_ptr<bool> fixed{};
  shared_ptr<long> startPort{};
  shared_ptr<long> targetPort{};

  CreateHoneypotProbeRequestHoneypotBindListBindPortList() {}

  explicit CreateHoneypotProbeRequestHoneypotBindListBindPortList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindPort) {
      res["BindPort"] = boost::any(*bindPort);
    }
    if (endPort) {
      res["EndPort"] = boost::any(*endPort);
    }
    if (fixed) {
      res["Fixed"] = boost::any(*fixed);
    }
    if (startPort) {
      res["StartPort"] = boost::any(*startPort);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindPort") != m.end() && !m["BindPort"].empty()) {
      bindPort = make_shared<bool>(boost::any_cast<bool>(m["BindPort"]));
    }
    if (m.find("EndPort") != m.end() && !m["EndPort"].empty()) {
      endPort = make_shared<long>(boost::any_cast<long>(m["EndPort"]));
    }
    if (m.find("Fixed") != m.end() && !m["Fixed"].empty()) {
      fixed = make_shared<bool>(boost::any_cast<bool>(m["Fixed"]));
    }
    if (m.find("StartPort") != m.end() && !m["StartPort"].empty()) {
      startPort = make_shared<long>(boost::any_cast<long>(m["StartPort"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<long>(boost::any_cast<long>(m["TargetPort"]));
    }
  }


  virtual ~CreateHoneypotProbeRequestHoneypotBindListBindPortList() = default;
};
class CreateHoneypotProbeRequestHoneypotBindList : public Darabonba::Model {
public:
  shared_ptr<vector<CreateHoneypotProbeRequestHoneypotBindListBindPortList>> bindPortList{};
  shared_ptr<string> honeypotId{};

  CreateHoneypotProbeRequestHoneypotBindList() {}

  explicit CreateHoneypotProbeRequestHoneypotBindList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindPortList) {
      vector<boost::any> temp1;
      for(auto item1:*bindPortList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BindPortList"] = boost::any(temp1);
    }
    if (honeypotId) {
      res["HoneypotId"] = boost::any(*honeypotId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindPortList") != m.end() && !m["BindPortList"].empty()) {
      if (typeid(vector<boost::any>) == m["BindPortList"].type()) {
        vector<CreateHoneypotProbeRequestHoneypotBindListBindPortList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BindPortList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHoneypotProbeRequestHoneypotBindListBindPortList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bindPortList = make_shared<vector<CreateHoneypotProbeRequestHoneypotBindListBindPortList>>(expect1);
      }
    }
    if (m.find("HoneypotId") != m.end() && !m["HoneypotId"].empty()) {
      honeypotId = make_shared<string>(boost::any_cast<string>(m["HoneypotId"]));
    }
  }


  virtual ~CreateHoneypotProbeRequestHoneypotBindList() = default;
};
class CreateHoneypotProbeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> arp{};
  shared_ptr<string> businessGroupId{};
  shared_ptr<string> controlNodeId{};
  shared_ptr<string> displayName{};
  shared_ptr<vector<CreateHoneypotProbeRequestHoneypotBindList>> honeypotBindList{};
  shared_ptr<bool> ping{};
  shared_ptr<string> probeType{};
  shared_ptr<string> probeVersion{};
  shared_ptr<string> proxyIp{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vpcId{};

  CreateHoneypotProbeRequest() {}

  explicit CreateHoneypotProbeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arp) {
      res["Arp"] = boost::any(*arp);
    }
    if (businessGroupId) {
      res["BusinessGroupId"] = boost::any(*businessGroupId);
    }
    if (controlNodeId) {
      res["ControlNodeId"] = boost::any(*controlNodeId);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (honeypotBindList) {
      vector<boost::any> temp1;
      for(auto item1:*honeypotBindList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HoneypotBindList"] = boost::any(temp1);
    }
    if (ping) {
      res["Ping"] = boost::any(*ping);
    }
    if (probeType) {
      res["ProbeType"] = boost::any(*probeType);
    }
    if (probeVersion) {
      res["ProbeVersion"] = boost::any(*probeVersion);
    }
    if (proxyIp) {
      res["ProxyIp"] = boost::any(*proxyIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arp") != m.end() && !m["Arp"].empty()) {
      arp = make_shared<bool>(boost::any_cast<bool>(m["Arp"]));
    }
    if (m.find("BusinessGroupId") != m.end() && !m["BusinessGroupId"].empty()) {
      businessGroupId = make_shared<string>(boost::any_cast<string>(m["BusinessGroupId"]));
    }
    if (m.find("ControlNodeId") != m.end() && !m["ControlNodeId"].empty()) {
      controlNodeId = make_shared<string>(boost::any_cast<string>(m["ControlNodeId"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("HoneypotBindList") != m.end() && !m["HoneypotBindList"].empty()) {
      if (typeid(vector<boost::any>) == m["HoneypotBindList"].type()) {
        vector<CreateHoneypotProbeRequestHoneypotBindList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HoneypotBindList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateHoneypotProbeRequestHoneypotBindList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        honeypotBindList = make_shared<vector<CreateHoneypotProbeRequestHoneypotBindList>>(expect1);
      }
    }
    if (m.find("Ping") != m.end() && !m["Ping"].empty()) {
      ping = make_shared<bool>(boost::any_cast<bool>(m["Ping"]));
    }
    if (m.find("ProbeType") != m.end() && !m["ProbeType"].empty()) {
      probeType = make_shared<string>(boost::any_cast<string>(m["ProbeType"]));
    }
    if (m.find("ProbeVersion") != m.end() && !m["ProbeVersion"].empty()) {
      probeVersion = make_shared<string>(boost::any_cast<string>(m["ProbeVersion"]));
    }
    if (m.find("ProxyIp") != m.end() && !m["ProxyIp"].empty()) {
      proxyIp = make_shared<string>(boost::any_cast<string>(m["ProxyIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateHoneypotProbeRequest() = default;
};
class CreateHoneypotProbeResponseBodyHoneypotProbe : public Darabonba::Model {
public:
  shared_ptr<string> probeId{};

  CreateHoneypotProbeResponseBodyHoneypotProbe() {}

  explicit CreateHoneypotProbeResponseBodyHoneypotProbe(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (probeId) {
      res["ProbeId"] = boost::any(*probeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProbeId") != m.end() && !m["ProbeId"].empty()) {
      probeId = make_shared<string>(boost::any_cast<string>(m["ProbeId"]));
    }
  }


  virtual ~CreateHoneypotProbeResponseBodyHoneypotProbe() = default;
};
class CreateHoneypotProbeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateHoneypotProbeResponseBodyHoneypotProbe> honeypotProbe{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateHoneypotProbeResponseBody() {}

  explicit CreateHoneypotProbeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (honeypotProbe) {
      res["HoneypotProbe"] = honeypotProbe ? boost::any(honeypotProbe->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HoneypotProbe") != m.end() && !m["HoneypotProbe"].empty()) {
      if (typeid(map<string, boost::any>) == m["HoneypotProbe"].type()) {
        CreateHoneypotProbeResponseBodyHoneypotProbe model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HoneypotProbe"]));
        honeypotProbe = make_shared<CreateHoneypotProbeResponseBodyHoneypotProbe>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateHoneypotProbeResponseBody() = default;
};
class CreateHoneypotProbeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHoneypotProbeResponseBody> body{};

  CreateHoneypotProbeResponse() {}

  explicit CreateHoneypotProbeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHoneypotProbeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHoneypotProbeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHoneypotProbeResponse() = default;
};
class CreateInterceptionRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<map<string, boost::any>> dstTargetList{};
  shared_ptr<long> interceptType{};
  shared_ptr<long> orderIndex{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleSwitch{};
  shared_ptr<string> ruleType{};
  shared_ptr<map<string, boost::any>> srcTarget{};

  CreateInterceptionRuleRequest() {}

  explicit CreateInterceptionRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (dstTargetList) {
      res["DstTargetList"] = boost::any(*dstTargetList);
    }
    if (interceptType) {
      res["InterceptType"] = boost::any(*interceptType);
    }
    if (orderIndex) {
      res["OrderIndex"] = boost::any(*orderIndex);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleSwitch) {
      res["RuleSwitch"] = boost::any(*ruleSwitch);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (srcTarget) {
      res["SrcTarget"] = boost::any(*srcTarget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("DstTargetList") != m.end() && !m["DstTargetList"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["DstTargetList"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      dstTargetList = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("InterceptType") != m.end() && !m["InterceptType"].empty()) {
      interceptType = make_shared<long>(boost::any_cast<long>(m["InterceptType"]));
    }
    if (m.find("OrderIndex") != m.end() && !m["OrderIndex"].empty()) {
      orderIndex = make_shared<long>(boost::any_cast<long>(m["OrderIndex"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleSwitch") != m.end() && !m["RuleSwitch"].empty()) {
      ruleSwitch = make_shared<long>(boost::any_cast<long>(m["RuleSwitch"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("SrcTarget") != m.end() && !m["SrcTarget"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SrcTarget"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      srcTarget = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~CreateInterceptionRuleRequest() = default;
};
class CreateInterceptionRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> dstTargetListShrink{};
  shared_ptr<long> interceptType{};
  shared_ptr<long> orderIndex{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleSwitch{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> srcTargetShrink{};

  CreateInterceptionRuleShrinkRequest() {}

  explicit CreateInterceptionRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (dstTargetListShrink) {
      res["DstTargetList"] = boost::any(*dstTargetListShrink);
    }
    if (interceptType) {
      res["InterceptType"] = boost::any(*interceptType);
    }
    if (orderIndex) {
      res["OrderIndex"] = boost::any(*orderIndex);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleSwitch) {
      res["RuleSwitch"] = boost::any(*ruleSwitch);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (srcTargetShrink) {
      res["SrcTarget"] = boost::any(*srcTargetShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("DstTargetList") != m.end() && !m["DstTargetList"].empty()) {
      dstTargetListShrink = make_shared<string>(boost::any_cast<string>(m["DstTargetList"]));
    }
    if (m.find("InterceptType") != m.end() && !m["InterceptType"].empty()) {
      interceptType = make_shared<long>(boost::any_cast<long>(m["InterceptType"]));
    }
    if (m.find("OrderIndex") != m.end() && !m["OrderIndex"].empty()) {
      orderIndex = make_shared<long>(boost::any_cast<long>(m["OrderIndex"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleSwitch") != m.end() && !m["RuleSwitch"].empty()) {
      ruleSwitch = make_shared<long>(boost::any_cast<long>(m["RuleSwitch"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("SrcTarget") != m.end() && !m["SrcTarget"].empty()) {
      srcTargetShrink = make_shared<string>(boost::any_cast<string>(m["SrcTarget"]));
    }
  }


  virtual ~CreateInterceptionRuleShrinkRequest() = default;
};
class CreateInterceptionRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateInterceptionRuleResponseBody() {}

  explicit CreateInterceptionRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateInterceptionRuleResponseBody() = default;
};
class CreateInterceptionRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInterceptionRuleResponseBody> body{};

  CreateInterceptionRuleResponse() {}

  explicit CreateInterceptionRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInterceptionRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInterceptionRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInterceptionRuleResponse() = default;
};
class CreateInterceptionTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<vector<string>> imageList{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<string>> tagList{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};

  CreateInterceptionTargetRequest() {}

  explicit CreateInterceptionTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (imageList) {
      res["ImageList"] = boost::any(*imageList);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ImageList") != m.end() && !m["ImageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~CreateInterceptionTargetRequest() = default;
};
class CreateInterceptionTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreateInterceptionTargetResponseBody() {}

  explicit CreateInterceptionTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreateInterceptionTargetResponseBody() = default;
};
class CreateInterceptionTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInterceptionTargetResponseBody> body{};

  CreateInterceptionTargetResponse() {}

  explicit CreateInterceptionTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInterceptionTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInterceptionTargetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInterceptionTargetResponse() = default;
};
class CreateJenkinsImageRegistryRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> extraParam{};
  shared_ptr<long> netType{};
  shared_ptr<string> password{};
  shared_ptr<long> persistenceDay{};
  shared_ptr<long> protocolType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> registryHostIp{};
  shared_ptr<string> registryName{};
  shared_ptr<string> registryType{};
  shared_ptr<string> registryVersion{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> transPerHour{};
  shared_ptr<string> userName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> whiteList{};

  CreateJenkinsImageRegistryRequest() {}

  explicit CreateJenkinsImageRegistryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (extraParam) {
      res["ExtraParam"] = boost::any(*extraParam);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (persistenceDay) {
      res["PersistenceDay"] = boost::any(*persistenceDay);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (registryHostIp) {
      res["RegistryHostIp"] = boost::any(*registryHostIp);
    }
    if (registryName) {
      res["RegistryName"] = boost::any(*registryName);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (registryVersion) {
      res["RegistryVersion"] = boost::any(*registryVersion);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (transPerHour) {
      res["TransPerHour"] = boost::any(*transPerHour);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ExtraParam") != m.end() && !m["ExtraParam"].empty()) {
      extraParam = make_shared<string>(boost::any_cast<string>(m["ExtraParam"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<long>(boost::any_cast<long>(m["NetType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PersistenceDay") != m.end() && !m["PersistenceDay"].empty()) {
      persistenceDay = make_shared<long>(boost::any_cast<long>(m["PersistenceDay"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<long>(boost::any_cast<long>(m["ProtocolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegistryHostIp") != m.end() && !m["RegistryHostIp"].empty()) {
      registryHostIp = make_shared<string>(boost::any_cast<string>(m["RegistryHostIp"]));
    }
    if (m.find("RegistryName") != m.end() && !m["RegistryName"].empty()) {
      registryName = make_shared<string>(boost::any_cast<string>(m["RegistryName"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("RegistryVersion") != m.end() && !m["RegistryVersion"].empty()) {
      registryVersion = make_shared<string>(boost::any_cast<string>(m["RegistryVersion"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("TransPerHour") != m.end() && !m["TransPerHour"].empty()) {
      transPerHour = make_shared<long>(boost::any_cast<long>(m["TransPerHour"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~CreateJenkinsImageRegistryRequest() = default;
};
class CreateJenkinsImageRegistryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> blackList{};
  shared_ptr<string> domainName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> netType{};
  shared_ptr<string> password{};
  shared_ptr<long> persistenceDay{};
  shared_ptr<long> protocolType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> registryHostIp{};
  shared_ptr<string> registryName{};
  shared_ptr<string> registryType{};
  shared_ptr<string> token{};
  shared_ptr<long> transPerHour{};
  shared_ptr<string> userName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> whiteList{};

  CreateJenkinsImageRegistryResponseBodyData() {}

  explicit CreateJenkinsImageRegistryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackList) {
      res["BlackList"] = boost::any(*blackList);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (persistenceDay) {
      res["PersistenceDay"] = boost::any(*persistenceDay);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (registryHostIp) {
      res["RegistryHostIp"] = boost::any(*registryHostIp);
    }
    if (registryName) {
      res["RegistryName"] = boost::any(*registryName);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (transPerHour) {
      res["TransPerHour"] = boost::any(*transPerHour);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackList") != m.end() && !m["BlackList"].empty()) {
      blackList = make_shared<string>(boost::any_cast<string>(m["BlackList"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<long>(boost::any_cast<long>(m["NetType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PersistenceDay") != m.end() && !m["PersistenceDay"].empty()) {
      persistenceDay = make_shared<long>(boost::any_cast<long>(m["PersistenceDay"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<long>(boost::any_cast<long>(m["ProtocolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegistryHostIp") != m.end() && !m["RegistryHostIp"].empty()) {
      registryHostIp = make_shared<string>(boost::any_cast<string>(m["RegistryHostIp"]));
    }
    if (m.find("RegistryName") != m.end() && !m["RegistryName"].empty()) {
      registryName = make_shared<string>(boost::any_cast<string>(m["RegistryName"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("TransPerHour") != m.end() && !m["TransPerHour"].empty()) {
      transPerHour = make_shared<long>(boost::any_cast<long>(m["TransPerHour"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~CreateJenkinsImageRegistryResponseBodyData() = default;
};
class CreateJenkinsImageRegistryResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateJenkinsImageRegistryResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<long> timeCost{};

  CreateJenkinsImageRegistryResponseBody() {}

  explicit CreateJenkinsImageRegistryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateJenkinsImageRegistryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateJenkinsImageRegistryResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<long>(boost::any_cast<long>(m["TimeCost"]));
    }
  }


  virtual ~CreateJenkinsImageRegistryResponseBody() = default;
};
class CreateJenkinsImageRegistryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateJenkinsImageRegistryResponseBody> body{};

  CreateJenkinsImageRegistryResponse() {}

  explicit CreateJenkinsImageRegistryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateJenkinsImageRegistryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateJenkinsImageRegistryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateJenkinsImageRegistryResponse() = default;
};
class CreateOrUpdateAssetGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> uuids{};

  CreateOrUpdateAssetGroupRequest() {}

  explicit CreateOrUpdateAssetGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~CreateOrUpdateAssetGroupRequest() = default;
};
class CreateOrUpdateAssetGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> requestId{};

  CreateOrUpdateAssetGroupResponseBody() {}

  explicit CreateOrUpdateAssetGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrUpdateAssetGroupResponseBody() = default;
};
class CreateOrUpdateAssetGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrUpdateAssetGroupResponseBody> body{};

  CreateOrUpdateAssetGroupResponse() {}

  explicit CreateOrUpdateAssetGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrUpdateAssetGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrUpdateAssetGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrUpdateAssetGroupResponse() = default;
};
class CreateRestoreJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> includes{};
  shared_ptr<string> snapshotHash{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> snapshotVersion{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> target{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vaultId{};

  CreateRestoreJobRequest() {}

  explicit CreateRestoreJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (includes) {
      res["Includes"] = boost::any(*includes);
    }
    if (snapshotHash) {
      res["SnapshotHash"] = boost::any(*snapshotHash);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotVersion) {
      res["SnapshotVersion"] = boost::any(*snapshotVersion);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vaultId) {
      res["VaultId"] = boost::any(*vaultId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Includes") != m.end() && !m["Includes"].empty()) {
      includes = make_shared<string>(boost::any_cast<string>(m["Includes"]));
    }
    if (m.find("SnapshotHash") != m.end() && !m["SnapshotHash"].empty()) {
      snapshotHash = make_shared<string>(boost::any_cast<string>(m["SnapshotHash"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotVersion") != m.end() && !m["SnapshotVersion"].empty()) {
      snapshotVersion = make_shared<string>(boost::any_cast<string>(m["SnapshotVersion"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VaultId") != m.end() && !m["VaultId"].empty()) {
      vaultId = make_shared<string>(boost::any_cast<string>(m["VaultId"]));
    }
  }


  virtual ~CreateRestoreJobRequest() = default;
};
class CreateRestoreJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateRestoreJobResponseBody() {}

  explicit CreateRestoreJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRestoreJobResponseBody() = default;
};
class CreateRestoreJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRestoreJobResponseBody> body{};

  CreateRestoreJobResponse() {}

  explicit CreateRestoreJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRestoreJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRestoreJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRestoreJobResponse() = default;
};
class CreateServiceLinkedRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> serviceLinkedRole{};

  CreateServiceLinkedRoleRequest() {}

  explicit CreateServiceLinkedRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceLinkedRole) {
      res["ServiceLinkedRole"] = boost::any(*serviceLinkedRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceLinkedRole") != m.end() && !m["ServiceLinkedRole"].empty()) {
      serviceLinkedRole = make_shared<string>(boost::any_cast<string>(m["ServiceLinkedRole"]));
    }
  }


  virtual ~CreateServiceLinkedRoleRequest() = default;
};
class CreateServiceLinkedRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateServiceLinkedRoleResponseBody() {}

  explicit CreateServiceLinkedRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateServiceLinkedRoleResponseBody() = default;
};
class CreateServiceLinkedRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateServiceLinkedRoleResponseBody> body{};

  CreateServiceLinkedRoleResponse() {}

  explicit CreateServiceLinkedRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateServiceLinkedRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateServiceLinkedRoleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateServiceLinkedRoleResponse() = default;
};
class CreateSimilarSecurityEventsQueryTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> securityEventId{};
  shared_ptr<string> similarEventScenarioCode{};
  shared_ptr<string> sourceIp{};

  CreateSimilarSecurityEventsQueryTaskRequest() {}

  explicit CreateSimilarSecurityEventsQueryTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    if (similarEventScenarioCode) {
      res["SimilarEventScenarioCode"] = boost::any(*similarEventScenarioCode);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<long>(boost::any_cast<long>(m["SecurityEventId"]));
    }
    if (m.find("SimilarEventScenarioCode") != m.end() && !m["SimilarEventScenarioCode"].empty()) {
      similarEventScenarioCode = make_shared<string>(boost::any_cast<string>(m["SimilarEventScenarioCode"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~CreateSimilarSecurityEventsQueryTaskRequest() = default;
};
class CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};

  CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse() {}

  explicit CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse() = default;
};
class CreateSimilarSecurityEventsQueryTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse> createSimilarSecurityEventsQueryTaskResponse{};
  shared_ptr<string> requestId{};

  CreateSimilarSecurityEventsQueryTaskResponseBody() {}

  explicit CreateSimilarSecurityEventsQueryTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createSimilarSecurityEventsQueryTaskResponse) {
      res["CreateSimilarSecurityEventsQueryTaskResponse"] = createSimilarSecurityEventsQueryTaskResponse ? boost::any(createSimilarSecurityEventsQueryTaskResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateSimilarSecurityEventsQueryTaskResponse") != m.end() && !m["CreateSimilarSecurityEventsQueryTaskResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateSimilarSecurityEventsQueryTaskResponse"].type()) {
        CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateSimilarSecurityEventsQueryTaskResponse"]));
        createSimilarSecurityEventsQueryTaskResponse = make_shared<CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSimilarSecurityEventsQueryTaskResponseBody() = default;
};
class CreateSimilarSecurityEventsQueryTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSimilarSecurityEventsQueryTaskResponseBody> body{};

  CreateSimilarSecurityEventsQueryTaskResponse() {}

  explicit CreateSimilarSecurityEventsQueryTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSimilarSecurityEventsQueryTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSimilarSecurityEventsQueryTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSimilarSecurityEventsQueryTaskResponse() = default;
};
class CreateSuspEventNoteRequest : public Darabonba::Model {
public:
  shared_ptr<long> eventId{};
  shared_ptr<string> note{};

  CreateSuspEventNoteRequest() {}

  explicit CreateSuspEventNoteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<long>(boost::any_cast<long>(m["EventId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
  }


  virtual ~CreateSuspEventNoteRequest() = default;
};
class CreateSuspEventNoteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateSuspEventNoteResponseBody() {}

  explicit CreateSuspEventNoteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSuspEventNoteResponseBody() = default;
};
class CreateSuspEventNoteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSuspEventNoteResponseBody> body{};

  CreateSuspEventNoteResponse() {}

  explicit CreateSuspEventNoteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSuspEventNoteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSuspEventNoteResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSuspEventNoteResponse() = default;
};
class CreateUniBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> accountPassword{};
  shared_ptr<string> databaseAddByUser{};
  shared_ptr<string> databaseType{};
  shared_ptr<map<string, boost::any>> fullPlan{};
  shared_ptr<map<string, boost::any>> incPlan{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyName{};
  shared_ptr<long> retention{};
  shared_ptr<long> speedLimiter{};
  shared_ptr<string> uniRegionId{};
  shared_ptr<string> uuid{};

  CreateUniBackupPolicyRequest() {}

  explicit CreateUniBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountPassword) {
      res["AccountPassword"] = boost::any(*accountPassword);
    }
    if (databaseAddByUser) {
      res["DatabaseAddByUser"] = boost::any(*databaseAddByUser);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (fullPlan) {
      res["FullPlan"] = boost::any(*fullPlan);
    }
    if (incPlan) {
      res["IncPlan"] = boost::any(*incPlan);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (speedLimiter) {
      res["SpeedLimiter"] = boost::any(*speedLimiter);
    }
    if (uniRegionId) {
      res["UniRegionId"] = boost::any(*uniRegionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountPassword") != m.end() && !m["AccountPassword"].empty()) {
      accountPassword = make_shared<string>(boost::any_cast<string>(m["AccountPassword"]));
    }
    if (m.find("DatabaseAddByUser") != m.end() && !m["DatabaseAddByUser"].empty()) {
      databaseAddByUser = make_shared<string>(boost::any_cast<string>(m["DatabaseAddByUser"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("FullPlan") != m.end() && !m["FullPlan"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FullPlan"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      fullPlan = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IncPlan") != m.end() && !m["IncPlan"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["IncPlan"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      incPlan = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("SpeedLimiter") != m.end() && !m["SpeedLimiter"].empty()) {
      speedLimiter = make_shared<long>(boost::any_cast<long>(m["SpeedLimiter"]));
    }
    if (m.find("UniRegionId") != m.end() && !m["UniRegionId"].empty()) {
      uniRegionId = make_shared<string>(boost::any_cast<string>(m["UniRegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~CreateUniBackupPolicyRequest() = default;
};
class CreateUniBackupPolicyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> accountPassword{};
  shared_ptr<string> databaseAddByUser{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> fullPlanShrink{};
  shared_ptr<string> incPlanShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> policyName{};
  shared_ptr<long> retention{};
  shared_ptr<long> speedLimiter{};
  shared_ptr<string> uniRegionId{};
  shared_ptr<string> uuid{};

  CreateUniBackupPolicyShrinkRequest() {}

  explicit CreateUniBackupPolicyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountPassword) {
      res["AccountPassword"] = boost::any(*accountPassword);
    }
    if (databaseAddByUser) {
      res["DatabaseAddByUser"] = boost::any(*databaseAddByUser);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (fullPlanShrink) {
      res["FullPlan"] = boost::any(*fullPlanShrink);
    }
    if (incPlanShrink) {
      res["IncPlan"] = boost::any(*incPlanShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (speedLimiter) {
      res["SpeedLimiter"] = boost::any(*speedLimiter);
    }
    if (uniRegionId) {
      res["UniRegionId"] = boost::any(*uniRegionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountPassword") != m.end() && !m["AccountPassword"].empty()) {
      accountPassword = make_shared<string>(boost::any_cast<string>(m["AccountPassword"]));
    }
    if (m.find("DatabaseAddByUser") != m.end() && !m["DatabaseAddByUser"].empty()) {
      databaseAddByUser = make_shared<string>(boost::any_cast<string>(m["DatabaseAddByUser"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("FullPlan") != m.end() && !m["FullPlan"].empty()) {
      fullPlanShrink = make_shared<string>(boost::any_cast<string>(m["FullPlan"]));
    }
    if (m.find("IncPlan") != m.end() && !m["IncPlan"].empty()) {
      incPlanShrink = make_shared<string>(boost::any_cast<string>(m["IncPlan"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("SpeedLimiter") != m.end() && !m["SpeedLimiter"].empty()) {
      speedLimiter = make_shared<long>(boost::any_cast<long>(m["SpeedLimiter"]));
    }
    if (m.find("UniRegionId") != m.end() && !m["UniRegionId"].empty()) {
      uniRegionId = make_shared<string>(boost::any_cast<string>(m["UniRegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~CreateUniBackupPolicyShrinkRequest() = default;
};
class CreateUniBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateUniBackupPolicyResponseBody() {}

  explicit CreateUniBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateUniBackupPolicyResponseBody() = default;
};
class CreateUniBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUniBackupPolicyResponseBody> body{};

  CreateUniBackupPolicyResponse() {}

  explicit CreateUniBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUniBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUniBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUniBackupPolicyResponse() = default;
};
class CreateUniRestorePlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<string> instanceUuid{};
  shared_ptr<long> policyId{};
  shared_ptr<string> resetScn{};
  shared_ptr<string> resetTime{};
  shared_ptr<string> restoreInfo{};
  shared_ptr<long> timePoint{};

  CreateUniRestorePlanRequest() {}

  explicit CreateUniRestorePlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (instanceUuid) {
      res["InstanceUuid"] = boost::any(*instanceUuid);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (resetScn) {
      res["ResetScn"] = boost::any(*resetScn);
    }
    if (resetTime) {
      res["ResetTime"] = boost::any(*resetTime);
    }
    if (restoreInfo) {
      res["RestoreInfo"] = boost::any(*restoreInfo);
    }
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("InstanceUuid") != m.end() && !m["InstanceUuid"].empty()) {
      instanceUuid = make_shared<string>(boost::any_cast<string>(m["InstanceUuid"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("ResetScn") != m.end() && !m["ResetScn"].empty()) {
      resetScn = make_shared<string>(boost::any_cast<string>(m["ResetScn"]));
    }
    if (m.find("ResetTime") != m.end() && !m["ResetTime"].empty()) {
      resetTime = make_shared<string>(boost::any_cast<string>(m["ResetTime"]));
    }
    if (m.find("RestoreInfo") != m.end() && !m["RestoreInfo"].empty()) {
      restoreInfo = make_shared<string>(boost::any_cast<string>(m["RestoreInfo"]));
    }
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<long>(boost::any_cast<long>(m["TimePoint"]));
    }
  }


  virtual ~CreateUniRestorePlanRequest() = default;
};
class CreateUniRestorePlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateUniRestorePlanResponseBody() {}

  explicit CreateUniRestorePlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateUniRestorePlanResponseBody() = default;
};
class CreateUniRestorePlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUniRestorePlanResponseBody> body{};

  CreateUniRestorePlanResponse() {}

  explicit CreateUniRestorePlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUniRestorePlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUniRestorePlanResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUniRestorePlanResponse() = default;
};
class CreateVulAutoRepairConfigRequestVulAutoRepairConfigList : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};

  CreateVulAutoRepairConfigRequestVulAutoRepairConfigList() {}

  explicit CreateVulAutoRepairConfigRequestVulAutoRepairConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateVulAutoRepairConfigRequestVulAutoRepairConfigList() = default;
};
class CreateVulAutoRepairConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> reason{};
  shared_ptr<string> type{};
  shared_ptr<vector<CreateVulAutoRepairConfigRequestVulAutoRepairConfigList>> vulAutoRepairConfigList{};

  CreateVulAutoRepairConfigRequest() {}

  explicit CreateVulAutoRepairConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vulAutoRepairConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*vulAutoRepairConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VulAutoRepairConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VulAutoRepairConfigList") != m.end() && !m["VulAutoRepairConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["VulAutoRepairConfigList"].type()) {
        vector<CreateVulAutoRepairConfigRequestVulAutoRepairConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VulAutoRepairConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateVulAutoRepairConfigRequestVulAutoRepairConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulAutoRepairConfigList = make_shared<vector<CreateVulAutoRepairConfigRequestVulAutoRepairConfigList>>(expect1);
      }
    }
  }


  virtual ~CreateVulAutoRepairConfigRequest() = default;
};
class CreateVulAutoRepairConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateVulAutoRepairConfigResponseBody() {}

  explicit CreateVulAutoRepairConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateVulAutoRepairConfigResponseBody() = default;
};
class CreateVulAutoRepairConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVulAutoRepairConfigResponseBody> body{};

  CreateVulAutoRepairConfigResponse() {}

  explicit CreateVulAutoRepairConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVulAutoRepairConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVulAutoRepairConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVulAutoRepairConfigResponse() = default;
};
class DeleteAntiBruteForceRuleRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> ids{};

  DeleteAntiBruteForceRuleRequest() {}

  explicit DeleteAntiBruteForceRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DeleteAntiBruteForceRuleRequest() = default;
};
class DeleteAntiBruteForceRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAntiBruteForceRuleResponseBody() {}

  explicit DeleteAntiBruteForceRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAntiBruteForceRuleResponseBody() = default;
};
class DeleteAntiBruteForceRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAntiBruteForceRuleResponseBody> body{};

  DeleteAntiBruteForceRuleResponse() {}

  explicit DeleteAntiBruteForceRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAntiBruteForceRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAntiBruteForceRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAntiBruteForceRuleResponse() = default;
};
class DeleteBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> policyVersion{};

  DeleteBackupPolicyRequest() {}

  explicit DeleteBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
  }


  virtual ~DeleteBackupPolicyRequest() = default;
};
class DeleteBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBackupPolicyResponseBody() {}

  explicit DeleteBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBackupPolicyResponseBody() = default;
};
class DeleteBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBackupPolicyResponseBody> body{};

  DeleteBackupPolicyResponse() {}

  explicit DeleteBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBackupPolicyResponse() = default;
};
class DeleteBackupPolicyMachineRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};
  shared_ptr<string> policyVersion{};
  shared_ptr<string> uuid{};
  shared_ptr<vector<string>> uuidList{};

  DeleteBackupPolicyMachineRequest() {}

  explicit DeleteBackupPolicyMachineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteBackupPolicyMachineRequest() = default;
};
class DeleteBackupPolicyMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBackupPolicyMachineResponseBody() {}

  explicit DeleteBackupPolicyMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBackupPolicyMachineResponseBody() = default;
};
class DeleteBackupPolicyMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBackupPolicyMachineResponseBody> body{};

  DeleteBackupPolicyMachineResponse() {}

  explicit DeleteBackupPolicyMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBackupPolicyMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBackupPolicyMachineResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBackupPolicyMachineResponse() = default;
};
class DeleteClientUserDefineRuleRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> idList{};

  DeleteClientUserDefineRuleRequest() {}

  explicit DeleteClientUserDefineRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idList) {
      res["IdList"] = boost::any(*idList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdList") != m.end() && !m["IdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["IdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      idList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DeleteClientUserDefineRuleRequest() = default;
};
class DeleteClientUserDefineRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteClientUserDefineRuleResponseBody() {}

  explicit DeleteClientUserDefineRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteClientUserDefineRuleResponseBody() = default;
};
class DeleteClientUserDefineRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteClientUserDefineRuleResponseBody> body{};

  DeleteClientUserDefineRuleResponse() {}

  explicit DeleteClientUserDefineRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteClientUserDefineRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteClientUserDefineRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteClientUserDefineRuleResponse() = default;
};
class DeleteCustomBlockRecordRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> resourceOwnerId{};

  DeleteCustomBlockRecordRequest() {}

  explicit DeleteCustomBlockRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteCustomBlockRecordRequest() = default;
};
class DeleteCustomBlockRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomBlockRecordResponseBody() {}

  explicit DeleteCustomBlockRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomBlockRecordResponseBody() = default;
};
class DeleteCustomBlockRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomBlockRecordResponseBody> body{};

  DeleteCustomBlockRecordResponse() {}

  explicit DeleteCustomBlockRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomBlockRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomBlockRecordResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomBlockRecordResponse() = default;
};
class DeleteCycleTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};

  DeleteCycleTaskRequest() {}

  explicit DeleteCycleTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
  }


  virtual ~DeleteCycleTaskRequest() = default;
};
class DeleteCycleTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCycleTaskResponseBody() {}

  explicit DeleteCycleTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCycleTaskResponseBody() = default;
};
class DeleteCycleTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCycleTaskResponseBody> body{};

  DeleteCycleTaskResponse() {}

  explicit DeleteCycleTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCycleTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCycleTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCycleTaskResponse() = default;
};
class DeleteGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> sourceIp{};

  DeleteGroupRequest() {}

  explicit DeleteGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DeleteGroupRequest() = default;
};
class DeleteGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};

  DeleteGroupResponseBody() {}

  explicit DeleteGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteGroupResponseBody() = default;
};
class DeleteGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGroupResponseBody> body{};

  DeleteGroupResponse() {}

  explicit DeleteGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGroupResponse() = default;
};
class DeleteHoneypotRequest : public Darabonba::Model {
public:
  shared_ptr<string> honeypotId{};
  shared_ptr<string> lang{};

  DeleteHoneypotRequest() {}

  explicit DeleteHoneypotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotId) {
      res["HoneypotId"] = boost::any(*honeypotId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotId") != m.end() && !m["HoneypotId"].empty()) {
      honeypotId = make_shared<string>(boost::any_cast<string>(m["HoneypotId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DeleteHoneypotRequest() = default;
};
class DeleteHoneypotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteHoneypotResponseBody() {}

  explicit DeleteHoneypotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteHoneypotResponseBody() = default;
};
class DeleteHoneypotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHoneypotResponseBody> body{};

  DeleteHoneypotResponse() {}

  explicit DeleteHoneypotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHoneypotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHoneypotResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHoneypotResponse() = default;
};
class DeleteHoneypotNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> nodeId{};

  DeleteHoneypotNodeRequest() {}

  explicit DeleteHoneypotNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~DeleteHoneypotNodeRequest() = default;
};
class DeleteHoneypotNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteHoneypotNodeResponseBody() {}

  explicit DeleteHoneypotNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteHoneypotNodeResponseBody() = default;
};
class DeleteHoneypotNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHoneypotNodeResponseBody> body{};

  DeleteHoneypotNodeResponse() {}

  explicit DeleteHoneypotNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHoneypotNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHoneypotNodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHoneypotNodeResponse() = default;
};
class DeleteHoneypotPresetRequest : public Darabonba::Model {
public:
  shared_ptr<string> honeypotPresetId{};
  shared_ptr<string> lang{};

  DeleteHoneypotPresetRequest() {}

  explicit DeleteHoneypotPresetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotPresetId) {
      res["HoneypotPresetId"] = boost::any(*honeypotPresetId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotPresetId") != m.end() && !m["HoneypotPresetId"].empty()) {
      honeypotPresetId = make_shared<string>(boost::any_cast<string>(m["HoneypotPresetId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DeleteHoneypotPresetRequest() = default;
};
class DeleteHoneypotPresetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteHoneypotPresetResponseBody() {}

  explicit DeleteHoneypotPresetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteHoneypotPresetResponseBody() = default;
};
class DeleteHoneypotPresetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHoneypotPresetResponseBody> body{};

  DeleteHoneypotPresetResponse() {}

  explicit DeleteHoneypotPresetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHoneypotPresetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHoneypotPresetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHoneypotPresetResponse() = default;
};
class DeleteHoneypotProbeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> probeId{};

  DeleteHoneypotProbeRequest() {}

  explicit DeleteHoneypotProbeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (probeId) {
      res["ProbeId"] = boost::any(*probeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ProbeId") != m.end() && !m["ProbeId"].empty()) {
      probeId = make_shared<string>(boost::any_cast<string>(m["ProbeId"]));
    }
  }


  virtual ~DeleteHoneypotProbeRequest() = default;
};
class DeleteHoneypotProbeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteHoneypotProbeResponseBody() {}

  explicit DeleteHoneypotProbeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteHoneypotProbeResponseBody() = default;
};
class DeleteHoneypotProbeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHoneypotProbeResponseBody> body{};

  DeleteHoneypotProbeResponse() {}

  explicit DeleteHoneypotProbeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHoneypotProbeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHoneypotProbeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHoneypotProbeResponse() = default;
};
class DeleteInstallCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> captchaCode{};

  DeleteInstallCodeRequest() {}

  explicit DeleteInstallCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (captchaCode) {
      res["CaptchaCode"] = boost::any(*captchaCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaptchaCode") != m.end() && !m["CaptchaCode"].empty()) {
      captchaCode = make_shared<string>(boost::any_cast<string>(m["CaptchaCode"]));
    }
  }


  virtual ~DeleteInstallCodeRequest() = default;
};
class DeleteInstallCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteInstallCodeResponseBody() {}

  explicit DeleteInstallCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteInstallCodeResponseBody() = default;
};
class DeleteInstallCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInstallCodeResponseBody> body{};

  DeleteInstallCodeResponse() {}

  explicit DeleteInstallCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstallCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstallCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstallCodeResponse() = default;
};
class DeleteInterceptionRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<vector<long>> ruleIds{};

  DeleteInterceptionRuleRequest() {}

  explicit DeleteInterceptionRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ruleIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DeleteInterceptionRuleRequest() = default;
};
class DeleteInterceptionRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteInterceptionRuleResponseBody() {}

  explicit DeleteInterceptionRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteInterceptionRuleResponseBody() = default;
};
class DeleteInterceptionRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInterceptionRuleResponseBody> body{};

  DeleteInterceptionRuleResponse() {}

  explicit DeleteInterceptionRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInterceptionRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInterceptionRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInterceptionRuleResponse() = default;
};
class DeleteInterceptionTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetIds{};

  DeleteInterceptionTargetRequest() {}

  explicit DeleteInterceptionTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetIds) {
      res["TargetIds"] = boost::any(*targetIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetIds") != m.end() && !m["TargetIds"].empty()) {
      targetIds = make_shared<string>(boost::any_cast<string>(m["TargetIds"]));
    }
  }


  virtual ~DeleteInterceptionTargetRequest() = default;
};
class DeleteInterceptionTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteInterceptionTargetResponseBody() {}

  explicit DeleteInterceptionTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteInterceptionTargetResponseBody() = default;
};
class DeleteInterceptionTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInterceptionTargetResponseBody> body{};

  DeleteInterceptionTargetResponse() {}

  explicit DeleteInterceptionTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInterceptionTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInterceptionTargetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInterceptionTargetResponse() = default;
};
class DeleteLoginBaseConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  DeleteLoginBaseConfigRequest() {}

  explicit DeleteLoginBaseConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteLoginBaseConfigRequest() = default;
};
class DeleteLoginBaseConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLoginBaseConfigResponseBody() {}

  explicit DeleteLoginBaseConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLoginBaseConfigResponseBody() = default;
};
class DeleteLoginBaseConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLoginBaseConfigResponseBody> body{};

  DeleteLoginBaseConfigResponse() {}

  explicit DeleteLoginBaseConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLoginBaseConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLoginBaseConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLoginBaseConfigResponse() = default;
};
class DeletePrivateRegistryRequest : public Darabonba::Model {
public:
  shared_ptr<long> registryId{};

  DeletePrivateRegistryRequest() {}

  explicit DeletePrivateRegistryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (registryId) {
      res["RegistryId"] = boost::any(*registryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegistryId") != m.end() && !m["RegistryId"].empty()) {
      registryId = make_shared<long>(boost::any_cast<long>(m["RegistryId"]));
    }
  }


  virtual ~DeletePrivateRegistryRequest() = default;
};
class DeletePrivateRegistryResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  DeletePrivateRegistryResponseBody() {}

  explicit DeletePrivateRegistryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePrivateRegistryResponseBody() = default;
};
class DeletePrivateRegistryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePrivateRegistryResponseBody> body{};

  DeletePrivateRegistryResponse() {}

  explicit DeletePrivateRegistryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePrivateRegistryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePrivateRegistryResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePrivateRegistryResponse() = default;
};
class DeleteSecurityEventMarkMissListRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> ids{};
  shared_ptr<long> resourceOwnerId{};

  DeleteSecurityEventMarkMissListRequest() {}

  explicit DeleteSecurityEventMarkMissListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ids = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteSecurityEventMarkMissListRequest() = default;
};
class DeleteSecurityEventMarkMissListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSecurityEventMarkMissListResponseBody() {}

  explicit DeleteSecurityEventMarkMissListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSecurityEventMarkMissListResponseBody() = default;
};
class DeleteSecurityEventMarkMissListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSecurityEventMarkMissListResponseBody> body{};

  DeleteSecurityEventMarkMissListResponse() {}

  explicit DeleteSecurityEventMarkMissListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSecurityEventMarkMissListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSecurityEventMarkMissListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSecurityEventMarkMissListResponse() = default;
};
class DeleteStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  DeleteStrategyRequest() {}

  explicit DeleteStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DeleteStrategyRequest() = default;
};
class DeleteStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteStrategyResponseBody() {}

  explicit DeleteStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteStrategyResponseBody() = default;
};
class DeleteStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStrategyResponseBody> body{};

  DeleteStrategyResponse() {}

  explicit DeleteStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStrategyResponse() = default;
};
class DeleteSuspEventNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> noteId{};

  DeleteSuspEventNodeRequest() {}

  explicit DeleteSuspEventNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (noteId) {
      res["NoteId"] = boost::any(*noteId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NoteId") != m.end() && !m["NoteId"].empty()) {
      noteId = make_shared<long>(boost::any_cast<long>(m["NoteId"]));
    }
  }


  virtual ~DeleteSuspEventNodeRequest() = default;
};
class DeleteSuspEventNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSuspEventNodeResponseBody() {}

  explicit DeleteSuspEventNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSuspEventNodeResponseBody() = default;
};
class DeleteSuspEventNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSuspEventNodeResponseBody> body{};

  DeleteSuspEventNodeResponse() {}

  explicit DeleteSuspEventNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSuspEventNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSuspEventNodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSuspEventNodeResponse() = default;
};
class DeleteTagWithUuidRequest : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> uuidList{};

  DeleteTagWithUuidRequest() {}

  explicit DeleteTagWithUuidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      uuidList = make_shared<string>(boost::any_cast<string>(m["UuidList"]));
    }
  }


  virtual ~DeleteTagWithUuidRequest() = default;
};
class DeleteTagWithUuidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTagWithUuidResponseBody() {}

  explicit DeleteTagWithUuidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTagWithUuidResponseBody() = default;
};
class DeleteTagWithUuidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTagWithUuidResponseBody> body{};

  DeleteTagWithUuidResponse() {}

  explicit DeleteTagWithUuidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTagWithUuidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTagWithUuidResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTagWithUuidResponse() = default;
};
class DeleteUniBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};
  shared_ptr<string> policyIds{};

  DeleteUniBackupPolicyRequest() {}

  explicit DeleteUniBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyIds) {
      res["PolicyIds"] = boost::any(*policyIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyIds") != m.end() && !m["PolicyIds"].empty()) {
      policyIds = make_shared<string>(boost::any_cast<string>(m["PolicyIds"]));
    }
  }


  virtual ~DeleteUniBackupPolicyRequest() = default;
};
class DeleteUniBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUniBackupPolicyResponseBody() {}

  explicit DeleteUniBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUniBackupPolicyResponseBody() = default;
};
class DeleteUniBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUniBackupPolicyResponseBody> body{};

  DeleteUniBackupPolicyResponse() {}

  explicit DeleteUniBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUniBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUniBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUniBackupPolicyResponse() = default;
};
class DeleteVpcHoneyPotRequest : public Darabonba::Model {
public:
  shared_ptr<string> vpcId{};

  DeleteVpcHoneyPotRequest() {}

  explicit DeleteVpcHoneyPotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DeleteVpcHoneyPotRequest() = default;
};
class DeleteVpcHoneyPotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVpcHoneyPotResponseBody() {}

  explicit DeleteVpcHoneyPotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVpcHoneyPotResponseBody() = default;
};
class DeleteVpcHoneyPotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVpcHoneyPotResponseBody> body{};

  DeleteVpcHoneyPotResponse() {}

  explicit DeleteVpcHoneyPotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpcHoneyPotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpcHoneyPotResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpcHoneyPotResponse() = default;
};
class DeleteVulWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> whitelist{};

  DeleteVulWhitelistRequest() {}

  explicit DeleteVulWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (whitelist) {
      res["Whitelist"] = boost::any(*whitelist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Whitelist") != m.end() && !m["Whitelist"].empty()) {
      whitelist = make_shared<string>(boost::any_cast<string>(m["Whitelist"]));
    }
  }


  virtual ~DeleteVulWhitelistRequest() = default;
};
class DeleteVulWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVulWhitelistResponseBody() {}

  explicit DeleteVulWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVulWhitelistResponseBody() = default;
};
class DeleteVulWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVulWhitelistResponseBody> body{};

  DeleteVulWhitelistResponse() {}

  explicit DeleteVulWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVulWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVulWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVulWhitelistResponse() = default;
};
class DescribeAccessKeyLeakDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DescribeAccessKeyLeakDetailRequest() {}

  explicit DescribeAccessKeyLeakDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeAccessKeyLeakDetailRequest() = default;
};
class DescribeAccessKeyLeakDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accesskeyId{};
  shared_ptr<string> asset{};
  shared_ptr<string> code{};
  shared_ptr<string> dealTime{};
  shared_ptr<string> dealType{};
  shared_ptr<string> githubFileName{};
  shared_ptr<string> githubFileType{};
  shared_ptr<string> githubFileUpdateTime{};
  shared_ptr<string> githubFileUrl{};
  shared_ptr<string> githubRepoName{};
  shared_ptr<string> githubRepoUrl{};
  shared_ptr<string> githubUser{};
  shared_ptr<string> githubUserPicUrl{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> remark{};
  shared_ptr<string> requestId{};
  shared_ptr<string> source{};
  shared_ptr<string> type{};
  shared_ptr<string> whitelistStatus{};

  DescribeAccessKeyLeakDetailResponseBody() {}

  explicit DescribeAccessKeyLeakDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accesskeyId) {
      res["AccesskeyId"] = boost::any(*accesskeyId);
    }
    if (asset) {
      res["Asset"] = boost::any(*asset);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dealTime) {
      res["DealTime"] = boost::any(*dealTime);
    }
    if (dealType) {
      res["DealType"] = boost::any(*dealType);
    }
    if (githubFileName) {
      res["GithubFileName"] = boost::any(*githubFileName);
    }
    if (githubFileType) {
      res["GithubFileType"] = boost::any(*githubFileType);
    }
    if (githubFileUpdateTime) {
      res["GithubFileUpdateTime"] = boost::any(*githubFileUpdateTime);
    }
    if (githubFileUrl) {
      res["GithubFileUrl"] = boost::any(*githubFileUrl);
    }
    if (githubRepoName) {
      res["GithubRepoName"] = boost::any(*githubRepoName);
    }
    if (githubRepoUrl) {
      res["GithubRepoUrl"] = boost::any(*githubRepoUrl);
    }
    if (githubUser) {
      res["GithubUser"] = boost::any(*githubUser);
    }
    if (githubUserPicUrl) {
      res["GithubUserPicUrl"] = boost::any(*githubUserPicUrl);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (whitelistStatus) {
      res["WhitelistStatus"] = boost::any(*whitelistStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccesskeyId") != m.end() && !m["AccesskeyId"].empty()) {
      accesskeyId = make_shared<string>(boost::any_cast<string>(m["AccesskeyId"]));
    }
    if (m.find("Asset") != m.end() && !m["Asset"].empty()) {
      asset = make_shared<string>(boost::any_cast<string>(m["Asset"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DealTime") != m.end() && !m["DealTime"].empty()) {
      dealTime = make_shared<string>(boost::any_cast<string>(m["DealTime"]));
    }
    if (m.find("DealType") != m.end() && !m["DealType"].empty()) {
      dealType = make_shared<string>(boost::any_cast<string>(m["DealType"]));
    }
    if (m.find("GithubFileName") != m.end() && !m["GithubFileName"].empty()) {
      githubFileName = make_shared<string>(boost::any_cast<string>(m["GithubFileName"]));
    }
    if (m.find("GithubFileType") != m.end() && !m["GithubFileType"].empty()) {
      githubFileType = make_shared<string>(boost::any_cast<string>(m["GithubFileType"]));
    }
    if (m.find("GithubFileUpdateTime") != m.end() && !m["GithubFileUpdateTime"].empty()) {
      githubFileUpdateTime = make_shared<string>(boost::any_cast<string>(m["GithubFileUpdateTime"]));
    }
    if (m.find("GithubFileUrl") != m.end() && !m["GithubFileUrl"].empty()) {
      githubFileUrl = make_shared<string>(boost::any_cast<string>(m["GithubFileUrl"]));
    }
    if (m.find("GithubRepoName") != m.end() && !m["GithubRepoName"].empty()) {
      githubRepoName = make_shared<string>(boost::any_cast<string>(m["GithubRepoName"]));
    }
    if (m.find("GithubRepoUrl") != m.end() && !m["GithubRepoUrl"].empty()) {
      githubRepoUrl = make_shared<string>(boost::any_cast<string>(m["GithubRepoUrl"]));
    }
    if (m.find("GithubUser") != m.end() && !m["GithubUser"].empty()) {
      githubUser = make_shared<string>(boost::any_cast<string>(m["GithubUser"]));
    }
    if (m.find("GithubUserPicUrl") != m.end() && !m["GithubUserPicUrl"].empty()) {
      githubUserPicUrl = make_shared<string>(boost::any_cast<string>(m["GithubUserPicUrl"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WhitelistStatus") != m.end() && !m["WhitelistStatus"].empty()) {
      whitelistStatus = make_shared<string>(boost::any_cast<string>(m["WhitelistStatus"]));
    }
  }


  virtual ~DescribeAccessKeyLeakDetailResponseBody() = default;
};
class DescribeAccessKeyLeakDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAccessKeyLeakDetailResponseBody> body{};

  DescribeAccessKeyLeakDetailResponse() {}

  explicit DescribeAccessKeyLeakDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccessKeyLeakDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccessKeyLeakDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccessKeyLeakDetailResponse() = default;
};
class DescribeAccesskeyLeakListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<long> startTs{};
  shared_ptr<string> status{};

  DescribeAccesskeyLeakListRequest() {}

  explicit DescribeAccesskeyLeakListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAccesskeyLeakListRequest() = default;
};
class DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList : public Darabonba::Model {
public:
  shared_ptr<string> accesskeyId{};
  shared_ptr<string> aliUserName{};
  shared_ptr<string> asset{};
  shared_ptr<string> dealTime{};
  shared_ptr<string> dealType{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};
  shared_ptr<string> userType{};

  DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList() {}

  explicit DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accesskeyId) {
      res["AccesskeyId"] = boost::any(*accesskeyId);
    }
    if (aliUserName) {
      res["AliUserName"] = boost::any(*aliUserName);
    }
    if (asset) {
      res["Asset"] = boost::any(*asset);
    }
    if (dealTime) {
      res["DealTime"] = boost::any(*dealTime);
    }
    if (dealType) {
      res["DealType"] = boost::any(*dealType);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccesskeyId") != m.end() && !m["AccesskeyId"].empty()) {
      accesskeyId = make_shared<string>(boost::any_cast<string>(m["AccesskeyId"]));
    }
    if (m.find("AliUserName") != m.end() && !m["AliUserName"].empty()) {
      aliUserName = make_shared<string>(boost::any_cast<string>(m["AliUserName"]));
    }
    if (m.find("Asset") != m.end() && !m["Asset"].empty()) {
      asset = make_shared<string>(boost::any_cast<string>(m["Asset"]));
    }
    if (m.find("DealTime") != m.end() && !m["DealTime"].empty()) {
      dealTime = make_shared<string>(boost::any_cast<string>(m["DealTime"]));
    }
    if (m.find("DealType") != m.end() && !m["DealType"].empty()) {
      dealType = make_shared<string>(boost::any_cast<string>(m["DealType"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList() = default;
};
class DescribeAccesskeyLeakListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList>> accessKeyLeakList{};
  shared_ptr<long> akLeakCount{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> gmtLast{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAccesskeyLeakListResponseBody() {}

  explicit DescribeAccesskeyLeakListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyLeakList) {
      vector<boost::any> temp1;
      for(auto item1:*accessKeyLeakList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessKeyLeakList"] = boost::any(temp1);
    }
    if (akLeakCount) {
      res["AkLeakCount"] = boost::any(*akLeakCount);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (gmtLast) {
      res["GmtLast"] = boost::any(*gmtLast);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyLeakList") != m.end() && !m["AccessKeyLeakList"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessKeyLeakList"].type()) {
        vector<DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessKeyLeakList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessKeyLeakList = make_shared<vector<DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList>>(expect1);
      }
    }
    if (m.find("AkLeakCount") != m.end() && !m["AkLeakCount"].empty()) {
      akLeakCount = make_shared<long>(boost::any_cast<long>(m["AkLeakCount"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GmtLast") != m.end() && !m["GmtLast"].empty()) {
      gmtLast = make_shared<long>(boost::any_cast<long>(m["GmtLast"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAccesskeyLeakListResponseBody() = default;
};
class DescribeAccesskeyLeakListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAccesskeyLeakListResponseBody> body{};

  DescribeAccesskeyLeakListResponse() {}

  explicit DescribeAccesskeyLeakListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccesskeyLeakListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccesskeyLeakListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccesskeyLeakListResponse() = default;
};
class DescribeAffectedAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> current{};
  shared_ptr<string> levels{};
  shared_ptr<string> pageSize{};

  DescribeAffectedAssetsRequest() {}

  explicit DescribeAffectedAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (levels) {
      res["Levels"] = boost::any(*levels);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<string>(boost::any_cast<string>(m["Current"]));
    }
    if (m.find("Levels") != m.end() && !m["Levels"].empty()) {
      levels = make_shared<string>(boost::any_cast<string>(m["Levels"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~DescribeAffectedAssetsRequest() = default;
};
class DescribeAffectedAssetsResponseBodyAssetList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> riskNum{};
  shared_ptr<string> uuid{};

  DescribeAffectedAssetsResponseBodyAssetList() {}

  explicit DescribeAffectedAssetsResponseBodyAssetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (riskNum) {
      res["RiskNum"] = boost::any(*riskNum);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("RiskNum") != m.end() && !m["RiskNum"].empty()) {
      riskNum = make_shared<long>(boost::any_cast<long>(m["RiskNum"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeAffectedAssetsResponseBodyAssetList() = default;
};
class DescribeAffectedAssetsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAffectedAssetsResponseBodyPageInfo() {}

  explicit DescribeAffectedAssetsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAffectedAssetsResponseBodyPageInfo() = default;
};
class DescribeAffectedAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAffectedAssetsResponseBodyAssetList>> assetList{};
  shared_ptr<DescribeAffectedAssetsResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeAffectedAssetsResponseBody() {}

  explicit DescribeAffectedAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetList) {
      vector<boost::any> temp1;
      for(auto item1:*assetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssetList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetList") != m.end() && !m["AssetList"].empty()) {
      if (typeid(vector<boost::any>) == m["AssetList"].type()) {
        vector<DescribeAffectedAssetsResponseBodyAssetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAffectedAssetsResponseBodyAssetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        assetList = make_shared<vector<DescribeAffectedAssetsResponseBodyAssetList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeAffectedAssetsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeAffectedAssetsResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAffectedAssetsResponseBody() = default;
};
class DescribeAffectedAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAffectedAssetsResponseBody> body{};

  DescribeAffectedAssetsResponse() {}

  explicit DescribeAffectedAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAffectedAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAffectedAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAffectedAssetsResponse() = default;
};
class DescribeAffectedMaliciousFileImagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> containerId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> image{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> imageLayer{};
  shared_ptr<string> imageTag{};
  shared_ptr<string> lang{};
  shared_ptr<string> levels{};
  shared_ptr<string> maliciousMd5{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> pod{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<vector<string>> scanRange{};

  DescribeAffectedMaliciousFileImagesRequest() {}

  explicit DescribeAffectedMaliciousFileImagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (imageLayer) {
      res["ImageLayer"] = boost::any(*imageLayer);
    }
    if (imageTag) {
      res["ImageTag"] = boost::any(*imageTag);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (levels) {
      res["Levels"] = boost::any(*levels);
    }
    if (maliciousMd5) {
      res["MaliciousMd5"] = boost::any(*maliciousMd5);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("ImageLayer") != m.end() && !m["ImageLayer"].empty()) {
      imageLayer = make_shared<string>(boost::any_cast<string>(m["ImageLayer"]));
    }
    if (m.find("ImageTag") != m.end() && !m["ImageTag"].empty()) {
      imageTag = make_shared<string>(boost::any_cast<string>(m["ImageTag"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Levels") != m.end() && !m["Levels"].empty()) {
      levels = make_shared<string>(boost::any_cast<string>(m["Levels"]));
    }
    if (m.find("MaliciousMd5") != m.end() && !m["MaliciousMd5"].empty()) {
      maliciousMd5 = make_shared<string>(boost::any_cast<string>(m["MaliciousMd5"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAffectedMaliciousFileImagesRequest() = default;
};
class DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> containerId{};
  shared_ptr<string> digest{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> filePath{};
  shared_ptr<long> firstScanTimestamp{};
  shared_ptr<string> highLight{};
  shared_ptr<string> image{};
  shared_ptr<string> imageUuid{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> latestScanTimestamp{};
  shared_ptr<long> latestVerifyTimestamp{};
  shared_ptr<string> layer{};
  shared_ptr<string> level{};
  shared_ptr<string> maliciousMd5{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> pod{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<long> status{};
  shared_ptr<string> tag{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};
  shared_ptr<string> uuid{};

  DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse() {}

  explicit DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (firstScanTimestamp) {
      res["FirstScanTimestamp"] = boost::any(*firstScanTimestamp);
    }
    if (highLight) {
      res["HighLight"] = boost::any(*highLight);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (latestScanTimestamp) {
      res["LatestScanTimestamp"] = boost::any(*latestScanTimestamp);
    }
    if (latestVerifyTimestamp) {
      res["LatestVerifyTimestamp"] = boost::any(*latestVerifyTimestamp);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (maliciousMd5) {
      res["MaliciousMd5"] = boost::any(*maliciousMd5);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("FirstScanTimestamp") != m.end() && !m["FirstScanTimestamp"].empty()) {
      firstScanTimestamp = make_shared<long>(boost::any_cast<long>(m["FirstScanTimestamp"]));
    }
    if (m.find("HighLight") != m.end() && !m["HighLight"].empty()) {
      highLight = make_shared<string>(boost::any_cast<string>(m["HighLight"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("LatestScanTimestamp") != m.end() && !m["LatestScanTimestamp"].empty()) {
      latestScanTimestamp = make_shared<long>(boost::any_cast<long>(m["LatestScanTimestamp"]));
    }
    if (m.find("LatestVerifyTimestamp") != m.end() && !m["LatestVerifyTimestamp"].empty()) {
      latestVerifyTimestamp = make_shared<long>(boost::any_cast<long>(m["LatestVerifyTimestamp"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MaliciousMd5") != m.end() && !m["MaliciousMd5"].empty()) {
      maliciousMd5 = make_shared<string>(boost::any_cast<string>(m["MaliciousMd5"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse() = default;
};
class DescribeAffectedMaliciousFileImagesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAffectedMaliciousFileImagesResponseBodyPageInfo() {}

  explicit DescribeAffectedMaliciousFileImagesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAffectedMaliciousFileImagesResponseBodyPageInfo() = default;
};
class DescribeAffectedMaliciousFileImagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse>> affectedMaliciousFileImagesResponse{};
  shared_ptr<DescribeAffectedMaliciousFileImagesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeAffectedMaliciousFileImagesResponseBody() {}

  explicit DescribeAffectedMaliciousFileImagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedMaliciousFileImagesResponse) {
      vector<boost::any> temp1;
      for(auto item1:*affectedMaliciousFileImagesResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AffectedMaliciousFileImagesResponse"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedMaliciousFileImagesResponse") != m.end() && !m["AffectedMaliciousFileImagesResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["AffectedMaliciousFileImagesResponse"].type()) {
        vector<DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AffectedMaliciousFileImagesResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        affectedMaliciousFileImagesResponse = make_shared<vector<DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeAffectedMaliciousFileImagesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeAffectedMaliciousFileImagesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAffectedMaliciousFileImagesResponseBody() = default;
};
class DescribeAffectedMaliciousFileImagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAffectedMaliciousFileImagesResponseBody> body{};

  DescribeAffectedMaliciousFileImagesResponse() {}

  explicit DescribeAffectedMaliciousFileImagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAffectedMaliciousFileImagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAffectedMaliciousFileImagesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAffectedMaliciousFileImagesResponse() = default;
};
class DescribeAgentInstallStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuids{};

  DescribeAgentInstallStatusRequest() {}

  explicit DescribeAgentInstallStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeAgentInstallStatusRequest() = default;
};
class DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> resuleCode{};
  shared_ptr<long> result{};
  shared_ptr<string> uuid{};

  DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList() {}

  explicit DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (resuleCode) {
      res["ResuleCode"] = boost::any(*resuleCode);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ResuleCode") != m.end() && !m["ResuleCode"].empty()) {
      resuleCode = make_shared<string>(boost::any_cast<string>(m["ResuleCode"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList() = default;
};
class DescribeAgentInstallStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList>> aegisClientInvokeStatusResponseList{};
  shared_ptr<string> requestId{};

  DescribeAgentInstallStatusResponseBody() {}

  explicit DescribeAgentInstallStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aegisClientInvokeStatusResponseList) {
      vector<boost::any> temp1;
      for(auto item1:*aegisClientInvokeStatusResponseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AegisClientInvokeStatusResponseList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AegisClientInvokeStatusResponseList") != m.end() && !m["AegisClientInvokeStatusResponseList"].empty()) {
      if (typeid(vector<boost::any>) == m["AegisClientInvokeStatusResponseList"].type()) {
        vector<DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AegisClientInvokeStatusResponseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aegisClientInvokeStatusResponseList = make_shared<vector<DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAgentInstallStatusResponseBody() = default;
};
class DescribeAgentInstallStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAgentInstallStatusResponseBody> body{};

  DescribeAgentInstallStatusResponse() {}

  explicit DescribeAgentInstallStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAgentInstallStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAgentInstallStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAgentInstallStatusResponse() = default;
};
class DescribeAlarmEventDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmUniqueInfo{};
  shared_ptr<string> from{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  DescribeAlarmEventDetailRequest() {}

  explicit DescribeAlarmEventDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmUniqueInfo) {
      res["AlarmUniqueInfo"] = boost::any(*alarmUniqueInfo);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmUniqueInfo") != m.end() && !m["AlarmUniqueInfo"].empty()) {
      alarmUniqueInfo = make_shared<string>(boost::any_cast<string>(m["AlarmUniqueInfo"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeAlarmEventDetailRequest() = default;
};
class DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue() {}

  explicit DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue() = default;
};
class DescribeAlarmEventDetailResponseBodyDataCauseDetails : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue>> value{};

  DescribeAlarmEventDetailResponseBodyDataCauseDetails() {}

  explicit DescribeAlarmEventDetailResponseBodyDataCauseDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      vector<boost::any> temp1;
      for(auto item1:*value){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Value"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Value"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        value = make_shared<vector<DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue>>(expect1);
      }
    }
  }


  virtual ~DescribeAlarmEventDetailResponseBodyDataCauseDetails() = default;
};
class DescribeAlarmEventDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> alarmEventAliasName{};
  shared_ptr<string> alarmEventDesc{};
  shared_ptr<string> alarmUniqueInfo{};
  shared_ptr<string> appName{};
  shared_ptr<bool> canBeDealOnLine{};
  shared_ptr<bool> canCancelFault{};
  shared_ptr<vector<DescribeAlarmEventDetailResponseBodyDataCauseDetails>> causeDetails{};
  shared_ptr<bool> containHwMode{};
  shared_ptr<string> containerId{};
  shared_ptr<string> containerImageId{};
  shared_ptr<string> containerImageName{};
  shared_ptr<string> dataSource{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> k8sClusterName{};
  shared_ptr<string> k8sNamespace{};
  shared_ptr<string> k8sNodeId{};
  shared_ptr<string> k8sNodeName{};
  shared_ptr<string> k8sPodName{};
  shared_ptr<string> level{};
  shared_ptr<string> solution{};
  shared_ptr<long> startTime{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  DescribeAlarmEventDetailResponseBodyData() {}

  explicit DescribeAlarmEventDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmEventAliasName) {
      res["AlarmEventAliasName"] = boost::any(*alarmEventAliasName);
    }
    if (alarmEventDesc) {
      res["AlarmEventDesc"] = boost::any(*alarmEventDesc);
    }
    if (alarmUniqueInfo) {
      res["AlarmUniqueInfo"] = boost::any(*alarmUniqueInfo);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (canBeDealOnLine) {
      res["CanBeDealOnLine"] = boost::any(*canBeDealOnLine);
    }
    if (canCancelFault) {
      res["CanCancelFault"] = boost::any(*canCancelFault);
    }
    if (causeDetails) {
      vector<boost::any> temp1;
      for(auto item1:*causeDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CauseDetails"] = boost::any(temp1);
    }
    if (containHwMode) {
      res["ContainHwMode"] = boost::any(*containHwMode);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (containerImageId) {
      res["ContainerImageId"] = boost::any(*containerImageId);
    }
    if (containerImageName) {
      res["ContainerImageName"] = boost::any(*containerImageName);
    }
    if (dataSource) {
      res["DataSource"] = boost::any(*dataSource);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (k8sClusterName) {
      res["K8sClusterName"] = boost::any(*k8sClusterName);
    }
    if (k8sNamespace) {
      res["K8sNamespace"] = boost::any(*k8sNamespace);
    }
    if (k8sNodeId) {
      res["K8sNodeId"] = boost::any(*k8sNodeId);
    }
    if (k8sNodeName) {
      res["K8sNodeName"] = boost::any(*k8sNodeName);
    }
    if (k8sPodName) {
      res["K8sPodName"] = boost::any(*k8sPodName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (solution) {
      res["Solution"] = boost::any(*solution);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmEventAliasName") != m.end() && !m["AlarmEventAliasName"].empty()) {
      alarmEventAliasName = make_shared<string>(boost::any_cast<string>(m["AlarmEventAliasName"]));
    }
    if (m.find("AlarmEventDesc") != m.end() && !m["AlarmEventDesc"].empty()) {
      alarmEventDesc = make_shared<string>(boost::any_cast<string>(m["AlarmEventDesc"]));
    }
    if (m.find("AlarmUniqueInfo") != m.end() && !m["AlarmUniqueInfo"].empty()) {
      alarmUniqueInfo = make_shared<string>(boost::any_cast<string>(m["AlarmUniqueInfo"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CanBeDealOnLine") != m.end() && !m["CanBeDealOnLine"].empty()) {
      canBeDealOnLine = make_shared<bool>(boost::any_cast<bool>(m["CanBeDealOnLine"]));
    }
    if (m.find("CanCancelFault") != m.end() && !m["CanCancelFault"].empty()) {
      canCancelFault = make_shared<bool>(boost::any_cast<bool>(m["CanCancelFault"]));
    }
    if (m.find("CauseDetails") != m.end() && !m["CauseDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["CauseDetails"].type()) {
        vector<DescribeAlarmEventDetailResponseBodyDataCauseDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CauseDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAlarmEventDetailResponseBodyDataCauseDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        causeDetails = make_shared<vector<DescribeAlarmEventDetailResponseBodyDataCauseDetails>>(expect1);
      }
    }
    if (m.find("ContainHwMode") != m.end() && !m["ContainHwMode"].empty()) {
      containHwMode = make_shared<bool>(boost::any_cast<bool>(m["ContainHwMode"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("ContainerImageId") != m.end() && !m["ContainerImageId"].empty()) {
      containerImageId = make_shared<string>(boost::any_cast<string>(m["ContainerImageId"]));
    }
    if (m.find("ContainerImageName") != m.end() && !m["ContainerImageName"].empty()) {
      containerImageName = make_shared<string>(boost::any_cast<string>(m["ContainerImageName"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSource = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("K8sClusterName") != m.end() && !m["K8sClusterName"].empty()) {
      k8sClusterName = make_shared<string>(boost::any_cast<string>(m["K8sClusterName"]));
    }
    if (m.find("K8sNamespace") != m.end() && !m["K8sNamespace"].empty()) {
      k8sNamespace = make_shared<string>(boost::any_cast<string>(m["K8sNamespace"]));
    }
    if (m.find("K8sNodeId") != m.end() && !m["K8sNodeId"].empty()) {
      k8sNodeId = make_shared<string>(boost::any_cast<string>(m["K8sNodeId"]));
    }
    if (m.find("K8sNodeName") != m.end() && !m["K8sNodeName"].empty()) {
      k8sNodeName = make_shared<string>(boost::any_cast<string>(m["K8sNodeName"]));
    }
    if (m.find("K8sPodName") != m.end() && !m["K8sPodName"].empty()) {
      k8sPodName = make_shared<string>(boost::any_cast<string>(m["K8sPodName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Solution") != m.end() && !m["Solution"].empty()) {
      solution = make_shared<string>(boost::any_cast<string>(m["Solution"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeAlarmEventDetailResponseBodyData() = default;
};
class DescribeAlarmEventDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAlarmEventDetailResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeAlarmEventDetailResponseBody() {}

  explicit DescribeAlarmEventDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeAlarmEventDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeAlarmEventDetailResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAlarmEventDetailResponseBody() = default;
};
class DescribeAlarmEventDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAlarmEventDetailResponseBody> body{};

  DescribeAlarmEventDetailResponse() {}

  explicit DescribeAlarmEventDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlarmEventDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlarmEventDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlarmEventDetailResponse() = default;
};
class DescribeAlarmEventStackInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uniqueInfo{};
  shared_ptr<string> uuid{};

  DescribeAlarmEventStackInfoRequest() {}

  explicit DescribeAlarmEventStackInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uniqueInfo) {
      res["UniqueInfo"] = boost::any(*uniqueInfo);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("UniqueInfo") != m.end() && !m["UniqueInfo"].empty()) {
      uniqueInfo = make_shared<string>(boost::any_cast<string>(m["UniqueInfo"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeAlarmEventStackInfoRequest() = default;
};
class DescribeAlarmEventStackInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> stackInfo{};

  DescribeAlarmEventStackInfoResponseBody() {}

  explicit DescribeAlarmEventStackInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stackInfo) {
      res["StackInfo"] = boost::any(*stackInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StackInfo") != m.end() && !m["StackInfo"].empty()) {
      stackInfo = make_shared<string>(boost::any_cast<string>(m["StackInfo"]));
    }
  }


  virtual ~DescribeAlarmEventStackInfoResponseBody() = default;
};
class DescribeAlarmEventStackInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAlarmEventStackInfoResponseBody> body{};

  DescribeAlarmEventStackInfoResponse() {}

  explicit DescribeAlarmEventStackInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAlarmEventStackInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAlarmEventStackInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAlarmEventStackInfoResponse() = default;
};
class DescribeAllEntityResponseBodyEntityList : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> os{};
  shared_ptr<string> uuid{};

  DescribeAllEntityResponseBodyEntityList() {}

  explicit DescribeAllEntityResponseBodyEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeAllEntityResponseBodyEntityList() = default;
};
class DescribeAllEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAllEntityResponseBodyEntityList>> entityList{};
  shared_ptr<string> requestId{};

  DescribeAllEntityResponseBody() {}

  explicit DescribeAllEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityList) {
      vector<boost::any> temp1;
      for(auto item1:*entityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EntityList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityList") != m.end() && !m["EntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["EntityList"].type()) {
        vector<DescribeAllEntityResponseBodyEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllEntityResponseBodyEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityList = make_shared<vector<DescribeAllEntityResponseBodyEntityList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAllEntityResponseBody() = default;
};
class DescribeAllEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAllEntityResponseBody> body{};

  DescribeAllEntityResponse() {}

  explicit DescribeAllEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAllEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAllEntityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAllEntityResponse() = default;
};
class DescribeAllGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeAllGroupsRequest() {}

  explicit DescribeAllGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeAllGroupsRequest() = default;
};
class DescribeAllGroupsResponseBodyGroups : public Darabonba::Model {
public:
  shared_ptr<long> groupFlag{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};

  DescribeAllGroupsResponseBodyGroups() {}

  explicit DescribeAllGroupsResponseBodyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupFlag) {
      res["GroupFlag"] = boost::any(*groupFlag);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupFlag") != m.end() && !m["GroupFlag"].empty()) {
      groupFlag = make_shared<long>(boost::any_cast<long>(m["GroupFlag"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~DescribeAllGroupsResponseBodyGroups() = default;
};
class DescribeAllGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeAllGroupsResponseBodyGroups>> groups{};
  shared_ptr<string> requestId{};

  DescribeAllGroupsResponseBody() {}

  explicit DescribeAllGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<DescribeAllGroupsResponseBodyGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllGroupsResponseBodyGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<DescribeAllGroupsResponseBodyGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAllGroupsResponseBody() = default;
};
class DescribeAllGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAllGroupsResponseBody> body{};

  DescribeAllGroupsResponse() {}

  explicit DescribeAllGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAllGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAllGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAllGroupsResponse() = default;
};
class DescribeAllImageBaselineRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeAllImageBaselineRequest() {}

  explicit DescribeAllImageBaselineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeAllImageBaselineRequest() = default;
};
class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> classKey{};
  shared_ptr<string> itemKey{};
  shared_ptr<string> nameKey{};

  DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList() {}

  explicit DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (classKey) {
      res["ClassKey"] = boost::any(*classKey);
    }
    if (itemKey) {
      res["ItemKey"] = boost::any(*itemKey);
    }
    if (nameKey) {
      res["NameKey"] = boost::any(*nameKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("ClassKey") != m.end() && !m["ClassKey"].empty()) {
      classKey = make_shared<string>(boost::any_cast<string>(m["ClassKey"]));
    }
    if (m.find("ItemKey") != m.end() && !m["ItemKey"].empty()) {
      itemKey = make_shared<string>(boost::any_cast<string>(m["ItemKey"]));
    }
    if (m.find("NameKey") != m.end() && !m["NameKey"].empty()) {
      nameKey = make_shared<string>(boost::any_cast<string>(m["NameKey"]));
    }
  }


  virtual ~DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList() = default;
};
class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<vector<DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList>> baselineItemList{};
  shared_ptr<string> classKey{};
  shared_ptr<string> nameKey{};

  DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList() {}

  explicit DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (baselineItemList) {
      vector<boost::any> temp1;
      for(auto item1:*baselineItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaselineItemList"] = boost::any(temp1);
    }
    if (classKey) {
      res["ClassKey"] = boost::any(*classKey);
    }
    if (nameKey) {
      res["NameKey"] = boost::any(*nameKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("BaselineItemList") != m.end() && !m["BaselineItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["BaselineItemList"].type()) {
        vector<DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaselineItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselineItemList = make_shared<vector<DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList>>(expect1);
      }
    }
    if (m.find("ClassKey") != m.end() && !m["ClassKey"].empty()) {
      classKey = make_shared<string>(boost::any_cast<string>(m["ClassKey"]));
    }
    if (m.find("NameKey") != m.end() && !m["NameKey"].empty()) {
      nameKey = make_shared<string>(boost::any_cast<string>(m["NameKey"]));
    }
  }


  virtual ~DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList() = default;
};
class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<vector<DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList>> baselineNameList{};
  shared_ptr<string> classKey{};

  DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList() {}

  explicit DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (baselineNameList) {
      vector<boost::any> temp1;
      for(auto item1:*baselineNameList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaselineNameList"] = boost::any(temp1);
    }
    if (classKey) {
      res["ClassKey"] = boost::any(*classKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("BaselineNameList") != m.end() && !m["BaselineNameList"].empty()) {
      if (typeid(vector<boost::any>) == m["BaselineNameList"].type()) {
        vector<DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaselineNameList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselineNameList = make_shared<vector<DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList>>(expect1);
      }
    }
    if (m.find("ClassKey") != m.end() && !m["ClassKey"].empty()) {
      classKey = make_shared<string>(boost::any_cast<string>(m["ClassKey"]));
    }
  }


  virtual ~DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList() = default;
};
class DescribeAllImageBaselineResponseBodyImageBaselines : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList>> baselineClassList{};

  DescribeAllImageBaselineResponseBodyImageBaselines() {}

  explicit DescribeAllImageBaselineResponseBodyImageBaselines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineClassList) {
      vector<boost::any> temp1;
      for(auto item1:*baselineClassList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaselineClassList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineClassList") != m.end() && !m["BaselineClassList"].empty()) {
      if (typeid(vector<boost::any>) == m["BaselineClassList"].type()) {
        vector<DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaselineClassList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselineClassList = make_shared<vector<DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList>>(expect1);
      }
    }
  }


  virtual ~DescribeAllImageBaselineResponseBodyImageBaselines() = default;
};
class DescribeAllImageBaselineResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAllImageBaselineResponseBodyImageBaselines> imageBaselines{};
  shared_ptr<string> requestId{};

  DescribeAllImageBaselineResponseBody() {}

  explicit DescribeAllImageBaselineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageBaselines) {
      res["ImageBaselines"] = imageBaselines ? boost::any(imageBaselines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageBaselines") != m.end() && !m["ImageBaselines"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageBaselines"].type()) {
        DescribeAllImageBaselineResponseBodyImageBaselines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageBaselines"]));
        imageBaselines = make_shared<DescribeAllImageBaselineResponseBodyImageBaselines>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAllImageBaselineResponseBody() = default;
};
class DescribeAllImageBaselineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAllImageBaselineResponseBody> body{};

  DescribeAllImageBaselineResponse() {}

  explicit DescribeAllImageBaselineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAllImageBaselineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAllImageBaselineResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAllImageBaselineResponse() = default;
};
class DescribeAntiBruteForceRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> id{};
  shared_ptr<string> pageSize{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};

  DescribeAntiBruteForceRulesRequest() {}

  explicit DescribeAntiBruteForceRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeAntiBruteForceRulesRequest() = default;
};
class DescribeAntiBruteForceRulesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntiBruteForceRulesResponseBodyPageInfo() {}

  explicit DescribeAntiBruteForceRulesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntiBruteForceRulesResponseBodyPageInfo() = default;
};
class DescribeAntiBruteForceRulesResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<bool> defaultRule{};
  shared_ptr<bool> enableSmartRule{};
  shared_ptr<long> failCount{};
  shared_ptr<long> forbiddenTime{};
  shared_ptr<long> id{};
  shared_ptr<long> machineCount{};
  shared_ptr<string> name{};
  shared_ptr<long> span{};
  shared_ptr<vector<string>> uuidList{};

  DescribeAntiBruteForceRulesResponseBodyRules() {}

  explicit DescribeAntiBruteForceRulesResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultRule) {
      res["DefaultRule"] = boost::any(*defaultRule);
    }
    if (enableSmartRule) {
      res["EnableSmartRule"] = boost::any(*enableSmartRule);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (forbiddenTime) {
      res["ForbiddenTime"] = boost::any(*forbiddenTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (machineCount) {
      res["MachineCount"] = boost::any(*machineCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (span) {
      res["Span"] = boost::any(*span);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultRule") != m.end() && !m["DefaultRule"].empty()) {
      defaultRule = make_shared<bool>(boost::any_cast<bool>(m["DefaultRule"]));
    }
    if (m.find("EnableSmartRule") != m.end() && !m["EnableSmartRule"].empty()) {
      enableSmartRule = make_shared<bool>(boost::any_cast<bool>(m["EnableSmartRule"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("ForbiddenTime") != m.end() && !m["ForbiddenTime"].empty()) {
      forbiddenTime = make_shared<long>(boost::any_cast<long>(m["ForbiddenTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MachineCount") != m.end() && !m["MachineCount"].empty()) {
      machineCount = make_shared<long>(boost::any_cast<long>(m["MachineCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Span") != m.end() && !m["Span"].empty()) {
      span = make_shared<long>(boost::any_cast<long>(m["Span"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAntiBruteForceRulesResponseBodyRules() = default;
};
class DescribeAntiBruteForceRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAntiBruteForceRulesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntiBruteForceRulesResponseBodyRules>> rules{};

  DescribeAntiBruteForceRulesResponseBody() {}

  explicit DescribeAntiBruteForceRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeAntiBruteForceRulesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeAntiBruteForceRulesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeAntiBruteForceRulesResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntiBruteForceRulesResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeAntiBruteForceRulesResponseBodyRules>>(expect1);
      }
    }
  }


  virtual ~DescribeAntiBruteForceRulesResponseBody() = default;
};
class DescribeAntiBruteForceRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntiBruteForceRulesResponseBody> body{};

  DescribeAntiBruteForceRulesResponse() {}

  explicit DescribeAntiBruteForceRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntiBruteForceRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntiBruteForceRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntiBruteForceRulesResponse() = default;
};
class DescribeAppVulScanCycleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cycle{};
  shared_ptr<string> requestId{};

  DescribeAppVulScanCycleResponseBody() {}

  explicit DescribeAppVulScanCycleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycle) {
      res["Cycle"] = boost::any(*cycle);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cycle") != m.end() && !m["Cycle"].empty()) {
      cycle = make_shared<string>(boost::any_cast<string>(m["Cycle"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppVulScanCycleResponseBody() = default;
};
class DescribeAppVulScanCycleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppVulScanCycleResponseBody> body{};

  DescribeAppVulScanCycleResponse() {}

  explicit DescribeAppVulScanCycleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppVulScanCycleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppVulScanCycleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppVulScanCycleResponse() = default;
};
class DescribeAssetDetailByUuidRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuid{};

  DescribeAssetDetailByUuidRequest() {}

  explicit DescribeAssetDetailByUuidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeAssetDetailByUuidRequest() = default;
};
class DescribeAssetDetailByUuidResponseBodyAssetDetail : public Darabonba::Model {
public:
  shared_ptr<string> assetType{};
  shared_ptr<long> authModifyTime{};
  shared_ptr<long> authVersion{};
  shared_ptr<bool> bind{};
  shared_ptr<string> clientStatus{};
  shared_ptr<string> clientVersion{};
  shared_ptr<long> cpu{};
  shared_ptr<string> cpuInfo{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<string>> diskInfoList{};
  shared_ptr<long> flag{};
  shared_ptr<string> groupTrace{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<vector<string>> ipList{};
  shared_ptr<string> kernel{};
  shared_ptr<vector<string>> macList{};
  shared_ptr<long> mem{};
  shared_ptr<long> memory{};
  shared_ptr<string> os{};
  shared_ptr<string> osDetail{};
  shared_ptr<string> osName{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};
  shared_ptr<string> sysInfo{};
  shared_ptr<string> tag{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vpcInstanceId{};

  DescribeAssetDetailByUuidResponseBodyAssetDetail() {}

  explicit DescribeAssetDetailByUuidResponseBodyAssetDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (authModifyTime) {
      res["AuthModifyTime"] = boost::any(*authModifyTime);
    }
    if (authVersion) {
      res["AuthVersion"] = boost::any(*authVersion);
    }
    if (bind) {
      res["Bind"] = boost::any(*bind);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (clientVersion) {
      res["ClientVersion"] = boost::any(*clientVersion);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (cpuInfo) {
      res["CpuInfo"] = boost::any(*cpuInfo);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (diskInfoList) {
      res["DiskInfoList"] = boost::any(*diskInfoList);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (groupTrace) {
      res["GroupTrace"] = boost::any(*groupTrace);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ipList) {
      res["IpList"] = boost::any(*ipList);
    }
    if (kernel) {
      res["Kernel"] = boost::any(*kernel);
    }
    if (macList) {
      res["MacList"] = boost::any(*macList);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (osDetail) {
      res["OsDetail"] = boost::any(*osDetail);
    }
    if (osName) {
      res["OsName"] = boost::any(*osName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (sysInfo) {
      res["SysInfo"] = boost::any(*sysInfo);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vpcInstanceId) {
      res["VpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("AuthModifyTime") != m.end() && !m["AuthModifyTime"].empty()) {
      authModifyTime = make_shared<long>(boost::any_cast<long>(m["AuthModifyTime"]));
    }
    if (m.find("AuthVersion") != m.end() && !m["AuthVersion"].empty()) {
      authVersion = make_shared<long>(boost::any_cast<long>(m["AuthVersion"]));
    }
    if (m.find("Bind") != m.end() && !m["Bind"].empty()) {
      bind = make_shared<bool>(boost::any_cast<bool>(m["Bind"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("ClientVersion") != m.end() && !m["ClientVersion"].empty()) {
      clientVersion = make_shared<string>(boost::any_cast<string>(m["ClientVersion"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CpuInfo") != m.end() && !m["CpuInfo"].empty()) {
      cpuInfo = make_shared<string>(boost::any_cast<string>(m["CpuInfo"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DiskInfoList") != m.end() && !m["DiskInfoList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiskInfoList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiskInfoList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diskInfoList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("GroupTrace") != m.end() && !m["GroupTrace"].empty()) {
      groupTrace = make_shared<string>(boost::any_cast<string>(m["GroupTrace"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Kernel") != m.end() && !m["Kernel"].empty()) {
      kernel = make_shared<string>(boost::any_cast<string>(m["Kernel"]));
    }
    if (m.find("MacList") != m.end() && !m["MacList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MacList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MacList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      macList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("OsDetail") != m.end() && !m["OsDetail"].empty()) {
      osDetail = make_shared<string>(boost::any_cast<string>(m["OsDetail"]));
    }
    if (m.find("OsName") != m.end() && !m["OsName"].empty()) {
      osName = make_shared<string>(boost::any_cast<string>(m["OsName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("SysInfo") != m.end() && !m["SysInfo"].empty()) {
      sysInfo = make_shared<string>(boost::any_cast<string>(m["SysInfo"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VpcInstanceId") != m.end() && !m["VpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcInstanceId"]));
    }
  }


  virtual ~DescribeAssetDetailByUuidResponseBodyAssetDetail() = default;
};
class DescribeAssetDetailByUuidResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAssetDetailByUuidResponseBodyAssetDetail> assetDetail{};
  shared_ptr<string> requestId{};

  DescribeAssetDetailByUuidResponseBody() {}

  explicit DescribeAssetDetailByUuidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetDetail) {
      res["AssetDetail"] = assetDetail ? boost::any(assetDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetDetail") != m.end() && !m["AssetDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssetDetail"].type()) {
        DescribeAssetDetailByUuidResponseBodyAssetDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssetDetail"]));
        assetDetail = make_shared<DescribeAssetDetailByUuidResponseBodyAssetDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAssetDetailByUuidResponseBody() = default;
};
class DescribeAssetDetailByUuidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAssetDetailByUuidResponseBody> body{};

  DescribeAssetDetailByUuidResponse() {}

  explicit DescribeAssetDetailByUuidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAssetDetailByUuidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAssetDetailByUuidResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAssetDetailByUuidResponse() = default;
};
class DescribeAssetDetailByUuidsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> uuids{};

  DescribeAssetDetailByUuidsRequest() {}

  explicit DescribeAssetDetailByUuidsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeAssetDetailByUuidsRequest() = default;
};
class DescribeAssetDetailByUuidsResponseBodyAssetList : public Darabonba::Model {
public:
  shared_ptr<string> assetType{};
  shared_ptr<string> clientStatus{};
  shared_ptr<long> flag{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> os{};
  shared_ptr<string> osName{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vpcInstanceId{};

  DescribeAssetDetailByUuidsResponseBodyAssetList() {}

  explicit DescribeAssetDetailByUuidsResponseBodyAssetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (osName) {
      res["OsName"] = boost::any(*osName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vpcInstanceId) {
      res["VpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("OsName") != m.end() && !m["OsName"].empty()) {
      osName = make_shared<string>(boost::any_cast<string>(m["OsName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VpcInstanceId") != m.end() && !m["VpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcInstanceId"]));
    }
  }


  virtual ~DescribeAssetDetailByUuidsResponseBodyAssetList() = default;
};
class DescribeAssetDetailByUuidsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAssetDetailByUuidsResponseBodyAssetList>> assetList{};
  shared_ptr<string> requestId{};

  DescribeAssetDetailByUuidsResponseBody() {}

  explicit DescribeAssetDetailByUuidsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetList) {
      vector<boost::any> temp1;
      for(auto item1:*assetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AssetList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetList") != m.end() && !m["AssetList"].empty()) {
      if (typeid(vector<boost::any>) == m["AssetList"].type()) {
        vector<DescribeAssetDetailByUuidsResponseBodyAssetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AssetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAssetDetailByUuidsResponseBodyAssetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        assetList = make_shared<vector<DescribeAssetDetailByUuidsResponseBodyAssetList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAssetDetailByUuidsResponseBody() = default;
};
class DescribeAssetDetailByUuidsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAssetDetailByUuidsResponseBody> body{};

  DescribeAssetDetailByUuidsResponse() {}

  explicit DescribeAssetDetailByUuidsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAssetDetailByUuidsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAssetDetailByUuidsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAssetDetailByUuidsResponse() = default;
};
class DescribeAssetSummaryResponseBodyAssetsSummary : public Darabonba::Model {
public:
  shared_ptr<long> totalAssetAllRegion{};
  shared_ptr<long> totalCoreAllRegion{};
  shared_ptr<long> totalCoreNum{};

  DescribeAssetSummaryResponseBodyAssetsSummary() {}

  explicit DescribeAssetSummaryResponseBodyAssetsSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalAssetAllRegion) {
      res["TotalAssetAllRegion"] = boost::any(*totalAssetAllRegion);
    }
    if (totalCoreAllRegion) {
      res["TotalCoreAllRegion"] = boost::any(*totalCoreAllRegion);
    }
    if (totalCoreNum) {
      res["TotalCoreNum"] = boost::any(*totalCoreNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalAssetAllRegion") != m.end() && !m["TotalAssetAllRegion"].empty()) {
      totalAssetAllRegion = make_shared<long>(boost::any_cast<long>(m["TotalAssetAllRegion"]));
    }
    if (m.find("TotalCoreAllRegion") != m.end() && !m["TotalCoreAllRegion"].empty()) {
      totalCoreAllRegion = make_shared<long>(boost::any_cast<long>(m["TotalCoreAllRegion"]));
    }
    if (m.find("TotalCoreNum") != m.end() && !m["TotalCoreNum"].empty()) {
      totalCoreNum = make_shared<long>(boost::any_cast<long>(m["TotalCoreNum"]));
    }
  }


  virtual ~DescribeAssetSummaryResponseBodyAssetsSummary() = default;
};
class DescribeAssetSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAssetSummaryResponseBodyAssetsSummary> assetsSummary{};
  shared_ptr<string> requestId{};

  DescribeAssetSummaryResponseBody() {}

  explicit DescribeAssetSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetsSummary) {
      res["AssetsSummary"] = assetsSummary ? boost::any(assetsSummary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetsSummary") != m.end() && !m["AssetsSummary"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssetsSummary"].type()) {
        DescribeAssetSummaryResponseBodyAssetsSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssetsSummary"]));
        assetsSummary = make_shared<DescribeAssetSummaryResponseBodyAssetsSummary>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAssetSummaryResponseBody() = default;
};
class DescribeAssetSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAssetSummaryResponseBody> body{};

  DescribeAssetSummaryResponse() {}

  explicit DescribeAssetSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAssetSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAssetSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAssetSummaryResponse() = default;
};
class DescribeAssetsSecurityEventSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};

  DescribeAssetsSecurityEventSummaryRequest() {}

  explicit DescribeAssetsSecurityEventSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeAssetsSecurityEventSummaryRequest() = default;
};
class DescribeAssetsSecurityEventSummaryResponseBodyAssets : public Darabonba::Model {
public:
  shared_ptr<string> assetType{};
  shared_ptr<long> riskCount{};
  shared_ptr<long> totalCount{};

  DescribeAssetsSecurityEventSummaryResponseBodyAssets() {}

  explicit DescribeAssetsSecurityEventSummaryResponseBodyAssets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (riskCount) {
      res["RiskCount"] = boost::any(*riskCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("RiskCount") != m.end() && !m["RiskCount"].empty()) {
      riskCount = make_shared<long>(boost::any_cast<long>(m["RiskCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAssetsSecurityEventSummaryResponseBodyAssets() = default;
};
class DescribeAssetsSecurityEventSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAssetsSecurityEventSummaryResponseBodyAssets>> assets{};
  shared_ptr<string> requestId{};

  DescribeAssetsSecurityEventSummaryResponseBody() {}

  explicit DescribeAssetsSecurityEventSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assets) {
      vector<boost::any> temp1;
      for(auto item1:*assets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Assets"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assets") != m.end() && !m["Assets"].empty()) {
      if (typeid(vector<boost::any>) == m["Assets"].type()) {
        vector<DescribeAssetsSecurityEventSummaryResponseBodyAssets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Assets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAssetsSecurityEventSummaryResponseBodyAssets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        assets = make_shared<vector<DescribeAssetsSecurityEventSummaryResponseBodyAssets>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAssetsSecurityEventSummaryResponseBody() = default;
};
class DescribeAssetsSecurityEventSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAssetsSecurityEventSummaryResponseBody> body{};

  DescribeAssetsSecurityEventSummaryResponse() {}

  explicit DescribeAssetsSecurityEventSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAssetsSecurityEventSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAssetsSecurityEventSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAssetsSecurityEventSummaryResponse() = default;
};
class DescribeAttackAnalysisDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> base64{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> data{};
  shared_ptr<long> endTime{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<string> type{};

  DescribeAttackAnalysisDataRequest() {}

  explicit DescribeAttackAnalysisDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (base64) {
      res["Base64"] = boost::any(*base64);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Base64") != m.end() && !m["Base64"].empty()) {
      base64 = make_shared<string>(boost::any_cast<string>(m["Base64"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeAttackAnalysisDataRequest() = default;
};
class DescribeAttackAnalysisDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeAttackAnalysisDataResponseBody() {}

  explicit DescribeAttackAnalysisDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeAttackAnalysisDataResponseBody() = default;
};
class DescribeAttackAnalysisDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAttackAnalysisDataResponseBody> body{};

  DescribeAttackAnalysisDataResponse() {}

  explicit DescribeAttackAnalysisDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAttackAnalysisDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAttackAnalysisDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAttackAnalysisDataResponse() = default;
};
class DescribeAutoDelConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> days{};
  shared_ptr<string> requestId{};

  DescribeAutoDelConfigResponseBody() {}

  explicit DescribeAutoDelConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      days = make_shared<long>(boost::any_cast<long>(m["Days"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAutoDelConfigResponseBody() = default;
};
class DescribeAutoDelConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAutoDelConfigResponseBody> body{};

  DescribeAutoDelConfigResponse() {}

  explicit DescribeAutoDelConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAutoDelConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAutoDelConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAutoDelConfigResponse() = default;
};
class DescribeBackUpExportInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> exportType{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};

  DescribeBackUpExportInfoRequest() {}

  explicit DescribeBackUpExportInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeBackUpExportInfoRequest() = default;
};
class DescribeBackUpExportInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> currentCount{};
  shared_ptr<string> fileName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> id{};
  shared_ptr<string> link{};
  shared_ptr<string> message{};
  shared_ptr<long> progress{};
  shared_ptr<string> status{};
  shared_ptr<long> totalCount{};

  DescribeBackUpExportInfoResponseBodyData() {}

  explicit DescribeBackUpExportInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBackUpExportInfoResponseBodyData() = default;
};
class DescribeBackUpExportInfoResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeBackUpExportInfoResponseBodyPageInfo() {}

  explicit DescribeBackUpExportInfoResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBackUpExportInfoResponseBodyPageInfo() = default;
};
class DescribeBackUpExportInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBackUpExportInfoResponseBodyData>> data{};
  shared_ptr<DescribeBackUpExportInfoResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeBackUpExportInfoResponseBody() {}

  explicit DescribeBackUpExportInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeBackUpExportInfoResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackUpExportInfoResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeBackUpExportInfoResponseBodyData>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeBackUpExportInfoResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeBackUpExportInfoResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackUpExportInfoResponseBody() = default;
};
class DescribeBackUpExportInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackUpExportInfoResponseBody> body{};

  DescribeBackUpExportInfoResponse() {}

  explicit DescribeBackUpExportInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackUpExportInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackUpExportInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackUpExportInfoResponse() = default;
};
class DescribeBackupClientsRequest : public Darabonba::Model {
public:
  shared_ptr<string> supportRegionId{};

  DescribeBackupClientsRequest() {}

  explicit DescribeBackupClientsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (supportRegionId) {
      res["SupportRegionId"] = boost::any(*supportRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SupportRegionId") != m.end() && !m["SupportRegionId"].empty()) {
      supportRegionId = make_shared<string>(boost::any_cast<string>(m["SupportRegionId"]));
    }
  }


  virtual ~DescribeBackupClientsRequest() = default;
};
class DescribeBackupClientsResponseBodyClients : public Darabonba::Model {
public:
  shared_ptr<string> clientId{};
  shared_ptr<string> clientStatus{};
  shared_ptr<string> clientVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> uuid{};

  DescribeBackupClientsResponseBodyClients() {}

  explicit DescribeBackupClientsResponseBodyClients(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (clientVersion) {
      res["ClientVersion"] = boost::any(*clientVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("ClientVersion") != m.end() && !m["ClientVersion"].empty()) {
      clientVersion = make_shared<string>(boost::any_cast<string>(m["ClientVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeBackupClientsResponseBodyClients() = default;
};
class DescribeBackupClientsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBackupClientsResponseBodyClients>> clients{};
  shared_ptr<string> requestId{};

  DescribeBackupClientsResponseBody() {}

  explicit DescribeBackupClientsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clients) {
      vector<boost::any> temp1;
      for(auto item1:*clients){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clients"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clients") != m.end() && !m["Clients"].empty()) {
      if (typeid(vector<boost::any>) == m["Clients"].type()) {
        vector<DescribeBackupClientsResponseBodyClients> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clients"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupClientsResponseBodyClients model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clients = make_shared<vector<DescribeBackupClientsResponseBodyClients>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackupClientsResponseBody() = default;
};
class DescribeBackupClientsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackupClientsResponseBody> body{};

  DescribeBackupClientsResponse() {}

  explicit DescribeBackupClientsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupClientsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupClientsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupClientsResponse() = default;
};
class DescribeBackupFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> snapshotHash{};
  shared_ptr<string> uuid{};

  DescribeBackupFilesRequest() {}

  explicit DescribeBackupFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (snapshotHash) {
      res["SnapshotHash"] = boost::any(*snapshotHash);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("SnapshotHash") != m.end() && !m["SnapshotHash"].empty()) {
      snapshotHash = make_shared<string>(boost::any_cast<string>(m["SnapshotHash"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeBackupFilesRequest() = default;
};
class DescribeBackupFilesResponseBodyBackupFiles : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> size{};
  shared_ptr<string> subtree{};
  shared_ptr<string> type{};

  DescribeBackupFilesResponseBodyBackupFiles() {}

  explicit DescribeBackupFilesResponseBodyBackupFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (subtree) {
      res["Subtree"] = boost::any(*subtree);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Subtree") != m.end() && !m["Subtree"].empty()) {
      subtree = make_shared<string>(boost::any_cast<string>(m["Subtree"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeBackupFilesResponseBodyBackupFiles() = default;
};
class DescribeBackupFilesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeBackupFilesResponseBodyPageInfo() {}

  explicit DescribeBackupFilesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBackupFilesResponseBodyPageInfo() = default;
};
class DescribeBackupFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBackupFilesResponseBodyBackupFiles>> backupFiles{};
  shared_ptr<DescribeBackupFilesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeBackupFilesResponseBody() {}

  explicit DescribeBackupFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupFiles) {
      vector<boost::any> temp1;
      for(auto item1:*backupFiles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackupFiles"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupFiles") != m.end() && !m["BackupFiles"].empty()) {
      if (typeid(vector<boost::any>) == m["BackupFiles"].type()) {
        vector<DescribeBackupFilesResponseBodyBackupFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackupFiles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupFilesResponseBodyBackupFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backupFiles = make_shared<vector<DescribeBackupFilesResponseBodyBackupFiles>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeBackupFilesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeBackupFilesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackupFilesResponseBody() = default;
};
class DescribeBackupFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackupFilesResponseBody> body{};

  DescribeBackupFilesResponse() {}

  explicit DescribeBackupFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupFilesResponse() = default;
};
class DescribeBackupMachineStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};
  shared_ptr<string> policyVersion{};
  shared_ptr<string> uuid{};

  DescribeBackupMachineStatusRequest() {}

  explicit DescribeBackupMachineStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeBackupMachineStatusRequest() = default;
};
class DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorStatus{};

  DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList() {}

  explicit DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorStatus) {
      res["ErrorStatus"] = boost::any(*errorStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorStatus") != m.end() && !m["ErrorStatus"].empty()) {
      errorStatus = make_shared<string>(boost::any_cast<string>(m["ErrorStatus"]));
    }
  }


  virtual ~DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList() = default;
};
class DescribeBackupMachineStatusResponseBodyBackupMachineStatus : public Darabonba::Model {
public:
  shared_ptr<string> clientId{};
  shared_ptr<string> clientStatus{};
  shared_ptr<string> clientVersion{};
  shared_ptr<string> errorCode{};
  shared_ptr<vector<DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList>> errorList{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> savedBackupCount{};
  shared_ptr<string> status{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vaultId{};

  DescribeBackupMachineStatusResponseBodyBackupMachineStatus() {}

  explicit DescribeBackupMachineStatusResponseBodyBackupMachineStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (clientVersion) {
      res["ClientVersion"] = boost::any(*clientVersion);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorList) {
      vector<boost::any> temp1;
      for(auto item1:*errorList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorList"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (savedBackupCount) {
      res["SavedBackupCount"] = boost::any(*savedBackupCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vaultId) {
      res["VaultId"] = boost::any(*vaultId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("ClientVersion") != m.end() && !m["ClientVersion"].empty()) {
      clientVersion = make_shared<string>(boost::any_cast<string>(m["ClientVersion"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorList") != m.end() && !m["ErrorList"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorList"].type()) {
        vector<DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorList = make_shared<vector<DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SavedBackupCount") != m.end() && !m["SavedBackupCount"].empty()) {
      savedBackupCount = make_shared<long>(boost::any_cast<long>(m["SavedBackupCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VaultId") != m.end() && !m["VaultId"].empty()) {
      vaultId = make_shared<string>(boost::any_cast<string>(m["VaultId"]));
    }
  }


  virtual ~DescribeBackupMachineStatusResponseBodyBackupMachineStatus() = default;
};
class DescribeBackupMachineStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBackupMachineStatusResponseBodyBackupMachineStatus> backupMachineStatus{};
  shared_ptr<string> requestId{};

  DescribeBackupMachineStatusResponseBody() {}

  explicit DescribeBackupMachineStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupMachineStatus) {
      res["BackupMachineStatus"] = backupMachineStatus ? boost::any(backupMachineStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupMachineStatus") != m.end() && !m["BackupMachineStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackupMachineStatus"].type()) {
        DescribeBackupMachineStatusResponseBodyBackupMachineStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackupMachineStatus"]));
        backupMachineStatus = make_shared<DescribeBackupMachineStatusResponseBodyBackupMachineStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackupMachineStatusResponseBody() = default;
};
class DescribeBackupMachineStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackupMachineStatusResponseBody> body{};

  DescribeBackupMachineStatusResponse() {}

  explicit DescribeBackupMachineStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupMachineStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupMachineStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupMachineStatusResponse() = default;
};
class DescribeBackupPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> machineRemark{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  DescribeBackupPoliciesRequest() {}

  explicit DescribeBackupPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (machineRemark) {
      res["MachineRemark"] = boost::any(*machineRemark);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("MachineRemark") != m.end() && !m["MachineRemark"].empty()) {
      machineRemark = make_shared<string>(boost::any_cast<string>(m["MachineRemark"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeBackupPoliciesRequest() = default;
};
class DescribeBackupPoliciesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeBackupPoliciesResponseBodyPageInfo() {}

  explicit DescribeBackupPoliciesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBackupPoliciesResponseBodyPageInfo() = default;
};
class DescribeBackupPoliciesResponseBodyPolicies : public Darabonba::Model {
public:
  shared_ptr<long> clientErrorCount{};
  shared_ptr<vector<string>> clientErrorUuidList{};
  shared_ptr<string> clientStatus{};
  shared_ptr<long> healthClientCount{};
  shared_ptr<vector<string>> healthClientUuidList{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> policy{};
  shared_ptr<string> policyRegionId{};
  shared_ptr<string> policyVersion{};
  shared_ptr<vector<string>> remarkedUuidList{};
  shared_ptr<string> serverType{};
  shared_ptr<long> serviceErrorCount{};
  shared_ptr<vector<string>> serviceErrorUuidList{};
  shared_ptr<string> status{};
  shared_ptr<string> upgradeStatus{};
  shared_ptr<vector<string>> uuidList{};

  DescribeBackupPoliciesResponseBodyPolicies() {}

  explicit DescribeBackupPoliciesResponseBodyPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientErrorCount) {
      res["ClientErrorCount"] = boost::any(*clientErrorCount);
    }
    if (clientErrorUuidList) {
      res["ClientErrorUuidList"] = boost::any(*clientErrorUuidList);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (healthClientCount) {
      res["HealthClientCount"] = boost::any(*healthClientCount);
    }
    if (healthClientUuidList) {
      res["HealthClientUuidList"] = boost::any(*healthClientUuidList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (policyRegionId) {
      res["PolicyRegionId"] = boost::any(*policyRegionId);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (remarkedUuidList) {
      res["RemarkedUuidList"] = boost::any(*remarkedUuidList);
    }
    if (serverType) {
      res["ServerType"] = boost::any(*serverType);
    }
    if (serviceErrorCount) {
      res["ServiceErrorCount"] = boost::any(*serviceErrorCount);
    }
    if (serviceErrorUuidList) {
      res["ServiceErrorUuidList"] = boost::any(*serviceErrorUuidList);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (upgradeStatus) {
      res["UpgradeStatus"] = boost::any(*upgradeStatus);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientErrorCount") != m.end() && !m["ClientErrorCount"].empty()) {
      clientErrorCount = make_shared<long>(boost::any_cast<long>(m["ClientErrorCount"]));
    }
    if (m.find("ClientErrorUuidList") != m.end() && !m["ClientErrorUuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClientErrorUuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClientErrorUuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clientErrorUuidList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("HealthClientCount") != m.end() && !m["HealthClientCount"].empty()) {
      healthClientCount = make_shared<long>(boost::any_cast<long>(m["HealthClientCount"]));
    }
    if (m.find("HealthClientUuidList") != m.end() && !m["HealthClientUuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HealthClientUuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HealthClientUuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      healthClientUuidList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PolicyRegionId") != m.end() && !m["PolicyRegionId"].empty()) {
      policyRegionId = make_shared<string>(boost::any_cast<string>(m["PolicyRegionId"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("RemarkedUuidList") != m.end() && !m["RemarkedUuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemarkedUuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemarkedUuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      remarkedUuidList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ServerType") != m.end() && !m["ServerType"].empty()) {
      serverType = make_shared<string>(boost::any_cast<string>(m["ServerType"]));
    }
    if (m.find("ServiceErrorCount") != m.end() && !m["ServiceErrorCount"].empty()) {
      serviceErrorCount = make_shared<long>(boost::any_cast<long>(m["ServiceErrorCount"]));
    }
    if (m.find("ServiceErrorUuidList") != m.end() && !m["ServiceErrorUuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceErrorUuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceErrorUuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceErrorUuidList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpgradeStatus") != m.end() && !m["UpgradeStatus"].empty()) {
      upgradeStatus = make_shared<string>(boost::any_cast<string>(m["UpgradeStatus"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeBackupPoliciesResponseBodyPolicies() = default;
};
class DescribeBackupPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBackupPoliciesResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeBackupPoliciesResponseBodyPolicies>> policies{};
  shared_ptr<string> requestId{};

  DescribeBackupPoliciesResponseBody() {}

  explicit DescribeBackupPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeBackupPoliciesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeBackupPoliciesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<DescribeBackupPoliciesResponseBodyPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackupPoliciesResponseBodyPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<DescribeBackupPoliciesResponseBodyPolicies>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackupPoliciesResponseBody() = default;
};
class DescribeBackupPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackupPoliciesResponseBody> body{};

  DescribeBackupPoliciesResponse() {}

  explicit DescribeBackupPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupPoliciesResponse() = default;
};
class DescribeBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DescribeBackupPolicyRequest() {}

  explicit DescribeBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeBackupPolicyRequest() = default;
};
class DescribeBackupPolicyResponseBodyBackupPolicyDetail : public Darabonba::Model {
public:
  shared_ptr<string> clientStatus{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> policy{};
  shared_ptr<string> policyVersion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> uuidList{};

  DescribeBackupPolicyResponseBodyBackupPolicyDetail() {}

  explicit DescribeBackupPolicyResponseBodyBackupPolicyDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeBackupPolicyResponseBodyBackupPolicyDetail() = default;
};
class DescribeBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBackupPolicyResponseBodyBackupPolicyDetail> backupPolicyDetail{};
  shared_ptr<string> requestId{};

  DescribeBackupPolicyResponseBody() {}

  explicit DescribeBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupPolicyDetail) {
      res["BackupPolicyDetail"] = backupPolicyDetail ? boost::any(backupPolicyDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupPolicyDetail") != m.end() && !m["BackupPolicyDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackupPolicyDetail"].type()) {
        DescribeBackupPolicyResponseBodyBackupPolicyDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackupPolicyDetail"]));
        backupPolicyDetail = make_shared<DescribeBackupPolicyResponseBodyBackupPolicyDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackupPolicyResponseBody() = default;
};
class DescribeBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackupPolicyResponseBody> body{};

  DescribeBackupPolicyResponse() {}

  explicit DescribeBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupPolicyResponse() = default;
};
class DescribeBackupRestoreCountResponseBodyBackupRestoreCount : public Darabonba::Model {
public:
  shared_ptr<long> recovering{};
  shared_ptr<long> total{};

  DescribeBackupRestoreCountResponseBodyBackupRestoreCount() {}

  explicit DescribeBackupRestoreCountResponseBodyBackupRestoreCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recovering) {
      res["Recovering"] = boost::any(*recovering);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Recovering") != m.end() && !m["Recovering"].empty()) {
      recovering = make_shared<long>(boost::any_cast<long>(m["Recovering"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeBackupRestoreCountResponseBodyBackupRestoreCount() = default;
};
class DescribeBackupRestoreCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBackupRestoreCountResponseBodyBackupRestoreCount> backupRestoreCount{};
  shared_ptr<string> requestId{};

  DescribeBackupRestoreCountResponseBody() {}

  explicit DescribeBackupRestoreCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupRestoreCount) {
      res["BackupRestoreCount"] = backupRestoreCount ? boost::any(backupRestoreCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupRestoreCount") != m.end() && !m["BackupRestoreCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackupRestoreCount"].type()) {
        DescribeBackupRestoreCountResponseBodyBackupRestoreCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackupRestoreCount"]));
        backupRestoreCount = make_shared<DescribeBackupRestoreCountResponseBodyBackupRestoreCount>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackupRestoreCountResponseBody() = default;
};
class DescribeBackupRestoreCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackupRestoreCountResponseBody> body{};

  DescribeBackupRestoreCountResponse() {}

  explicit DescribeBackupRestoreCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupRestoreCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupRestoreCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupRestoreCountResponse() = default;
};
class DescribeBruteForceRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> blockIp{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> status{};

  DescribeBruteForceRecordsRequest() {}

  explicit DescribeBruteForceRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockIp) {
      res["BlockIp"] = boost::any(*blockIp);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockIp") != m.end() && !m["BlockIp"].empty()) {
      blockIp = make_shared<string>(boost::any_cast<string>(m["BlockIp"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeBruteForceRecordsRequest() = default;
};
class DescribeBruteForceRecordsResponseBodyMachineList : public Darabonba::Model {
public:
  shared_ptr<long> blockExpireDate{};
  shared_ptr<string> blockIp{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> port{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> uuid{};

  DescribeBruteForceRecordsResponseBodyMachineList() {}

  explicit DescribeBruteForceRecordsResponseBodyMachineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockExpireDate) {
      res["BlockExpireDate"] = boost::any(*blockExpireDate);
    }
    if (blockIp) {
      res["BlockIp"] = boost::any(*blockIp);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockExpireDate") != m.end() && !m["BlockExpireDate"].empty()) {
      blockExpireDate = make_shared<long>(boost::any_cast<long>(m["BlockExpireDate"]));
    }
    if (m.find("BlockIp") != m.end() && !m["BlockIp"].empty()) {
      blockIp = make_shared<string>(boost::any_cast<string>(m["BlockIp"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeBruteForceRecordsResponseBodyMachineList() = default;
};
class DescribeBruteForceRecordsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeBruteForceRecordsResponseBodyPageInfo() {}

  explicit DescribeBruteForceRecordsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBruteForceRecordsResponseBodyPageInfo() = default;
};
class DescribeBruteForceRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBruteForceRecordsResponseBodyMachineList>> machineList{};
  shared_ptr<DescribeBruteForceRecordsResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeBruteForceRecordsResponseBody() {}

  explicit DescribeBruteForceRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineList) {
      vector<boost::any> temp1;
      for(auto item1:*machineList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MachineList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineList") != m.end() && !m["MachineList"].empty()) {
      if (typeid(vector<boost::any>) == m["MachineList"].type()) {
        vector<DescribeBruteForceRecordsResponseBodyMachineList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MachineList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBruteForceRecordsResponseBodyMachineList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machineList = make_shared<vector<DescribeBruteForceRecordsResponseBodyMachineList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeBruteForceRecordsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeBruteForceRecordsResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBruteForceRecordsResponseBody() = default;
};
class DescribeBruteForceRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBruteForceRecordsResponseBody> body{};

  DescribeBruteForceRecordsResponse() {}

  explicit DescribeBruteForceRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBruteForceRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBruteForceRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBruteForceRecordsResponse() = default;
};
class DescribeBruteForceSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};

  DescribeBruteForceSummaryRequest() {}

  explicit DescribeBruteForceSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeBruteForceSummaryRequest() = default;
};
class DescribeBruteForceSummaryResponseBodyBruteForceSummary : public Darabonba::Model {
public:
  shared_ptr<long> allStrategyCount{};
  shared_ptr<long> effectiveCount{};

  DescribeBruteForceSummaryResponseBodyBruteForceSummary() {}

  explicit DescribeBruteForceSummaryResponseBodyBruteForceSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allStrategyCount) {
      res["AllStrategyCount"] = boost::any(*allStrategyCount);
    }
    if (effectiveCount) {
      res["EffectiveCount"] = boost::any(*effectiveCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllStrategyCount") != m.end() && !m["AllStrategyCount"].empty()) {
      allStrategyCount = make_shared<long>(boost::any_cast<long>(m["AllStrategyCount"]));
    }
    if (m.find("EffectiveCount") != m.end() && !m["EffectiveCount"].empty()) {
      effectiveCount = make_shared<long>(boost::any_cast<long>(m["EffectiveCount"]));
    }
  }


  virtual ~DescribeBruteForceSummaryResponseBodyBruteForceSummary() = default;
};
class DescribeBruteForceSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBruteForceSummaryResponseBodyBruteForceSummary> bruteForceSummary{};
  shared_ptr<string> requestId{};

  DescribeBruteForceSummaryResponseBody() {}

  explicit DescribeBruteForceSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bruteForceSummary) {
      res["BruteForceSummary"] = bruteForceSummary ? boost::any(bruteForceSummary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BruteForceSummary") != m.end() && !m["BruteForceSummary"].empty()) {
      if (typeid(map<string, boost::any>) == m["BruteForceSummary"].type()) {
        DescribeBruteForceSummaryResponseBodyBruteForceSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BruteForceSummary"]));
        bruteForceSummary = make_shared<DescribeBruteForceSummaryResponseBodyBruteForceSummary>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBruteForceSummaryResponseBody() = default;
};
class DescribeBruteForceSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBruteForceSummaryResponseBody> body{};

  DescribeBruteForceSummaryResponse() {}

  explicit DescribeBruteForceSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBruteForceSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBruteForceSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBruteForceSummaryResponse() = default;
};
class DescribeCheckEcsWarningsRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  DescribeCheckEcsWarningsRequest() {}

  explicit DescribeCheckEcsWarningsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeCheckEcsWarningsRequest() = default;
};
class DescribeCheckEcsWarningsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> canTry{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sasVersion{};
  shared_ptr<string> weakPasswordCount{};

  DescribeCheckEcsWarningsResponseBody() {}

  explicit DescribeCheckEcsWarningsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canTry) {
      res["CanTry"] = boost::any(*canTry);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sasVersion) {
      res["SasVersion"] = boost::any(*sasVersion);
    }
    if (weakPasswordCount) {
      res["WeakPasswordCount"] = boost::any(*weakPasswordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanTry") != m.end() && !m["CanTry"].empty()) {
      canTry = make_shared<string>(boost::any_cast<string>(m["CanTry"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SasVersion") != m.end() && !m["SasVersion"].empty()) {
      sasVersion = make_shared<string>(boost::any_cast<string>(m["SasVersion"]));
    }
    if (m.find("WeakPasswordCount") != m.end() && !m["WeakPasswordCount"].empty()) {
      weakPasswordCount = make_shared<string>(boost::any_cast<string>(m["WeakPasswordCount"]));
    }
  }


  virtual ~DescribeCheckEcsWarningsResponseBody() = default;
};
class DescribeCheckEcsWarningsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCheckEcsWarningsResponseBody> body{};

  DescribeCheckEcsWarningsResponse() {}

  explicit DescribeCheckEcsWarningsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckEcsWarningsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckEcsWarningsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckEcsWarningsResponse() = default;
};
class DescribeCheckFixDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkIds{};
  shared_ptr<string> lang{};
  shared_ptr<long> riskId{};

  DescribeCheckFixDetailsRequest() {}

  explicit DescribeCheckFixDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkIds) {
      res["CheckIds"] = boost::any(*checkIds);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckIds") != m.end() && !m["CheckIds"].empty()) {
      checkIds = make_shared<string>(boost::any_cast<string>(m["CheckIds"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
  }


  virtual ~DescribeCheckFixDetailsRequest() = default;
};
class DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList : public Darabonba::Model {
public:
  shared_ptr<string> enumValue{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minValue{};
  shared_ptr<string> paramDefaultValue{};
  shared_ptr<string> paramDesc{};
  shared_ptr<string> paramName{};
  shared_ptr<long> paramType{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> value{};

  DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList() {}

  explicit DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (paramDefaultValue) {
      res["ParamDefaultValue"] = boost::any(*paramDefaultValue);
    }
    if (paramDesc) {
      res["ParamDesc"] = boost::any(*paramDesc);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParamDefaultValue") != m.end() && !m["ParamDefaultValue"].empty()) {
      paramDefaultValue = make_shared<string>(boost::any_cast<string>(m["ParamDefaultValue"]));
    }
    if (m.find("ParamDesc") != m.end() && !m["ParamDesc"].empty()) {
      paramDesc = make_shared<string>(boost::any_cast<string>(m["ParamDesc"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<long>(boost::any_cast<long>(m["ParamType"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList() = default;
};
class DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<long> defaultValue{};
  shared_ptr<long> optional{};
  shared_ptr<vector<DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList>> paramList{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> ruleId{};
  shared_ptr<long> value{};
  shared_ptr<string> varName{};

  DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules() {}

  explicit DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (optional) {
      res["Optional"] = boost::any(*optional);
    }
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (varName) {
      res["VarName"] = boost::any(*varName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<long>(boost::any_cast<long>(m["DefaultValue"]));
    }
    if (m.find("Optional") != m.end() && !m["Optional"].empty()) {
      optional = make_shared<long>(boost::any_cast<long>(m["Optional"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList>>(expect1);
      }
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
    if (m.find("VarName") != m.end() && !m["VarName"].empty()) {
      varName = make_shared<string>(boost::any_cast<string>(m["VarName"]));
    }
  }


  virtual ~DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules() = default;
};
class DescribeCheckFixDetailsResponseBodyCheckFixDetails : public Darabonba::Model {
public:
  shared_ptr<string> checkDesc{};
  shared_ptr<long> checkId{};
  shared_ptr<string> checkItem{};
  shared_ptr<vector<DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules>> rules{};

  DescribeCheckFixDetailsResponseBodyCheckFixDetails() {}

  explicit DescribeCheckFixDetailsResponseBodyCheckFixDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkDesc) {
      res["CheckDesc"] = boost::any(*checkDesc);
    }
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckDesc") != m.end() && !m["CheckDesc"].empty()) {
      checkDesc = make_shared<string>(boost::any_cast<string>(m["CheckDesc"]));
    }
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules>>(expect1);
      }
    }
  }


  virtual ~DescribeCheckFixDetailsResponseBodyCheckFixDetails() = default;
};
class DescribeCheckFixDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCheckFixDetailsResponseBodyCheckFixDetails>> checkFixDetails{};
  shared_ptr<long> count{};
  shared_ptr<string> requestId{};

  DescribeCheckFixDetailsResponseBody() {}

  explicit DescribeCheckFixDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkFixDetails) {
      vector<boost::any> temp1;
      for(auto item1:*checkFixDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CheckFixDetails"] = boost::any(temp1);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckFixDetails") != m.end() && !m["CheckFixDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["CheckFixDetails"].type()) {
        vector<DescribeCheckFixDetailsResponseBodyCheckFixDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CheckFixDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCheckFixDetailsResponseBodyCheckFixDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkFixDetails = make_shared<vector<DescribeCheckFixDetailsResponseBodyCheckFixDetails>>(expect1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCheckFixDetailsResponseBody() = default;
};
class DescribeCheckFixDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCheckFixDetailsResponseBody> body{};

  DescribeCheckFixDetailsResponse() {}

  explicit DescribeCheckFixDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckFixDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckFixDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckFixDetailsResponse() = default;
};
class DescribeCheckWarningDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkWarningId{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  DescribeCheckWarningDetailRequest() {}

  explicit DescribeCheckWarningDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkWarningId) {
      res["CheckWarningId"] = boost::any(*checkWarningId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckWarningId") != m.end() && !m["CheckWarningId"].empty()) {
      checkWarningId = make_shared<long>(boost::any_cast<long>(m["CheckWarningId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeCheckWarningDetailRequest() = default;
};
class DescribeCheckWarningDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<long> checkId{};
  shared_ptr<string> description{};
  shared_ptr<string> item{};
  shared_ptr<string> level{};
  shared_ptr<string> prompt{};
  shared_ptr<string> requestId{};
  shared_ptr<string> type{};

  DescribeCheckWarningDetailResponseBody() {}

  explicit DescribeCheckWarningDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCheckWarningDetailResponseBody() = default;
};
class DescribeCheckWarningDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCheckWarningDetailResponseBody> body{};

  DescribeCheckWarningDetailResponse() {}

  explicit DescribeCheckWarningDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckWarningDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckWarningDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckWarningDetailResponse() = default;
};
class DescribeCheckWarningMachinesRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<string> lang{};
  shared_ptr<long> riskId{};
  shared_ptr<long> status{};

  DescribeCheckWarningMachinesRequest() {}

  explicit DescribeCheckWarningMachinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeCheckWarningMachinesRequest() = default;
};
class DescribeCheckWarningMachinesResponseBodyMachines : public Darabonba::Model {
public:
  shared_ptr<bool> bind{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uuid{};

  DescribeCheckWarningMachinesResponseBodyMachines() {}

  explicit DescribeCheckWarningMachinesResponseBodyMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bind) {
      res["Bind"] = boost::any(*bind);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bind") != m.end() && !m["Bind"].empty()) {
      bind = make_shared<bool>(boost::any_cast<bool>(m["Bind"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeCheckWarningMachinesResponseBodyMachines() = default;
};
class DescribeCheckWarningMachinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeCheckWarningMachinesResponseBodyMachines>> machines{};
  shared_ptr<string> requestId{};

  DescribeCheckWarningMachinesResponseBody() {}

  explicit DescribeCheckWarningMachinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (machines) {
      vector<boost::any> temp1;
      for(auto item1:*machines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Machines"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Machines") != m.end() && !m["Machines"].empty()) {
      if (typeid(vector<boost::any>) == m["Machines"].type()) {
        vector<DescribeCheckWarningMachinesResponseBodyMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Machines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCheckWarningMachinesResponseBodyMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machines = make_shared<vector<DescribeCheckWarningMachinesResponseBodyMachines>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCheckWarningMachinesResponseBody() = default;
};
class DescribeCheckWarningMachinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCheckWarningMachinesResponseBody> body{};

  DescribeCheckWarningMachinesResponse() {}

  explicit DescribeCheckWarningMachinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckWarningMachinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckWarningMachinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckWarningMachinesResponse() = default;
};
class DescribeCheckWarningSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> groupId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> riskName{};
  shared_ptr<long> riskStatus{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> status{};
  shared_ptr<long> strategyId{};
  shared_ptr<string> targetType{};
  shared_ptr<string> typeName_{};
  shared_ptr<string> uuids{};

  DescribeCheckWarningSummaryRequest() {}

  explicit DescribeCheckWarningSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<long>(boost::any_cast<long>(m["RiskStatus"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeCheckWarningSummaryRequest() = default;
};
class DescribeCheckWarningSummaryResponseBodyWarningSummarys : public Darabonba::Model {
public:
  shared_ptr<long> checkCount{};
  shared_ptr<bool> checkExploit{};
  shared_ptr<bool> databaseRisk{};
  shared_ptr<long> highWarningCount{};
  shared_ptr<string> lastFoundTime{};
  shared_ptr<string> level{};
  shared_ptr<long> lowWarningCount{};
  shared_ptr<long> mediumWarningCount{};
  shared_ptr<long> riskId{};
  shared_ptr<string> riskName{};
  shared_ptr<string> subTypeAlias{};
  shared_ptr<string> typeAlias{};
  shared_ptr<long> warningMachineCount{};

  DescribeCheckWarningSummaryResponseBodyWarningSummarys() {}

  explicit DescribeCheckWarningSummaryResponseBodyWarningSummarys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkCount) {
      res["CheckCount"] = boost::any(*checkCount);
    }
    if (checkExploit) {
      res["CheckExploit"] = boost::any(*checkExploit);
    }
    if (databaseRisk) {
      res["DatabaseRisk"] = boost::any(*databaseRisk);
    }
    if (highWarningCount) {
      res["HighWarningCount"] = boost::any(*highWarningCount);
    }
    if (lastFoundTime) {
      res["LastFoundTime"] = boost::any(*lastFoundTime);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (lowWarningCount) {
      res["LowWarningCount"] = boost::any(*lowWarningCount);
    }
    if (mediumWarningCount) {
      res["MediumWarningCount"] = boost::any(*mediumWarningCount);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    if (subTypeAlias) {
      res["SubTypeAlias"] = boost::any(*subTypeAlias);
    }
    if (typeAlias) {
      res["TypeAlias"] = boost::any(*typeAlias);
    }
    if (warningMachineCount) {
      res["WarningMachineCount"] = boost::any(*warningMachineCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckCount") != m.end() && !m["CheckCount"].empty()) {
      checkCount = make_shared<long>(boost::any_cast<long>(m["CheckCount"]));
    }
    if (m.find("CheckExploit") != m.end() && !m["CheckExploit"].empty()) {
      checkExploit = make_shared<bool>(boost::any_cast<bool>(m["CheckExploit"]));
    }
    if (m.find("DatabaseRisk") != m.end() && !m["DatabaseRisk"].empty()) {
      databaseRisk = make_shared<bool>(boost::any_cast<bool>(m["DatabaseRisk"]));
    }
    if (m.find("HighWarningCount") != m.end() && !m["HighWarningCount"].empty()) {
      highWarningCount = make_shared<long>(boost::any_cast<long>(m["HighWarningCount"]));
    }
    if (m.find("LastFoundTime") != m.end() && !m["LastFoundTime"].empty()) {
      lastFoundTime = make_shared<string>(boost::any_cast<string>(m["LastFoundTime"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("LowWarningCount") != m.end() && !m["LowWarningCount"].empty()) {
      lowWarningCount = make_shared<long>(boost::any_cast<long>(m["LowWarningCount"]));
    }
    if (m.find("MediumWarningCount") != m.end() && !m["MediumWarningCount"].empty()) {
      mediumWarningCount = make_shared<long>(boost::any_cast<long>(m["MediumWarningCount"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
    if (m.find("SubTypeAlias") != m.end() && !m["SubTypeAlias"].empty()) {
      subTypeAlias = make_shared<string>(boost::any_cast<string>(m["SubTypeAlias"]));
    }
    if (m.find("TypeAlias") != m.end() && !m["TypeAlias"].empty()) {
      typeAlias = make_shared<string>(boost::any_cast<string>(m["TypeAlias"]));
    }
    if (m.find("WarningMachineCount") != m.end() && !m["WarningMachineCount"].empty()) {
      warningMachineCount = make_shared<long>(boost::any_cast<long>(m["WarningMachineCount"]));
    }
  }


  virtual ~DescribeCheckWarningSummaryResponseBodyWarningSummarys() = default;
};
class DescribeCheckWarningSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeCheckWarningSummaryResponseBodyWarningSummarys>> warningSummarys{};

  DescribeCheckWarningSummaryResponseBody() {}

  explicit DescribeCheckWarningSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (warningSummarys) {
      vector<boost::any> temp1;
      for(auto item1:*warningSummarys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WarningSummarys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WarningSummarys") != m.end() && !m["WarningSummarys"].empty()) {
      if (typeid(vector<boost::any>) == m["WarningSummarys"].type()) {
        vector<DescribeCheckWarningSummaryResponseBodyWarningSummarys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WarningSummarys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCheckWarningSummaryResponseBodyWarningSummarys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        warningSummarys = make_shared<vector<DescribeCheckWarningSummaryResponseBodyWarningSummarys>>(expect1);
      }
    }
  }


  virtual ~DescribeCheckWarningSummaryResponseBody() = default;
};
class DescribeCheckWarningSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCheckWarningSummaryResponseBody> body{};

  DescribeCheckWarningSummaryResponse() {}

  explicit DescribeCheckWarningSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckWarningSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckWarningSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckWarningSummaryResponse() = default;
};
class DescribeCheckWarningsRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<string> checkType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> riskId{};
  shared_ptr<long> riskStatus{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuid{};

  DescribeCheckWarningsRequest() {}

  explicit DescribeCheckWarningsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<string>(boost::any_cast<string>(m["CheckType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<long>(boost::any_cast<long>(m["RiskStatus"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeCheckWarningsRequest() = default;
};
class DescribeCheckWarningsResponseBodyCheckWarnings : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<long> checkWarningId{};
  shared_ptr<string> execErrorMessage{};
  shared_ptr<long> fixStatus{};
  shared_ptr<string> item{};
  shared_ptr<string> level{};
  shared_ptr<string> reason{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  DescribeCheckWarningsResponseBodyCheckWarnings() {}

  explicit DescribeCheckWarningsResponseBodyCheckWarnings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (checkWarningId) {
      res["CheckWarningId"] = boost::any(*checkWarningId);
    }
    if (execErrorMessage) {
      res["ExecErrorMessage"] = boost::any(*execErrorMessage);
    }
    if (fixStatus) {
      res["FixStatus"] = boost::any(*fixStatus);
    }
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("CheckWarningId") != m.end() && !m["CheckWarningId"].empty()) {
      checkWarningId = make_shared<long>(boost::any_cast<long>(m["CheckWarningId"]));
    }
    if (m.find("ExecErrorMessage") != m.end() && !m["ExecErrorMessage"].empty()) {
      execErrorMessage = make_shared<string>(boost::any_cast<string>(m["ExecErrorMessage"]));
    }
    if (m.find("FixStatus") != m.end() && !m["FixStatus"].empty()) {
      fixStatus = make_shared<long>(boost::any_cast<long>(m["FixStatus"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeCheckWarningsResponseBodyCheckWarnings() = default;
};
class DescribeCheckWarningsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCheckWarningsResponseBodyCheckWarnings>> checkWarnings{};
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCheckWarningsResponseBody() {}

  explicit DescribeCheckWarningsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkWarnings) {
      vector<boost::any> temp1;
      for(auto item1:*checkWarnings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CheckWarnings"] = boost::any(temp1);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckWarnings") != m.end() && !m["CheckWarnings"].empty()) {
      if (typeid(vector<boost::any>) == m["CheckWarnings"].type()) {
        vector<DescribeCheckWarningsResponseBodyCheckWarnings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CheckWarnings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCheckWarningsResponseBodyCheckWarnings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkWarnings = make_shared<vector<DescribeCheckWarningsResponseBodyCheckWarnings>>(expect1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCheckWarningsResponseBody() = default;
};
class DescribeCheckWarningsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCheckWarningsResponseBody> body{};

  DescribeCheckWarningsResponse() {}

  explicit DescribeCheckWarningsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCheckWarningsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCheckWarningsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCheckWarningsResponse() = default;
};
class DescribeClientConfSetupRequest : public Darabonba::Model {
public:
  shared_ptr<string> strategyTag{};
  shared_ptr<string> strategyTagValue{};

  DescribeClientConfSetupRequest() {}

  explicit DescribeClientConfSetupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (strategyTag) {
      res["StrategyTag"] = boost::any(*strategyTag);
    }
    if (strategyTagValue) {
      res["StrategyTagValue"] = boost::any(*strategyTagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StrategyTag") != m.end() && !m["StrategyTag"].empty()) {
      strategyTag = make_shared<string>(boost::any_cast<string>(m["StrategyTag"]));
    }
    if (m.find("StrategyTagValue") != m.end() && !m["StrategyTagValue"].empty()) {
      strategyTagValue = make_shared<string>(boost::any_cast<string>(m["StrategyTagValue"]));
    }
  }


  virtual ~DescribeClientConfSetupRequest() = default;
};
class DescribeClientConfSetupResponseBodyClientConf : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> strategyTag{};
  shared_ptr<string> strategyTagValue{};

  DescribeClientConfSetupResponseBodyClientConf() {}

  explicit DescribeClientConfSetupResponseBodyClientConf(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (strategyTag) {
      res["StrategyTag"] = boost::any(*strategyTag);
    }
    if (strategyTagValue) {
      res["StrategyTagValue"] = boost::any(*strategyTagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("StrategyTag") != m.end() && !m["StrategyTag"].empty()) {
      strategyTag = make_shared<string>(boost::any_cast<string>(m["StrategyTag"]));
    }
    if (m.find("StrategyTagValue") != m.end() && !m["StrategyTagValue"].empty()) {
      strategyTagValue = make_shared<string>(boost::any_cast<string>(m["StrategyTagValue"]));
    }
  }


  virtual ~DescribeClientConfSetupResponseBodyClientConf() = default;
};
class DescribeClientConfSetupResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeClientConfSetupResponseBodyClientConf> clientConf{};
  shared_ptr<string> requestId{};

  DescribeClientConfSetupResponseBody() {}

  explicit DescribeClientConfSetupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientConf) {
      res["ClientConf"] = clientConf ? boost::any(clientConf->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientConf") != m.end() && !m["ClientConf"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientConf"].type()) {
        DescribeClientConfSetupResponseBodyClientConf model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClientConf"]));
        clientConf = make_shared<DescribeClientConfSetupResponseBodyClientConf>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClientConfSetupResponseBody() = default;
};
class DescribeClientConfSetupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClientConfSetupResponseBody> body{};

  DescribeClientConfSetupResponse() {}

  explicit DescribeClientConfSetupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClientConfSetupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClientConfSetupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClientConfSetupResponse() = default;
};
class DescribeClientConfStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> tag{};
  shared_ptr<string> tagValue{};

  DescribeClientConfStrategyRequest() {}

  explicit DescribeClientConfStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeClientConfStrategyRequest() = default;
};
class DescribeClientConfStrategyResponseBodyTargetList : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};

  DescribeClientConfStrategyResponseBodyTargetList() {}

  explicit DescribeClientConfStrategyResponseBodyTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeClientConfStrategyResponseBodyTargetList() = default;
};
class DescribeClientConfStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeClientConfStrategyResponseBodyTargetList>> targetList{};
  shared_ptr<long> totalCount{};

  DescribeClientConfStrategyResponseBody() {}

  explicit DescribeClientConfStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (targetList) {
      vector<boost::any> temp1;
      for(auto item1:*targetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TargetList") != m.end() && !m["TargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetList"].type()) {
        vector<DescribeClientConfStrategyResponseBodyTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClientConfStrategyResponseBodyTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetList = make_shared<vector<DescribeClientConfStrategyResponseBodyTargetList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeClientConfStrategyResponseBody() = default;
};
class DescribeClientConfStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClientConfStrategyResponseBody> body{};

  DescribeClientConfStrategyResponse() {}

  explicit DescribeClientConfStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClientConfStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClientConfStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClientConfStrategyResponse() = default;
};
class DescribeCloudCenterInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> importance{};
  shared_ptr<string> lang{};
  shared_ptr<string> logicalExp{};
  shared_ptr<string> machineTypes{};
  shared_ptr<bool> noGroupTrace{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  DescribeCloudCenterInstancesRequest() {}

  explicit DescribeCloudCenterInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (importance) {
      res["Importance"] = boost::any(*importance);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (logicalExp) {
      res["LogicalExp"] = boost::any(*logicalExp);
    }
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    if (noGroupTrace) {
      res["NoGroupTrace"] = boost::any(*noGroupTrace);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Importance") != m.end() && !m["Importance"].empty()) {
      importance = make_shared<long>(boost::any_cast<long>(m["Importance"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("LogicalExp") != m.end() && !m["LogicalExp"].empty()) {
      logicalExp = make_shared<string>(boost::any_cast<string>(m["LogicalExp"]));
    }
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
    if (m.find("NoGroupTrace") != m.end() && !m["NoGroupTrace"].empty()) {
      noGroupTrace = make_shared<bool>(boost::any_cast<bool>(m["NoGroupTrace"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCloudCenterInstancesRequest() = default;
};
class DescribeCloudCenterInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> assetType{};
  shared_ptr<long> authModifyTime{};
  shared_ptr<long> authVersion{};
  shared_ptr<string> authVersionName{};
  shared_ptr<bool> bind{};
  shared_ptr<string> clientStatus{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> cores{};
  shared_ptr<string> cpuInfo{};
  shared_ptr<long> createdTime{};
  shared_ptr<long> exposedStatus{};
  shared_ptr<long> flag{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupTrace{};
  shared_ptr<string> hcStatus{};
  shared_ptr<long> healthCheckCount{};
  shared_ptr<long> importance{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> ipListString{};
  shared_ptr<string> kernel{};
  shared_ptr<long> lastLoginTimestamp{};
  shared_ptr<string> macListString{};
  shared_ptr<long> mem{};
  shared_ptr<string> os{};
  shared_ptr<string> osName{};
  shared_ptr<long> podCount{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};
  shared_ptr<string> riskCount{};
  shared_ptr<string> riskStatus{};
  shared_ptr<long> safeEventCount{};
  shared_ptr<string> status{};
  shared_ptr<string> tag{};
  shared_ptr<string> tagId{};
  shared_ptr<string> uuid{};
  shared_ptr<long> vendor{};
  shared_ptr<string> vendorName{};
  shared_ptr<string> vpcInstanceId{};
  shared_ptr<long> vulCount{};
  shared_ptr<string> vulStatus{};

  DescribeCloudCenterInstancesResponseBodyInstances() {}

  explicit DescribeCloudCenterInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (authModifyTime) {
      res["AuthModifyTime"] = boost::any(*authModifyTime);
    }
    if (authVersion) {
      res["AuthVersion"] = boost::any(*authVersion);
    }
    if (authVersionName) {
      res["AuthVersionName"] = boost::any(*authVersionName);
    }
    if (bind) {
      res["Bind"] = boost::any(*bind);
    }
    if (clientStatus) {
      res["ClientStatus"] = boost::any(*clientStatus);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (cores) {
      res["Cores"] = boost::any(*cores);
    }
    if (cpuInfo) {
      res["CpuInfo"] = boost::any(*cpuInfo);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (exposedStatus) {
      res["ExposedStatus"] = boost::any(*exposedStatus);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupTrace) {
      res["GroupTrace"] = boost::any(*groupTrace);
    }
    if (hcStatus) {
      res["HcStatus"] = boost::any(*hcStatus);
    }
    if (healthCheckCount) {
      res["HealthCheckCount"] = boost::any(*healthCheckCount);
    }
    if (importance) {
      res["Importance"] = boost::any(*importance);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ipListString) {
      res["IpListString"] = boost::any(*ipListString);
    }
    if (kernel) {
      res["Kernel"] = boost::any(*kernel);
    }
    if (lastLoginTimestamp) {
      res["LastLoginTimestamp"] = boost::any(*lastLoginTimestamp);
    }
    if (macListString) {
      res["MacListString"] = boost::any(*macListString);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (osName) {
      res["OsName"] = boost::any(*osName);
    }
    if (podCount) {
      res["PodCount"] = boost::any(*podCount);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (riskCount) {
      res["RiskCount"] = boost::any(*riskCount);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (safeEventCount) {
      res["SafeEventCount"] = boost::any(*safeEventCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tagId) {
      res["TagId"] = boost::any(*tagId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    if (vpcInstanceId) {
      res["VpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    if (vulStatus) {
      res["VulStatus"] = boost::any(*vulStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("AuthModifyTime") != m.end() && !m["AuthModifyTime"].empty()) {
      authModifyTime = make_shared<long>(boost::any_cast<long>(m["AuthModifyTime"]));
    }
    if (m.find("AuthVersion") != m.end() && !m["AuthVersion"].empty()) {
      authVersion = make_shared<long>(boost::any_cast<long>(m["AuthVersion"]));
    }
    if (m.find("AuthVersionName") != m.end() && !m["AuthVersionName"].empty()) {
      authVersionName = make_shared<string>(boost::any_cast<string>(m["AuthVersionName"]));
    }
    if (m.find("Bind") != m.end() && !m["Bind"].empty()) {
      bind = make_shared<bool>(boost::any_cast<bool>(m["Bind"]));
    }
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      clientStatus = make_shared<string>(boost::any_cast<string>(m["ClientStatus"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Cores") != m.end() && !m["Cores"].empty()) {
      cores = make_shared<long>(boost::any_cast<long>(m["Cores"]));
    }
    if (m.find("CpuInfo") != m.end() && !m["CpuInfo"].empty()) {
      cpuInfo = make_shared<string>(boost::any_cast<string>(m["CpuInfo"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("ExposedStatus") != m.end() && !m["ExposedStatus"].empty()) {
      exposedStatus = make_shared<long>(boost::any_cast<long>(m["ExposedStatus"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<long>(boost::any_cast<long>(m["Flag"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupTrace") != m.end() && !m["GroupTrace"].empty()) {
      groupTrace = make_shared<string>(boost::any_cast<string>(m["GroupTrace"]));
    }
    if (m.find("HcStatus") != m.end() && !m["HcStatus"].empty()) {
      hcStatus = make_shared<string>(boost::any_cast<string>(m["HcStatus"]));
    }
    if (m.find("HealthCheckCount") != m.end() && !m["HealthCheckCount"].empty()) {
      healthCheckCount = make_shared<long>(boost::any_cast<long>(m["HealthCheckCount"]));
    }
    if (m.find("Importance") != m.end() && !m["Importance"].empty()) {
      importance = make_shared<long>(boost::any_cast<long>(m["Importance"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IpListString") != m.end() && !m["IpListString"].empty()) {
      ipListString = make_shared<string>(boost::any_cast<string>(m["IpListString"]));
    }
    if (m.find("Kernel") != m.end() && !m["Kernel"].empty()) {
      kernel = make_shared<string>(boost::any_cast<string>(m["Kernel"]));
    }
    if (m.find("LastLoginTimestamp") != m.end() && !m["LastLoginTimestamp"].empty()) {
      lastLoginTimestamp = make_shared<long>(boost::any_cast<long>(m["LastLoginTimestamp"]));
    }
    if (m.find("MacListString") != m.end() && !m["MacListString"].empty()) {
      macListString = make_shared<string>(boost::any_cast<string>(m["MacListString"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("OsName") != m.end() && !m["OsName"].empty()) {
      osName = make_shared<string>(boost::any_cast<string>(m["OsName"]));
    }
    if (m.find("PodCount") != m.end() && !m["PodCount"].empty()) {
      podCount = make_shared<long>(boost::any_cast<long>(m["PodCount"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("RiskCount") != m.end() && !m["RiskCount"].empty()) {
      riskCount = make_shared<string>(boost::any_cast<string>(m["RiskCount"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("SafeEventCount") != m.end() && !m["SafeEventCount"].empty()) {
      safeEventCount = make_shared<long>(boost::any_cast<long>(m["SafeEventCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TagId") != m.end() && !m["TagId"].empty()) {
      tagId = make_shared<string>(boost::any_cast<string>(m["TagId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<long>(boost::any_cast<long>(m["Vendor"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
    if (m.find("VpcInstanceId") != m.end() && !m["VpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["VpcInstanceId"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
    if (m.find("VulStatus") != m.end() && !m["VulStatus"].empty()) {
      vulStatus = make_shared<string>(boost::any_cast<string>(m["VulStatus"]));
    }
  }


  virtual ~DescribeCloudCenterInstancesResponseBodyInstances() = default;
};
class DescribeCloudCenterInstancesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeCloudCenterInstancesResponseBodyPageInfo() {}

  explicit DescribeCloudCenterInstancesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCloudCenterInstancesResponseBodyPageInfo() = default;
};
class DescribeCloudCenterInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudCenterInstancesResponseBodyInstances>> instances{};
  shared_ptr<DescribeCloudCenterInstancesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeCloudCenterInstancesResponseBody() {}

  explicit DescribeCloudCenterInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeCloudCenterInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudCenterInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeCloudCenterInstancesResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeCloudCenterInstancesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeCloudCenterInstancesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeCloudCenterInstancesResponseBody() = default;
};
class DescribeCloudCenterInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudCenterInstancesResponseBody> body{};

  DescribeCloudCenterInstancesResponse() {}

  explicit DescribeCloudCenterInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudCenterInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudCenterInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudCenterInstancesResponse() = default;
};
class DescribeCloudProductFieldStatisticsResponseBodyGroupedFields : public Darabonba::Model {
public:
  shared_ptr<string> categoryCount{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> riskInstanceCount{};

  DescribeCloudProductFieldStatisticsResponseBodyGroupedFields() {}

  explicit DescribeCloudProductFieldStatisticsResponseBodyGroupedFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryCount) {
      res["CategoryCount"] = boost::any(*categoryCount);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (riskInstanceCount) {
      res["RiskInstanceCount"] = boost::any(*riskInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryCount") != m.end() && !m["CategoryCount"].empty()) {
      categoryCount = make_shared<string>(boost::any_cast<string>(m["CategoryCount"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("RiskInstanceCount") != m.end() && !m["RiskInstanceCount"].empty()) {
      riskInstanceCount = make_shared<long>(boost::any_cast<long>(m["RiskInstanceCount"]));
    }
  }


  virtual ~DescribeCloudProductFieldStatisticsResponseBodyGroupedFields() = default;
};
class DescribeCloudProductFieldStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCloudProductFieldStatisticsResponseBodyGroupedFields> groupedFields{};
  shared_ptr<string> requestId{};

  DescribeCloudProductFieldStatisticsResponseBody() {}

  explicit DescribeCloudProductFieldStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupedFields) {
      res["GroupedFields"] = groupedFields ? boost::any(groupedFields->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupedFields") != m.end() && !m["GroupedFields"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupedFields"].type()) {
        DescribeCloudProductFieldStatisticsResponseBodyGroupedFields model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupedFields"]));
        groupedFields = make_shared<DescribeCloudProductFieldStatisticsResponseBodyGroupedFields>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCloudProductFieldStatisticsResponseBody() = default;
};
class DescribeCloudProductFieldStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudProductFieldStatisticsResponseBody> body{};

  DescribeCloudProductFieldStatisticsResponse() {}

  explicit DescribeCloudProductFieldStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudProductFieldStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudProductFieldStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudProductFieldStatisticsResponse() = default;
};
class DescribeClusterBasicInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};

  DescribeClusterBasicInfoRequest() {}

  explicit DescribeClusterBasicInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeClusterBasicInfoRequest() = default;
};
class DescribeClusterBasicInfoResponseBodyClusterInfo : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<long> createTime{};
  shared_ptr<string> currentVersion{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<bool> targetResult{};

  DescribeClusterBasicInfoResponseBodyClusterInfo() {}

  explicit DescribeClusterBasicInfoResponseBodyClusterInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (targetResult) {
      res["TargetResult"] = boost::any(*targetResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<string>(boost::any_cast<string>(m["CurrentVersion"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TargetResult") != m.end() && !m["TargetResult"].empty()) {
      targetResult = make_shared<bool>(boost::any_cast<bool>(m["TargetResult"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBodyClusterInfo() = default;
};
class DescribeClusterBasicInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterBasicInfoResponseBodyClusterInfo> clusterInfo{};
  shared_ptr<string> requestId{};

  DescribeClusterBasicInfoResponseBody() {}

  explicit DescribeClusterBasicInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInfo) {
      res["ClusterInfo"] = clusterInfo ? boost::any(clusterInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInfo") != m.end() && !m["ClusterInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterInfo"].type()) {
        DescribeClusterBasicInfoResponseBodyClusterInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterInfo"]));
        clusterInfo = make_shared<DescribeClusterBasicInfoResponseBodyClusterInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterBasicInfoResponseBody() = default;
};
class DescribeClusterBasicInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterBasicInfoResponseBody> body{};

  DescribeClusterBasicInfoResponse() {}

  explicit DescribeClusterBasicInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterBasicInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterBasicInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterBasicInfoResponse() = default;
};
class DescribeClusterInfoListRequest : public Darabonba::Model {
public:
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};

  DescribeClusterInfoListRequest() {}

  explicit DescribeClusterInfoListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeClusterInfoListRequest() = default;
};
class DescribeClusterInfoListResponseBodyClusterList : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<bool> targetResult{};

  DescribeClusterInfoListResponseBodyClusterList() {}

  explicit DescribeClusterInfoListResponseBodyClusterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (targetResult) {
      res["TargetResult"] = boost::any(*targetResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TargetResult") != m.end() && !m["TargetResult"].empty()) {
      targetResult = make_shared<bool>(boost::any_cast<bool>(m["TargetResult"]));
    }
  }


  virtual ~DescribeClusterInfoListResponseBodyClusterList() = default;
};
class DescribeClusterInfoListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterInfoListResponseBodyClusterList>> clusterList{};
  shared_ptr<string> requestId{};

  DescribeClusterInfoListResponseBody() {}

  explicit DescribeClusterInfoListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterList) {
      vector<boost::any> temp1;
      for(auto item1:*clusterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterList") != m.end() && !m["ClusterList"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterList"].type()) {
        vector<DescribeClusterInfoListResponseBodyClusterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterInfoListResponseBodyClusterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterList = make_shared<vector<DescribeClusterInfoListResponseBodyClusterList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterInfoListResponseBody() = default;
};
class DescribeClusterInfoListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterInfoListResponseBody> body{};

  DescribeClusterInfoListResponse() {}

  explicit DescribeClusterInfoListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterInfoListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterInfoListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterInfoListResponse() = default;
};
class DescribeClusterNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  DescribeClusterNetworkRequest() {}

  explicit DescribeClusterNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeClusterNetworkRequest() = default;
};
class DescribeClusterNetworkResponseBodyClusterNetworkEdge : public Darabonba::Model {
public:
  shared_ptr<string> dstNodeId{};
  shared_ptr<string> dstNodeType{};
  shared_ptr<string> id{};
  shared_ptr<string> port{};
  shared_ptr<string> srcNodeId{};
  shared_ptr<string> srcNodeType{};

  DescribeClusterNetworkResponseBodyClusterNetworkEdge() {}

  explicit DescribeClusterNetworkResponseBodyClusterNetworkEdge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstNodeId) {
      res["DstNodeId"] = boost::any(*dstNodeId);
    }
    if (dstNodeType) {
      res["DstNodeType"] = boost::any(*dstNodeType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (srcNodeId) {
      res["SrcNodeId"] = boost::any(*srcNodeId);
    }
    if (srcNodeType) {
      res["SrcNodeType"] = boost::any(*srcNodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstNodeId") != m.end() && !m["DstNodeId"].empty()) {
      dstNodeId = make_shared<string>(boost::any_cast<string>(m["DstNodeId"]));
    }
    if (m.find("DstNodeType") != m.end() && !m["DstNodeType"].empty()) {
      dstNodeType = make_shared<string>(boost::any_cast<string>(m["DstNodeType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("SrcNodeId") != m.end() && !m["SrcNodeId"].empty()) {
      srcNodeId = make_shared<string>(boost::any_cast<string>(m["SrcNodeId"]));
    }
    if (m.find("SrcNodeType") != m.end() && !m["SrcNodeType"].empty()) {
      srcNodeType = make_shared<string>(boost::any_cast<string>(m["SrcNodeType"]));
    }
  }


  virtual ~DescribeClusterNetworkResponseBodyClusterNetworkEdge() = default;
};
class DescribeClusterNetworkResponseBodyClusterNetworkNode : public Darabonba::Model {
public:
  shared_ptr<long> cnnfSwitch{};
  shared_ptr<string> id{};
  shared_ptr<long> interceptionType{};
  shared_ptr<string> name{};
  shared_ptr<string> netTopoSwitch{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> type{};

  DescribeClusterNetworkResponseBodyClusterNetworkNode() {}

  explicit DescribeClusterNetworkResponseBodyClusterNetworkNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cnnfSwitch) {
      res["CnnfSwitch"] = boost::any(*cnnfSwitch);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interceptionType) {
      res["InterceptionType"] = boost::any(*interceptionType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (netTopoSwitch) {
      res["NetTopoSwitch"] = boost::any(*netTopoSwitch);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CnnfSwitch") != m.end() && !m["CnnfSwitch"].empty()) {
      cnnfSwitch = make_shared<long>(boost::any_cast<long>(m["CnnfSwitch"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InterceptionType") != m.end() && !m["InterceptionType"].empty()) {
      interceptionType = make_shared<long>(boost::any_cast<long>(m["InterceptionType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetTopoSwitch") != m.end() && !m["NetTopoSwitch"].empty()) {
      netTopoSwitch = make_shared<string>(boost::any_cast<string>(m["NetTopoSwitch"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeClusterNetworkResponseBodyClusterNetworkNode() = default;
};
class DescribeClusterNetworkResponseBodyClusterNetwork : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeClusterNetworkResponseBodyClusterNetworkEdge>> edge{};
  shared_ptr<vector<DescribeClusterNetworkResponseBodyClusterNetworkNode>> node{};

  DescribeClusterNetworkResponseBodyClusterNetwork() {}

  explicit DescribeClusterNetworkResponseBodyClusterNetwork(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edge) {
      vector<boost::any> temp1;
      for(auto item1:*edge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Edge"] = boost::any(temp1);
    }
    if (node) {
      vector<boost::any> temp1;
      for(auto item1:*node){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Node"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edge") != m.end() && !m["Edge"].empty()) {
      if (typeid(vector<boost::any>) == m["Edge"].type()) {
        vector<DescribeClusterNetworkResponseBodyClusterNetworkEdge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Edge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterNetworkResponseBodyClusterNetworkEdge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        edge = make_shared<vector<DescribeClusterNetworkResponseBodyClusterNetworkEdge>>(expect1);
      }
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(vector<boost::any>) == m["Node"].type()) {
        vector<DescribeClusterNetworkResponseBodyClusterNetworkNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Node"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeClusterNetworkResponseBodyClusterNetworkNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        node = make_shared<vector<DescribeClusterNetworkResponseBodyClusterNetworkNode>>(expect1);
      }
    }
  }


  virtual ~DescribeClusterNetworkResponseBodyClusterNetwork() = default;
};
class DescribeClusterNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeClusterNetworkResponseBodyClusterNetwork> clusterNetwork{};
  shared_ptr<string> requestId{};

  DescribeClusterNetworkResponseBody() {}

  explicit DescribeClusterNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterNetwork) {
      res["ClusterNetwork"] = clusterNetwork ? boost::any(clusterNetwork->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterNetwork") != m.end() && !m["ClusterNetwork"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterNetwork"].type()) {
        DescribeClusterNetworkResponseBodyClusterNetwork model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterNetwork"]));
        clusterNetwork = make_shared<DescribeClusterNetworkResponseBodyClusterNetwork>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeClusterNetworkResponseBody() = default;
};
class DescribeClusterNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterNetworkResponseBody> body{};

  DescribeClusterNetworkResponse() {}

  explicit DescribeClusterNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterNetworkResponse() = default;
};
class DescribeClusterVulStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> types{};

  DescribeClusterVulStatisticsRequest() {}

  explicit DescribeClusterVulStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      types = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
  }


  virtual ~DescribeClusterVulStatisticsRequest() = default;
};
class DescribeClusterVulStatisticsResponseBodyVulStat : public Darabonba::Model {
public:
  shared_ptr<string> asapCount{};
  shared_ptr<string> laterCount{};
  shared_ptr<string> nntfCount{};

  DescribeClusterVulStatisticsResponseBodyVulStat() {}

  explicit DescribeClusterVulStatisticsResponseBodyVulStat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asapCount) {
      res["AsapCount"] = boost::any(*asapCount);
    }
    if (laterCount) {
      res["LaterCount"] = boost::any(*laterCount);
    }
    if (nntfCount) {
      res["NntfCount"] = boost::any(*nntfCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsapCount") != m.end() && !m["AsapCount"].empty()) {
      asapCount = make_shared<string>(boost::any_cast<string>(m["AsapCount"]));
    }
    if (m.find("LaterCount") != m.end() && !m["LaterCount"].empty()) {
      laterCount = make_shared<string>(boost::any_cast<string>(m["LaterCount"]));
    }
    if (m.find("NntfCount") != m.end() && !m["NntfCount"].empty()) {
      nntfCount = make_shared<string>(boost::any_cast<string>(m["NntfCount"]));
    }
  }


  virtual ~DescribeClusterVulStatisticsResponseBodyVulStat() = default;
};
class DescribeClusterVulStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeClusterVulStatisticsResponseBodyVulStat> vulStat{};

  DescribeClusterVulStatisticsResponseBody() {}

  explicit DescribeClusterVulStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vulStat) {
      res["VulStat"] = vulStat ? boost::any(vulStat->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VulStat") != m.end() && !m["VulStat"].empty()) {
      if (typeid(map<string, boost::any>) == m["VulStat"].type()) {
        DescribeClusterVulStatisticsResponseBodyVulStat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VulStat"]));
        vulStat = make_shared<DescribeClusterVulStatisticsResponseBodyVulStat>(model1);
      }
    }
  }


  virtual ~DescribeClusterVulStatisticsResponseBody() = default;
};
class DescribeClusterVulStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeClusterVulStatisticsResponseBody> body{};

  DescribeClusterVulStatisticsResponse() {}

  explicit DescribeClusterVulStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClusterVulStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClusterVulStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClusterVulStatisticsResponse() = default;
};
class DescribeCommonOverallConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  DescribeCommonOverallConfigRequest() {}

  explicit DescribeCommonOverallConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCommonOverallConfigRequest() = default;
};
class DescribeCommonOverallConfigResponseBodyOverallConfig : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> type{};

  DescribeCommonOverallConfigResponseBodyOverallConfig() {}

  explicit DescribeCommonOverallConfigResponseBodyOverallConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCommonOverallConfigResponseBodyOverallConfig() = default;
};
class DescribeCommonOverallConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCommonOverallConfigResponseBodyOverallConfig> overallConfig{};
  shared_ptr<string> requestId{};

  DescribeCommonOverallConfigResponseBody() {}

  explicit DescribeCommonOverallConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overallConfig) {
      res["OverallConfig"] = overallConfig ? boost::any(overallConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverallConfig") != m.end() && !m["OverallConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverallConfig"].type()) {
        DescribeCommonOverallConfigResponseBodyOverallConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverallConfig"]));
        overallConfig = make_shared<DescribeCommonOverallConfigResponseBodyOverallConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCommonOverallConfigResponseBody() = default;
};
class DescribeCommonOverallConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCommonOverallConfigResponseBody> body{};

  DescribeCommonOverallConfigResponse() {}

  explicit DescribeCommonOverallConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCommonOverallConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCommonOverallConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCommonOverallConfigResponse() = default;
};
class DescribeCommonOverallConfigListRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<vector<string>> typeList{};

  DescribeCommonOverallConfigListRequest() {}

  explicit DescribeCommonOverallConfigListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (typeList) {
      res["TypeList"] = boost::any(*typeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("TypeList") != m.end() && !m["TypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      typeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCommonOverallConfigListRequest() = default;
};
class DescribeCommonOverallConfigListResponseBodyOverallList : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> type{};

  DescribeCommonOverallConfigListResponseBodyOverallList() {}

  explicit DescribeCommonOverallConfigListResponseBodyOverallList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCommonOverallConfigListResponseBodyOverallList() = default;
};
class DescribeCommonOverallConfigListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCommonOverallConfigListResponseBodyOverallList>> overallList{};
  shared_ptr<string> requestId{};

  DescribeCommonOverallConfigListResponseBody() {}

  explicit DescribeCommonOverallConfigListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overallList) {
      vector<boost::any> temp1;
      for(auto item1:*overallList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OverallList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverallList") != m.end() && !m["OverallList"].empty()) {
      if (typeid(vector<boost::any>) == m["OverallList"].type()) {
        vector<DescribeCommonOverallConfigListResponseBodyOverallList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OverallList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommonOverallConfigListResponseBodyOverallList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        overallList = make_shared<vector<DescribeCommonOverallConfigListResponseBodyOverallList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCommonOverallConfigListResponseBody() = default;
};
class DescribeCommonOverallConfigListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCommonOverallConfigListResponseBody> body{};

  DescribeCommonOverallConfigListResponse() {}

  explicit DescribeCommonOverallConfigListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCommonOverallConfigListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCommonOverallConfigListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCommonOverallConfigListResponse() = default;
};
class DescribeCommonTargetConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  DescribeCommonTargetConfigRequest() {}

  explicit DescribeCommonTargetConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCommonTargetConfigRequest() = default;
};
class DescribeCommonTargetConfigResponseBodyTargetList : public Darabonba::Model {
public:
  shared_ptr<string> flag{};
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};

  DescribeCommonTargetConfigResponseBodyTargetList() {}

  explicit DescribeCommonTargetConfigResponseBodyTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<string>(boost::any_cast<string>(m["Flag"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeCommonTargetConfigResponseBodyTargetList() = default;
};
class DescribeCommonTargetConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeCommonTargetConfigResponseBodyTargetList>> targetList{};

  DescribeCommonTargetConfigResponseBody() {}

  explicit DescribeCommonTargetConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (targetList) {
      vector<boost::any> temp1;
      for(auto item1:*targetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TargetList") != m.end() && !m["TargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetList"].type()) {
        vector<DescribeCommonTargetConfigResponseBodyTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommonTargetConfigResponseBodyTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetList = make_shared<vector<DescribeCommonTargetConfigResponseBodyTargetList>>(expect1);
      }
    }
  }


  virtual ~DescribeCommonTargetConfigResponseBody() = default;
};
class DescribeCommonTargetConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCommonTargetConfigResponseBody> body{};

  DescribeCommonTargetConfigResponse() {}

  explicit DescribeCommonTargetConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCommonTargetConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCommonTargetConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCommonTargetConfigResponse() = default;
};
class DescribeCommonTargetResultListRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  DescribeCommonTargetResultListRequest() {}

  explicit DescribeCommonTargetResultListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCommonTargetResultListRequest() = default;
};
class DescribeCommonTargetResultListResponseBodyTargetConfig : public Darabonba::Model {
public:
  shared_ptr<string> flag{};
  shared_ptr<string> targetDefault{};
  shared_ptr<vector<string>> targetList{};
  shared_ptr<string> targetType{};
  shared_ptr<string> totalCount{};
  shared_ptr<string> type{};

  DescribeCommonTargetResultListResponseBodyTargetConfig() {}

  explicit DescribeCommonTargetResultListResponseBodyTargetConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (targetDefault) {
      res["TargetDefault"] = boost::any(*targetDefault);
    }
    if (targetList) {
      res["TargetList"] = boost::any(*targetList);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<string>(boost::any_cast<string>(m["Flag"]));
    }
    if (m.find("TargetDefault") != m.end() && !m["TargetDefault"].empty()) {
      targetDefault = make_shared<string>(boost::any_cast<string>(m["TargetDefault"]));
    }
    if (m.find("TargetList") != m.end() && !m["TargetList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCommonTargetResultListResponseBodyTargetConfig() = default;
};
class DescribeCommonTargetResultListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCommonTargetResultListResponseBodyTargetConfig> targetConfig{};

  DescribeCommonTargetResultListResponseBody() {}

  explicit DescribeCommonTargetResultListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (targetConfig) {
      res["TargetConfig"] = targetConfig ? boost::any(targetConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TargetConfig") != m.end() && !m["TargetConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetConfig"].type()) {
        DescribeCommonTargetResultListResponseBodyTargetConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetConfig"]));
        targetConfig = make_shared<DescribeCommonTargetResultListResponseBodyTargetConfig>(model1);
      }
    }
  }


  virtual ~DescribeCommonTargetResultListResponseBody() = default;
};
class DescribeCommonTargetResultListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCommonTargetResultListResponseBody> body{};

  DescribeCommonTargetResultListResponse() {}

  explicit DescribeCommonTargetResultListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCommonTargetResultListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCommonTargetResultListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCommonTargetResultListResponse() = default;
};
class DescribeConcernNecessityRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeConcernNecessityRequest() {}

  explicit DescribeConcernNecessityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeConcernNecessityRequest() = default;
};
class DescribeConcernNecessityResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> concernNecessity{};
  shared_ptr<string> requestId{};

  DescribeConcernNecessityResponseBody() {}

  explicit DescribeConcernNecessityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concernNecessity) {
      res["ConcernNecessity"] = boost::any(*concernNecessity);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcernNecessity") != m.end() && !m["ConcernNecessity"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConcernNecessity"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConcernNecessity"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      concernNecessity = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeConcernNecessityResponseBody() = default;
};
class DescribeConcernNecessityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConcernNecessityResponseBody> body{};

  DescribeConcernNecessityResponse() {}

  explicit DescribeConcernNecessityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConcernNecessityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConcernNecessityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConcernNecessityResponse() = default;
};
class DescribeContainerCriteriaRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupField{};
  shared_ptr<string> value{};

  DescribeContainerCriteriaRequest() {}

  explicit DescribeContainerCriteriaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupField) {
      res["GroupField"] = boost::any(*groupField);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupField") != m.end() && !m["GroupField"].empty()) {
      groupField = make_shared<string>(boost::any_cast<string>(m["GroupField"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeContainerCriteriaRequest() = default;
};
class DescribeContainerCriteriaResponseBodyCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> values{};

  DescribeContainerCriteriaResponseBodyCriteriaList() {}

  explicit DescribeContainerCriteriaResponseBodyCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DescribeContainerCriteriaResponseBodyCriteriaList() = default;
};
class DescribeContainerCriteriaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeContainerCriteriaResponseBodyCriteriaList>> criteriaList{};
  shared_ptr<string> requestId{};

  DescribeContainerCriteriaResponseBody() {}

  explicit DescribeContainerCriteriaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*criteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CriteriaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CriteriaList") != m.end() && !m["CriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["CriteriaList"].type()) {
        vector<DescribeContainerCriteriaResponseBodyCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContainerCriteriaResponseBodyCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteriaList = make_shared<vector<DescribeContainerCriteriaResponseBodyCriteriaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeContainerCriteriaResponseBody() = default;
};
class DescribeContainerCriteriaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContainerCriteriaResponseBody> body{};

  DescribeContainerCriteriaResponse() {}

  explicit DescribeContainerCriteriaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContainerCriteriaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContainerCriteriaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContainerCriteriaResponse() = default;
};
class DescribeContainerInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> logicalExp{};
  shared_ptr<long> pageSize{};

  DescribeContainerInstancesRequest() {}

  explicit DescribeContainerInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logicalExp) {
      res["LogicalExp"] = boost::any(*logicalExp);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LogicalExp") != m.end() && !m["LogicalExp"].empty()) {
      logicalExp = make_shared<string>(boost::any_cast<string>(m["LogicalExp"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeContainerInstancesRequest() = default;
};
class DescribeContainerInstancesResponseBodyContainerInstanceList : public Darabonba::Model {
public:
  shared_ptr<long> alarmCount{};
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> containerId{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<long> hcCount{};
  shared_ptr<string> hcStatus{};
  shared_ptr<string> hostIp{};
  shared_ptr<string> image{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageRepoName{};
  shared_ptr<string> imageRepoNamespace{};
  shared_ptr<string> imageRepoTag{};
  shared_ptr<string> imageUuid{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> nodeInfo{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> pod{};
  shared_ptr<string> podIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> riskCount{};
  shared_ptr<string> riskStatus{};
  shared_ptr<string> updateMark{};
  shared_ptr<long> vulCount{};
  shared_ptr<string> vulStatus{};

  DescribeContainerInstancesResponseBodyContainerInstanceList() {}

  explicit DescribeContainerInstancesResponseBodyContainerInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmCount) {
      res["AlarmCount"] = boost::any(*alarmCount);
    }
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (hcCount) {
      res["HcCount"] = boost::any(*hcCount);
    }
    if (hcStatus) {
      res["HcStatus"] = boost::any(*hcStatus);
    }
    if (hostIp) {
      res["HostIp"] = boost::any(*hostIp);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageRepoName) {
      res["ImageRepoName"] = boost::any(*imageRepoName);
    }
    if (imageRepoNamespace) {
      res["ImageRepoNamespace"] = boost::any(*imageRepoNamespace);
    }
    if (imageRepoTag) {
      res["ImageRepoTag"] = boost::any(*imageRepoTag);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (nodeInfo) {
      res["NodeInfo"] = boost::any(*nodeInfo);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (podIp) {
      res["PodIp"] = boost::any(*podIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (riskCount) {
      res["RiskCount"] = boost::any(*riskCount);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (updateMark) {
      res["UpdateMark"] = boost::any(*updateMark);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    if (vulStatus) {
      res["VulStatus"] = boost::any(*vulStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmCount") != m.end() && !m["AlarmCount"].empty()) {
      alarmCount = make_shared<long>(boost::any_cast<long>(m["AlarmCount"]));
    }
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("HcCount") != m.end() && !m["HcCount"].empty()) {
      hcCount = make_shared<long>(boost::any_cast<long>(m["HcCount"]));
    }
    if (m.find("HcStatus") != m.end() && !m["HcStatus"].empty()) {
      hcStatus = make_shared<string>(boost::any_cast<string>(m["HcStatus"]));
    }
    if (m.find("HostIp") != m.end() && !m["HostIp"].empty()) {
      hostIp = make_shared<string>(boost::any_cast<string>(m["HostIp"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageRepoName") != m.end() && !m["ImageRepoName"].empty()) {
      imageRepoName = make_shared<string>(boost::any_cast<string>(m["ImageRepoName"]));
    }
    if (m.find("ImageRepoNamespace") != m.end() && !m["ImageRepoNamespace"].empty()) {
      imageRepoNamespace = make_shared<string>(boost::any_cast<string>(m["ImageRepoNamespace"]));
    }
    if (m.find("ImageRepoTag") != m.end() && !m["ImageRepoTag"].empty()) {
      imageRepoTag = make_shared<string>(boost::any_cast<string>(m["ImageRepoTag"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NodeInfo") != m.end() && !m["NodeInfo"].empty()) {
      nodeInfo = make_shared<string>(boost::any_cast<string>(m["NodeInfo"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("PodIp") != m.end() && !m["PodIp"].empty()) {
      podIp = make_shared<string>(boost::any_cast<string>(m["PodIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RiskCount") != m.end() && !m["RiskCount"].empty()) {
      riskCount = make_shared<string>(boost::any_cast<string>(m["RiskCount"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("UpdateMark") != m.end() && !m["UpdateMark"].empty()) {
      updateMark = make_shared<string>(boost::any_cast<string>(m["UpdateMark"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
    if (m.find("VulStatus") != m.end() && !m["VulStatus"].empty()) {
      vulStatus = make_shared<string>(boost::any_cast<string>(m["VulStatus"]));
    }
  }


  virtual ~DescribeContainerInstancesResponseBodyContainerInstanceList() = default;
};
class DescribeContainerInstancesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeContainerInstancesResponseBodyPageInfo() {}

  explicit DescribeContainerInstancesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeContainerInstancesResponseBodyPageInfo() = default;
};
class DescribeContainerInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeContainerInstancesResponseBodyContainerInstanceList>> containerInstanceList{};
  shared_ptr<DescribeContainerInstancesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeContainerInstancesResponseBody() {}

  explicit DescribeContainerInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*containerInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContainerInstanceList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerInstanceList") != m.end() && !m["ContainerInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ContainerInstanceList"].type()) {
        vector<DescribeContainerInstancesResponseBodyContainerInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContainerInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeContainerInstancesResponseBodyContainerInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        containerInstanceList = make_shared<vector<DescribeContainerInstancesResponseBodyContainerInstanceList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeContainerInstancesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeContainerInstancesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeContainerInstancesResponseBody() = default;
};
class DescribeContainerInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContainerInstancesResponseBody> body{};

  DescribeContainerInstancesResponse() {}

  explicit DescribeContainerInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContainerInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContainerInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContainerInstancesResponse() = default;
};
class DescribeContainerStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  DescribeContainerStatisticsRequest() {}

  explicit DescribeContainerStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~DescribeContainerStatisticsRequest() = default;
};
class DescribeContainerStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> remindAlarmCount{};
  shared_ptr<long> seriousAlarmCount{};
  shared_ptr<long> suspiciousAlarmCount{};
  shared_ptr<long> totalAlarmCount{};
  shared_ptr<long> totalNode{};
  shared_ptr<long> hasRiskNode{};

  DescribeContainerStatisticsResponseBodyData() {}

  explicit DescribeContainerStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindAlarmCount) {
      res["RemindAlarmCount"] = boost::any(*remindAlarmCount);
    }
    if (seriousAlarmCount) {
      res["SeriousAlarmCount"] = boost::any(*seriousAlarmCount);
    }
    if (suspiciousAlarmCount) {
      res["SuspiciousAlarmCount"] = boost::any(*suspiciousAlarmCount);
    }
    if (totalAlarmCount) {
      res["TotalAlarmCount"] = boost::any(*totalAlarmCount);
    }
    if (totalNode) {
      res["TotalNode"] = boost::any(*totalNode);
    }
    if (hasRiskNode) {
      res["hasRiskNode"] = boost::any(*hasRiskNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindAlarmCount") != m.end() && !m["RemindAlarmCount"].empty()) {
      remindAlarmCount = make_shared<long>(boost::any_cast<long>(m["RemindAlarmCount"]));
    }
    if (m.find("SeriousAlarmCount") != m.end() && !m["SeriousAlarmCount"].empty()) {
      seriousAlarmCount = make_shared<long>(boost::any_cast<long>(m["SeriousAlarmCount"]));
    }
    if (m.find("SuspiciousAlarmCount") != m.end() && !m["SuspiciousAlarmCount"].empty()) {
      suspiciousAlarmCount = make_shared<long>(boost::any_cast<long>(m["SuspiciousAlarmCount"]));
    }
    if (m.find("TotalAlarmCount") != m.end() && !m["TotalAlarmCount"].empty()) {
      totalAlarmCount = make_shared<long>(boost::any_cast<long>(m["TotalAlarmCount"]));
    }
    if (m.find("TotalNode") != m.end() && !m["TotalNode"].empty()) {
      totalNode = make_shared<long>(boost::any_cast<long>(m["TotalNode"]));
    }
    if (m.find("hasRiskNode") != m.end() && !m["hasRiskNode"].empty()) {
      hasRiskNode = make_shared<long>(boost::any_cast<long>(m["hasRiskNode"]));
    }
  }


  virtual ~DescribeContainerStatisticsResponseBodyData() = default;
};
class DescribeContainerStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeContainerStatisticsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeContainerStatisticsResponseBody() {}

  explicit DescribeContainerStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeContainerStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeContainerStatisticsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeContainerStatisticsResponseBody() = default;
};
class DescribeContainerStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContainerStatisticsResponseBody> body{};

  DescribeContainerStatisticsResponse() {}

  explicit DescribeContainerStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContainerStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContainerStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContainerStatisticsResponse() = default;
};
class DescribeContainerTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageSize{};

  DescribeContainerTagsRequest() {}

  explicit DescribeContainerTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeContainerTagsRequest() = default;
};
class DescribeContainerTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> tagValues{};

  DescribeContainerTagsResponseBody() {}

  explicit DescribeContainerTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagValues) {
      res["TagValues"] = boost::any(*tagValues);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagValues") != m.end() && !m["TagValues"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagValues"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagValues"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagValues = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeContainerTagsResponseBody() = default;
};
class DescribeContainerTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeContainerTagsResponseBody> body{};

  DescribeContainerTagsResponse() {}

  explicit DescribeContainerTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeContainerTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeContainerTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeContainerTagsResponse() = default;
};
class DescribeCountNotScannedImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> notScannedCnt{};
  shared_ptr<string> requestId{};

  DescribeCountNotScannedImageResponseBody() {}

  explicit DescribeCountNotScannedImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notScannedCnt) {
      res["NotScannedCnt"] = boost::any(*notScannedCnt);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NotScannedCnt") != m.end() && !m["NotScannedCnt"].empty()) {
      notScannedCnt = make_shared<long>(boost::any_cast<long>(m["NotScannedCnt"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCountNotScannedImageResponseBody() = default;
};
class DescribeCountNotScannedImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCountNotScannedImageResponseBody> body{};

  DescribeCountNotScannedImageResponse() {}

  explicit DescribeCountNotScannedImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCountNotScannedImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCountNotScannedImageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCountNotScannedImageResponse() = default;
};
class DescribeCountScannedImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> scannedCount{};

  DescribeCountScannedImageResponseBody() {}

  explicit DescribeCountScannedImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scannedCount) {
      res["ScannedCount"] = boost::any(*scannedCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScannedCount") != m.end() && !m["ScannedCount"].empty()) {
      scannedCount = make_shared<long>(boost::any_cast<long>(m["ScannedCount"]));
    }
  }


  virtual ~DescribeCountScannedImageResponseBody() = default;
};
class DescribeCountScannedImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCountScannedImageResponseBody> body{};

  DescribeCountScannedImageResponse() {}

  explicit DescribeCountScannedImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCountScannedImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCountScannedImageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCountScannedImageResponse() = default;
};
class DescribeCriteriaRequest : public Darabonba::Model {
public:
  shared_ptr<string> machineTypes{};
  shared_ptr<bool> supportAutoTag{};
  shared_ptr<string> value{};

  DescribeCriteriaRequest() {}

  explicit DescribeCriteriaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    if (supportAutoTag) {
      res["SupportAutoTag"] = boost::any(*supportAutoTag);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
    if (m.find("SupportAutoTag") != m.end() && !m["SupportAutoTag"].empty()) {
      supportAutoTag = make_shared<bool>(boost::any_cast<bool>(m["SupportAutoTag"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCriteriaRequest() = default;
};
class DescribeCriteriaResponseBodyCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> multiValues{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> values{};

  DescribeCriteriaResponseBodyCriteriaList() {}

  explicit DescribeCriteriaResponseBodyCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (multiValues) {
      res["MultiValues"] = boost::any(*multiValues);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MultiValues") != m.end() && !m["MultiValues"].empty()) {
      multiValues = make_shared<string>(boost::any_cast<string>(m["MultiValues"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DescribeCriteriaResponseBodyCriteriaList() = default;
};
class DescribeCriteriaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCriteriaResponseBodyCriteriaList>> criteriaList{};
  shared_ptr<string> requestId{};

  DescribeCriteriaResponseBody() {}

  explicit DescribeCriteriaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*criteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CriteriaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CriteriaList") != m.end() && !m["CriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["CriteriaList"].type()) {
        vector<DescribeCriteriaResponseBodyCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCriteriaResponseBodyCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteriaList = make_shared<vector<DescribeCriteriaResponseBodyCriteriaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCriteriaResponseBody() = default;
};
class DescribeCriteriaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCriteriaResponseBody> body{};

  DescribeCriteriaResponse() {}

  explicit DescribeCriteriaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCriteriaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCriteriaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCriteriaResponse() = default;
};
class DescribeCustomBlockRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> blockIp{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> status{};

  DescribeCustomBlockRecordsRequest() {}

  explicit DescribeCustomBlockRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockIp) {
      res["BlockIp"] = boost::any(*blockIp);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockIp") != m.end() && !m["BlockIp"].empty()) {
      blockIp = make_shared<string>(boost::any_cast<string>(m["BlockIp"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeCustomBlockRecordsRequest() = default;
};
class DescribeCustomBlockRecordsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeCustomBlockRecordsResponseBodyPageInfo() {}

  explicit DescribeCustomBlockRecordsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCustomBlockRecordsResponseBodyPageInfo() = default;
};
class DescribeCustomBlockRecordsResponseBodyRecordListTargetList : public Darabonba::Model {
public:
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};

  DescribeCustomBlockRecordsResponseBodyRecordListTargetList() {}

  explicit DescribeCustomBlockRecordsResponseBodyRecordListTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeCustomBlockRecordsResponseBodyRecordListTargetList() = default;
};
class DescribeCustomBlockRecordsResponseBodyRecordList : public Darabonba::Model {
public:
  shared_ptr<long> blockExpireDate{};
  shared_ptr<string> blockIp{};
  shared_ptr<string> bound{};
  shared_ptr<long> enableCount{};
  shared_ptr<long> id{};
  shared_ptr<long> serverCount{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<vector<DescribeCustomBlockRecordsResponseBodyRecordListTargetList>> targetList{};

  DescribeCustomBlockRecordsResponseBodyRecordList() {}

  explicit DescribeCustomBlockRecordsResponseBodyRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockExpireDate) {
      res["BlockExpireDate"] = boost::any(*blockExpireDate);
    }
    if (blockIp) {
      res["BlockIp"] = boost::any(*blockIp);
    }
    if (bound) {
      res["Bound"] = boost::any(*bound);
    }
    if (enableCount) {
      res["EnableCount"] = boost::any(*enableCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (serverCount) {
      res["ServerCount"] = boost::any(*serverCount);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetList) {
      vector<boost::any> temp1;
      for(auto item1:*targetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockExpireDate") != m.end() && !m["BlockExpireDate"].empty()) {
      blockExpireDate = make_shared<long>(boost::any_cast<long>(m["BlockExpireDate"]));
    }
    if (m.find("BlockIp") != m.end() && !m["BlockIp"].empty()) {
      blockIp = make_shared<string>(boost::any_cast<string>(m["BlockIp"]));
    }
    if (m.find("Bound") != m.end() && !m["Bound"].empty()) {
      bound = make_shared<string>(boost::any_cast<string>(m["Bound"]));
    }
    if (m.find("EnableCount") != m.end() && !m["EnableCount"].empty()) {
      enableCount = make_shared<long>(boost::any_cast<long>(m["EnableCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ServerCount") != m.end() && !m["ServerCount"].empty()) {
      serverCount = make_shared<long>(boost::any_cast<long>(m["ServerCount"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TargetList") != m.end() && !m["TargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetList"].type()) {
        vector<DescribeCustomBlockRecordsResponseBodyRecordListTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomBlockRecordsResponseBodyRecordListTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetList = make_shared<vector<DescribeCustomBlockRecordsResponseBodyRecordListTargetList>>(expect1);
      }
    }
  }


  virtual ~DescribeCustomBlockRecordsResponseBodyRecordList() = default;
};
class DescribeCustomBlockRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCustomBlockRecordsResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribeCustomBlockRecordsResponseBodyRecordList>> recordList{};
  shared_ptr<string> requestId{};

  DescribeCustomBlockRecordsResponseBody() {}

  explicit DescribeCustomBlockRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recordList) {
      vector<boost::any> temp1;
      for(auto item1:*recordList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeCustomBlockRecordsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeCustomBlockRecordsResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RecordList") != m.end() && !m["RecordList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordList"].type()) {
        vector<DescribeCustomBlockRecordsResponseBodyRecordList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomBlockRecordsResponseBodyRecordList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordList = make_shared<vector<DescribeCustomBlockRecordsResponseBodyRecordList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCustomBlockRecordsResponseBody() = default;
};
class DescribeCustomBlockRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomBlockRecordsResponseBody> body{};

  DescribeCustomBlockRecordsResponse() {}

  explicit DescribeCustomBlockRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomBlockRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomBlockRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomBlockRecordsResponse() = default;
};
class DescribeCycleTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};

  DescribeCycleTaskListRequest() {}

  explicit DescribeCycleTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeCycleTaskListRequest() = default;
};
class DescribeCycleTaskListResponseBodyCycleScheduleResponseList : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<long> enable{};
  shared_ptr<long> firstDateStr{};
  shared_ptr<long> intervalPeriod{};
  shared_ptr<string> lastTaskId{};
  shared_ptr<long> nextStartTimeStr{};
  shared_ptr<string> param{};
  shared_ptr<string> periodUnit{};
  shared_ptr<long> targetEndTime{};
  shared_ptr<long> targetStartTime{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};

  DescribeCycleTaskListResponseBodyCycleScheduleResponseList() {}

  explicit DescribeCycleTaskListResponseBodyCycleScheduleResponseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (firstDateStr) {
      res["FirstDateStr"] = boost::any(*firstDateStr);
    }
    if (intervalPeriod) {
      res["IntervalPeriod"] = boost::any(*intervalPeriod);
    }
    if (lastTaskId) {
      res["LastTaskId"] = boost::any(*lastTaskId);
    }
    if (nextStartTimeStr) {
      res["NextStartTimeStr"] = boost::any(*nextStartTimeStr);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (targetEndTime) {
      res["TargetEndTime"] = boost::any(*targetEndTime);
    }
    if (targetStartTime) {
      res["TargetStartTime"] = boost::any(*targetStartTime);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<long>(boost::any_cast<long>(m["Enable"]));
    }
    if (m.find("FirstDateStr") != m.end() && !m["FirstDateStr"].empty()) {
      firstDateStr = make_shared<long>(boost::any_cast<long>(m["FirstDateStr"]));
    }
    if (m.find("IntervalPeriod") != m.end() && !m["IntervalPeriod"].empty()) {
      intervalPeriod = make_shared<long>(boost::any_cast<long>(m["IntervalPeriod"]));
    }
    if (m.find("LastTaskId") != m.end() && !m["LastTaskId"].empty()) {
      lastTaskId = make_shared<string>(boost::any_cast<string>(m["LastTaskId"]));
    }
    if (m.find("NextStartTimeStr") != m.end() && !m["NextStartTimeStr"].empty()) {
      nextStartTimeStr = make_shared<long>(boost::any_cast<long>(m["NextStartTimeStr"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("TargetEndTime") != m.end() && !m["TargetEndTime"].empty()) {
      targetEndTime = make_shared<long>(boost::any_cast<long>(m["TargetEndTime"]));
    }
    if (m.find("TargetStartTime") != m.end() && !m["TargetStartTime"].empty()) {
      targetStartTime = make_shared<long>(boost::any_cast<long>(m["TargetStartTime"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeCycleTaskListResponseBodyCycleScheduleResponseList() = default;
};
class DescribeCycleTaskListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeCycleTaskListResponseBodyPageInfo() {}

  explicit DescribeCycleTaskListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCycleTaskListResponseBodyPageInfo() = default;
};
class DescribeCycleTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCycleTaskListResponseBodyCycleScheduleResponseList>> cycleScheduleResponseList{};
  shared_ptr<DescribeCycleTaskListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeCycleTaskListResponseBody() {}

  explicit DescribeCycleTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleScheduleResponseList) {
      vector<boost::any> temp1;
      for(auto item1:*cycleScheduleResponseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CycleScheduleResponseList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleScheduleResponseList") != m.end() && !m["CycleScheduleResponseList"].empty()) {
      if (typeid(vector<boost::any>) == m["CycleScheduleResponseList"].type()) {
        vector<DescribeCycleTaskListResponseBodyCycleScheduleResponseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CycleScheduleResponseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCycleTaskListResponseBodyCycleScheduleResponseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cycleScheduleResponseList = make_shared<vector<DescribeCycleTaskListResponseBodyCycleScheduleResponseList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeCycleTaskListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeCycleTaskListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCycleTaskListResponseBody() = default;
};
class DescribeCycleTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCycleTaskListResponseBody> body{};

  DescribeCycleTaskListResponse() {}

  explicit DescribeCycleTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCycleTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCycleTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCycleTaskListResponse() = default;
};
class DescribeDingTalkRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleActionName{};

  DescribeDingTalkRequest() {}

  explicit DescribeDingTalkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleActionName) {
      res["RuleActionName"] = boost::any(*ruleActionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleActionName") != m.end() && !m["RuleActionName"].empty()) {
      ruleActionName = make_shared<string>(boost::any_cast<string>(m["RuleActionName"]));
    }
  }


  virtual ~DescribeDingTalkRequest() = default;
};
class DescribeDingTalkResponseBodyActionList : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<long> aliUid{};
  shared_ptr<string> configList{};
  shared_ptr<string> dingTalkLang{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> groupIdList{};
  shared_ptr<long> id{};
  shared_ptr<long> intervalTime{};
  shared_ptr<long> status{};
  shared_ptr<string> url{};

  DescribeDingTalkResponseBodyActionList() {}

  explicit DescribeDingTalkResponseBodyActionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (configList) {
      res["ConfigList"] = boost::any(*configList);
    }
    if (dingTalkLang) {
      res["DingTalkLang"] = boost::any(*dingTalkLang);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupIdList) {
      res["GroupIdList"] = boost::any(*groupIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (intervalTime) {
      res["IntervalTime"] = boost::any(*intervalTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      configList = make_shared<string>(boost::any_cast<string>(m["ConfigList"]));
    }
    if (m.find("DingTalkLang") != m.end() && !m["DingTalkLang"].empty()) {
      dingTalkLang = make_shared<string>(boost::any_cast<string>(m["DingTalkLang"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("GroupIdList") != m.end() && !m["GroupIdList"].empty()) {
      groupIdList = make_shared<string>(boost::any_cast<string>(m["GroupIdList"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IntervalTime") != m.end() && !m["IntervalTime"].empty()) {
      intervalTime = make_shared<long>(boost::any_cast<long>(m["IntervalTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeDingTalkResponseBodyActionList() = default;
};
class DescribeDingTalkResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeDingTalkResponseBodyPageInfo() {}

  explicit DescribeDingTalkResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDingTalkResponseBodyPageInfo() = default;
};
class DescribeDingTalkResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDingTalkResponseBodyActionList>> actionList{};
  shared_ptr<DescribeDingTalkResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeDingTalkResponseBody() {}

  explicit DescribeDingTalkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionList) {
      vector<boost::any> temp1;
      for(auto item1:*actionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActionList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionList") != m.end() && !m["ActionList"].empty()) {
      if (typeid(vector<boost::any>) == m["ActionList"].type()) {
        vector<DescribeDingTalkResponseBodyActionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDingTalkResponseBodyActionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actionList = make_shared<vector<DescribeDingTalkResponseBodyActionList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeDingTalkResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeDingTalkResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDingTalkResponseBody() = default;
};
class DescribeDingTalkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDingTalkResponseBody> body{};

  DescribeDingTalkResponse() {}

  explicit DescribeDingTalkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDingTalkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDingTalkResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDingTalkResponse() = default;
};
class DescribeDomainCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  DescribeDomainCountRequest() {}

  explicit DescribeDomainCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeDomainCountRequest() = default;
};
class DescribeDomainCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> rootDomainsCount{};
  shared_ptr<long> subDomainsCount{};
  shared_ptr<long> totalDomainsCount{};

  DescribeDomainCountResponseBody() {}

  explicit DescribeDomainCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rootDomainsCount) {
      res["RootDomainsCount"] = boost::any(*rootDomainsCount);
    }
    if (subDomainsCount) {
      res["SubDomainsCount"] = boost::any(*subDomainsCount);
    }
    if (totalDomainsCount) {
      res["TotalDomainsCount"] = boost::any(*totalDomainsCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RootDomainsCount") != m.end() && !m["RootDomainsCount"].empty()) {
      rootDomainsCount = make_shared<long>(boost::any_cast<long>(m["RootDomainsCount"]));
    }
    if (m.find("SubDomainsCount") != m.end() && !m["SubDomainsCount"].empty()) {
      subDomainsCount = make_shared<long>(boost::any_cast<long>(m["SubDomainsCount"]));
    }
    if (m.find("TotalDomainsCount") != m.end() && !m["TotalDomainsCount"].empty()) {
      totalDomainsCount = make_shared<long>(boost::any_cast<long>(m["TotalDomainsCount"]));
    }
  }


  virtual ~DescribeDomainCountResponseBody() = default;
};
class DescribeDomainCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainCountResponseBody> body{};

  DescribeDomainCountResponse() {}

  explicit DescribeDomainCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainCountResponse() = default;
};
class DescribeDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> sourceIp{};

  DescribeDomainDetailRequest() {}

  explicit DescribeDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeDomainDetailRequest() = default;
};
class DescribeDomainDetailResponseBodyDomainDetailItems : public Darabonba::Model {
public:
  shared_ptr<string> assetType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> uuid{};

  DescribeDomainDetailResponseBodyDomainDetailItems() {}

  explicit DescribeDomainDetailResponseBodyDomainDetailItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeDomainDetailResponseBodyDomainDetailItems() = default;
};
class DescribeDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> alarmCount{};
  shared_ptr<string> domain{};
  shared_ptr<vector<DescribeDomainDetailResponseBodyDomainDetailItems>> domainDetailItems{};
  shared_ptr<string> requestId{};
  shared_ptr<string> rootDomain{};
  shared_ptr<long> vulCount{};

  DescribeDomainDetailResponseBody() {}

  explicit DescribeDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmCount) {
      res["AlarmCount"] = boost::any(*alarmCount);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (domainDetailItems) {
      vector<boost::any> temp1;
      for(auto item1:*domainDetailItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainDetailItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rootDomain) {
      res["RootDomain"] = boost::any(*rootDomain);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmCount") != m.end() && !m["AlarmCount"].empty()) {
      alarmCount = make_shared<long>(boost::any_cast<long>(m["AlarmCount"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DomainDetailItems") != m.end() && !m["DomainDetailItems"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainDetailItems"].type()) {
        vector<DescribeDomainDetailResponseBodyDomainDetailItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainDetailItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainDetailResponseBodyDomainDetailItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainDetailItems = make_shared<vector<DescribeDomainDetailResponseBodyDomainDetailItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RootDomain") != m.end() && !m["RootDomain"].empty()) {
      rootDomain = make_shared<string>(boost::any_cast<string>(m["RootDomain"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
  }


  virtual ~DescribeDomainDetailResponseBody() = default;
};
class DescribeDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainDetailResponseBody> body{};

  DescribeDomainDetailResponse() {}

  explicit DescribeDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainDetailResponse() = default;
};
class DescribeDomainListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> domainType{};
  shared_ptr<string> fuzzyDomain{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sourceIp{};

  DescribeDomainListRequest() {}

  explicit DescribeDomainListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (fuzzyDomain) {
      res["FuzzyDomain"] = boost::any(*fuzzyDomain);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("FuzzyDomain") != m.end() && !m["FuzzyDomain"].empty()) {
      fuzzyDomain = make_shared<string>(boost::any_cast<string>(m["FuzzyDomain"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeDomainListRequest() = default;
};
class DescribeDomainListResponseBodyDomainListResponseList : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> ipList{};

  DescribeDomainListResponseBodyDomainListResponseList() {}

  explicit DescribeDomainListResponseBodyDomainListResponseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ipList) {
      res["IpList"] = boost::any(*ipList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      ipList = make_shared<string>(boost::any_cast<string>(m["IpList"]));
    }
  }


  virtual ~DescribeDomainListResponseBodyDomainListResponseList() = default;
};
class DescribeDomainListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeDomainListResponseBodyPageInfo() {}

  explicit DescribeDomainListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDomainListResponseBodyPageInfo() = default;
};
class DescribeDomainListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainListResponseBodyDomainListResponseList>> domainListResponseList{};
  shared_ptr<DescribeDomainListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeDomainListResponseBody() {}

  explicit DescribeDomainListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainListResponseList) {
      vector<boost::any> temp1;
      for(auto item1:*domainListResponseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainListResponseList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainListResponseList") != m.end() && !m["DomainListResponseList"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainListResponseList"].type()) {
        vector<DescribeDomainListResponseBodyDomainListResponseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainListResponseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainListResponseBodyDomainListResponseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainListResponseList = make_shared<vector<DescribeDomainListResponseBodyDomainListResponseList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeDomainListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeDomainListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainListResponseBody() = default;
};
class DescribeDomainListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainListResponseBody> body{};

  DescribeDomainListResponse() {}

  explicit DescribeDomainListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainListResponse() = default;
};
class DescribeEmgUserAgreementResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> auth{};
  shared_ptr<string> requestId{};

  DescribeEmgUserAgreementResponseBody() {}

  explicit DescribeEmgUserAgreementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auth) {
      res["Auth"] = boost::any(*auth);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Auth") != m.end() && !m["Auth"].empty()) {
      auth = make_shared<bool>(boost::any_cast<bool>(m["Auth"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEmgUserAgreementResponseBody() = default;
};
class DescribeEmgUserAgreementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEmgUserAgreementResponseBody> body{};

  DescribeEmgUserAgreementResponse() {}

  explicit DescribeEmgUserAgreementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEmgUserAgreementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEmgUserAgreementResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEmgUserAgreementResponse() = default;
};
class DescribeEmgVulItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> riskStatus{};
  shared_ptr<string> scanType{};
  shared_ptr<string> vulName{};

  DescribeEmgVulItemRequest() {}

  explicit DescribeEmgVulItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (scanType) {
      res["ScanType"] = boost::any(*scanType);
    }
    if (vulName) {
      res["VulName"] = boost::any(*vulName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<long>(boost::any_cast<long>(m["CheckType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("ScanType") != m.end() && !m["ScanType"].empty()) {
      scanType = make_shared<string>(boost::any_cast<string>(m["ScanType"]));
    }
    if (m.find("VulName") != m.end() && !m["VulName"].empty()) {
      vulName = make_shared<string>(boost::any_cast<string>(m["VulName"]));
    }
  }


  virtual ~DescribeEmgVulItemRequest() = default;
};
class DescribeEmgVulItemResponseBodyGroupedVulItems : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<long> checkType{};
  shared_ptr<long> gmtLastCheck{};
  shared_ptr<long> gmtPublish{};
  shared_ptr<string> name{};
  shared_ptr<long> pendingCount{};
  shared_ptr<long> progress{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  DescribeEmgVulItemResponseBodyGroupedVulItems() {}

  explicit DescribeEmgVulItemResponseBodyGroupedVulItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (gmtLastCheck) {
      res["GmtLastCheck"] = boost::any(*gmtLastCheck);
    }
    if (gmtPublish) {
      res["GmtPublish"] = boost::any(*gmtPublish);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pendingCount) {
      res["PendingCount"] = boost::any(*pendingCount);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<long>(boost::any_cast<long>(m["CheckType"]));
    }
    if (m.find("GmtLastCheck") != m.end() && !m["GmtLastCheck"].empty()) {
      gmtLastCheck = make_shared<long>(boost::any_cast<long>(m["GmtLastCheck"]));
    }
    if (m.find("GmtPublish") != m.end() && !m["GmtPublish"].empty()) {
      gmtPublish = make_shared<long>(boost::any_cast<long>(m["GmtPublish"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PendingCount") != m.end() && !m["PendingCount"].empty()) {
      pendingCount = make_shared<long>(boost::any_cast<long>(m["PendingCount"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeEmgVulItemResponseBodyGroupedVulItems() = default;
};
class DescribeEmgVulItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeEmgVulItemResponseBodyGroupedVulItems>> groupedVulItems{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeEmgVulItemResponseBody() {}

  explicit DescribeEmgVulItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupedVulItems) {
      vector<boost::any> temp1;
      for(auto item1:*groupedVulItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedVulItems"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupedVulItems") != m.end() && !m["GroupedVulItems"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedVulItems"].type()) {
        vector<DescribeEmgVulItemResponseBodyGroupedVulItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedVulItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEmgVulItemResponseBodyGroupedVulItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedVulItems = make_shared<vector<DescribeEmgVulItemResponseBodyGroupedVulItems>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeEmgVulItemResponseBody() = default;
};
class DescribeEmgVulItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEmgVulItemResponseBody> body{};

  DescribeEmgVulItemResponse() {}

  explicit DescribeEmgVulItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEmgVulItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEmgVulItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEmgVulItemResponse() = default;
};
class DescribeEventLevelCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<string> containerIds{};
  shared_ptr<string> from{};
  shared_ptr<string> targetType{};

  DescribeEventLevelCountRequest() {}

  explicit DescribeEventLevelCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (containerIds) {
      res["ContainerIds"] = boost::any(*containerIds);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("ContainerIds") != m.end() && !m["ContainerIds"].empty()) {
      containerIds = make_shared<string>(boost::any_cast<string>(m["ContainerIds"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeEventLevelCountRequest() = default;
};
class DescribeEventLevelCountResponseBodyEventLevels : public Darabonba::Model {
public:
  shared_ptr<long> remind{};
  shared_ptr<long> serious{};
  shared_ptr<long> suspicious{};

  DescribeEventLevelCountResponseBodyEventLevels() {}

  explicit DescribeEventLevelCountResponseBodyEventLevels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remind) {
      res["Remind"] = boost::any(*remind);
    }
    if (serious) {
      res["Serious"] = boost::any(*serious);
    }
    if (suspicious) {
      res["Suspicious"] = boost::any(*suspicious);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Remind") != m.end() && !m["Remind"].empty()) {
      remind = make_shared<long>(boost::any_cast<long>(m["Remind"]));
    }
    if (m.find("Serious") != m.end() && !m["Serious"].empty()) {
      serious = make_shared<long>(boost::any_cast<long>(m["Serious"]));
    }
    if (m.find("Suspicious") != m.end() && !m["Suspicious"].empty()) {
      suspicious = make_shared<long>(boost::any_cast<long>(m["Suspicious"]));
    }
  }


  virtual ~DescribeEventLevelCountResponseBodyEventLevels() = default;
};
class DescribeEventLevelCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DescribeEventLevelCountResponseBodyEventLevels> eventLevels{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeEventLevelCountResponseBody() {}

  explicit DescribeEventLevelCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (eventLevels) {
      res["EventLevels"] = eventLevels ? boost::any(eventLevels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EventLevels") != m.end() && !m["EventLevels"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventLevels"].type()) {
        DescribeEventLevelCountResponseBodyEventLevels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventLevels"]));
        eventLevels = make_shared<DescribeEventLevelCountResponseBodyEventLevels>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEventLevelCountResponseBody() = default;
};
class DescribeEventLevelCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventLevelCountResponseBody> body{};

  DescribeEventLevelCountResponse() {}

  explicit DescribeEventLevelCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventLevelCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventLevelCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventLevelCountResponse() = default;
};
class DescribeEventOnStageRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeEventOnStageRequest() {}

  explicit DescribeEventOnStageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeEventOnStageRequest() = default;
};
class DescribeEventOnStageResponseBodySecurityEventStageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> securityEventOnStag{};

  DescribeEventOnStageResponseBodySecurityEventStageResponse() {}

  explicit DescribeEventOnStageResponseBodySecurityEventStageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityEventOnStag) {
      res["SecurityEventOnStag"] = boost::any(*securityEventOnStag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityEventOnStag") != m.end() && !m["SecurityEventOnStag"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SecurityEventOnStag"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      securityEventOnStag = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeEventOnStageResponseBodySecurityEventStageResponse() = default;
};
class DescribeEventOnStageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEventOnStageResponseBodySecurityEventStageResponse> securityEventStageResponse{};

  DescribeEventOnStageResponseBody() {}

  explicit DescribeEventOnStageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEventStageResponse) {
      res["SecurityEventStageResponse"] = securityEventStageResponse ? boost::any(securityEventStageResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEventStageResponse") != m.end() && !m["SecurityEventStageResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityEventStageResponse"].type()) {
        DescribeEventOnStageResponseBodySecurityEventStageResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityEventStageResponse"]));
        securityEventStageResponse = make_shared<DescribeEventOnStageResponseBodySecurityEventStageResponse>(model1);
      }
    }
  }


  virtual ~DescribeEventOnStageResponseBody() = default;
};
class DescribeEventOnStageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEventOnStageResponseBody> body{};

  DescribeEventOnStageResponse() {}

  explicit DescribeEventOnStageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEventOnStageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEventOnStageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEventOnStageResponse() = default;
};
class DescribeExcludeSystemPathRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeExcludeSystemPathRequest() {}

  explicit DescribeExcludeSystemPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeExcludeSystemPathRequest() = default;
};
class DescribeExcludeSystemPathResponseBodyExcludePaths : public Darabonba::Model {
public:
  shared_ptr<string> os{};
  shared_ptr<string> path{};

  DescribeExcludeSystemPathResponseBodyExcludePaths() {}

  explicit DescribeExcludeSystemPathResponseBodyExcludePaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DescribeExcludeSystemPathResponseBodyExcludePaths() = default;
};
class DescribeExcludeSystemPathResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeExcludeSystemPathResponseBodyPageInfo() {}

  explicit DescribeExcludeSystemPathResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeExcludeSystemPathResponseBodyPageInfo() = default;
};
class DescribeExcludeSystemPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExcludeSystemPathResponseBodyExcludePaths>> excludePaths{};
  shared_ptr<DescribeExcludeSystemPathResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeExcludeSystemPathResponseBody() {}

  explicit DescribeExcludeSystemPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludePaths) {
      vector<boost::any> temp1;
      for(auto item1:*excludePaths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExcludePaths"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludePaths") != m.end() && !m["ExcludePaths"].empty()) {
      if (typeid(vector<boost::any>) == m["ExcludePaths"].type()) {
        vector<DescribeExcludeSystemPathResponseBodyExcludePaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExcludePaths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExcludeSystemPathResponseBodyExcludePaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        excludePaths = make_shared<vector<DescribeExcludeSystemPathResponseBodyExcludePaths>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeExcludeSystemPathResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeExcludeSystemPathResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeExcludeSystemPathResponseBody() = default;
};
class DescribeExcludeSystemPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExcludeSystemPathResponseBody> body{};

  DescribeExcludeSystemPathResponse() {}

  explicit DescribeExcludeSystemPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExcludeSystemPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExcludeSystemPathResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExcludeSystemPathResponse() = default;
};
class DescribeExportInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> exportId{};

  DescribeExportInfoRequest() {}

  explicit DescribeExportInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportId) {
      res["ExportId"] = boost::any(*exportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportId") != m.end() && !m["ExportId"].empty()) {
      exportId = make_shared<long>(boost::any_cast<long>(m["ExportId"]));
    }
  }


  virtual ~DescribeExportInfoRequest() = default;
};
class DescribeExportInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentCount{};
  shared_ptr<string> exportStatus{};
  shared_ptr<string> fileName{};
  shared_ptr<long> id{};
  shared_ptr<string> link{};
  shared_ptr<string> message{};
  shared_ptr<long> progress{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeExportInfoResponseBody() {}

  explicit DescribeExportInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (exportStatus) {
      res["ExportStatus"] = boost::any(*exportStatus);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("ExportStatus") != m.end() && !m["ExportStatus"].empty()) {
      exportStatus = make_shared<string>(boost::any_cast<string>(m["ExportStatus"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeExportInfoResponseBody() = default;
};
class DescribeExportInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExportInfoResponseBody> body{};

  DescribeExportInfoResponse() {}

  explicit DescribeExportInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExportInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExportInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExportInfoResponse() = default;
};
class DescribeExposedCheckWarningRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> typeName_{};
  shared_ptr<string> uuids{};

  DescribeExposedCheckWarningRequest() {}

  explicit DescribeExposedCheckWarningRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeExposedCheckWarningRequest() = default;
};
class DescribeExposedCheckWarningResponseBodyWarningList : public Darabonba::Model {
public:
  shared_ptr<long> riskId{};
  shared_ptr<string> riskName{};
  shared_ptr<string> subTypeAlias{};
  shared_ptr<string> typeAlias{};
  shared_ptr<string> uuid{};

  DescribeExposedCheckWarningResponseBodyWarningList() {}

  explicit DescribeExposedCheckWarningResponseBodyWarningList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    if (subTypeAlias) {
      res["SubTypeAlias"] = boost::any(*subTypeAlias);
    }
    if (typeAlias) {
      res["TypeAlias"] = boost::any(*typeAlias);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
    if (m.find("SubTypeAlias") != m.end() && !m["SubTypeAlias"].empty()) {
      subTypeAlias = make_shared<string>(boost::any_cast<string>(m["SubTypeAlias"]));
    }
    if (m.find("TypeAlias") != m.end() && !m["TypeAlias"].empty()) {
      typeAlias = make_shared<string>(boost::any_cast<string>(m["TypeAlias"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeExposedCheckWarningResponseBodyWarningList() = default;
};
class DescribeExposedCheckWarningResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeExposedCheckWarningResponseBodyWarningList>> warningList{};

  DescribeExposedCheckWarningResponseBody() {}

  explicit DescribeExposedCheckWarningResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (warningList) {
      vector<boost::any> temp1;
      for(auto item1:*warningList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WarningList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WarningList") != m.end() && !m["WarningList"].empty()) {
      if (typeid(vector<boost::any>) == m["WarningList"].type()) {
        vector<DescribeExposedCheckWarningResponseBodyWarningList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WarningList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedCheckWarningResponseBodyWarningList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        warningList = make_shared<vector<DescribeExposedCheckWarningResponseBodyWarningList>>(expect1);
      }
    }
  }


  virtual ~DescribeExposedCheckWarningResponseBody() = default;
};
class DescribeExposedCheckWarningResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExposedCheckWarningResponseBody> body{};

  DescribeExposedCheckWarningResponse() {}

  explicit DescribeExposedCheckWarningResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedCheckWarningResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedCheckWarningResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedCheckWarningResponse() = default;
};
class DescribeExposedInstanceCriteriaRequest : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  DescribeExposedInstanceCriteriaRequest() {}

  explicit DescribeExposedInstanceCriteriaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeExposedInstanceCriteriaRequest() = default;
};
class DescribeExposedInstanceCriteriaResponseBodyCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> values{};

  DescribeExposedInstanceCriteriaResponseBodyCriteriaList() {}

  explicit DescribeExposedInstanceCriteriaResponseBodyCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DescribeExposedInstanceCriteriaResponseBodyCriteriaList() = default;
};
class DescribeExposedInstanceCriteriaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExposedInstanceCriteriaResponseBodyCriteriaList>> criteriaList{};
  shared_ptr<string> requestId{};

  DescribeExposedInstanceCriteriaResponseBody() {}

  explicit DescribeExposedInstanceCriteriaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*criteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CriteriaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CriteriaList") != m.end() && !m["CriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["CriteriaList"].type()) {
        vector<DescribeExposedInstanceCriteriaResponseBodyCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedInstanceCriteriaResponseBodyCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteriaList = make_shared<vector<DescribeExposedInstanceCriteriaResponseBodyCriteriaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeExposedInstanceCriteriaResponseBody() = default;
};
class DescribeExposedInstanceCriteriaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExposedInstanceCriteriaResponseBody> body{};

  DescribeExposedInstanceCriteriaResponse() {}

  explicit DescribeExposedInstanceCriteriaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedInstanceCriteriaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedInstanceCriteriaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedInstanceCriteriaResponse() = default;
};
class DescribeExposedInstanceDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};

  DescribeExposedInstanceDetailRequest() {}

  explicit DescribeExposedInstanceDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeExposedInstanceDetailRequest() = default;
};
class DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};
  shared_ptr<string> necessity{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList() {}

  explicit DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList() = default;
};
class DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};
  shared_ptr<string> necessity{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList() {}

  explicit DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList() = default;
};
class DescribeExposedInstanceDetailResponseBodyExposedChains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList>> allVulList{};
  shared_ptr<string> exposureComponent{};
  shared_ptr<string> exposureIp{};
  shared_ptr<string> exposurePort{};
  shared_ptr<string> exposureType{};
  shared_ptr<string> exposureTypeId{};
  shared_ptr<string> groupNo{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<vector<DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList>> realVulList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uuid{};

  DescribeExposedInstanceDetailResponseBodyExposedChains() {}

  explicit DescribeExposedInstanceDetailResponseBodyExposedChains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allVulList) {
      vector<boost::any> temp1;
      for(auto item1:*allVulList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AllVulList"] = boost::any(temp1);
    }
    if (exposureComponent) {
      res["ExposureComponent"] = boost::any(*exposureComponent);
    }
    if (exposureIp) {
      res["ExposureIp"] = boost::any(*exposureIp);
    }
    if (exposurePort) {
      res["ExposurePort"] = boost::any(*exposurePort);
    }
    if (exposureType) {
      res["ExposureType"] = boost::any(*exposureType);
    }
    if (exposureTypeId) {
      res["ExposureTypeId"] = boost::any(*exposureTypeId);
    }
    if (groupNo) {
      res["GroupNo"] = boost::any(*groupNo);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (realVulList) {
      vector<boost::any> temp1;
      for(auto item1:*realVulList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealVulList"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllVulList") != m.end() && !m["AllVulList"].empty()) {
      if (typeid(vector<boost::any>) == m["AllVulList"].type()) {
        vector<DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AllVulList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        allVulList = make_shared<vector<DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList>>(expect1);
      }
    }
    if (m.find("ExposureComponent") != m.end() && !m["ExposureComponent"].empty()) {
      exposureComponent = make_shared<string>(boost::any_cast<string>(m["ExposureComponent"]));
    }
    if (m.find("ExposureIp") != m.end() && !m["ExposureIp"].empty()) {
      exposureIp = make_shared<string>(boost::any_cast<string>(m["ExposureIp"]));
    }
    if (m.find("ExposurePort") != m.end() && !m["ExposurePort"].empty()) {
      exposurePort = make_shared<string>(boost::any_cast<string>(m["ExposurePort"]));
    }
    if (m.find("ExposureType") != m.end() && !m["ExposureType"].empty()) {
      exposureType = make_shared<string>(boost::any_cast<string>(m["ExposureType"]));
    }
    if (m.find("ExposureTypeId") != m.end() && !m["ExposureTypeId"].empty()) {
      exposureTypeId = make_shared<string>(boost::any_cast<string>(m["ExposureTypeId"]));
    }
    if (m.find("GroupNo") != m.end() && !m["GroupNo"].empty()) {
      groupNo = make_shared<string>(boost::any_cast<string>(m["GroupNo"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("RealVulList") != m.end() && !m["RealVulList"].empty()) {
      if (typeid(vector<boost::any>) == m["RealVulList"].type()) {
        vector<DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealVulList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realVulList = make_shared<vector<DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeExposedInstanceDetailResponseBodyExposedChains() = default;
};
class DescribeExposedInstanceDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExposedInstanceDetailResponseBodyExposedChains>> exposedChains{};
  shared_ptr<string> requestId{};

  DescribeExposedInstanceDetailResponseBody() {}

  explicit DescribeExposedInstanceDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exposedChains) {
      vector<boost::any> temp1;
      for(auto item1:*exposedChains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExposedChains"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExposedChains") != m.end() && !m["ExposedChains"].empty()) {
      if (typeid(vector<boost::any>) == m["ExposedChains"].type()) {
        vector<DescribeExposedInstanceDetailResponseBodyExposedChains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExposedChains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedInstanceDetailResponseBodyExposedChains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        exposedChains = make_shared<vector<DescribeExposedInstanceDetailResponseBodyExposedChains>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeExposedInstanceDetailResponseBody() = default;
};
class DescribeExposedInstanceDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExposedInstanceDetailResponseBody> body{};

  DescribeExposedInstanceDetailResponse() {}

  explicit DescribeExposedInstanceDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedInstanceDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedInstanceDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedInstanceDetailResponse() = default;
};
class DescribeExposedInstanceListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> exposureComponent{};
  shared_ptr<string> exposureIp{};
  shared_ptr<string> exposurePort{};
  shared_ptr<long> groupId{};
  shared_ptr<bool> healthStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> vulStatus{};

  DescribeExposedInstanceListRequest() {}

  explicit DescribeExposedInstanceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (exposureComponent) {
      res["ExposureComponent"] = boost::any(*exposureComponent);
    }
    if (exposureIp) {
      res["ExposureIp"] = boost::any(*exposureIp);
    }
    if (exposurePort) {
      res["ExposurePort"] = boost::any(*exposurePort);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (vulStatus) {
      res["VulStatus"] = boost::any(*vulStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ExposureComponent") != m.end() && !m["ExposureComponent"].empty()) {
      exposureComponent = make_shared<string>(boost::any_cast<string>(m["ExposureComponent"]));
    }
    if (m.find("ExposureIp") != m.end() && !m["ExposureIp"].empty()) {
      exposureIp = make_shared<string>(boost::any_cast<string>(m["ExposureIp"]));
    }
    if (m.find("ExposurePort") != m.end() && !m["ExposurePort"].empty()) {
      exposurePort = make_shared<string>(boost::any_cast<string>(m["ExposurePort"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<bool>(boost::any_cast<bool>(m["HealthStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VulStatus") != m.end() && !m["VulStatus"].empty()) {
      vulStatus = make_shared<bool>(boost::any_cast<bool>(m["VulStatus"]));
    }
  }


  virtual ~DescribeExposedInstanceListRequest() = default;
};
class DescribeExposedInstanceListResponseBodyExposedInstances : public Darabonba::Model {
public:
  shared_ptr<long> asapVulCount{};
  shared_ptr<long> exploitHealthCount{};
  shared_ptr<string> exposureComponent{};
  shared_ptr<string> exposureIp{};
  shared_ptr<string> exposurePort{};
  shared_ptr<string> exposureType{};
  shared_ptr<string> exposureTypeId{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> laterVulCount{};
  shared_ptr<long> nntfVulCount{};
  shared_ptr<string> regionId{};
  shared_ptr<long> totalVulCount{};
  shared_ptr<string> uuid{};

  DescribeExposedInstanceListResponseBodyExposedInstances() {}

  explicit DescribeExposedInstanceListResponseBodyExposedInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asapVulCount) {
      res["AsapVulCount"] = boost::any(*asapVulCount);
    }
    if (exploitHealthCount) {
      res["ExploitHealthCount"] = boost::any(*exploitHealthCount);
    }
    if (exposureComponent) {
      res["ExposureComponent"] = boost::any(*exposureComponent);
    }
    if (exposureIp) {
      res["ExposureIp"] = boost::any(*exposureIp);
    }
    if (exposurePort) {
      res["ExposurePort"] = boost::any(*exposurePort);
    }
    if (exposureType) {
      res["ExposureType"] = boost::any(*exposureType);
    }
    if (exposureTypeId) {
      res["ExposureTypeId"] = boost::any(*exposureTypeId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (laterVulCount) {
      res["LaterVulCount"] = boost::any(*laterVulCount);
    }
    if (nntfVulCount) {
      res["NntfVulCount"] = boost::any(*nntfVulCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (totalVulCount) {
      res["TotalVulCount"] = boost::any(*totalVulCount);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsapVulCount") != m.end() && !m["AsapVulCount"].empty()) {
      asapVulCount = make_shared<long>(boost::any_cast<long>(m["AsapVulCount"]));
    }
    if (m.find("ExploitHealthCount") != m.end() && !m["ExploitHealthCount"].empty()) {
      exploitHealthCount = make_shared<long>(boost::any_cast<long>(m["ExploitHealthCount"]));
    }
    if (m.find("ExposureComponent") != m.end() && !m["ExposureComponent"].empty()) {
      exposureComponent = make_shared<string>(boost::any_cast<string>(m["ExposureComponent"]));
    }
    if (m.find("ExposureIp") != m.end() && !m["ExposureIp"].empty()) {
      exposureIp = make_shared<string>(boost::any_cast<string>(m["ExposureIp"]));
    }
    if (m.find("ExposurePort") != m.end() && !m["ExposurePort"].empty()) {
      exposurePort = make_shared<string>(boost::any_cast<string>(m["ExposurePort"]));
    }
    if (m.find("ExposureType") != m.end() && !m["ExposureType"].empty()) {
      exposureType = make_shared<string>(boost::any_cast<string>(m["ExposureType"]));
    }
    if (m.find("ExposureTypeId") != m.end() && !m["ExposureTypeId"].empty()) {
      exposureTypeId = make_shared<string>(boost::any_cast<string>(m["ExposureTypeId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("LaterVulCount") != m.end() && !m["LaterVulCount"].empty()) {
      laterVulCount = make_shared<long>(boost::any_cast<long>(m["LaterVulCount"]));
    }
    if (m.find("NntfVulCount") != m.end() && !m["NntfVulCount"].empty()) {
      nntfVulCount = make_shared<long>(boost::any_cast<long>(m["NntfVulCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TotalVulCount") != m.end() && !m["TotalVulCount"].empty()) {
      totalVulCount = make_shared<long>(boost::any_cast<long>(m["TotalVulCount"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeExposedInstanceListResponseBodyExposedInstances() = default;
};
class DescribeExposedInstanceListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeExposedInstanceListResponseBodyPageInfo() {}

  explicit DescribeExposedInstanceListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeExposedInstanceListResponseBodyPageInfo() = default;
};
class DescribeExposedInstanceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeExposedInstanceListResponseBodyExposedInstances>> exposedInstances{};
  shared_ptr<DescribeExposedInstanceListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeExposedInstanceListResponseBody() {}

  explicit DescribeExposedInstanceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exposedInstances) {
      vector<boost::any> temp1;
      for(auto item1:*exposedInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExposedInstances"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExposedInstances") != m.end() && !m["ExposedInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["ExposedInstances"].type()) {
        vector<DescribeExposedInstanceListResponseBodyExposedInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExposedInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedInstanceListResponseBodyExposedInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        exposedInstances = make_shared<vector<DescribeExposedInstanceListResponseBodyExposedInstances>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeExposedInstanceListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeExposedInstanceListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeExposedInstanceListResponseBody() = default;
};
class DescribeExposedInstanceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExposedInstanceListResponseBody> body{};

  DescribeExposedInstanceListResponse() {}

  explicit DescribeExposedInstanceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedInstanceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedInstanceListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedInstanceListResponse() = default;
};
class DescribeExposedStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> exposedAsapVulCount{};
  shared_ptr<long> exposedComponentCount{};
  shared_ptr<long> exposedInstanceCount{};
  shared_ptr<long> exposedIpCount{};
  shared_ptr<long> exposedLaterVulCount{};
  shared_ptr<long> exposedNntfVulCount{};
  shared_ptr<long> exposedPortCount{};
  shared_ptr<long> exposedWeekPasswordMachineCount{};
  shared_ptr<long> gatewayAssetCount{};
  shared_ptr<string> requestId{};

  DescribeExposedStatisticsResponseBody() {}

  explicit DescribeExposedStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exposedAsapVulCount) {
      res["ExposedAsapVulCount"] = boost::any(*exposedAsapVulCount);
    }
    if (exposedComponentCount) {
      res["ExposedComponentCount"] = boost::any(*exposedComponentCount);
    }
    if (exposedInstanceCount) {
      res["ExposedInstanceCount"] = boost::any(*exposedInstanceCount);
    }
    if (exposedIpCount) {
      res["ExposedIpCount"] = boost::any(*exposedIpCount);
    }
    if (exposedLaterVulCount) {
      res["ExposedLaterVulCount"] = boost::any(*exposedLaterVulCount);
    }
    if (exposedNntfVulCount) {
      res["ExposedNntfVulCount"] = boost::any(*exposedNntfVulCount);
    }
    if (exposedPortCount) {
      res["ExposedPortCount"] = boost::any(*exposedPortCount);
    }
    if (exposedWeekPasswordMachineCount) {
      res["ExposedWeekPasswordMachineCount"] = boost::any(*exposedWeekPasswordMachineCount);
    }
    if (gatewayAssetCount) {
      res["GatewayAssetCount"] = boost::any(*gatewayAssetCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExposedAsapVulCount") != m.end() && !m["ExposedAsapVulCount"].empty()) {
      exposedAsapVulCount = make_shared<long>(boost::any_cast<long>(m["ExposedAsapVulCount"]));
    }
    if (m.find("ExposedComponentCount") != m.end() && !m["ExposedComponentCount"].empty()) {
      exposedComponentCount = make_shared<long>(boost::any_cast<long>(m["ExposedComponentCount"]));
    }
    if (m.find("ExposedInstanceCount") != m.end() && !m["ExposedInstanceCount"].empty()) {
      exposedInstanceCount = make_shared<long>(boost::any_cast<long>(m["ExposedInstanceCount"]));
    }
    if (m.find("ExposedIpCount") != m.end() && !m["ExposedIpCount"].empty()) {
      exposedIpCount = make_shared<long>(boost::any_cast<long>(m["ExposedIpCount"]));
    }
    if (m.find("ExposedLaterVulCount") != m.end() && !m["ExposedLaterVulCount"].empty()) {
      exposedLaterVulCount = make_shared<long>(boost::any_cast<long>(m["ExposedLaterVulCount"]));
    }
    if (m.find("ExposedNntfVulCount") != m.end() && !m["ExposedNntfVulCount"].empty()) {
      exposedNntfVulCount = make_shared<long>(boost::any_cast<long>(m["ExposedNntfVulCount"]));
    }
    if (m.find("ExposedPortCount") != m.end() && !m["ExposedPortCount"].empty()) {
      exposedPortCount = make_shared<long>(boost::any_cast<long>(m["ExposedPortCount"]));
    }
    if (m.find("ExposedWeekPasswordMachineCount") != m.end() && !m["ExposedWeekPasswordMachineCount"].empty()) {
      exposedWeekPasswordMachineCount = make_shared<long>(boost::any_cast<long>(m["ExposedWeekPasswordMachineCount"]));
    }
    if (m.find("GatewayAssetCount") != m.end() && !m["GatewayAssetCount"].empty()) {
      gatewayAssetCount = make_shared<long>(boost::any_cast<long>(m["GatewayAssetCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeExposedStatisticsResponseBody() = default;
};
class DescribeExposedStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExposedStatisticsResponseBody> body{};

  DescribeExposedStatisticsResponse() {}

  explicit DescribeExposedStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedStatisticsResponse() = default;
};
class DescribeExposedStatisticsDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> statisticsType{};
  shared_ptr<string> statisticsTypeGatewayType{};
  shared_ptr<string> statisticsTypeInstanceValue{};

  DescribeExposedStatisticsDetailRequest() {}

  explicit DescribeExposedStatisticsDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (statisticsType) {
      res["StatisticsType"] = boost::any(*statisticsType);
    }
    if (statisticsTypeGatewayType) {
      res["StatisticsTypeGatewayType"] = boost::any(*statisticsTypeGatewayType);
    }
    if (statisticsTypeInstanceValue) {
      res["StatisticsTypeInstanceValue"] = boost::any(*statisticsTypeInstanceValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StatisticsType") != m.end() && !m["StatisticsType"].empty()) {
      statisticsType = make_shared<string>(boost::any_cast<string>(m["StatisticsType"]));
    }
    if (m.find("StatisticsTypeGatewayType") != m.end() && !m["StatisticsTypeGatewayType"].empty()) {
      statisticsTypeGatewayType = make_shared<string>(boost::any_cast<string>(m["StatisticsTypeGatewayType"]));
    }
    if (m.find("StatisticsTypeInstanceValue") != m.end() && !m["StatisticsTypeInstanceValue"].empty()) {
      statisticsTypeInstanceValue = make_shared<string>(boost::any_cast<string>(m["StatisticsTypeInstanceValue"]));
    }
  }


  virtual ~DescribeExposedStatisticsDetailRequest() = default;
};
class DescribeExposedStatisticsDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeExposedStatisticsDetailResponseBodyPageInfo() {}

  explicit DescribeExposedStatisticsDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeExposedStatisticsDetailResponseBodyPageInfo() = default;
};
class DescribeExposedStatisticsDetailResponseBodyStatisticsDetails : public Darabonba::Model {
public:
  shared_ptr<long> exposedCount{};
  shared_ptr<string> exposureComponent{};
  shared_ptr<string> exposureIp{};
  shared_ptr<string> exposurePort{};
  shared_ptr<string> exposureType{};
  shared_ptr<string> exposureTypeId{};
  shared_ptr<string> exposureTypeInstanceName{};
  shared_ptr<string> regionId{};

  DescribeExposedStatisticsDetailResponseBodyStatisticsDetails() {}

  explicit DescribeExposedStatisticsDetailResponseBodyStatisticsDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exposedCount) {
      res["ExposedCount"] = boost::any(*exposedCount);
    }
    if (exposureComponent) {
      res["ExposureComponent"] = boost::any(*exposureComponent);
    }
    if (exposureIp) {
      res["ExposureIp"] = boost::any(*exposureIp);
    }
    if (exposurePort) {
      res["ExposurePort"] = boost::any(*exposurePort);
    }
    if (exposureType) {
      res["ExposureType"] = boost::any(*exposureType);
    }
    if (exposureTypeId) {
      res["ExposureTypeId"] = boost::any(*exposureTypeId);
    }
    if (exposureTypeInstanceName) {
      res["ExposureTypeInstanceName"] = boost::any(*exposureTypeInstanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExposedCount") != m.end() && !m["ExposedCount"].empty()) {
      exposedCount = make_shared<long>(boost::any_cast<long>(m["ExposedCount"]));
    }
    if (m.find("ExposureComponent") != m.end() && !m["ExposureComponent"].empty()) {
      exposureComponent = make_shared<string>(boost::any_cast<string>(m["ExposureComponent"]));
    }
    if (m.find("ExposureIp") != m.end() && !m["ExposureIp"].empty()) {
      exposureIp = make_shared<string>(boost::any_cast<string>(m["ExposureIp"]));
    }
    if (m.find("ExposurePort") != m.end() && !m["ExposurePort"].empty()) {
      exposurePort = make_shared<string>(boost::any_cast<string>(m["ExposurePort"]));
    }
    if (m.find("ExposureType") != m.end() && !m["ExposureType"].empty()) {
      exposureType = make_shared<string>(boost::any_cast<string>(m["ExposureType"]));
    }
    if (m.find("ExposureTypeId") != m.end() && !m["ExposureTypeId"].empty()) {
      exposureTypeId = make_shared<string>(boost::any_cast<string>(m["ExposureTypeId"]));
    }
    if (m.find("ExposureTypeInstanceName") != m.end() && !m["ExposureTypeInstanceName"].empty()) {
      exposureTypeInstanceName = make_shared<string>(boost::any_cast<string>(m["ExposureTypeInstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeExposedStatisticsDetailResponseBodyStatisticsDetails() = default;
};
class DescribeExposedStatisticsDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeExposedStatisticsDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeExposedStatisticsDetailResponseBodyStatisticsDetails>> statisticsDetails{};

  DescribeExposedStatisticsDetailResponseBody() {}

  explicit DescribeExposedStatisticsDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statisticsDetails) {
      vector<boost::any> temp1;
      for(auto item1:*statisticsDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatisticsDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeExposedStatisticsDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeExposedStatisticsDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatisticsDetails") != m.end() && !m["StatisticsDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["StatisticsDetails"].type()) {
        vector<DescribeExposedStatisticsDetailResponseBodyStatisticsDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatisticsDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeExposedStatisticsDetailResponseBodyStatisticsDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statisticsDetails = make_shared<vector<DescribeExposedStatisticsDetailResponseBodyStatisticsDetails>>(expect1);
      }
    }
  }


  virtual ~DescribeExposedStatisticsDetailResponseBody() = default;
};
class DescribeExposedStatisticsDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExposedStatisticsDetailResponseBody> body{};

  DescribeExposedStatisticsDetailResponse() {}

  explicit DescribeExposedStatisticsDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExposedStatisticsDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExposedStatisticsDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExposedStatisticsDetailResponse() = default;
};
class DescribeFieldStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> machineTypes{};
  shared_ptr<string> regionId{};

  DescribeFieldStatisticsRequest() {}

  explicit DescribeFieldStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeFieldStatisticsRequest() = default;
};
class DescribeFieldStatisticsResponseBodyGroupedFields : public Darabonba::Model {
public:
  shared_ptr<long> aliYunInstanceCount{};
  shared_ptr<long> awsInstanceCount{};
  shared_ptr<long> exposedInstanceCount{};
  shared_ptr<long> generalAssetCount{};
  shared_ptr<long> groupCount{};
  shared_ptr<long> huaweiInstanceCount{};
  shared_ptr<long> idcInstanceCount{};
  shared_ptr<long> importantAssetCount{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> instanceSyncTaskCount{};
  shared_ptr<long> newInstanceCount{};
  shared_ptr<long> noRiskInstanceCount{};
  shared_ptr<long> notRunningStatusCount{};
  shared_ptr<long> offlineInstanceCount{};
  shared_ptr<long> outMachineInstanceCount{};
  shared_ptr<long> pauseInstanceCount{};
  shared_ptr<long> regionCount{};
  shared_ptr<long> riskInstanceCount{};
  shared_ptr<long> tencentInstanceCount{};
  shared_ptr<long> testAssetCount{};
  shared_ptr<long> tripartiteInstanceCount{};
  shared_ptr<long> unKnowStatusInstanceCount{};
  shared_ptr<long> unprotectedInstanceCount{};
  shared_ptr<long> vpcCount{};

  DescribeFieldStatisticsResponseBodyGroupedFields() {}

  explicit DescribeFieldStatisticsResponseBodyGroupedFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliYunInstanceCount) {
      res["AliYunInstanceCount"] = boost::any(*aliYunInstanceCount);
    }
    if (awsInstanceCount) {
      res["AwsInstanceCount"] = boost::any(*awsInstanceCount);
    }
    if (exposedInstanceCount) {
      res["ExposedInstanceCount"] = boost::any(*exposedInstanceCount);
    }
    if (generalAssetCount) {
      res["GeneralAssetCount"] = boost::any(*generalAssetCount);
    }
    if (groupCount) {
      res["GroupCount"] = boost::any(*groupCount);
    }
    if (huaweiInstanceCount) {
      res["HuaweiInstanceCount"] = boost::any(*huaweiInstanceCount);
    }
    if (idcInstanceCount) {
      res["IdcInstanceCount"] = boost::any(*idcInstanceCount);
    }
    if (importantAssetCount) {
      res["ImportantAssetCount"] = boost::any(*importantAssetCount);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceSyncTaskCount) {
      res["InstanceSyncTaskCount"] = boost::any(*instanceSyncTaskCount);
    }
    if (newInstanceCount) {
      res["NewInstanceCount"] = boost::any(*newInstanceCount);
    }
    if (noRiskInstanceCount) {
      res["NoRiskInstanceCount"] = boost::any(*noRiskInstanceCount);
    }
    if (notRunningStatusCount) {
      res["NotRunningStatusCount"] = boost::any(*notRunningStatusCount);
    }
    if (offlineInstanceCount) {
      res["OfflineInstanceCount"] = boost::any(*offlineInstanceCount);
    }
    if (outMachineInstanceCount) {
      res["OutMachineInstanceCount"] = boost::any(*outMachineInstanceCount);
    }
    if (pauseInstanceCount) {
      res["PauseInstanceCount"] = boost::any(*pauseInstanceCount);
    }
    if (regionCount) {
      res["RegionCount"] = boost::any(*regionCount);
    }
    if (riskInstanceCount) {
      res["RiskInstanceCount"] = boost::any(*riskInstanceCount);
    }
    if (tencentInstanceCount) {
      res["TencentInstanceCount"] = boost::any(*tencentInstanceCount);
    }
    if (testAssetCount) {
      res["TestAssetCount"] = boost::any(*testAssetCount);
    }
    if (tripartiteInstanceCount) {
      res["TripartiteInstanceCount"] = boost::any(*tripartiteInstanceCount);
    }
    if (unKnowStatusInstanceCount) {
      res["UnKnowStatusInstanceCount"] = boost::any(*unKnowStatusInstanceCount);
    }
    if (unprotectedInstanceCount) {
      res["UnprotectedInstanceCount"] = boost::any(*unprotectedInstanceCount);
    }
    if (vpcCount) {
      res["VpcCount"] = boost::any(*vpcCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliYunInstanceCount") != m.end() && !m["AliYunInstanceCount"].empty()) {
      aliYunInstanceCount = make_shared<long>(boost::any_cast<long>(m["AliYunInstanceCount"]));
    }
    if (m.find("AwsInstanceCount") != m.end() && !m["AwsInstanceCount"].empty()) {
      awsInstanceCount = make_shared<long>(boost::any_cast<long>(m["AwsInstanceCount"]));
    }
    if (m.find("ExposedInstanceCount") != m.end() && !m["ExposedInstanceCount"].empty()) {
      exposedInstanceCount = make_shared<long>(boost::any_cast<long>(m["ExposedInstanceCount"]));
    }
    if (m.find("GeneralAssetCount") != m.end() && !m["GeneralAssetCount"].empty()) {
      generalAssetCount = make_shared<long>(boost::any_cast<long>(m["GeneralAssetCount"]));
    }
    if (m.find("GroupCount") != m.end() && !m["GroupCount"].empty()) {
      groupCount = make_shared<long>(boost::any_cast<long>(m["GroupCount"]));
    }
    if (m.find("HuaweiInstanceCount") != m.end() && !m["HuaweiInstanceCount"].empty()) {
      huaweiInstanceCount = make_shared<long>(boost::any_cast<long>(m["HuaweiInstanceCount"]));
    }
    if (m.find("IdcInstanceCount") != m.end() && !m["IdcInstanceCount"].empty()) {
      idcInstanceCount = make_shared<long>(boost::any_cast<long>(m["IdcInstanceCount"]));
    }
    if (m.find("ImportantAssetCount") != m.end() && !m["ImportantAssetCount"].empty()) {
      importantAssetCount = make_shared<long>(boost::any_cast<long>(m["ImportantAssetCount"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InstanceSyncTaskCount") != m.end() && !m["InstanceSyncTaskCount"].empty()) {
      instanceSyncTaskCount = make_shared<long>(boost::any_cast<long>(m["InstanceSyncTaskCount"]));
    }
    if (m.find("NewInstanceCount") != m.end() && !m["NewInstanceCount"].empty()) {
      newInstanceCount = make_shared<long>(boost::any_cast<long>(m["NewInstanceCount"]));
    }
    if (m.find("NoRiskInstanceCount") != m.end() && !m["NoRiskInstanceCount"].empty()) {
      noRiskInstanceCount = make_shared<long>(boost::any_cast<long>(m["NoRiskInstanceCount"]));
    }
    if (m.find("NotRunningStatusCount") != m.end() && !m["NotRunningStatusCount"].empty()) {
      notRunningStatusCount = make_shared<long>(boost::any_cast<long>(m["NotRunningStatusCount"]));
    }
    if (m.find("OfflineInstanceCount") != m.end() && !m["OfflineInstanceCount"].empty()) {
      offlineInstanceCount = make_shared<long>(boost::any_cast<long>(m["OfflineInstanceCount"]));
    }
    if (m.find("OutMachineInstanceCount") != m.end() && !m["OutMachineInstanceCount"].empty()) {
      outMachineInstanceCount = make_shared<long>(boost::any_cast<long>(m["OutMachineInstanceCount"]));
    }
    if (m.find("PauseInstanceCount") != m.end() && !m["PauseInstanceCount"].empty()) {
      pauseInstanceCount = make_shared<long>(boost::any_cast<long>(m["PauseInstanceCount"]));
    }
    if (m.find("RegionCount") != m.end() && !m["RegionCount"].empty()) {
      regionCount = make_shared<long>(boost::any_cast<long>(m["RegionCount"]));
    }
    if (m.find("RiskInstanceCount") != m.end() && !m["RiskInstanceCount"].empty()) {
      riskInstanceCount = make_shared<long>(boost::any_cast<long>(m["RiskInstanceCount"]));
    }
    if (m.find("TencentInstanceCount") != m.end() && !m["TencentInstanceCount"].empty()) {
      tencentInstanceCount = make_shared<long>(boost::any_cast<long>(m["TencentInstanceCount"]));
    }
    if (m.find("TestAssetCount") != m.end() && !m["TestAssetCount"].empty()) {
      testAssetCount = make_shared<long>(boost::any_cast<long>(m["TestAssetCount"]));
    }
    if (m.find("TripartiteInstanceCount") != m.end() && !m["TripartiteInstanceCount"].empty()) {
      tripartiteInstanceCount = make_shared<long>(boost::any_cast<long>(m["TripartiteInstanceCount"]));
    }
    if (m.find("UnKnowStatusInstanceCount") != m.end() && !m["UnKnowStatusInstanceCount"].empty()) {
      unKnowStatusInstanceCount = make_shared<long>(boost::any_cast<long>(m["UnKnowStatusInstanceCount"]));
    }
    if (m.find("UnprotectedInstanceCount") != m.end() && !m["UnprotectedInstanceCount"].empty()) {
      unprotectedInstanceCount = make_shared<long>(boost::any_cast<long>(m["UnprotectedInstanceCount"]));
    }
    if (m.find("VpcCount") != m.end() && !m["VpcCount"].empty()) {
      vpcCount = make_shared<long>(boost::any_cast<long>(m["VpcCount"]));
    }
  }


  virtual ~DescribeFieldStatisticsResponseBodyGroupedFields() = default;
};
class DescribeFieldStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeFieldStatisticsResponseBodyGroupedFields> groupedFields{};
  shared_ptr<string> requestId{};

  DescribeFieldStatisticsResponseBody() {}

  explicit DescribeFieldStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupedFields) {
      res["GroupedFields"] = groupedFields ? boost::any(groupedFields->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupedFields") != m.end() && !m["GroupedFields"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupedFields"].type()) {
        DescribeFieldStatisticsResponseBodyGroupedFields model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupedFields"]));
        groupedFields = make_shared<DescribeFieldStatisticsResponseBodyGroupedFields>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFieldStatisticsResponseBody() = default;
};
class DescribeFieldStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFieldStatisticsResponseBody> body{};

  DescribeFieldStatisticsResponse() {}

  explicit DescribeFieldStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFieldStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFieldStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFieldStatisticsResponse() = default;
};
class DescribeFrontVulPatchListRequest : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> lang{};
  shared_ptr<string> operateType{};
  shared_ptr<string> type{};

  DescribeFrontVulPatchListRequest() {}

  explicit DescribeFrontVulPatchListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeFrontVulPatchListRequest() = default;
};
class DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> name{};

  DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList() {}

  explicit DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList() = default;
};
class DescribeFrontVulPatchListResponseBodyFrontPatchList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList>> patchList{};
  shared_ptr<string> uuid{};

  DescribeFrontVulPatchListResponseBodyFrontPatchList() {}

  explicit DescribeFrontVulPatchListResponseBodyFrontPatchList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (patchList) {
      vector<boost::any> temp1;
      for(auto item1:*patchList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PatchList"] = boost::any(temp1);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PatchList") != m.end() && !m["PatchList"].empty()) {
      if (typeid(vector<boost::any>) == m["PatchList"].type()) {
        vector<DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PatchList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        patchList = make_shared<vector<DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList>>(expect1);
      }
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeFrontVulPatchListResponseBodyFrontPatchList() = default;
};
class DescribeFrontVulPatchListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFrontVulPatchListResponseBodyFrontPatchList>> frontPatchList{};
  shared_ptr<string> requestId{};

  DescribeFrontVulPatchListResponseBody() {}

  explicit DescribeFrontVulPatchListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frontPatchList) {
      vector<boost::any> temp1;
      for(auto item1:*frontPatchList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FrontPatchList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrontPatchList") != m.end() && !m["FrontPatchList"].empty()) {
      if (typeid(vector<boost::any>) == m["FrontPatchList"].type()) {
        vector<DescribeFrontVulPatchListResponseBodyFrontPatchList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FrontPatchList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFrontVulPatchListResponseBodyFrontPatchList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        frontPatchList = make_shared<vector<DescribeFrontVulPatchListResponseBodyFrontPatchList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFrontVulPatchListResponseBody() = default;
};
class DescribeFrontVulPatchListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFrontVulPatchListResponseBody> body{};

  DescribeFrontVulPatchListResponse() {}

  explicit DescribeFrontVulPatchListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFrontVulPatchListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFrontVulPatchListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFrontVulPatchListResponse() = default;
};
class DescribeGroupStructRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeGroupStructRequest() {}

  explicit DescribeGroupStructRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeGroupStructRequest() = default;
};
class DescribeGroupStructResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> groupFather{};
  shared_ptr<long> groupFlag{};
  shared_ptr<long> groupId{};
  shared_ptr<long> groupIndex{};
  shared_ptr<long> groupLevel{};
  shared_ptr<string> groupName{};
  shared_ptr<vector<string>> groups{};
  shared_ptr<long> machineNum{};
  shared_ptr<string> requestId{};

  DescribeGroupStructResponseBody() {}

  explicit DescribeGroupStructResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupFather) {
      res["GroupFather"] = boost::any(*groupFather);
    }
    if (groupFlag) {
      res["GroupFlag"] = boost::any(*groupFlag);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupIndex) {
      res["GroupIndex"] = boost::any(*groupIndex);
    }
    if (groupLevel) {
      res["GroupLevel"] = boost::any(*groupLevel);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groups) {
      res["Groups"] = boost::any(*groups);
    }
    if (machineNum) {
      res["MachineNum"] = boost::any(*machineNum);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupFather") != m.end() && !m["GroupFather"].empty()) {
      groupFather = make_shared<long>(boost::any_cast<long>(m["GroupFather"]));
    }
    if (m.find("GroupFlag") != m.end() && !m["GroupFlag"].empty()) {
      groupFlag = make_shared<long>(boost::any_cast<long>(m["GroupFlag"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupIndex") != m.end() && !m["GroupIndex"].empty()) {
      groupIndex = make_shared<long>(boost::any_cast<long>(m["GroupIndex"]));
    }
    if (m.find("GroupLevel") != m.end() && !m["GroupLevel"].empty()) {
      groupLevel = make_shared<long>(boost::any_cast<long>(m["GroupLevel"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Groups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MachineNum") != m.end() && !m["MachineNum"].empty()) {
      machineNum = make_shared<long>(boost::any_cast<long>(m["MachineNum"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeGroupStructResponseBody() = default;
};
class DescribeGroupStructResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupStructResponseBody> body{};

  DescribeGroupStructResponse() {}

  explicit DescribeGroupStructResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupStructResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupStructResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupStructResponse() = default;
};
class DescribeGroupedContainerInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> groupField{};
  shared_ptr<string> logicalExp{};
  shared_ptr<long> pageSize{};

  DescribeGroupedContainerInstancesRequest() {}

  explicit DescribeGroupedContainerInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (groupField) {
      res["GroupField"] = boost::any(*groupField);
    }
    if (logicalExp) {
      res["LogicalExp"] = boost::any(*logicalExp);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("GroupField") != m.end() && !m["GroupField"].empty()) {
      groupField = make_shared<string>(boost::any_cast<string>(m["GroupField"]));
    }
    if (m.find("LogicalExp") != m.end() && !m["LogicalExp"].empty()) {
      logicalExp = make_shared<string>(boost::any_cast<string>(m["LogicalExp"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeGroupedContainerInstancesRequest() = default;
};
class DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList : public Darabonba::Model {
public:
  shared_ptr<long> alarmCount{};
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<long> createTime{};
  shared_ptr<string> custerState{};
  shared_ptr<long> hcCount{};
  shared_ptr<string> hostIp{};
  shared_ptr<string> image{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> imageRepoName{};
  shared_ptr<string> imageRepoNamespace{};
  shared_ptr<string> imageRepoTag{};
  shared_ptr<string> imageUuid{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> pod{};
  shared_ptr<string> podIp{};
  shared_ptr<string> regionId{};
  shared_ptr<long> riskInstanceCount{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> riskStatus{};
  shared_ptr<long> vulCount{};

  DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList() {}

  explicit DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmCount) {
      res["AlarmCount"] = boost::any(*alarmCount);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (custerState) {
      res["CusterState"] = boost::any(*custerState);
    }
    if (hcCount) {
      res["HcCount"] = boost::any(*hcCount);
    }
    if (hostIp) {
      res["HostIp"] = boost::any(*hostIp);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (imageRepoName) {
      res["ImageRepoName"] = boost::any(*imageRepoName);
    }
    if (imageRepoNamespace) {
      res["ImageRepoNamespace"] = boost::any(*imageRepoNamespace);
    }
    if (imageRepoTag) {
      res["ImageRepoTag"] = boost::any(*imageRepoTag);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (podIp) {
      res["PodIp"] = boost::any(*podIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (riskInstanceCount) {
      res["RiskInstanceCount"] = boost::any(*riskInstanceCount);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmCount") != m.end() && !m["AlarmCount"].empty()) {
      alarmCount = make_shared<long>(boost::any_cast<long>(m["AlarmCount"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CusterState") != m.end() && !m["CusterState"].empty()) {
      custerState = make_shared<string>(boost::any_cast<string>(m["CusterState"]));
    }
    if (m.find("HcCount") != m.end() && !m["HcCount"].empty()) {
      hcCount = make_shared<long>(boost::any_cast<long>(m["HcCount"]));
    }
    if (m.find("HostIp") != m.end() && !m["HostIp"].empty()) {
      hostIp = make_shared<string>(boost::any_cast<string>(m["HostIp"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("ImageRepoName") != m.end() && !m["ImageRepoName"].empty()) {
      imageRepoName = make_shared<string>(boost::any_cast<string>(m["ImageRepoName"]));
    }
    if (m.find("ImageRepoNamespace") != m.end() && !m["ImageRepoNamespace"].empty()) {
      imageRepoNamespace = make_shared<string>(boost::any_cast<string>(m["ImageRepoNamespace"]));
    }
    if (m.find("ImageRepoTag") != m.end() && !m["ImageRepoTag"].empty()) {
      imageRepoTag = make_shared<string>(boost::any_cast<string>(m["ImageRepoTag"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("PodIp") != m.end() && !m["PodIp"].empty()) {
      podIp = make_shared<string>(boost::any_cast<string>(m["PodIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RiskInstanceCount") != m.end() && !m["RiskInstanceCount"].empty()) {
      riskInstanceCount = make_shared<long>(boost::any_cast<long>(m["RiskInstanceCount"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
  }


  virtual ~DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList() = default;
};
class DescribeGroupedContainerInstancesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeGroupedContainerInstancesResponseBodyPageInfo() {}

  explicit DescribeGroupedContainerInstancesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeGroupedContainerInstancesResponseBodyPageInfo() = default;
};
class DescribeGroupedContainerInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList>> groupedContainerInstanceList{};
  shared_ptr<DescribeGroupedContainerInstancesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeGroupedContainerInstancesResponseBody() {}

  explicit DescribeGroupedContainerInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupedContainerInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*groupedContainerInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedContainerInstanceList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupedContainerInstanceList") != m.end() && !m["GroupedContainerInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedContainerInstanceList"].type()) {
        vector<DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedContainerInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedContainerInstanceList = make_shared<vector<DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeGroupedContainerInstancesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeGroupedContainerInstancesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeGroupedContainerInstancesResponseBody() = default;
};
class DescribeGroupedContainerInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupedContainerInstancesResponseBody> body{};

  DescribeGroupedContainerInstancesResponse() {}

  explicit DescribeGroupedContainerInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupedContainerInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupedContainerInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupedContainerInstancesResponse() = default;
};
class DescribeGroupedInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> groupField{};
  shared_ptr<string> lang{};
  shared_ptr<string> machineTypes{};
  shared_ptr<bool> noPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> vendor{};
  shared_ptr<string> vendors{};

  DescribeGroupedInstancesRequest() {}

  explicit DescribeGroupedInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (groupField) {
      res["GroupField"] = boost::any(*groupField);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    if (noPage) {
      res["NoPage"] = boost::any(*noPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    if (vendors) {
      res["Vendors"] = boost::any(*vendors);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("GroupField") != m.end() && !m["GroupField"].empty()) {
      groupField = make_shared<string>(boost::any_cast<string>(m["GroupField"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
    if (m.find("NoPage") != m.end() && !m["NoPage"].empty()) {
      noPage = make_shared<bool>(boost::any_cast<bool>(m["NoPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<long>(boost::any_cast<long>(m["Vendor"]));
    }
    if (m.find("Vendors") != m.end() && !m["Vendors"].empty()) {
      vendors = make_shared<string>(boost::any_cast<string>(m["Vendors"]));
    }
  }


  virtual ~DescribeGroupedInstancesRequest() = default;
};
class DescribeGroupedInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<long> asapVulInstanceCount{};
  shared_ptr<string> fieldAliasName{};
  shared_ptr<long> groupFlag{};
  shared_ptr<string> instanceCount{};
  shared_ptr<string> riskInstanceCount{};
  shared_ptr<string> unProtectedInstanceCount{};

  DescribeGroupedInstancesResponseBodyInstances() {}

  explicit DescribeGroupedInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asapVulInstanceCount) {
      res["AsapVulInstanceCount"] = boost::any(*asapVulInstanceCount);
    }
    if (fieldAliasName) {
      res["FieldAliasName"] = boost::any(*fieldAliasName);
    }
    if (groupFlag) {
      res["GroupFlag"] = boost::any(*groupFlag);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (riskInstanceCount) {
      res["RiskInstanceCount"] = boost::any(*riskInstanceCount);
    }
    if (unProtectedInstanceCount) {
      res["UnProtectedInstanceCount"] = boost::any(*unProtectedInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsapVulInstanceCount") != m.end() && !m["AsapVulInstanceCount"].empty()) {
      asapVulInstanceCount = make_shared<long>(boost::any_cast<long>(m["AsapVulInstanceCount"]));
    }
    if (m.find("FieldAliasName") != m.end() && !m["FieldAliasName"].empty()) {
      fieldAliasName = make_shared<string>(boost::any_cast<string>(m["FieldAliasName"]));
    }
    if (m.find("GroupFlag") != m.end() && !m["GroupFlag"].empty()) {
      groupFlag = make_shared<long>(boost::any_cast<long>(m["GroupFlag"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<string>(boost::any_cast<string>(m["InstanceCount"]));
    }
    if (m.find("RiskInstanceCount") != m.end() && !m["RiskInstanceCount"].empty()) {
      riskInstanceCount = make_shared<string>(boost::any_cast<string>(m["RiskInstanceCount"]));
    }
    if (m.find("UnProtectedInstanceCount") != m.end() && !m["UnProtectedInstanceCount"].empty()) {
      unProtectedInstanceCount = make_shared<string>(boost::any_cast<string>(m["UnProtectedInstanceCount"]));
    }
  }


  virtual ~DescribeGroupedInstancesResponseBodyInstances() = default;
};
class DescribeGroupedInstancesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeGroupedInstancesResponseBodyPageInfo() {}

  explicit DescribeGroupedInstancesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeGroupedInstancesResponseBodyPageInfo() = default;
};
class DescribeGroupedInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupedInstancesResponseBodyInstances>> instances{};
  shared_ptr<DescribeGroupedInstancesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeGroupedInstancesResponseBody() {}

  explicit DescribeGroupedInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeGroupedInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupedInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeGroupedInstancesResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeGroupedInstancesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeGroupedInstancesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeGroupedInstancesResponseBody() = default;
};
class DescribeGroupedInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupedInstancesResponseBody> body{};

  DescribeGroupedInstancesResponse() {}

  explicit DescribeGroupedInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupedInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupedInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupedInstancesResponse() = default;
};
class DescribeGroupedMaliciousFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> fuzzyMaliciousName{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> imageLayer{};
  shared_ptr<string> imageTag{};
  shared_ptr<string> lang{};
  shared_ptr<string> levels{};
  shared_ptr<string> maliciousMd5{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<vector<string>> scanRange{};

  DescribeGroupedMaliciousFilesRequest() {}

  explicit DescribeGroupedMaliciousFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (fuzzyMaliciousName) {
      res["FuzzyMaliciousName"] = boost::any(*fuzzyMaliciousName);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (imageLayer) {
      res["ImageLayer"] = boost::any(*imageLayer);
    }
    if (imageTag) {
      res["ImageTag"] = boost::any(*imageTag);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (levels) {
      res["Levels"] = boost::any(*levels);
    }
    if (maliciousMd5) {
      res["MaliciousMd5"] = boost::any(*maliciousMd5);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("FuzzyMaliciousName") != m.end() && !m["FuzzyMaliciousName"].empty()) {
      fuzzyMaliciousName = make_shared<string>(boost::any_cast<string>(m["FuzzyMaliciousName"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("ImageLayer") != m.end() && !m["ImageLayer"].empty()) {
      imageLayer = make_shared<string>(boost::any_cast<string>(m["ImageLayer"]));
    }
    if (m.find("ImageTag") != m.end() && !m["ImageTag"].empty()) {
      imageTag = make_shared<string>(boost::any_cast<string>(m["ImageTag"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Levels") != m.end() && !m["Levels"].empty()) {
      levels = make_shared<string>(boost::any_cast<string>(m["Levels"]));
    }
    if (m.find("MaliciousMd5") != m.end() && !m["MaliciousMd5"].empty()) {
      maliciousMd5 = make_shared<string>(boost::any_cast<string>(m["MaliciousMd5"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeGroupedMaliciousFilesRequest() = default;
};
class DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse : public Darabonba::Model {
public:
  shared_ptr<long> firstScanTimestamp{};
  shared_ptr<long> imageCount{};
  shared_ptr<long> latestScanTimestamp{};
  shared_ptr<string> level{};
  shared_ptr<string> maliciousMd5{};
  shared_ptr<string> maliciousName{};
  shared_ptr<long> status{};

  DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse() {}

  explicit DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstScanTimestamp) {
      res["FirstScanTimestamp"] = boost::any(*firstScanTimestamp);
    }
    if (imageCount) {
      res["ImageCount"] = boost::any(*imageCount);
    }
    if (latestScanTimestamp) {
      res["LatestScanTimestamp"] = boost::any(*latestScanTimestamp);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (maliciousMd5) {
      res["MaliciousMd5"] = boost::any(*maliciousMd5);
    }
    if (maliciousName) {
      res["MaliciousName"] = boost::any(*maliciousName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstScanTimestamp") != m.end() && !m["FirstScanTimestamp"].empty()) {
      firstScanTimestamp = make_shared<long>(boost::any_cast<long>(m["FirstScanTimestamp"]));
    }
    if (m.find("ImageCount") != m.end() && !m["ImageCount"].empty()) {
      imageCount = make_shared<long>(boost::any_cast<long>(m["ImageCount"]));
    }
    if (m.find("LatestScanTimestamp") != m.end() && !m["LatestScanTimestamp"].empty()) {
      latestScanTimestamp = make_shared<long>(boost::any_cast<long>(m["LatestScanTimestamp"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MaliciousMd5") != m.end() && !m["MaliciousMd5"].empty()) {
      maliciousMd5 = make_shared<string>(boost::any_cast<string>(m["MaliciousMd5"]));
    }
    if (m.find("MaliciousName") != m.end() && !m["MaliciousName"].empty()) {
      maliciousName = make_shared<string>(boost::any_cast<string>(m["MaliciousName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse() = default;
};
class DescribeGroupedMaliciousFilesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeGroupedMaliciousFilesResponseBodyPageInfo() {}

  explicit DescribeGroupedMaliciousFilesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeGroupedMaliciousFilesResponseBodyPageInfo() = default;
};
class DescribeGroupedMaliciousFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse>> groupedMaliciousFileResponse{};
  shared_ptr<DescribeGroupedMaliciousFilesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeGroupedMaliciousFilesResponseBody() {}

  explicit DescribeGroupedMaliciousFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupedMaliciousFileResponse) {
      vector<boost::any> temp1;
      for(auto item1:*groupedMaliciousFileResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedMaliciousFileResponse"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupedMaliciousFileResponse") != m.end() && !m["GroupedMaliciousFileResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedMaliciousFileResponse"].type()) {
        vector<DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedMaliciousFileResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedMaliciousFileResponse = make_shared<vector<DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeGroupedMaliciousFilesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeGroupedMaliciousFilesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeGroupedMaliciousFilesResponseBody() = default;
};
class DescribeGroupedMaliciousFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupedMaliciousFilesResponseBody> body{};

  DescribeGroupedMaliciousFilesResponse() {}

  explicit DescribeGroupedMaliciousFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupedMaliciousFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupedMaliciousFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupedMaliciousFilesResponse() = default;
};
class DescribeGroupedTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> machineTypes{};

  DescribeGroupedTagsRequest() {}

  explicit DescribeGroupedTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
  }


  virtual ~DescribeGroupedTagsRequest() = default;
};
class DescribeGroupedTagsResponseBodyGroupedFileds : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<string> name{};
  shared_ptr<long> tagId{};

  DescribeGroupedTagsResponseBodyGroupedFileds() {}

  explicit DescribeGroupedTagsResponseBodyGroupedFileds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tagId) {
      res["TagId"] = boost::any(*tagId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TagId") != m.end() && !m["TagId"].empty()) {
      tagId = make_shared<long>(boost::any_cast<long>(m["TagId"]));
    }
  }


  virtual ~DescribeGroupedTagsResponseBodyGroupedFileds() = default;
};
class DescribeGroupedTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeGroupedTagsResponseBodyGroupedFileds>> groupedFileds{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeGroupedTagsResponseBody() {}

  explicit DescribeGroupedTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (groupedFileds) {
      vector<boost::any> temp1;
      for(auto item1:*groupedFileds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedFileds"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("GroupedFileds") != m.end() && !m["GroupedFileds"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedFileds"].type()) {
        vector<DescribeGroupedTagsResponseBodyGroupedFileds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedFileds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupedTagsResponseBodyGroupedFileds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedFileds = make_shared<vector<DescribeGroupedTagsResponseBodyGroupedFileds>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeGroupedTagsResponseBody() = default;
};
class DescribeGroupedTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupedTagsResponseBody> body{};

  DescribeGroupedTagsResponse() {}

  explicit DescribeGroupedTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupedTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupedTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupedTagsResponse() = default;
};
class DescribeGroupedVulRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> assetType{};
  shared_ptr<string> attachTypes{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> dealed{};
  shared_ptr<string> groupId{};
  shared_ptr<string> lang{};
  shared_ptr<string> necessity{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchTags{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};
  shared_ptr<string> uuids{};

  DescribeGroupedVulRequest() {}

  explicit DescribeGroupedVulRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (attachTypes) {
      res["AttachTypes"] = boost::any(*attachTypes);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchTags) {
      res["SearchTags"] = boost::any(*searchTags);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("AttachTypes") != m.end() && !m["AttachTypes"].empty()) {
      attachTypes = make_shared<string>(boost::any_cast<string>(m["AttachTypes"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchTags") != m.end() && !m["SearchTags"].empty()) {
      searchTags = make_shared<string>(boost::any_cast<string>(m["SearchTags"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeGroupedVulRequest() = default;
};
class DescribeGroupedVulResponseBodyGroupedVulItems : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<long> asapCount{};
  shared_ptr<long> gmtLast{};
  shared_ptr<long> handledCount{};
  shared_ptr<long> laterCount{};
  shared_ptr<string> name{};
  shared_ptr<long> nntfCount{};
  shared_ptr<long> raspDefend{};
  shared_ptr<string> tags{};
  shared_ptr<long> totalFixCount{};
  shared_ptr<string> type{};

  DescribeGroupedVulResponseBodyGroupedVulItems() {}

  explicit DescribeGroupedVulResponseBodyGroupedVulItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (asapCount) {
      res["AsapCount"] = boost::any(*asapCount);
    }
    if (gmtLast) {
      res["GmtLast"] = boost::any(*gmtLast);
    }
    if (handledCount) {
      res["HandledCount"] = boost::any(*handledCount);
    }
    if (laterCount) {
      res["LaterCount"] = boost::any(*laterCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nntfCount) {
      res["NntfCount"] = boost::any(*nntfCount);
    }
    if (raspDefend) {
      res["RaspDefend"] = boost::any(*raspDefend);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (totalFixCount) {
      res["TotalFixCount"] = boost::any(*totalFixCount);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("AsapCount") != m.end() && !m["AsapCount"].empty()) {
      asapCount = make_shared<long>(boost::any_cast<long>(m["AsapCount"]));
    }
    if (m.find("GmtLast") != m.end() && !m["GmtLast"].empty()) {
      gmtLast = make_shared<long>(boost::any_cast<long>(m["GmtLast"]));
    }
    if (m.find("HandledCount") != m.end() && !m["HandledCount"].empty()) {
      handledCount = make_shared<long>(boost::any_cast<long>(m["HandledCount"]));
    }
    if (m.find("LaterCount") != m.end() && !m["LaterCount"].empty()) {
      laterCount = make_shared<long>(boost::any_cast<long>(m["LaterCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NntfCount") != m.end() && !m["NntfCount"].empty()) {
      nntfCount = make_shared<long>(boost::any_cast<long>(m["NntfCount"]));
    }
    if (m.find("RaspDefend") != m.end() && !m["RaspDefend"].empty()) {
      raspDefend = make_shared<long>(boost::any_cast<long>(m["RaspDefend"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TotalFixCount") != m.end() && !m["TotalFixCount"].empty()) {
      totalFixCount = make_shared<long>(boost::any_cast<long>(m["TotalFixCount"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeGroupedVulResponseBodyGroupedVulItems() = default;
};
class DescribeGroupedVulResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeGroupedVulResponseBodyGroupedVulItems>> groupedVulItems{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeGroupedVulResponseBody() {}

  explicit DescribeGroupedVulResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupedVulItems) {
      vector<boost::any> temp1;
      for(auto item1:*groupedVulItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedVulItems"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupedVulItems") != m.end() && !m["GroupedVulItems"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedVulItems"].type()) {
        vector<DescribeGroupedVulResponseBodyGroupedVulItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedVulItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupedVulResponseBodyGroupedVulItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedVulItems = make_shared<vector<DescribeGroupedVulResponseBodyGroupedVulItems>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeGroupedVulResponseBody() = default;
};
class DescribeGroupedVulResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupedVulResponseBody> body{};

  DescribeGroupedVulResponse() {}

  explicit DescribeGroupedVulResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupedVulResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupedVulResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupedVulResponse() = default;
};
class DescribeHcExportInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> exportId{};

  DescribeHcExportInfoRequest() {}

  explicit DescribeHcExportInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportId) {
      res["ExportId"] = boost::any(*exportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportId") != m.end() && !m["ExportId"].empty()) {
      exportId = make_shared<long>(boost::any_cast<long>(m["ExportId"]));
    }
  }


  virtual ~DescribeHcExportInfoRequest() = default;
};
class DescribeHcExportInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentCount{};
  shared_ptr<string> fileName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> id{};
  shared_ptr<string> link{};
  shared_ptr<long> progress{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resultStatus{};
  shared_ptr<long> totalCount{};

  DescribeHcExportInfoResponseBody() {}

  explicit DescribeHcExportInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultStatus) {
      res["ResultStatus"] = boost::any(*resultStatus);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultStatus") != m.end() && !m["ResultStatus"].empty()) {
      resultStatus = make_shared<string>(boost::any_cast<string>(m["ResultStatus"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeHcExportInfoResponseBody() = default;
};
class DescribeHcExportInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHcExportInfoResponseBody> body{};

  DescribeHcExportInfoResponse() {}

  explicit DescribeHcExportInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHcExportInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHcExportInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHcExportInfoResponse() = default;
};
class DescribeHoneyPotAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeHoneyPotAuthRequest() {}

  explicit DescribeHoneyPotAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeHoneyPotAuthRequest() = default;
};
class DescribeHoneyPotAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> honeyPotAuthCount{};
  shared_ptr<long> honeyPotCount{};
  shared_ptr<string> requestId{};

  DescribeHoneyPotAuthResponseBody() {}

  explicit DescribeHoneyPotAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeyPotAuthCount) {
      res["HoneyPotAuthCount"] = boost::any(*honeyPotAuthCount);
    }
    if (honeyPotCount) {
      res["HoneyPotCount"] = boost::any(*honeyPotCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneyPotAuthCount") != m.end() && !m["HoneyPotAuthCount"].empty()) {
      honeyPotAuthCount = make_shared<long>(boost::any_cast<long>(m["HoneyPotAuthCount"]));
    }
    if (m.find("HoneyPotCount") != m.end() && !m["HoneyPotCount"].empty()) {
      honeyPotCount = make_shared<long>(boost::any_cast<long>(m["HoneyPotCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeHoneyPotAuthResponseBody() = default;
};
class DescribeHoneyPotAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHoneyPotAuthResponseBody> body{};

  DescribeHoneyPotAuthResponse() {}

  explicit DescribeHoneyPotAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHoneyPotAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHoneyPotAuthResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHoneyPotAuthResponse() = default;
};
class DescribeHoneyPotSuspStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> lang{};
  shared_ptr<long> statisticsDays{};
  shared_ptr<string> statisticsKeyType{};

  DescribeHoneyPotSuspStatisticsRequest() {}

  explicit DescribeHoneyPotSuspStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (statisticsDays) {
      res["StatisticsDays"] = boost::any(*statisticsDays);
    }
    if (statisticsKeyType) {
      res["StatisticsKeyType"] = boost::any(*statisticsKeyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StatisticsDays") != m.end() && !m["StatisticsDays"].empty()) {
      statisticsDays = make_shared<long>(boost::any_cast<long>(m["StatisticsDays"]));
    }
    if (m.find("StatisticsKeyType") != m.end() && !m["StatisticsKeyType"].empty()) {
      statisticsKeyType = make_shared<string>(boost::any_cast<string>(m["StatisticsKeyType"]));
    }
  }


  virtual ~DescribeHoneyPotSuspStatisticsRequest() = default;
};
class DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse() {}

  explicit DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse() = default;
};
class DescribeHoneyPotSuspStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse>> suspHoneyPotStatisticsResponse{};

  DescribeHoneyPotSuspStatisticsResponseBody() {}

  explicit DescribeHoneyPotSuspStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (suspHoneyPotStatisticsResponse) {
      vector<boost::any> temp1;
      for(auto item1:*suspHoneyPotStatisticsResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuspHoneyPotStatisticsResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuspHoneyPotStatisticsResponse") != m.end() && !m["SuspHoneyPotStatisticsResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SuspHoneyPotStatisticsResponse"].type()) {
        vector<DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuspHoneyPotStatisticsResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        suspHoneyPotStatisticsResponse = make_shared<vector<DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse>>(expect1);
      }
    }
  }


  virtual ~DescribeHoneyPotSuspStatisticsResponseBody() = default;
};
class DescribeHoneyPotSuspStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHoneyPotSuspStatisticsResponseBody> body{};

  DescribeHoneyPotSuspStatisticsResponse() {}

  explicit DescribeHoneyPotSuspStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHoneyPotSuspStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHoneyPotSuspStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHoneyPotSuspStatisticsResponse() = default;
};
class DescribeImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> imageInstanceId{};
  shared_ptr<string> imageRegionId{};
  shared_ptr<string> imageRepoId{};
  shared_ptr<string> imageTag{};

  DescribeImageRequest() {}

  explicit DescribeImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageInstanceId) {
      res["ImageInstanceId"] = boost::any(*imageInstanceId);
    }
    if (imageRegionId) {
      res["ImageRegionId"] = boost::any(*imageRegionId);
    }
    if (imageRepoId) {
      res["ImageRepoId"] = boost::any(*imageRepoId);
    }
    if (imageTag) {
      res["ImageTag"] = boost::any(*imageTag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageInstanceId") != m.end() && !m["ImageInstanceId"].empty()) {
      imageInstanceId = make_shared<string>(boost::any_cast<string>(m["ImageInstanceId"]));
    }
    if (m.find("ImageRegionId") != m.end() && !m["ImageRegionId"].empty()) {
      imageRegionId = make_shared<string>(boost::any_cast<string>(m["ImageRegionId"]));
    }
    if (m.find("ImageRepoId") != m.end() && !m["ImageRepoId"].empty()) {
      imageRepoId = make_shared<string>(boost::any_cast<string>(m["ImageRepoId"]));
    }
    if (m.find("ImageTag") != m.end() && !m["ImageTag"].empty()) {
      imageTag = make_shared<string>(boost::any_cast<string>(m["ImageTag"]));
    }
  }


  virtual ~DescribeImageRequest() = default;
};
class DescribeImageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> digest{};

  DescribeImageResponseBodyData() {}

  explicit DescribeImageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
  }


  virtual ~DescribeImageResponseBodyData() = default;
};
class DescribeImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeImageResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeImageResponseBody() {}

  explicit DescribeImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeImageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeImageResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageResponseBody() = default;
};
class DescribeImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageResponseBody> body{};

  DescribeImageResponse() {}

  explicit DescribeImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageResponse() = default;
};
class DescribeImageBaselineCheckResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<string> criteriaType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> imageUuid{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> riskLevel{};
  shared_ptr<vector<string>> scanRange{};

  DescribeImageBaselineCheckResultRequest() {}

  explicit DescribeImageBaselineCheckResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (criteriaType) {
      res["CriteriaType"] = boost::any(*criteriaType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CriteriaType") != m.end() && !m["CriteriaType"].empty()) {
      criteriaType = make_shared<string>(boost::any_cast<string>(m["CriteriaType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeImageBaselineCheckResultRequest() = default;
};
class DescribeImageBaselineCheckResultResponseBodyBaselineResult : public Darabonba::Model {
public:
  shared_ptr<string> baselineClassAlias{};
  shared_ptr<long> baselineItemCount{};
  shared_ptr<string> baselineNameAlias{};
  shared_ptr<string> baselineNameKey{};
  shared_ptr<string> baselineNameLevel{};
  shared_ptr<long> firstScanTime{};
  shared_ptr<long> highRiskItemCount{};
  shared_ptr<long> lastScanTime{};
  shared_ptr<long> lowRiskItemCount{};
  shared_ptr<long> middleRiskItemCount{};
  shared_ptr<long> status{};

  DescribeImageBaselineCheckResultResponseBodyBaselineResult() {}

  explicit DescribeImageBaselineCheckResultResponseBodyBaselineResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineClassAlias) {
      res["BaselineClassAlias"] = boost::any(*baselineClassAlias);
    }
    if (baselineItemCount) {
      res["BaselineItemCount"] = boost::any(*baselineItemCount);
    }
    if (baselineNameAlias) {
      res["BaselineNameAlias"] = boost::any(*baselineNameAlias);
    }
    if (baselineNameKey) {
      res["BaselineNameKey"] = boost::any(*baselineNameKey);
    }
    if (baselineNameLevel) {
      res["BaselineNameLevel"] = boost::any(*baselineNameLevel);
    }
    if (firstScanTime) {
      res["FirstScanTime"] = boost::any(*firstScanTime);
    }
    if (highRiskItemCount) {
      res["HighRiskItemCount"] = boost::any(*highRiskItemCount);
    }
    if (lastScanTime) {
      res["LastScanTime"] = boost::any(*lastScanTime);
    }
    if (lowRiskItemCount) {
      res["LowRiskItemCount"] = boost::any(*lowRiskItemCount);
    }
    if (middleRiskItemCount) {
      res["MiddleRiskItemCount"] = boost::any(*middleRiskItemCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineClassAlias") != m.end() && !m["BaselineClassAlias"].empty()) {
      baselineClassAlias = make_shared<string>(boost::any_cast<string>(m["BaselineClassAlias"]));
    }
    if (m.find("BaselineItemCount") != m.end() && !m["BaselineItemCount"].empty()) {
      baselineItemCount = make_shared<long>(boost::any_cast<long>(m["BaselineItemCount"]));
    }
    if (m.find("BaselineNameAlias") != m.end() && !m["BaselineNameAlias"].empty()) {
      baselineNameAlias = make_shared<string>(boost::any_cast<string>(m["BaselineNameAlias"]));
    }
    if (m.find("BaselineNameKey") != m.end() && !m["BaselineNameKey"].empty()) {
      baselineNameKey = make_shared<string>(boost::any_cast<string>(m["BaselineNameKey"]));
    }
    if (m.find("BaselineNameLevel") != m.end() && !m["BaselineNameLevel"].empty()) {
      baselineNameLevel = make_shared<string>(boost::any_cast<string>(m["BaselineNameLevel"]));
    }
    if (m.find("FirstScanTime") != m.end() && !m["FirstScanTime"].empty()) {
      firstScanTime = make_shared<long>(boost::any_cast<long>(m["FirstScanTime"]));
    }
    if (m.find("HighRiskItemCount") != m.end() && !m["HighRiskItemCount"].empty()) {
      highRiskItemCount = make_shared<long>(boost::any_cast<long>(m["HighRiskItemCount"]));
    }
    if (m.find("LastScanTime") != m.end() && !m["LastScanTime"].empty()) {
      lastScanTime = make_shared<long>(boost::any_cast<long>(m["LastScanTime"]));
    }
    if (m.find("LowRiskItemCount") != m.end() && !m["LowRiskItemCount"].empty()) {
      lowRiskItemCount = make_shared<long>(boost::any_cast<long>(m["LowRiskItemCount"]));
    }
    if (m.find("MiddleRiskItemCount") != m.end() && !m["MiddleRiskItemCount"].empty()) {
      middleRiskItemCount = make_shared<long>(boost::any_cast<long>(m["MiddleRiskItemCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeImageBaselineCheckResultResponseBodyBaselineResult() = default;
};
class DescribeImageBaselineCheckResultResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageBaselineCheckResultResponseBodyPageInfo() {}

  explicit DescribeImageBaselineCheckResultResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageBaselineCheckResultResponseBodyPageInfo() = default;
};
class DescribeImageBaselineCheckResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageBaselineCheckResultResponseBodyBaselineResult>> baselineResult{};
  shared_ptr<DescribeImageBaselineCheckResultResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeImageBaselineCheckResultResponseBody() {}

  explicit DescribeImageBaselineCheckResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineResult) {
      vector<boost::any> temp1;
      for(auto item1:*baselineResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaselineResult"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineResult") != m.end() && !m["BaselineResult"].empty()) {
      if (typeid(vector<boost::any>) == m["BaselineResult"].type()) {
        vector<DescribeImageBaselineCheckResultResponseBodyBaselineResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaselineResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageBaselineCheckResultResponseBodyBaselineResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselineResult = make_shared<vector<DescribeImageBaselineCheckResultResponseBodyBaselineResult>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageBaselineCheckResultResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageBaselineCheckResultResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageBaselineCheckResultResponseBody() = default;
};
class DescribeImageBaselineCheckResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageBaselineCheckResultResponseBody> body{};

  DescribeImageBaselineCheckResultResponse() {}

  explicit DescribeImageBaselineCheckResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageBaselineCheckResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageBaselineCheckResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageBaselineCheckResultResponse() = default;
};
class DescribeImageBaselineCheckSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> criteria{};
  shared_ptr<string> criteriaType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> riskLevel{};
  shared_ptr<vector<string>> scanRange{};

  DescribeImageBaselineCheckSummaryRequest() {}

  explicit DescribeImageBaselineCheckSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (criteriaType) {
      res["CriteriaType"] = boost::any(*criteriaType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CriteriaType") != m.end() && !m["CriteriaType"].empty()) {
      criteriaType = make_shared<string>(boost::any_cast<string>(m["CriteriaType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeImageBaselineCheckSummaryRequest() = default;
};
class DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary : public Darabonba::Model {
public:
  shared_ptr<string> baselineClassAlias{};
  shared_ptr<string> baselineClassKey{};
  shared_ptr<string> baselineNameAlias{};
  shared_ptr<string> baselineNameKey{};
  shared_ptr<string> baselineNameLevel{};
  shared_ptr<long> firstScanTime{};
  shared_ptr<long> highRiskImage{};
  shared_ptr<long> lastScanTime{};
  shared_ptr<long> lowRiskImage{};
  shared_ptr<long> middleRiskImage{};
  shared_ptr<long> status{};

  DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary() {}

  explicit DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineClassAlias) {
      res["BaselineClassAlias"] = boost::any(*baselineClassAlias);
    }
    if (baselineClassKey) {
      res["BaselineClassKey"] = boost::any(*baselineClassKey);
    }
    if (baselineNameAlias) {
      res["BaselineNameAlias"] = boost::any(*baselineNameAlias);
    }
    if (baselineNameKey) {
      res["BaselineNameKey"] = boost::any(*baselineNameKey);
    }
    if (baselineNameLevel) {
      res["BaselineNameLevel"] = boost::any(*baselineNameLevel);
    }
    if (firstScanTime) {
      res["FirstScanTime"] = boost::any(*firstScanTime);
    }
    if (highRiskImage) {
      res["HighRiskImage"] = boost::any(*highRiskImage);
    }
    if (lastScanTime) {
      res["LastScanTime"] = boost::any(*lastScanTime);
    }
    if (lowRiskImage) {
      res["LowRiskImage"] = boost::any(*lowRiskImage);
    }
    if (middleRiskImage) {
      res["MiddleRiskImage"] = boost::any(*middleRiskImage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineClassAlias") != m.end() && !m["BaselineClassAlias"].empty()) {
      baselineClassAlias = make_shared<string>(boost::any_cast<string>(m["BaselineClassAlias"]));
    }
    if (m.find("BaselineClassKey") != m.end() && !m["BaselineClassKey"].empty()) {
      baselineClassKey = make_shared<string>(boost::any_cast<string>(m["BaselineClassKey"]));
    }
    if (m.find("BaselineNameAlias") != m.end() && !m["BaselineNameAlias"].empty()) {
      baselineNameAlias = make_shared<string>(boost::any_cast<string>(m["BaselineNameAlias"]));
    }
    if (m.find("BaselineNameKey") != m.end() && !m["BaselineNameKey"].empty()) {
      baselineNameKey = make_shared<string>(boost::any_cast<string>(m["BaselineNameKey"]));
    }
    if (m.find("BaselineNameLevel") != m.end() && !m["BaselineNameLevel"].empty()) {
      baselineNameLevel = make_shared<string>(boost::any_cast<string>(m["BaselineNameLevel"]));
    }
    if (m.find("FirstScanTime") != m.end() && !m["FirstScanTime"].empty()) {
      firstScanTime = make_shared<long>(boost::any_cast<long>(m["FirstScanTime"]));
    }
    if (m.find("HighRiskImage") != m.end() && !m["HighRiskImage"].empty()) {
      highRiskImage = make_shared<long>(boost::any_cast<long>(m["HighRiskImage"]));
    }
    if (m.find("LastScanTime") != m.end() && !m["LastScanTime"].empty()) {
      lastScanTime = make_shared<long>(boost::any_cast<long>(m["LastScanTime"]));
    }
    if (m.find("LowRiskImage") != m.end() && !m["LowRiskImage"].empty()) {
      lowRiskImage = make_shared<long>(boost::any_cast<long>(m["LowRiskImage"]));
    }
    if (m.find("MiddleRiskImage") != m.end() && !m["MiddleRiskImage"].empty()) {
      middleRiskImage = make_shared<long>(boost::any_cast<long>(m["MiddleRiskImage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary() = default;
};
class DescribeImageBaselineCheckSummaryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageBaselineCheckSummaryResponseBodyPageInfo() {}

  explicit DescribeImageBaselineCheckSummaryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageBaselineCheckSummaryResponseBodyPageInfo() = default;
};
class DescribeImageBaselineCheckSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary>> baselineResultSummary{};
  shared_ptr<DescribeImageBaselineCheckSummaryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeImageBaselineCheckSummaryResponseBody() {}

  explicit DescribeImageBaselineCheckSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineResultSummary) {
      vector<boost::any> temp1;
      for(auto item1:*baselineResultSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaselineResultSummary"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineResultSummary") != m.end() && !m["BaselineResultSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["BaselineResultSummary"].type()) {
        vector<DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaselineResultSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselineResultSummary = make_shared<vector<DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageBaselineCheckSummaryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageBaselineCheckSummaryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageBaselineCheckSummaryResponseBody() = default;
};
class DescribeImageBaselineCheckSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageBaselineCheckSummaryResponseBody> body{};

  DescribeImageBaselineCheckSummaryResponse() {}

  explicit DescribeImageBaselineCheckSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageBaselineCheckSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageBaselineCheckSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageBaselineCheckSummaryResponse() = default;
};
class DescribeImageBaselineDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> baselineItemKey{};
  shared_ptr<string> imageUuid{};
  shared_ptr<string> lang{};

  DescribeImageBaselineDetailRequest() {}

  explicit DescribeImageBaselineDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineItemKey) {
      res["BaselineItemKey"] = boost::any(*baselineItemKey);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineItemKey") != m.end() && !m["BaselineItemKey"].empty()) {
      baselineItemKey = make_shared<string>(boost::any_cast<string>(m["BaselineItemKey"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeImageBaselineDetailRequest() = default;
};
class DescribeImageBaselineDetailResponseBodyBaselineDetail : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> baselineClassAlias{};
  shared_ptr<string> baselineItemAlias{};
  shared_ptr<string> baselineItemKey{};
  shared_ptr<string> baselineNameAlias{};
  shared_ptr<string> description{};
  shared_ptr<string> level{};
  shared_ptr<string> prompt{};
  shared_ptr<string> resultId{};

  DescribeImageBaselineDetailResponseBodyBaselineDetail() {}

  explicit DescribeImageBaselineDetailResponseBodyBaselineDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (baselineClassAlias) {
      res["BaselineClassAlias"] = boost::any(*baselineClassAlias);
    }
    if (baselineItemAlias) {
      res["BaselineItemAlias"] = boost::any(*baselineItemAlias);
    }
    if (baselineItemKey) {
      res["BaselineItemKey"] = boost::any(*baselineItemKey);
    }
    if (baselineNameAlias) {
      res["BaselineNameAlias"] = boost::any(*baselineNameAlias);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (resultId) {
      res["ResultId"] = boost::any(*resultId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("BaselineClassAlias") != m.end() && !m["BaselineClassAlias"].empty()) {
      baselineClassAlias = make_shared<string>(boost::any_cast<string>(m["BaselineClassAlias"]));
    }
    if (m.find("BaselineItemAlias") != m.end() && !m["BaselineItemAlias"].empty()) {
      baselineItemAlias = make_shared<string>(boost::any_cast<string>(m["BaselineItemAlias"]));
    }
    if (m.find("BaselineItemKey") != m.end() && !m["BaselineItemKey"].empty()) {
      baselineItemKey = make_shared<string>(boost::any_cast<string>(m["BaselineItemKey"]));
    }
    if (m.find("BaselineNameAlias") != m.end() && !m["BaselineNameAlias"].empty()) {
      baselineNameAlias = make_shared<string>(boost::any_cast<string>(m["BaselineNameAlias"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ResultId") != m.end() && !m["ResultId"].empty()) {
      resultId = make_shared<string>(boost::any_cast<string>(m["ResultId"]));
    }
  }


  virtual ~DescribeImageBaselineDetailResponseBodyBaselineDetail() = default;
};
class DescribeImageBaselineDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeImageBaselineDetailResponseBodyBaselineDetail> baselineDetail{};
  shared_ptr<string> requestId{};

  DescribeImageBaselineDetailResponseBody() {}

  explicit DescribeImageBaselineDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineDetail) {
      res["BaselineDetail"] = baselineDetail ? boost::any(baselineDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineDetail") != m.end() && !m["BaselineDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["BaselineDetail"].type()) {
        DescribeImageBaselineDetailResponseBodyBaselineDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BaselineDetail"]));
        baselineDetail = make_shared<DescribeImageBaselineDetailResponseBodyBaselineDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageBaselineDetailResponseBody() = default;
};
class DescribeImageBaselineDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageBaselineDetailResponseBody> body{};

  DescribeImageBaselineDetailResponse() {}

  explicit DescribeImageBaselineDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageBaselineDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageBaselineDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageBaselineDetailResponse() = default;
};
class DescribeImageBaselineItemListRequest : public Darabonba::Model {
public:
  shared_ptr<string> baselineClassKey{};
  shared_ptr<string> baselineNameKey{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> imageUuid{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> scanRange{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> uuids{};

  DescribeImageBaselineItemListRequest() {}

  explicit DescribeImageBaselineItemListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineClassKey) {
      res["BaselineClassKey"] = boost::any(*baselineClassKey);
    }
    if (baselineNameKey) {
      res["BaselineNameKey"] = boost::any(*baselineNameKey);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineClassKey") != m.end() && !m["BaselineClassKey"].empty()) {
      baselineClassKey = make_shared<string>(boost::any_cast<string>(m["BaselineClassKey"]));
    }
    if (m.find("BaselineNameKey") != m.end() && !m["BaselineNameKey"].empty()) {
      baselineNameKey = make_shared<string>(boost::any_cast<string>(m["BaselineNameKey"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Uuids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Uuids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuids = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeImageBaselineItemListRequest() = default;
};
class DescribeImageBaselineItemListResponseBodyBaselineItemInfos : public Darabonba::Model {
public:
  shared_ptr<string> baselineClassAlias{};
  shared_ptr<string> baselineClassKey{};
  shared_ptr<string> baselineItemAlias{};
  shared_ptr<string> baselineItemKey{};
  shared_ptr<string> baselineNameAlias{};
  shared_ptr<string> baselineNameKey{};
  shared_ptr<long> status{};
  shared_ptr<long> whiteList{};

  DescribeImageBaselineItemListResponseBodyBaselineItemInfos() {}

  explicit DescribeImageBaselineItemListResponseBodyBaselineItemInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineClassAlias) {
      res["BaselineClassAlias"] = boost::any(*baselineClassAlias);
    }
    if (baselineClassKey) {
      res["BaselineClassKey"] = boost::any(*baselineClassKey);
    }
    if (baselineItemAlias) {
      res["BaselineItemAlias"] = boost::any(*baselineItemAlias);
    }
    if (baselineItemKey) {
      res["BaselineItemKey"] = boost::any(*baselineItemKey);
    }
    if (baselineNameAlias) {
      res["BaselineNameAlias"] = boost::any(*baselineNameAlias);
    }
    if (baselineNameKey) {
      res["BaselineNameKey"] = boost::any(*baselineNameKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineClassAlias") != m.end() && !m["BaselineClassAlias"].empty()) {
      baselineClassAlias = make_shared<string>(boost::any_cast<string>(m["BaselineClassAlias"]));
    }
    if (m.find("BaselineClassKey") != m.end() && !m["BaselineClassKey"].empty()) {
      baselineClassKey = make_shared<string>(boost::any_cast<string>(m["BaselineClassKey"]));
    }
    if (m.find("BaselineItemAlias") != m.end() && !m["BaselineItemAlias"].empty()) {
      baselineItemAlias = make_shared<string>(boost::any_cast<string>(m["BaselineItemAlias"]));
    }
    if (m.find("BaselineItemKey") != m.end() && !m["BaselineItemKey"].empty()) {
      baselineItemKey = make_shared<string>(boost::any_cast<string>(m["BaselineItemKey"]));
    }
    if (m.find("BaselineNameAlias") != m.end() && !m["BaselineNameAlias"].empty()) {
      baselineNameAlias = make_shared<string>(boost::any_cast<string>(m["BaselineNameAlias"]));
    }
    if (m.find("BaselineNameKey") != m.end() && !m["BaselineNameKey"].empty()) {
      baselineNameKey = make_shared<string>(boost::any_cast<string>(m["BaselineNameKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<long>(boost::any_cast<long>(m["WhiteList"]));
    }
  }


  virtual ~DescribeImageBaselineItemListResponseBodyBaselineItemInfos() = default;
};
class DescribeImageBaselineItemListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageBaselineItemListResponseBodyPageInfo() {}

  explicit DescribeImageBaselineItemListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageBaselineItemListResponseBodyPageInfo() = default;
};
class DescribeImageBaselineItemListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageBaselineItemListResponseBodyBaselineItemInfos>> baselineItemInfos{};
  shared_ptr<DescribeImageBaselineItemListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeImageBaselineItemListResponseBody() {}

  explicit DescribeImageBaselineItemListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineItemInfos) {
      vector<boost::any> temp1;
      for(auto item1:*baselineItemInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaselineItemInfos"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineItemInfos") != m.end() && !m["BaselineItemInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["BaselineItemInfos"].type()) {
        vector<DescribeImageBaselineItemListResponseBodyBaselineItemInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaselineItemInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageBaselineItemListResponseBodyBaselineItemInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselineItemInfos = make_shared<vector<DescribeImageBaselineItemListResponseBodyBaselineItemInfos>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageBaselineItemListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageBaselineItemListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageBaselineItemListResponseBody() = default;
};
class DescribeImageBaselineItemListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageBaselineItemListResponseBody> body{};

  DescribeImageBaselineItemListResponse() {}

  explicit DescribeImageBaselineItemListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageBaselineItemListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageBaselineItemListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageBaselineItemListResponse() = default;
};
class DescribeImageBaselineStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> strategyId{};

  DescribeImageBaselineStrategyRequest() {}

  explicit DescribeImageBaselineStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
  }


  virtual ~DescribeImageBaselineStrategyRequest() = default;
};
class DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList : public Darabonba::Model {
public:
  shared_ptr<string> classKey{};
  shared_ptr<string> itemKey{};
  shared_ptr<string> nameKey{};

  DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList() {}

  explicit DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classKey) {
      res["ClassKey"] = boost::any(*classKey);
    }
    if (itemKey) {
      res["ItemKey"] = boost::any(*itemKey);
    }
    if (nameKey) {
      res["NameKey"] = boost::any(*nameKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClassKey") != m.end() && !m["ClassKey"].empty()) {
      classKey = make_shared<string>(boost::any_cast<string>(m["ClassKey"]));
    }
    if (m.find("ItemKey") != m.end() && !m["ItemKey"].empty()) {
      itemKey = make_shared<string>(boost::any_cast<string>(m["ItemKey"]));
    }
    if (m.find("NameKey") != m.end() && !m["NameKey"].empty()) {
      nameKey = make_shared<string>(boost::any_cast<string>(m["NameKey"]));
    }
  }


  virtual ~DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList() = default;
};
class DescribeImageBaselineStrategyResponseBodyStrategy : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList>> baselineItemList{};
  shared_ptr<long> selectedItemCount{};
  shared_ptr<long> strategyId{};
  shared_ptr<string> strategyName{};
  shared_ptr<long> totalItemCount{};
  shared_ptr<string> type{};

  DescribeImageBaselineStrategyResponseBodyStrategy() {}

  explicit DescribeImageBaselineStrategyResponseBodyStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineItemList) {
      vector<boost::any> temp1;
      for(auto item1:*baselineItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaselineItemList"] = boost::any(temp1);
    }
    if (selectedItemCount) {
      res["SelectedItemCount"] = boost::any(*selectedItemCount);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (totalItemCount) {
      res["TotalItemCount"] = boost::any(*totalItemCount);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineItemList") != m.end() && !m["BaselineItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["BaselineItemList"].type()) {
        vector<DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaselineItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselineItemList = make_shared<vector<DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList>>(expect1);
      }
    }
    if (m.find("SelectedItemCount") != m.end() && !m["SelectedItemCount"].empty()) {
      selectedItemCount = make_shared<long>(boost::any_cast<long>(m["SelectedItemCount"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("TotalItemCount") != m.end() && !m["TotalItemCount"].empty()) {
      totalItemCount = make_shared<long>(boost::any_cast<long>(m["TotalItemCount"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeImageBaselineStrategyResponseBodyStrategy() = default;
};
class DescribeImageBaselineStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeImageBaselineStrategyResponseBodyStrategy> strategy{};

  DescribeImageBaselineStrategyResponseBody() {}

  explicit DescribeImageBaselineStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        DescribeImageBaselineStrategyResponseBodyStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<DescribeImageBaselineStrategyResponseBodyStrategy>(model1);
      }
    }
  }


  virtual ~DescribeImageBaselineStrategyResponseBody() = default;
};
class DescribeImageBaselineStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageBaselineStrategyResponseBody> body{};

  DescribeImageBaselineStrategyResponse() {}

  explicit DescribeImageBaselineStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageBaselineStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageBaselineStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageBaselineStrategyResponse() = default;
};
class DescribeImageCriteriaRequest : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  DescribeImageCriteriaRequest() {}

  explicit DescribeImageCriteriaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeImageCriteriaRequest() = default;
};
class DescribeImageCriteriaResponseBodyCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> values{};

  DescribeImageCriteriaResponseBodyCriteriaList() {}

  explicit DescribeImageCriteriaResponseBodyCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DescribeImageCriteriaResponseBodyCriteriaList() = default;
};
class DescribeImageCriteriaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageCriteriaResponseBodyCriteriaList>> criteriaList{};
  shared_ptr<string> requestId{};

  DescribeImageCriteriaResponseBody() {}

  explicit DescribeImageCriteriaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*criteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CriteriaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CriteriaList") != m.end() && !m["CriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["CriteriaList"].type()) {
        vector<DescribeImageCriteriaResponseBodyCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageCriteriaResponseBodyCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteriaList = make_shared<vector<DescribeImageCriteriaResponseBodyCriteriaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageCriteriaResponseBody() = default;
};
class DescribeImageCriteriaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageCriteriaResponseBody> body{};

  DescribeImageCriteriaResponse() {}

  explicit DescribeImageCriteriaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageCriteriaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageCriteriaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageCriteriaResponse() = default;
};
class DescribeImageFixTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  DescribeImageFixTaskRequest() {}

  explicit DescribeImageFixTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeImageFixTaskRequest() = default;
};
class DescribeImageFixTaskResponseBodyBuildTasks : public Darabonba::Model {
public:
  shared_ptr<string> buildTaskId{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> fixTime{};
  shared_ptr<string> newTag{};
  shared_ptr<string> newUuid{};
  shared_ptr<string> oldTag{};
  shared_ptr<string> oldUuid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<long> status{};
  shared_ptr<string> taskType{};
  shared_ptr<string> vulAlias{};

  DescribeImageFixTaskResponseBodyBuildTasks() {}

  explicit DescribeImageFixTaskResponseBodyBuildTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildTaskId) {
      res["BuildTaskId"] = boost::any(*buildTaskId);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (fixTime) {
      res["FixTime"] = boost::any(*fixTime);
    }
    if (newTag) {
      res["NewTag"] = boost::any(*newTag);
    }
    if (newUuid) {
      res["NewUuid"] = boost::any(*newUuid);
    }
    if (oldTag) {
      res["OldTag"] = boost::any(*oldTag);
    }
    if (oldUuid) {
      res["OldUuid"] = boost::any(*oldUuid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (vulAlias) {
      res["VulAlias"] = boost::any(*vulAlias);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuildTaskId") != m.end() && !m["BuildTaskId"].empty()) {
      buildTaskId = make_shared<string>(boost::any_cast<string>(m["BuildTaskId"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("FixTime") != m.end() && !m["FixTime"].empty()) {
      fixTime = make_shared<string>(boost::any_cast<string>(m["FixTime"]));
    }
    if (m.find("NewTag") != m.end() && !m["NewTag"].empty()) {
      newTag = make_shared<string>(boost::any_cast<string>(m["NewTag"]));
    }
    if (m.find("NewUuid") != m.end() && !m["NewUuid"].empty()) {
      newUuid = make_shared<string>(boost::any_cast<string>(m["NewUuid"]));
    }
    if (m.find("OldTag") != m.end() && !m["OldTag"].empty()) {
      oldTag = make_shared<string>(boost::any_cast<string>(m["OldTag"]));
    }
    if (m.find("OldUuid") != m.end() && !m["OldUuid"].empty()) {
      oldUuid = make_shared<string>(boost::any_cast<string>(m["OldUuid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("VulAlias") != m.end() && !m["VulAlias"].empty()) {
      vulAlias = make_shared<string>(boost::any_cast<string>(m["VulAlias"]));
    }
  }


  virtual ~DescribeImageFixTaskResponseBodyBuildTasks() = default;
};
class DescribeImageFixTaskResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageFixTaskResponseBodyPageInfo() {}

  explicit DescribeImageFixTaskResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageFixTaskResponseBodyPageInfo() = default;
};
class DescribeImageFixTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageFixTaskResponseBodyBuildTasks>> buildTasks{};
  shared_ptr<DescribeImageFixTaskResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeImageFixTaskResponseBody() {}

  explicit DescribeImageFixTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildTasks) {
      vector<boost::any> temp1;
      for(auto item1:*buildTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BuildTasks"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuildTasks") != m.end() && !m["BuildTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["BuildTasks"].type()) {
        vector<DescribeImageFixTaskResponseBodyBuildTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BuildTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageFixTaskResponseBodyBuildTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        buildTasks = make_shared<vector<DescribeImageFixTaskResponseBodyBuildTasks>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageFixTaskResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageFixTaskResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageFixTaskResponseBody() = default;
};
class DescribeImageFixTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageFixTaskResponseBody> body{};

  DescribeImageFixTaskResponse() {}

  explicit DescribeImageFixTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageFixTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageFixTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageFixTaskResponse() = default;
};
class DescribeImageGroupedVulListRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> cveId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> imageLayer{};
  shared_ptr<string> imageTag{};
  shared_ptr<long> isLatest{};
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<string> necessity{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> patchId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<vector<string>> scanRange{};
  shared_ptr<string> type{};
  shared_ptr<string> uuids{};

  DescribeImageGroupedVulListRequest() {}

  explicit DescribeImageGroupedVulListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (cveId) {
      res["CveId"] = boost::any(*cveId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (imageLayer) {
      res["ImageLayer"] = boost::any(*imageLayer);
    }
    if (imageTag) {
      res["ImageTag"] = boost::any(*imageTag);
    }
    if (isLatest) {
      res["IsLatest"] = boost::any(*isLatest);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (patchId) {
      res["PatchId"] = boost::any(*patchId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("CveId") != m.end() && !m["CveId"].empty()) {
      cveId = make_shared<string>(boost::any_cast<string>(m["CveId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("ImageLayer") != m.end() && !m["ImageLayer"].empty()) {
      imageLayer = make_shared<string>(boost::any_cast<string>(m["ImageLayer"]));
    }
    if (m.find("ImageTag") != m.end() && !m["ImageTag"].empty()) {
      imageTag = make_shared<string>(boost::any_cast<string>(m["ImageTag"]));
    }
    if (m.find("IsLatest") != m.end() && !m["IsLatest"].empty()) {
      isLatest = make_shared<long>(boost::any_cast<long>(m["IsLatest"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PatchId") != m.end() && !m["PatchId"].empty()) {
      patchId = make_shared<long>(boost::any_cast<long>(m["PatchId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeImageGroupedVulListRequest() = default;
};
class DescribeImageGroupedVulListResponseBodyGroupedVulItems : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<long> asapCount{};
  shared_ptr<string> canFix{};
  shared_ptr<long> gmtLast{};
  shared_ptr<long> lastScanTime{};
  shared_ptr<long> laterCount{};
  shared_ptr<string> name{};
  shared_ptr<long> nntfCount{};
  shared_ptr<long> status{};
  shared_ptr<string> tags{};
  shared_ptr<string> type{};

  DescribeImageGroupedVulListResponseBodyGroupedVulItems() {}

  explicit DescribeImageGroupedVulListResponseBodyGroupedVulItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (asapCount) {
      res["AsapCount"] = boost::any(*asapCount);
    }
    if (canFix) {
      res["CanFix"] = boost::any(*canFix);
    }
    if (gmtLast) {
      res["GmtLast"] = boost::any(*gmtLast);
    }
    if (lastScanTime) {
      res["LastScanTime"] = boost::any(*lastScanTime);
    }
    if (laterCount) {
      res["LaterCount"] = boost::any(*laterCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nntfCount) {
      res["NntfCount"] = boost::any(*nntfCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("AsapCount") != m.end() && !m["AsapCount"].empty()) {
      asapCount = make_shared<long>(boost::any_cast<long>(m["AsapCount"]));
    }
    if (m.find("CanFix") != m.end() && !m["CanFix"].empty()) {
      canFix = make_shared<string>(boost::any_cast<string>(m["CanFix"]));
    }
    if (m.find("GmtLast") != m.end() && !m["GmtLast"].empty()) {
      gmtLast = make_shared<long>(boost::any_cast<long>(m["GmtLast"]));
    }
    if (m.find("LastScanTime") != m.end() && !m["LastScanTime"].empty()) {
      lastScanTime = make_shared<long>(boost::any_cast<long>(m["LastScanTime"]));
    }
    if (m.find("LaterCount") != m.end() && !m["LaterCount"].empty()) {
      laterCount = make_shared<long>(boost::any_cast<long>(m["LaterCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NntfCount") != m.end() && !m["NntfCount"].empty()) {
      nntfCount = make_shared<long>(boost::any_cast<long>(m["NntfCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeImageGroupedVulListResponseBodyGroupedVulItems() = default;
};
class DescribeImageGroupedVulListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeImageGroupedVulListResponseBodyGroupedVulItems>> groupedVulItems{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeImageGroupedVulListResponseBody() {}

  explicit DescribeImageGroupedVulListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupedVulItems) {
      vector<boost::any> temp1;
      for(auto item1:*groupedVulItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GroupedVulItems"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupedVulItems") != m.end() && !m["GroupedVulItems"].empty()) {
      if (typeid(vector<boost::any>) == m["GroupedVulItems"].type()) {
        vector<DescribeImageGroupedVulListResponseBodyGroupedVulItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GroupedVulItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageGroupedVulListResponseBodyGroupedVulItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groupedVulItems = make_shared<vector<DescribeImageGroupedVulListResponseBodyGroupedVulItems>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageGroupedVulListResponseBody() = default;
};
class DescribeImageGroupedVulListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageGroupedVulListResponseBody> body{};

  DescribeImageGroupedVulListResponse() {}

  explicit DescribeImageGroupedVulListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageGroupedVulListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageGroupedVulListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageGroupedVulListResponse() = default;
};
class DescribeImageInfoListRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuids{};

  DescribeImageInfoListRequest() {}

  explicit DescribeImageInfoListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeImageInfoListRequest() = default;
};
class DescribeImageInfoListResponseBodyImageInfos : public Darabonba::Model {
public:
  shared_ptr<long> alarmCount{};
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> digest{};
  shared_ptr<string> endpoints{};
  shared_ptr<long> imageCreate{};
  shared_ptr<string> imageId{};
  shared_ptr<long> imageSize{};
  shared_ptr<long> imageUpdate{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> registryType{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoType{};
  shared_ptr<string> riskStatus{};
  shared_ptr<string> status{};
  shared_ptr<string> tag{};
  shared_ptr<long> tagImmutable{};
  shared_ptr<string> uuid{};
  shared_ptr<long> vulCount{};
  shared_ptr<string> vulStatus{};

  DescribeImageInfoListResponseBodyImageInfos() {}

  explicit DescribeImageInfoListResponseBodyImageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmCount) {
      res["AlarmCount"] = boost::any(*alarmCount);
    }
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (endpoints) {
      res["Endpoints"] = boost::any(*endpoints);
    }
    if (imageCreate) {
      res["ImageCreate"] = boost::any(*imageCreate);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageSize) {
      res["ImageSize"] = boost::any(*imageSize);
    }
    if (imageUpdate) {
      res["ImageUpdate"] = boost::any(*imageUpdate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoType) {
      res["RepoType"] = boost::any(*repoType);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tagImmutable) {
      res["TagImmutable"] = boost::any(*tagImmutable);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    if (vulStatus) {
      res["VulStatus"] = boost::any(*vulStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmCount") != m.end() && !m["AlarmCount"].empty()) {
      alarmCount = make_shared<long>(boost::any_cast<long>(m["AlarmCount"]));
    }
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      endpoints = make_shared<string>(boost::any_cast<string>(m["Endpoints"]));
    }
    if (m.find("ImageCreate") != m.end() && !m["ImageCreate"].empty()) {
      imageCreate = make_shared<long>(boost::any_cast<long>(m["ImageCreate"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageSize") != m.end() && !m["ImageSize"].empty()) {
      imageSize = make_shared<long>(boost::any_cast<long>(m["ImageSize"]));
    }
    if (m.find("ImageUpdate") != m.end() && !m["ImageUpdate"].empty()) {
      imageUpdate = make_shared<long>(boost::any_cast<long>(m["ImageUpdate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoType") != m.end() && !m["RepoType"].empty()) {
      repoType = make_shared<string>(boost::any_cast<string>(m["RepoType"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TagImmutable") != m.end() && !m["TagImmutable"].empty()) {
      tagImmutable = make_shared<long>(boost::any_cast<long>(m["TagImmutable"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
    if (m.find("VulStatus") != m.end() && !m["VulStatus"].empty()) {
      vulStatus = make_shared<string>(boost::any_cast<string>(m["VulStatus"]));
    }
  }


  virtual ~DescribeImageInfoListResponseBodyImageInfos() = default;
};
class DescribeImageInfoListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageInfoListResponseBodyImageInfos>> imageInfos{};
  shared_ptr<string> requestId{};

  DescribeImageInfoListResponseBody() {}

  explicit DescribeImageInfoListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageInfos) {
      vector<boost::any> temp1;
      for(auto item1:*imageInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageInfos") != m.end() && !m["ImageInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageInfos"].type()) {
        vector<DescribeImageInfoListResponseBodyImageInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageInfoListResponseBodyImageInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageInfos = make_shared<vector<DescribeImageInfoListResponseBodyImageInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageInfoListResponseBody() = default;
};
class DescribeImageInfoListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageInfoListResponseBody> body{};

  DescribeImageInfoListResponse() {}

  explicit DescribeImageInfoListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageInfoListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageInfoListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageInfoListResponse() = default;
};
class DescribeImageInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> logicalExp{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> scanned{};

  DescribeImageInstancesRequest() {}

  explicit DescribeImageInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logicalExp) {
      res["LogicalExp"] = boost::any(*logicalExp);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scanned) {
      res["Scanned"] = boost::any(*scanned);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LogicalExp") != m.end() && !m["LogicalExp"].empty()) {
      logicalExp = make_shared<string>(boost::any_cast<string>(m["LogicalExp"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Scanned") != m.end() && !m["Scanned"].empty()) {
      scanned = make_shared<bool>(boost::any_cast<bool>(m["Scanned"]));
    }
  }


  virtual ~DescribeImageInstancesRequest() = default;
};
class DescribeImageInstancesResponseBodyImageInstanceList : public Darabonba::Model {
public:
  shared_ptr<long> alarmCount{};
  shared_ptr<string> alarmStatus{};
  shared_ptr<long> deployed{};
  shared_ptr<string> digest{};
  shared_ptr<string> endpoints{};
  shared_ptr<long> hcCount{};
  shared_ptr<string> hcStatus{};
  shared_ptr<string> imageCreate{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageSize{};
  shared_ptr<string> imageUpdate{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> registryType{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoType{};
  shared_ptr<string> riskStatus{};
  shared_ptr<long> scaProgress{};
  shared_ptr<string> scaResult{};
  shared_ptr<string> scaStatus{};
  shared_ptr<string> status{};
  shared_ptr<string> tag{};
  shared_ptr<string> uuid{};
  shared_ptr<long> vulCount{};
  shared_ptr<string> vulStatus{};

  DescribeImageInstancesResponseBodyImageInstanceList() {}

  explicit DescribeImageInstancesResponseBodyImageInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmCount) {
      res["AlarmCount"] = boost::any(*alarmCount);
    }
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (deployed) {
      res["Deployed"] = boost::any(*deployed);
    }
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (endpoints) {
      res["Endpoints"] = boost::any(*endpoints);
    }
    if (hcCount) {
      res["HcCount"] = boost::any(*hcCount);
    }
    if (hcStatus) {
      res["HcStatus"] = boost::any(*hcStatus);
    }
    if (imageCreate) {
      res["ImageCreate"] = boost::any(*imageCreate);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageSize) {
      res["ImageSize"] = boost::any(*imageSize);
    }
    if (imageUpdate) {
      res["ImageUpdate"] = boost::any(*imageUpdate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoType) {
      res["RepoType"] = boost::any(*repoType);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (scaProgress) {
      res["ScaProgress"] = boost::any(*scaProgress);
    }
    if (scaResult) {
      res["ScaResult"] = boost::any(*scaResult);
    }
    if (scaStatus) {
      res["ScaStatus"] = boost::any(*scaStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    if (vulStatus) {
      res["VulStatus"] = boost::any(*vulStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmCount") != m.end() && !m["AlarmCount"].empty()) {
      alarmCount = make_shared<long>(boost::any_cast<long>(m["AlarmCount"]));
    }
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("Deployed") != m.end() && !m["Deployed"].empty()) {
      deployed = make_shared<long>(boost::any_cast<long>(m["Deployed"]));
    }
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      endpoints = make_shared<string>(boost::any_cast<string>(m["Endpoints"]));
    }
    if (m.find("HcCount") != m.end() && !m["HcCount"].empty()) {
      hcCount = make_shared<long>(boost::any_cast<long>(m["HcCount"]));
    }
    if (m.find("HcStatus") != m.end() && !m["HcStatus"].empty()) {
      hcStatus = make_shared<string>(boost::any_cast<string>(m["HcStatus"]));
    }
    if (m.find("ImageCreate") != m.end() && !m["ImageCreate"].empty()) {
      imageCreate = make_shared<string>(boost::any_cast<string>(m["ImageCreate"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageSize") != m.end() && !m["ImageSize"].empty()) {
      imageSize = make_shared<string>(boost::any_cast<string>(m["ImageSize"]));
    }
    if (m.find("ImageUpdate") != m.end() && !m["ImageUpdate"].empty()) {
      imageUpdate = make_shared<string>(boost::any_cast<string>(m["ImageUpdate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoType") != m.end() && !m["RepoType"].empty()) {
      repoType = make_shared<string>(boost::any_cast<string>(m["RepoType"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("ScaProgress") != m.end() && !m["ScaProgress"].empty()) {
      scaProgress = make_shared<long>(boost::any_cast<long>(m["ScaProgress"]));
    }
    if (m.find("ScaResult") != m.end() && !m["ScaResult"].empty()) {
      scaResult = make_shared<string>(boost::any_cast<string>(m["ScaResult"]));
    }
    if (m.find("ScaStatus") != m.end() && !m["ScaStatus"].empty()) {
      scaStatus = make_shared<string>(boost::any_cast<string>(m["ScaStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
    if (m.find("VulStatus") != m.end() && !m["VulStatus"].empty()) {
      vulStatus = make_shared<string>(boost::any_cast<string>(m["VulStatus"]));
    }
  }


  virtual ~DescribeImageInstancesResponseBodyImageInstanceList() = default;
};
class DescribeImageInstancesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageInstancesResponseBodyPageInfo() {}

  explicit DescribeImageInstancesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageInstancesResponseBodyPageInfo() = default;
};
class DescribeImageInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageInstancesResponseBodyImageInstanceList>> imageInstanceList{};
  shared_ptr<DescribeImageInstancesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeImageInstancesResponseBody() {}

  explicit DescribeImageInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*imageInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageInstanceList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageInstanceList") != m.end() && !m["ImageInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageInstanceList"].type()) {
        vector<DescribeImageInstancesResponseBodyImageInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageInstancesResponseBodyImageInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageInstanceList = make_shared<vector<DescribeImageInstancesResponseBodyImageInstanceList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageInstancesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageInstancesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageInstancesResponseBody() = default;
};
class DescribeImageInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageInstancesResponseBody> body{};

  DescribeImageInstancesResponse() {}

  explicit DescribeImageInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageInstancesResponse() = default;
};
class DescribeImageLatestScanTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> digest{};

  DescribeImageLatestScanTaskRequest() {}

  explicit DescribeImageLatestScanTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
  }


  virtual ~DescribeImageLatestScanTaskRequest() = default;
};
class DescribeImageLatestScanTaskResponseBodyTask : public Darabonba::Model {
public:
  shared_ptr<string> create{};
  shared_ptr<long> finish{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> id{};
  shared_ptr<string> modified{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};

  DescribeImageLatestScanTaskResponseBodyTask() {}

  explicit DescribeImageLatestScanTaskResponseBodyTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (finish) {
      res["Finish"] = boost::any(*finish);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modified) {
      res["Modified"] = boost::any(*modified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<string>(boost::any_cast<string>(m["Create"]));
    }
    if (m.find("Finish") != m.end() && !m["Finish"].empty()) {
      finish = make_shared<long>(boost::any_cast<long>(m["Finish"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Modified") != m.end() && !m["Modified"].empty()) {
      modified = make_shared<string>(boost::any_cast<string>(m["Modified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeImageLatestScanTaskResponseBodyTask() = default;
};
class DescribeImageLatestScanTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeImageLatestScanTaskResponseBodyTask>> task{};

  DescribeImageLatestScanTaskResponseBody() {}

  explicit DescribeImageLatestScanTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (task) {
      vector<boost::any> temp1;
      for(auto item1:*task){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Task"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(vector<boost::any>) == m["Task"].type()) {
        vector<DescribeImageLatestScanTaskResponseBodyTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Task"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageLatestScanTaskResponseBodyTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        task = make_shared<vector<DescribeImageLatestScanTaskResponseBodyTask>>(expect1);
      }
    }
  }


  virtual ~DescribeImageLatestScanTaskResponseBody() = default;
};
class DescribeImageLatestScanTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageLatestScanTaskResponseBody> body{};

  DescribeImageLatestScanTaskResponse() {}

  explicit DescribeImageLatestScanTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageLatestScanTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageLatestScanTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageLatestScanTaskResponse() = default;
};
class DescribeImageListBySensitiveFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> riskLevel{};
  shared_ptr<vector<string>> scanRange{};
  shared_ptr<string> sensitiveFileKey{};

  DescribeImageListBySensitiveFileRequest() {}

  explicit DescribeImageListBySensitiveFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    if (sensitiveFileKey) {
      res["SensitiveFileKey"] = boost::any(*sensitiveFileKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SensitiveFileKey") != m.end() && !m["SensitiveFileKey"].empty()) {
      sensitiveFileKey = make_shared<string>(boost::any_cast<string>(m["SensitiveFileKey"]));
    }
  }


  virtual ~DescribeImageListBySensitiveFileRequest() = default;
};
class DescribeImageListBySensitiveFileShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> scanRangeShrink{};
  shared_ptr<string> sensitiveFileKey{};

  DescribeImageListBySensitiveFileShrinkRequest() {}

  explicit DescribeImageListBySensitiveFileShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scanRangeShrink) {
      res["ScanRange"] = boost::any(*scanRangeShrink);
    }
    if (sensitiveFileKey) {
      res["SensitiveFileKey"] = boost::any(*sensitiveFileKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      scanRangeShrink = make_shared<string>(boost::any_cast<string>(m["ScanRange"]));
    }
    if (m.find("SensitiveFileKey") != m.end() && !m["SensitiveFileKey"].empty()) {
      sensitiveFileKey = make_shared<string>(boost::any_cast<string>(m["SensitiveFileKey"]));
    }
  }


  virtual ~DescribeImageListBySensitiveFileShrinkRequest() = default;
};
class DescribeImageListBySensitiveFileResponseBodyImageInfos : public Darabonba::Model {
public:
  shared_ptr<string> digest{};
  shared_ptr<long> firstScanTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lastScanTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> tag{};
  shared_ptr<string> uuid{};

  DescribeImageListBySensitiveFileResponseBodyImageInfos() {}

  explicit DescribeImageListBySensitiveFileResponseBodyImageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (firstScanTime) {
      res["FirstScanTime"] = boost::any(*firstScanTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastScanTime) {
      res["LastScanTime"] = boost::any(*lastScanTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("FirstScanTime") != m.end() && !m["FirstScanTime"].empty()) {
      firstScanTime = make_shared<long>(boost::any_cast<long>(m["FirstScanTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastScanTime") != m.end() && !m["LastScanTime"].empty()) {
      lastScanTime = make_shared<long>(boost::any_cast<long>(m["LastScanTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeImageListBySensitiveFileResponseBodyImageInfos() = default;
};
class DescribeImageListBySensitiveFileResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> lastRowKey{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageListBySensitiveFileResponseBodyPageInfo() {}

  explicit DescribeImageListBySensitiveFileResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lastRowKey) {
      res["LastRowKey"] = boost::any(*lastRowKey);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LastRowKey") != m.end() && !m["LastRowKey"].empty()) {
      lastRowKey = make_shared<string>(boost::any_cast<string>(m["LastRowKey"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageListBySensitiveFileResponseBodyPageInfo() = default;
};
class DescribeImageListBySensitiveFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<DescribeImageListBySensitiveFileResponseBodyImageInfos>> imageInfos{};
  shared_ptr<string> message{};
  shared_ptr<DescribeImageListBySensitiveFileResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeImageListBySensitiveFileResponseBody() {}

  explicit DescribeImageListBySensitiveFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (imageInfos) {
      vector<boost::any> temp1;
      for(auto item1:*imageInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageInfos"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ImageInfos") != m.end() && !m["ImageInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageInfos"].type()) {
        vector<DescribeImageListBySensitiveFileResponseBodyImageInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageListBySensitiveFileResponseBodyImageInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageInfos = make_shared<vector<DescribeImageListBySensitiveFileResponseBodyImageInfos>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageListBySensitiveFileResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageListBySensitiveFileResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeImageListBySensitiveFileResponseBody() = default;
};
class DescribeImageListBySensitiveFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageListBySensitiveFileResponseBody> body{};

  DescribeImageListBySensitiveFileResponse() {}

  explicit DescribeImageListBySensitiveFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageListBySensitiveFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageListBySensitiveFileResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageListBySensitiveFileResponse() = default;
};
class DescribeImageListWithBaselineNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> baselineNameKey{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> containerId{};
  shared_ptr<string> criteria{};
  shared_ptr<string> criteriaType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> image{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> lang{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pod{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<vector<string>> scanRange{};

  DescribeImageListWithBaselineNameRequest() {}

  explicit DescribeImageListWithBaselineNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineNameKey) {
      res["BaselineNameKey"] = boost::any(*baselineNameKey);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (criteriaType) {
      res["CriteriaType"] = boost::any(*criteriaType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineNameKey") != m.end() && !m["BaselineNameKey"].empty()) {
      baselineNameKey = make_shared<string>(boost::any_cast<string>(m["BaselineNameKey"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CriteriaType") != m.end() && !m["CriteriaType"].empty()) {
      criteriaType = make_shared<string>(boost::any_cast<string>(m["CriteriaType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeImageListWithBaselineNameRequest() = default;
};
class DescribeImageListWithBaselineNameResponseBodyImageInfos : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> containerId{};
  shared_ptr<string> digest{};
  shared_ptr<long> highRiskImage{};
  shared_ptr<string> image{};
  shared_ptr<long> imageCreate{};
  shared_ptr<string> imageId{};
  shared_ptr<long> imageSize{};
  shared_ptr<long> imageUpdate{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> lastScanTime{};
  shared_ptr<long> lowRiskImage{};
  shared_ptr<long> middleRiskImage{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> noRiskImage{};
  shared_ptr<string> pod{};
  shared_ptr<string> regionId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoType{};
  shared_ptr<string> riskStatus{};
  shared_ptr<string> tag{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};
  shared_ptr<long> totalItemCount{};
  shared_ptr<string> uuid{};

  DescribeImageListWithBaselineNameResponseBodyImageInfos() {}

  explicit DescribeImageListWithBaselineNameResponseBodyImageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (highRiskImage) {
      res["HighRiskImage"] = boost::any(*highRiskImage);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imageCreate) {
      res["ImageCreate"] = boost::any(*imageCreate);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageSize) {
      res["ImageSize"] = boost::any(*imageSize);
    }
    if (imageUpdate) {
      res["ImageUpdate"] = boost::any(*imageUpdate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (lastScanTime) {
      res["LastScanTime"] = boost::any(*lastScanTime);
    }
    if (lowRiskImage) {
      res["LowRiskImage"] = boost::any(*lowRiskImage);
    }
    if (middleRiskImage) {
      res["MiddleRiskImage"] = boost::any(*middleRiskImage);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (noRiskImage) {
      res["NoRiskImage"] = boost::any(*noRiskImage);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoType) {
      res["RepoType"] = boost::any(*repoType);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (totalItemCount) {
      res["TotalItemCount"] = boost::any(*totalItemCount);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("HighRiskImage") != m.end() && !m["HighRiskImage"].empty()) {
      highRiskImage = make_shared<long>(boost::any_cast<long>(m["HighRiskImage"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImageCreate") != m.end() && !m["ImageCreate"].empty()) {
      imageCreate = make_shared<long>(boost::any_cast<long>(m["ImageCreate"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageSize") != m.end() && !m["ImageSize"].empty()) {
      imageSize = make_shared<long>(boost::any_cast<long>(m["ImageSize"]));
    }
    if (m.find("ImageUpdate") != m.end() && !m["ImageUpdate"].empty()) {
      imageUpdate = make_shared<long>(boost::any_cast<long>(m["ImageUpdate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("LastScanTime") != m.end() && !m["LastScanTime"].empty()) {
      lastScanTime = make_shared<long>(boost::any_cast<long>(m["LastScanTime"]));
    }
    if (m.find("LowRiskImage") != m.end() && !m["LowRiskImage"].empty()) {
      lowRiskImage = make_shared<long>(boost::any_cast<long>(m["LowRiskImage"]));
    }
    if (m.find("MiddleRiskImage") != m.end() && !m["MiddleRiskImage"].empty()) {
      middleRiskImage = make_shared<long>(boost::any_cast<long>(m["MiddleRiskImage"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NoRiskImage") != m.end() && !m["NoRiskImage"].empty()) {
      noRiskImage = make_shared<long>(boost::any_cast<long>(m["NoRiskImage"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoType") != m.end() && !m["RepoType"].empty()) {
      repoType = make_shared<string>(boost::any_cast<string>(m["RepoType"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TotalItemCount") != m.end() && !m["TotalItemCount"].empty()) {
      totalItemCount = make_shared<long>(boost::any_cast<long>(m["TotalItemCount"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeImageListWithBaselineNameResponseBodyImageInfos() = default;
};
class DescribeImageListWithBaselineNameResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageListWithBaselineNameResponseBodyPageInfo() {}

  explicit DescribeImageListWithBaselineNameResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageListWithBaselineNameResponseBodyPageInfo() = default;
};
class DescribeImageListWithBaselineNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageListWithBaselineNameResponseBodyImageInfos>> imageInfos{};
  shared_ptr<DescribeImageListWithBaselineNameResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeImageListWithBaselineNameResponseBody() {}

  explicit DescribeImageListWithBaselineNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageInfos) {
      vector<boost::any> temp1;
      for(auto item1:*imageInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageInfos"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageInfos") != m.end() && !m["ImageInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageInfos"].type()) {
        vector<DescribeImageListWithBaselineNameResponseBodyImageInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageListWithBaselineNameResponseBodyImageInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageInfos = make_shared<vector<DescribeImageListWithBaselineNameResponseBodyImageInfos>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageListWithBaselineNameResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageListWithBaselineNameResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageListWithBaselineNameResponseBody() = default;
};
class DescribeImageListWithBaselineNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageListWithBaselineNameResponseBody> body{};

  DescribeImageListWithBaselineNameResponse() {}

  explicit DescribeImageListWithBaselineNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageListWithBaselineNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageListWithBaselineNameResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageListWithBaselineNameResponse() = default;
};
class DescribeImageRepoCriteriaRequest : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  DescribeImageRepoCriteriaRequest() {}

  explicit DescribeImageRepoCriteriaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeImageRepoCriteriaRequest() = default;
};
class DescribeImageRepoCriteriaResponseBodyCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> values{};

  DescribeImageRepoCriteriaResponseBodyCriteriaList() {}

  explicit DescribeImageRepoCriteriaResponseBodyCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DescribeImageRepoCriteriaResponseBodyCriteriaList() = default;
};
class DescribeImageRepoCriteriaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageRepoCriteriaResponseBodyCriteriaList>> criteriaList{};
  shared_ptr<string> requestId{};

  DescribeImageRepoCriteriaResponseBody() {}

  explicit DescribeImageRepoCriteriaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*criteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CriteriaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CriteriaList") != m.end() && !m["CriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["CriteriaList"].type()) {
        vector<DescribeImageRepoCriteriaResponseBodyCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageRepoCriteriaResponseBodyCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteriaList = make_shared<vector<DescribeImageRepoCriteriaResponseBodyCriteriaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageRepoCriteriaResponseBody() = default;
};
class DescribeImageRepoCriteriaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageRepoCriteriaResponseBody> body{};

  DescribeImageRepoCriteriaResponse() {}

  explicit DescribeImageRepoCriteriaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageRepoCriteriaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageRepoCriteriaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageRepoCriteriaResponse() = default;
};
class DescribeImageRepoDetailListRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> logicalExp{};
  shared_ptr<long> pageSize{};

  DescribeImageRepoDetailListRequest() {}

  explicit DescribeImageRepoDetailListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logicalExp) {
      res["LogicalExp"] = boost::any(*logicalExp);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LogicalExp") != m.end() && !m["LogicalExp"].empty()) {
      logicalExp = make_shared<string>(boost::any_cast<string>(m["LogicalExp"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeImageRepoDetailListRequest() = default;
};
class DescribeImageRepoDetailListResponseBodyImageRepoResponses : public Darabonba::Model {
public:
  shared_ptr<long> alarmCount{};
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> endpoints{};
  shared_ptr<long> hcCount{};
  shared_ptr<string> hcStatus{};
  shared_ptr<long> imageCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> registryType{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> riskStatus{};
  shared_ptr<long> vulCount{};
  shared_ptr<string> vulStatus{};

  DescribeImageRepoDetailListResponseBodyImageRepoResponses() {}

  explicit DescribeImageRepoDetailListResponseBodyImageRepoResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmCount) {
      res["AlarmCount"] = boost::any(*alarmCount);
    }
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (endpoints) {
      res["Endpoints"] = boost::any(*endpoints);
    }
    if (hcCount) {
      res["HcCount"] = boost::any(*hcCount);
    }
    if (hcStatus) {
      res["HcStatus"] = boost::any(*hcStatus);
    }
    if (imageCount) {
      res["ImageCount"] = boost::any(*imageCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    if (vulStatus) {
      res["VulStatus"] = boost::any(*vulStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmCount") != m.end() && !m["AlarmCount"].empty()) {
      alarmCount = make_shared<long>(boost::any_cast<long>(m["AlarmCount"]));
    }
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      endpoints = make_shared<string>(boost::any_cast<string>(m["Endpoints"]));
    }
    if (m.find("HcCount") != m.end() && !m["HcCount"].empty()) {
      hcCount = make_shared<long>(boost::any_cast<long>(m["HcCount"]));
    }
    if (m.find("HcStatus") != m.end() && !m["HcStatus"].empty()) {
      hcStatus = make_shared<string>(boost::any_cast<string>(m["HcStatus"]));
    }
    if (m.find("ImageCount") != m.end() && !m["ImageCount"].empty()) {
      imageCount = make_shared<long>(boost::any_cast<long>(m["ImageCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
    if (m.find("VulStatus") != m.end() && !m["VulStatus"].empty()) {
      vulStatus = make_shared<string>(boost::any_cast<string>(m["VulStatus"]));
    }
  }


  virtual ~DescribeImageRepoDetailListResponseBodyImageRepoResponses() = default;
};
class DescribeImageRepoDetailListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageRepoDetailListResponseBodyPageInfo() {}

  explicit DescribeImageRepoDetailListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageRepoDetailListResponseBodyPageInfo() = default;
};
class DescribeImageRepoDetailListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImageRepoDetailListResponseBodyImageRepoResponses>> imageRepoResponses{};
  shared_ptr<DescribeImageRepoDetailListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeImageRepoDetailListResponseBody() {}

  explicit DescribeImageRepoDetailListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageRepoResponses) {
      vector<boost::any> temp1;
      for(auto item1:*imageRepoResponses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageRepoResponses"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageRepoResponses") != m.end() && !m["ImageRepoResponses"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageRepoResponses"].type()) {
        vector<DescribeImageRepoDetailListResponseBodyImageRepoResponses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageRepoResponses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageRepoDetailListResponseBodyImageRepoResponses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageRepoResponses = make_shared<vector<DescribeImageRepoDetailListResponseBodyImageRepoResponses>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageRepoDetailListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageRepoDetailListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageRepoDetailListResponseBody() = default;
};
class DescribeImageRepoDetailListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageRepoDetailListResponseBody> body{};

  DescribeImageRepoDetailListResponse() {}

  explicit DescribeImageRepoDetailListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageRepoDetailListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageRepoDetailListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageRepoDetailListResponse() = default;
};
class DescribeImageRepoListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> operateType{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};

  DescribeImageRepoListRequest() {}

  explicit DescribeImageRepoListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeImageRepoListRequest() = default;
};
class DescribeImageRepoListResponseBodyImageRepoList : public Darabonba::Model {
public:
  shared_ptr<string> flag{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};

  DescribeImageRepoListResponseBodyImageRepoList() {}

  explicit DescribeImageRepoListResponseBodyImageRepoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<string>(boost::any_cast<string>(m["Flag"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
  }


  virtual ~DescribeImageRepoListResponseBodyImageRepoList() = default;
};
class DescribeImageRepoListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageRepoListResponseBodyPageInfo() {}

  explicit DescribeImageRepoListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageRepoListResponseBodyPageInfo() = default;
};
class DescribeImageRepoListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> addTargetCount{};
  shared_ptr<long> allTargetCount{};
  shared_ptr<long> delTargetCount{};
  shared_ptr<vector<DescribeImageRepoListResponseBodyImageRepoList>> imageRepoList{};
  shared_ptr<DescribeImageRepoListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeImageRepoListResponseBody() {}

  explicit DescribeImageRepoListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addTargetCount) {
      res["AddTargetCount"] = boost::any(*addTargetCount);
    }
    if (allTargetCount) {
      res["AllTargetCount"] = boost::any(*allTargetCount);
    }
    if (delTargetCount) {
      res["DelTargetCount"] = boost::any(*delTargetCount);
    }
    if (imageRepoList) {
      vector<boost::any> temp1;
      for(auto item1:*imageRepoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageRepoList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddTargetCount") != m.end() && !m["AddTargetCount"].empty()) {
      addTargetCount = make_shared<long>(boost::any_cast<long>(m["AddTargetCount"]));
    }
    if (m.find("AllTargetCount") != m.end() && !m["AllTargetCount"].empty()) {
      allTargetCount = make_shared<long>(boost::any_cast<long>(m["AllTargetCount"]));
    }
    if (m.find("DelTargetCount") != m.end() && !m["DelTargetCount"].empty()) {
      delTargetCount = make_shared<long>(boost::any_cast<long>(m["DelTargetCount"]));
    }
    if (m.find("ImageRepoList") != m.end() && !m["ImageRepoList"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageRepoList"].type()) {
        vector<DescribeImageRepoListResponseBodyImageRepoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageRepoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageRepoListResponseBodyImageRepoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageRepoList = make_shared<vector<DescribeImageRepoListResponseBodyImageRepoList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageRepoListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageRepoListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageRepoListResponseBody() = default;
};
class DescribeImageRepoListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageRepoListResponseBody> body{};

  DescribeImageRepoListResponse() {}

  explicit DescribeImageRepoListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageRepoListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageRepoListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageRepoListResponse() = default;
};
class DescribeImageScanAuthCountResponseBodyImageScan : public Darabonba::Model {
public:
  shared_ptr<long> imageScanCapacity{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> scanCount{};

  DescribeImageScanAuthCountResponseBodyImageScan() {}

  explicit DescribeImageScanAuthCountResponseBodyImageScan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageScanCapacity) {
      res["ImageScanCapacity"] = boost::any(*imageScanCapacity);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scanCount) {
      res["ScanCount"] = boost::any(*scanCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageScanCapacity") != m.end() && !m["ImageScanCapacity"].empty()) {
      imageScanCapacity = make_shared<long>(boost::any_cast<long>(m["ImageScanCapacity"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScanCount") != m.end() && !m["ScanCount"].empty()) {
      scanCount = make_shared<long>(boost::any_cast<long>(m["ScanCount"]));
    }
  }


  virtual ~DescribeImageScanAuthCountResponseBodyImageScan() = default;
};
class DescribeImageScanAuthCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeImageScanAuthCountResponseBodyImageScan> imageScan{};
  shared_ptr<string> requestId{};

  DescribeImageScanAuthCountResponseBody() {}

  explicit DescribeImageScanAuthCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageScan) {
      res["ImageScan"] = imageScan ? boost::any(imageScan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageScan") != m.end() && !m["ImageScan"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageScan"].type()) {
        DescribeImageScanAuthCountResponseBodyImageScan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageScan"]));
        imageScan = make_shared<DescribeImageScanAuthCountResponseBodyImageScan>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageScanAuthCountResponseBody() = default;
};
class DescribeImageScanAuthCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageScanAuthCountResponseBody> body{};

  DescribeImageScanAuthCountResponse() {}

  explicit DescribeImageScanAuthCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageScanAuthCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageScanAuthCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageScanAuthCountResponse() = default;
};
class DescribeImageScanAuthorizationResponseBodyAuthStatus : public Darabonba::Model {
public:
  shared_ptr<bool> status{};

  DescribeImageScanAuthorizationResponseBodyAuthStatus() {}

  explicit DescribeImageScanAuthorizationResponseBodyAuthStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~DescribeImageScanAuthorizationResponseBodyAuthStatus() = default;
};
class DescribeImageScanAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeImageScanAuthorizationResponseBodyAuthStatus> authStatus{};
  shared_ptr<string> requestId{};

  DescribeImageScanAuthorizationResponseBody() {}

  explicit DescribeImageScanAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authStatus) {
      res["AuthStatus"] = authStatus ? boost::any(authStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthStatus") != m.end() && !m["AuthStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthStatus"].type()) {
        DescribeImageScanAuthorizationResponseBodyAuthStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthStatus"]));
        authStatus = make_shared<DescribeImageScanAuthorizationResponseBodyAuthStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeImageScanAuthorizationResponseBody() = default;
};
class DescribeImageScanAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageScanAuthorizationResponseBody> body{};

  DescribeImageScanAuthorizationResponse() {}

  explicit DescribeImageScanAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageScanAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageScanAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageScanAuthorizationResponse() = default;
};
class DescribeImageSensitiveFileByKeyRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> imageUuid{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> scanRange{};
  shared_ptr<string> sensitiveFileKey{};

  DescribeImageSensitiveFileByKeyRequest() {}

  explicit DescribeImageSensitiveFileByKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    if (sensitiveFileKey) {
      res["SensitiveFileKey"] = boost::any(*sensitiveFileKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SensitiveFileKey") != m.end() && !m["SensitiveFileKey"].empty()) {
      sensitiveFileKey = make_shared<string>(boost::any_cast<string>(m["SensitiveFileKey"]));
    }
  }


  virtual ~DescribeImageSensitiveFileByKeyRequest() = default;
};
class DescribeImageSensitiveFileByKeyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> imageUuid{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scanRangeShrink{};
  shared_ptr<string> sensitiveFileKey{};

  DescribeImageSensitiveFileByKeyShrinkRequest() {}

  explicit DescribeImageSensitiveFileByKeyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scanRangeShrink) {
      res["ScanRange"] = boost::any(*scanRangeShrink);
    }
    if (sensitiveFileKey) {
      res["SensitiveFileKey"] = boost::any(*sensitiveFileKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      scanRangeShrink = make_shared<string>(boost::any_cast<string>(m["ScanRange"]));
    }
    if (m.find("SensitiveFileKey") != m.end() && !m["SensitiveFileKey"].empty()) {
      sensitiveFileKey = make_shared<string>(boost::any_cast<string>(m["SensitiveFileKey"]));
    }
  }


  virtual ~DescribeImageSensitiveFileByKeyShrinkRequest() = default;
};
class DescribeImageSensitiveFileByKeyResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> lastRowKey{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageSensitiveFileByKeyResponseBodyPageInfo() {}

  explicit DescribeImageSensitiveFileByKeyResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lastRowKey) {
      res["LastRowKey"] = boost::any(*lastRowKey);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LastRowKey") != m.end() && !m["LastRowKey"].empty()) {
      lastRowKey = make_shared<string>(boost::any_cast<string>(m["LastRowKey"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageSensitiveFileByKeyResponseBodyPageInfo() = default;
};
class DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> filePath{};
  shared_ptr<long> firstScanTime{};
  shared_ptr<long> lastScanTime{};
  shared_ptr<string> layerDigest{};
  shared_ptr<string> promt{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> sensitiveFileKey{};
  shared_ptr<string> sensitiveFileName{};

  DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList() {}

  explicit DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (firstScanTime) {
      res["FirstScanTime"] = boost::any(*firstScanTime);
    }
    if (lastScanTime) {
      res["LastScanTime"] = boost::any(*lastScanTime);
    }
    if (layerDigest) {
      res["LayerDigest"] = boost::any(*layerDigest);
    }
    if (promt) {
      res["Promt"] = boost::any(*promt);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sensitiveFileKey) {
      res["SensitiveFileKey"] = boost::any(*sensitiveFileKey);
    }
    if (sensitiveFileName) {
      res["SensitiveFileName"] = boost::any(*sensitiveFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("FirstScanTime") != m.end() && !m["FirstScanTime"].empty()) {
      firstScanTime = make_shared<long>(boost::any_cast<long>(m["FirstScanTime"]));
    }
    if (m.find("LastScanTime") != m.end() && !m["LastScanTime"].empty()) {
      lastScanTime = make_shared<long>(boost::any_cast<long>(m["LastScanTime"]));
    }
    if (m.find("LayerDigest") != m.end() && !m["LayerDigest"].empty()) {
      layerDigest = make_shared<string>(boost::any_cast<string>(m["LayerDigest"]));
    }
    if (m.find("Promt") != m.end() && !m["Promt"].empty()) {
      promt = make_shared<string>(boost::any_cast<string>(m["Promt"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("SensitiveFileKey") != m.end() && !m["SensitiveFileKey"].empty()) {
      sensitiveFileKey = make_shared<string>(boost::any_cast<string>(m["SensitiveFileKey"]));
    }
    if (m.find("SensitiveFileName") != m.end() && !m["SensitiveFileName"].empty()) {
      sensitiveFileName = make_shared<string>(boost::any_cast<string>(m["SensitiveFileName"]));
    }
  }


  virtual ~DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList() = default;
};
class DescribeImageSensitiveFileByKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<DescribeImageSensitiveFileByKeyResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList>> sensitiveFileList{};
  shared_ptr<bool> success{};

  DescribeImageSensitiveFileByKeyResponseBody() {}

  explicit DescribeImageSensitiveFileByKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sensitiveFileList) {
      vector<boost::any> temp1;
      for(auto item1:*sensitiveFileList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SensitiveFileList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageSensitiveFileByKeyResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageSensitiveFileByKeyResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SensitiveFileList") != m.end() && !m["SensitiveFileList"].empty()) {
      if (typeid(vector<boost::any>) == m["SensitiveFileList"].type()) {
        vector<DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SensitiveFileList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sensitiveFileList = make_shared<vector<DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeImageSensitiveFileByKeyResponseBody() = default;
};
class DescribeImageSensitiveFileByKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageSensitiveFileByKeyResponseBody> body{};

  DescribeImageSensitiveFileByKeyResponse() {}

  explicit DescribeImageSensitiveFileByKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageSensitiveFileByKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageSensitiveFileByKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageSensitiveFileByKeyResponse() = default;
};
class DescribeImageSensitiveFileListRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<string> criteriaType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> imageUuid{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> riskLevel{};
  shared_ptr<vector<string>> scanRange{};

  DescribeImageSensitiveFileListRequest() {}

  explicit DescribeImageSensitiveFileListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (criteriaType) {
      res["CriteriaType"] = boost::any(*criteriaType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CriteriaType") != m.end() && !m["CriteriaType"].empty()) {
      criteriaType = make_shared<string>(boost::any_cast<string>(m["CriteriaType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeImageSensitiveFileListRequest() = default;
};
class DescribeImageSensitiveFileListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<string> criteriaType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> imageUuid{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> scanRangeShrink{};

  DescribeImageSensitiveFileListShrinkRequest() {}

  explicit DescribeImageSensitiveFileListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (criteriaType) {
      res["CriteriaType"] = boost::any(*criteriaType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (scanRangeShrink) {
      res["ScanRange"] = boost::any(*scanRangeShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CriteriaType") != m.end() && !m["CriteriaType"].empty()) {
      criteriaType = make_shared<string>(boost::any_cast<string>(m["CriteriaType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      scanRangeShrink = make_shared<string>(boost::any_cast<string>(m["ScanRange"]));
    }
  }


  virtual ~DescribeImageSensitiveFileListShrinkRequest() = default;
};
class DescribeImageSensitiveFileListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> lastRowKey{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeImageSensitiveFileListResponseBodyPageInfo() {}

  explicit DescribeImageSensitiveFileListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lastRowKey) {
      res["LastRowKey"] = boost::any(*lastRowKey);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LastRowKey") != m.end() && !m["LastRowKey"].empty()) {
      lastRowKey = make_shared<string>(boost::any_cast<string>(m["LastRowKey"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeImageSensitiveFileListResponseBodyPageInfo() = default;
};
class DescribeImageSensitiveFileListResponseBodySensitiveFileList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> firstScanTime{};
  shared_ptr<long> lastScanTime{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> sensitiveFileKey{};
  shared_ptr<string> sensitiveFileName{};

  DescribeImageSensitiveFileListResponseBodySensitiveFileList() {}

  explicit DescribeImageSensitiveFileListResponseBodySensitiveFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (firstScanTime) {
      res["FirstScanTime"] = boost::any(*firstScanTime);
    }
    if (lastScanTime) {
      res["LastScanTime"] = boost::any(*lastScanTime);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sensitiveFileKey) {
      res["SensitiveFileKey"] = boost::any(*sensitiveFileKey);
    }
    if (sensitiveFileName) {
      res["SensitiveFileName"] = boost::any(*sensitiveFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("FirstScanTime") != m.end() && !m["FirstScanTime"].empty()) {
      firstScanTime = make_shared<long>(boost::any_cast<long>(m["FirstScanTime"]));
    }
    if (m.find("LastScanTime") != m.end() && !m["LastScanTime"].empty()) {
      lastScanTime = make_shared<long>(boost::any_cast<long>(m["LastScanTime"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("SensitiveFileKey") != m.end() && !m["SensitiveFileKey"].empty()) {
      sensitiveFileKey = make_shared<string>(boost::any_cast<string>(m["SensitiveFileKey"]));
    }
    if (m.find("SensitiveFileName") != m.end() && !m["SensitiveFileName"].empty()) {
      sensitiveFileName = make_shared<string>(boost::any_cast<string>(m["SensitiveFileName"]));
    }
  }


  virtual ~DescribeImageSensitiveFileListResponseBodySensitiveFileList() = default;
};
class DescribeImageSensitiveFileListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<DescribeImageSensitiveFileListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeImageSensitiveFileListResponseBodySensitiveFileList>> sensitiveFileList{};
  shared_ptr<bool> success{};

  DescribeImageSensitiveFileListResponseBody() {}

  explicit DescribeImageSensitiveFileListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sensitiveFileList) {
      vector<boost::any> temp1;
      for(auto item1:*sensitiveFileList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SensitiveFileList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeImageSensitiveFileListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeImageSensitiveFileListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SensitiveFileList") != m.end() && !m["SensitiveFileList"].empty()) {
      if (typeid(vector<boost::any>) == m["SensitiveFileList"].type()) {
        vector<DescribeImageSensitiveFileListResponseBodySensitiveFileList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SensitiveFileList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageSensitiveFileListResponseBodySensitiveFileList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sensitiveFileList = make_shared<vector<DescribeImageSensitiveFileListResponseBodySensitiveFileList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeImageSensitiveFileListResponseBody() = default;
};
class DescribeImageSensitiveFileListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageSensitiveFileListResponseBody> body{};

  DescribeImageSensitiveFileListResponse() {}

  explicit DescribeImageSensitiveFileListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageSensitiveFileListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageSensitiveFileListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageSensitiveFileListResponse() = default;
};
class DescribeImageStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> instanceCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> riskInstanceCount{};

  DescribeImageStatisticsResponseBody() {}

  explicit DescribeImageStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (riskInstanceCount) {
      res["RiskInstanceCount"] = boost::any(*riskInstanceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RiskInstanceCount") != m.end() && !m["RiskInstanceCount"].empty()) {
      riskInstanceCount = make_shared<long>(boost::any_cast<long>(m["RiskInstanceCount"]));
    }
  }


  virtual ~DescribeImageStatisticsResponseBody() = default;
};
class DescribeImageStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageStatisticsResponseBody> body{};

  DescribeImageStatisticsResponse() {}

  explicit DescribeImageStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageStatisticsResponse() = default;
};
class DescribeImageVulListRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> containerId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> dealed{};
  shared_ptr<string> digest{};
  shared_ptr<string> image{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> necessity{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pod{};
  shared_ptr<string> regionId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoInstanceId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<vector<string>> scanRange{};
  shared_ptr<string> statusList{};
  shared_ptr<string> tag{};
  shared_ptr<string> type{};
  shared_ptr<string> uuids{};

  DescribeImageVulListRequest() {}

  explicit DescribeImageVulListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoInstanceId) {
      res["RepoInstanceId"] = boost::any(*repoInstanceId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoInstanceId") != m.end() && !m["RepoInstanceId"].empty()) {
      repoInstanceId = make_shared<string>(boost::any_cast<string>(m["RepoInstanceId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      statusList = make_shared<string>(boost::any_cast<string>(m["StatusList"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeImageVulListRequest() = default;
};
class DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList : public Darabonba::Model {
public:
  shared_ptr<string> fullVersion{};
  shared_ptr<string> layer{};
  shared_ptr<string> matchDetail{};
  shared_ptr<vector<string>> matchList{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> updateCmd{};
  shared_ptr<string> version{};

  DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList() {}

  explicit DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullVersion) {
      res["FullVersion"] = boost::any(*fullVersion);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (matchDetail) {
      res["MatchDetail"] = boost::any(*matchDetail);
    }
    if (matchList) {
      res["MatchList"] = boost::any(*matchList);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (updateCmd) {
      res["UpdateCmd"] = boost::any(*updateCmd);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullVersion") != m.end() && !m["FullVersion"].empty()) {
      fullVersion = make_shared<string>(boost::any_cast<string>(m["FullVersion"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("MatchDetail") != m.end() && !m["MatchDetail"].empty()) {
      matchDetail = make_shared<string>(boost::any_cast<string>(m["MatchDetail"]));
    }
    if (m.find("MatchList") != m.end() && !m["MatchList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MatchList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MatchList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      matchList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("UpdateCmd") != m.end() && !m["UpdateCmd"].empty()) {
      updateCmd = make_shared<string>(boost::any_cast<string>(m["UpdateCmd"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList() = default;
};
class DescribeImageVulListResponseBodyVulRecordsExtendContentJson : public Darabonba::Model {
public:
  shared_ptr<string> os{};
  shared_ptr<string> osRelease{};
  shared_ptr<vector<DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList>> rpmEntityList{};

  DescribeImageVulListResponseBodyVulRecordsExtendContentJson() {}

  explicit DescribeImageVulListResponseBodyVulRecordsExtendContentJson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (osRelease) {
      res["OsRelease"] = boost::any(*osRelease);
    }
    if (rpmEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*rpmEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RpmEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("OsRelease") != m.end() && !m["OsRelease"].empty()) {
      osRelease = make_shared<string>(boost::any_cast<string>(m["OsRelease"]));
    }
    if (m.find("RpmEntityList") != m.end() && !m["RpmEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["RpmEntityList"].type()) {
        vector<DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RpmEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rpmEntityList = make_shared<vector<DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList>>(expect1);
      }
    }
  }


  virtual ~DescribeImageVulListResponseBodyVulRecordsExtendContentJson() = default;
};
class DescribeImageVulListResponseBodyVulRecords : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> canFix{};
  shared_ptr<bool> canUpdate{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> containerId{};
  shared_ptr<DescribeImageVulListResponseBodyVulRecordsExtendContentJson> extendContentJson{};
  shared_ptr<long> firstTs{};
  shared_ptr<string> image{};
  shared_ptr<string> imageDigest{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> lastTs{};
  shared_ptr<vector<string>> layers{};
  shared_ptr<string> maliciousSource{};
  shared_ptr<long> modifyTs{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> necessity{};
  shared_ptr<string> pod{};
  shared_ptr<long> primaryId{};
  shared_ptr<string> related{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<long> scanTime{};
  shared_ptr<long> status{};
  shared_ptr<string> tag{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  DescribeImageVulListResponseBodyVulRecords() {}

  explicit DescribeImageVulListResponseBodyVulRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (canFix) {
      res["CanFix"] = boost::any(*canFix);
    }
    if (canUpdate) {
      res["CanUpdate"] = boost::any(*canUpdate);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (extendContentJson) {
      res["ExtendContentJson"] = extendContentJson ? boost::any(extendContentJson->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (firstTs) {
      res["FirstTs"] = boost::any(*firstTs);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imageDigest) {
      res["ImageDigest"] = boost::any(*imageDigest);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (lastTs) {
      res["LastTs"] = boost::any(*lastTs);
    }
    if (layers) {
      res["Layers"] = boost::any(*layers);
    }
    if (maliciousSource) {
      res["MaliciousSource"] = boost::any(*maliciousSource);
    }
    if (modifyTs) {
      res["ModifyTs"] = boost::any(*modifyTs);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (primaryId) {
      res["PrimaryId"] = boost::any(*primaryId);
    }
    if (related) {
      res["Related"] = boost::any(*related);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (scanTime) {
      res["ScanTime"] = boost::any(*scanTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("CanFix") != m.end() && !m["CanFix"].empty()) {
      canFix = make_shared<string>(boost::any_cast<string>(m["CanFix"]));
    }
    if (m.find("CanUpdate") != m.end() && !m["CanUpdate"].empty()) {
      canUpdate = make_shared<bool>(boost::any_cast<bool>(m["CanUpdate"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("ExtendContentJson") != m.end() && !m["ExtendContentJson"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendContentJson"].type()) {
        DescribeImageVulListResponseBodyVulRecordsExtendContentJson model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendContentJson"]));
        extendContentJson = make_shared<DescribeImageVulListResponseBodyVulRecordsExtendContentJson>(model1);
      }
    }
    if (m.find("FirstTs") != m.end() && !m["FirstTs"].empty()) {
      firstTs = make_shared<long>(boost::any_cast<long>(m["FirstTs"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImageDigest") != m.end() && !m["ImageDigest"].empty()) {
      imageDigest = make_shared<string>(boost::any_cast<string>(m["ImageDigest"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("LastTs") != m.end() && !m["LastTs"].empty()) {
      lastTs = make_shared<long>(boost::any_cast<long>(m["LastTs"]));
    }
    if (m.find("Layers") != m.end() && !m["Layers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Layers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Layers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      layers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaliciousSource") != m.end() && !m["MaliciousSource"].empty()) {
      maliciousSource = make_shared<string>(boost::any_cast<string>(m["MaliciousSource"]));
    }
    if (m.find("ModifyTs") != m.end() && !m["ModifyTs"].empty()) {
      modifyTs = make_shared<long>(boost::any_cast<long>(m["ModifyTs"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("PrimaryId") != m.end() && !m["PrimaryId"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["PrimaryId"]));
    }
    if (m.find("Related") != m.end() && !m["Related"].empty()) {
      related = make_shared<string>(boost::any_cast<string>(m["Related"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("ScanTime") != m.end() && !m["ScanTime"].empty()) {
      scanTime = make_shared<long>(boost::any_cast<long>(m["ScanTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeImageVulListResponseBodyVulRecords() = default;
};
class DescribeImageVulListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeImageVulListResponseBodyVulRecords>> vulRecords{};

  DescribeImageVulListResponseBody() {}

  explicit DescribeImageVulListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vulRecords) {
      vector<boost::any> temp1;
      for(auto item1:*vulRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VulRecords"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VulRecords") != m.end() && !m["VulRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["VulRecords"].type()) {
        vector<DescribeImageVulListResponseBodyVulRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VulRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImageVulListResponseBodyVulRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulRecords = make_shared<vector<DescribeImageVulListResponseBodyVulRecords>>(expect1);
      }
    }
  }


  virtual ~DescribeImageVulListResponseBody() = default;
};
class DescribeImageVulListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImageVulListResponseBody> body{};

  DescribeImageVulListResponse() {}

  explicit DescribeImageVulListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImageVulListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImageVulListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImageVulListResponse() = default;
};
class DescribeInstallCaptchaRequest : public Darabonba::Model {
public:
  shared_ptr<string> deadline{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  DescribeInstallCaptchaRequest() {}

  explicit DescribeInstallCaptchaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deadline) {
      res["Deadline"] = boost::any(*deadline);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deadline") != m.end() && !m["Deadline"].empty()) {
      deadline = make_shared<string>(boost::any_cast<string>(m["Deadline"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeInstallCaptchaRequest() = default;
};
class DescribeInstallCaptchaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> captchaCode{};
  shared_ptr<string> deadline{};
  shared_ptr<string> requestId{};

  DescribeInstallCaptchaResponseBody() {}

  explicit DescribeInstallCaptchaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (captchaCode) {
      res["CaptchaCode"] = boost::any(*captchaCode);
    }
    if (deadline) {
      res["Deadline"] = boost::any(*deadline);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaptchaCode") != m.end() && !m["CaptchaCode"].empty()) {
      captchaCode = make_shared<string>(boost::any_cast<string>(m["CaptchaCode"]));
    }
    if (m.find("Deadline") != m.end() && !m["Deadline"].empty()) {
      deadline = make_shared<string>(boost::any_cast<string>(m["Deadline"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstallCaptchaResponseBody() = default;
};
class DescribeInstallCaptchaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstallCaptchaResponseBody> body{};

  DescribeInstallCaptchaResponse() {}

  explicit DescribeInstallCaptchaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstallCaptchaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstallCaptchaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstallCaptchaResponse() = default;
};
class DescribeInstallCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};

  DescribeInstallCodeResponseBody() {}

  explicit DescribeInstallCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstallCodeResponseBody() = default;
};
class DescribeInstallCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstallCodeResponseBody> body{};

  DescribeInstallCodeResponse() {}

  explicit DescribeInstallCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstallCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstallCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstallCodeResponse() = default;
};
class DescribeInstallCodesResponseBodyInstallCodes : public Darabonba::Model {
public:
  shared_ptr<string> captchaCode{};
  shared_ptr<long> expiredDate{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<bool> onlyImage{};
  shared_ptr<string> os{};
  shared_ptr<string> vendorName{};

  DescribeInstallCodesResponseBodyInstallCodes() {}

  explicit DescribeInstallCodesResponseBodyInstallCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (captchaCode) {
      res["CaptchaCode"] = boost::any(*captchaCode);
    }
    if (expiredDate) {
      res["ExpiredDate"] = boost::any(*expiredDate);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (onlyImage) {
      res["OnlyImage"] = boost::any(*onlyImage);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaptchaCode") != m.end() && !m["CaptchaCode"].empty()) {
      captchaCode = make_shared<string>(boost::any_cast<string>(m["CaptchaCode"]));
    }
    if (m.find("ExpiredDate") != m.end() && !m["ExpiredDate"].empty()) {
      expiredDate = make_shared<long>(boost::any_cast<long>(m["ExpiredDate"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("OnlyImage") != m.end() && !m["OnlyImage"].empty()) {
      onlyImage = make_shared<bool>(boost::any_cast<bool>(m["OnlyImage"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
  }


  virtual ~DescribeInstallCodesResponseBodyInstallCodes() = default;
};
class DescribeInstallCodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstallCodesResponseBodyInstallCodes>> installCodes{};
  shared_ptr<string> requestId{};

  DescribeInstallCodesResponseBody() {}

  explicit DescribeInstallCodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (installCodes) {
      vector<boost::any> temp1;
      for(auto item1:*installCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstallCodes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstallCodes") != m.end() && !m["InstallCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["InstallCodes"].type()) {
        vector<DescribeInstallCodesResponseBodyInstallCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstallCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstallCodesResponseBodyInstallCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        installCodes = make_shared<vector<DescribeInstallCodesResponseBodyInstallCodes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstallCodesResponseBody() = default;
};
class DescribeInstallCodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstallCodesResponseBody> body{};

  DescribeInstallCodesResponse() {}

  explicit DescribeInstallCodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstallCodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstallCodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstallCodesResponse() = default;
};
class DescribeInstanceAntiBruteForceRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<vector<string>> uuidList{};

  DescribeInstanceAntiBruteForceRulesRequest() {}

  explicit DescribeInstanceAntiBruteForceRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceAntiBruteForceRulesRequest() = default;
};
class DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo() {}

  explicit DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo() = default;
};
class DescribeInstanceAntiBruteForceRulesResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> uuid{};

  DescribeInstanceAntiBruteForceRulesResponseBodyRules() {}

  explicit DescribeInstanceAntiBruteForceRulesResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeInstanceAntiBruteForceRulesResponseBodyRules() = default;
};
class DescribeInstanceAntiBruteForceRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeInstanceAntiBruteForceRulesResponseBodyRules>> rules{};

  DescribeInstanceAntiBruteForceRulesResponseBody() {}

  explicit DescribeInstanceAntiBruteForceRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeInstanceAntiBruteForceRulesResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceAntiBruteForceRulesResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeInstanceAntiBruteForceRulesResponseBodyRules>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceAntiBruteForceRulesResponseBody() = default;
};
class DescribeInstanceAntiBruteForceRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceAntiBruteForceRulesResponseBody> body{};

  DescribeInstanceAntiBruteForceRulesResponse() {}

  explicit DescribeInstanceAntiBruteForceRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceAntiBruteForceRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceAntiBruteForceRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceAntiBruteForceRulesResponse() = default;
};
class DescribeInstanceRebootStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuids{};

  DescribeInstanceRebootStatusRequest() {}

  explicit DescribeInstanceRebootStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeInstanceRebootStatusRequest() = default;
};
class DescribeInstanceRebootStatusResponseBodyRebootStatuses : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> msg{};
  shared_ptr<long> rebootStatus{};
  shared_ptr<string> uuid{};

  DescribeInstanceRebootStatusResponseBodyRebootStatuses() {}

  explicit DescribeInstanceRebootStatusResponseBodyRebootStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (rebootStatus) {
      res["RebootStatus"] = boost::any(*rebootStatus);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RebootStatus") != m.end() && !m["RebootStatus"].empty()) {
      rebootStatus = make_shared<long>(boost::any_cast<long>(m["RebootStatus"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeInstanceRebootStatusResponseBodyRebootStatuses() = default;
};
class DescribeInstanceRebootStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceRebootStatusResponseBodyRebootStatuses>> rebootStatuses{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstanceRebootStatusResponseBody() {}

  explicit DescribeInstanceRebootStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rebootStatuses) {
      vector<boost::any> temp1;
      for(auto item1:*rebootStatuses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RebootStatuses"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RebootStatuses") != m.end() && !m["RebootStatuses"].empty()) {
      if (typeid(vector<boost::any>) == m["RebootStatuses"].type()) {
        vector<DescribeInstanceRebootStatusResponseBodyRebootStatuses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RebootStatuses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceRebootStatusResponseBodyRebootStatuses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rebootStatuses = make_shared<vector<DescribeInstanceRebootStatusResponseBodyRebootStatuses>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstanceRebootStatusResponseBody() = default;
};
class DescribeInstanceRebootStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceRebootStatusResponseBody> body{};

  DescribeInstanceRebootStatusResponse() {}

  explicit DescribeInstanceRebootStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceRebootStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceRebootStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceRebootStatusResponse() = default;
};
class DescribeInstanceStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuid{};

  DescribeInstanceStatisticsRequest() {}

  explicit DescribeInstanceStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeInstanceStatisticsRequest() = default;
};
class DescribeInstanceStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> account{};
  shared_ptr<long> agentlessAll{};
  shared_ptr<long> agentlessBaseline{};
  shared_ptr<long> agentlessMalicious{};
  shared_ptr<long> agentlessVulCve{};
  shared_ptr<long> agentlessVulSca{};
  shared_ptr<long> appNum{};
  shared_ptr<long> cmsNum{};
  shared_ptr<long> cspmNum{};
  shared_ptr<long> cveNum{};
  shared_ptr<long> emgNum{};
  shared_ptr<long> health{};
  shared_ptr<long> scaNum{};
  shared_ptr<long> suspicious{};
  shared_ptr<long> sysNum{};
  shared_ptr<long> trojan{};
  shared_ptr<string> uuid{};
  shared_ptr<long> vul{};
  shared_ptr<long> weakPWNum{};

  DescribeInstanceStatisticsResponseBodyData() {}

  explicit DescribeInstanceStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (agentlessAll) {
      res["AgentlessAll"] = boost::any(*agentlessAll);
    }
    if (agentlessBaseline) {
      res["AgentlessBaseline"] = boost::any(*agentlessBaseline);
    }
    if (agentlessMalicious) {
      res["AgentlessMalicious"] = boost::any(*agentlessMalicious);
    }
    if (agentlessVulCve) {
      res["AgentlessVulCve"] = boost::any(*agentlessVulCve);
    }
    if (agentlessVulSca) {
      res["AgentlessVulSca"] = boost::any(*agentlessVulSca);
    }
    if (appNum) {
      res["AppNum"] = boost::any(*appNum);
    }
    if (cmsNum) {
      res["CmsNum"] = boost::any(*cmsNum);
    }
    if (cspmNum) {
      res["CspmNum"] = boost::any(*cspmNum);
    }
    if (cveNum) {
      res["CveNum"] = boost::any(*cveNum);
    }
    if (emgNum) {
      res["EmgNum"] = boost::any(*emgNum);
    }
    if (health) {
      res["Health"] = boost::any(*health);
    }
    if (scaNum) {
      res["ScaNum"] = boost::any(*scaNum);
    }
    if (suspicious) {
      res["Suspicious"] = boost::any(*suspicious);
    }
    if (sysNum) {
      res["SysNum"] = boost::any(*sysNum);
    }
    if (trojan) {
      res["Trojan"] = boost::any(*trojan);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vul) {
      res["Vul"] = boost::any(*vul);
    }
    if (weakPWNum) {
      res["WeakPWNum"] = boost::any(*weakPWNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<long>(boost::any_cast<long>(m["Account"]));
    }
    if (m.find("AgentlessAll") != m.end() && !m["AgentlessAll"].empty()) {
      agentlessAll = make_shared<long>(boost::any_cast<long>(m["AgentlessAll"]));
    }
    if (m.find("AgentlessBaseline") != m.end() && !m["AgentlessBaseline"].empty()) {
      agentlessBaseline = make_shared<long>(boost::any_cast<long>(m["AgentlessBaseline"]));
    }
    if (m.find("AgentlessMalicious") != m.end() && !m["AgentlessMalicious"].empty()) {
      agentlessMalicious = make_shared<long>(boost::any_cast<long>(m["AgentlessMalicious"]));
    }
    if (m.find("AgentlessVulCve") != m.end() && !m["AgentlessVulCve"].empty()) {
      agentlessVulCve = make_shared<long>(boost::any_cast<long>(m["AgentlessVulCve"]));
    }
    if (m.find("AgentlessVulSca") != m.end() && !m["AgentlessVulSca"].empty()) {
      agentlessVulSca = make_shared<long>(boost::any_cast<long>(m["AgentlessVulSca"]));
    }
    if (m.find("AppNum") != m.end() && !m["AppNum"].empty()) {
      appNum = make_shared<long>(boost::any_cast<long>(m["AppNum"]));
    }
    if (m.find("CmsNum") != m.end() && !m["CmsNum"].empty()) {
      cmsNum = make_shared<long>(boost::any_cast<long>(m["CmsNum"]));
    }
    if (m.find("CspmNum") != m.end() && !m["CspmNum"].empty()) {
      cspmNum = make_shared<long>(boost::any_cast<long>(m["CspmNum"]));
    }
    if (m.find("CveNum") != m.end() && !m["CveNum"].empty()) {
      cveNum = make_shared<long>(boost::any_cast<long>(m["CveNum"]));
    }
    if (m.find("EmgNum") != m.end() && !m["EmgNum"].empty()) {
      emgNum = make_shared<long>(boost::any_cast<long>(m["EmgNum"]));
    }
    if (m.find("Health") != m.end() && !m["Health"].empty()) {
      health = make_shared<long>(boost::any_cast<long>(m["Health"]));
    }
    if (m.find("ScaNum") != m.end() && !m["ScaNum"].empty()) {
      scaNum = make_shared<long>(boost::any_cast<long>(m["ScaNum"]));
    }
    if (m.find("Suspicious") != m.end() && !m["Suspicious"].empty()) {
      suspicious = make_shared<long>(boost::any_cast<long>(m["Suspicious"]));
    }
    if (m.find("SysNum") != m.end() && !m["SysNum"].empty()) {
      sysNum = make_shared<long>(boost::any_cast<long>(m["SysNum"]));
    }
    if (m.find("Trojan") != m.end() && !m["Trojan"].empty()) {
      trojan = make_shared<long>(boost::any_cast<long>(m["Trojan"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Vul") != m.end() && !m["Vul"].empty()) {
      vul = make_shared<long>(boost::any_cast<long>(m["Vul"]));
    }
    if (m.find("WeakPWNum") != m.end() && !m["WeakPWNum"].empty()) {
      weakPWNum = make_shared<long>(boost::any_cast<long>(m["WeakPWNum"]));
    }
  }


  virtual ~DescribeInstanceStatisticsResponseBodyData() = default;
};
class DescribeInstanceStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceStatisticsResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeInstanceStatisticsResponseBody() {}

  explicit DescribeInstanceStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeInstanceStatisticsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceStatisticsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeInstanceStatisticsResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceStatisticsResponseBody() = default;
};
class DescribeInstanceStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceStatisticsResponseBody> body{};

  DescribeInstanceStatisticsResponse() {}

  explicit DescribeInstanceStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceStatisticsResponse() = default;
};
class DescribeIpTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ip{};
  shared_ptr<string> securityEventId{};

  DescribeIpTagsRequest() {}

  explicit DescribeIpTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<string>(boost::any_cast<string>(m["SecurityEventId"]));
    }
  }


  virtual ~DescribeIpTagsRequest() = default;
};
class DescribeIpTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> tags{};

  DescribeIpTagsResponseBody() {}

  explicit DescribeIpTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~DescribeIpTagsResponseBody() = default;
};
class DescribeIpTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpTagsResponseBody> body{};

  DescribeIpTagsResponse() {}

  explicit DescribeIpTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpTagsResponse() = default;
};
class DescribeLatestScanTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> lastCheckTime{};
  shared_ptr<string> requestId{};
  shared_ptr<long> riskNum{};
  shared_ptr<string> targetInfo{};
  shared_ptr<vector<string>> uuids{};

  DescribeLatestScanTaskResponseBody() {}

  explicit DescribeLatestScanTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastCheckTime) {
      res["LastCheckTime"] = boost::any(*lastCheckTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (riskNum) {
      res["RiskNum"] = boost::any(*riskNum);
    }
    if (targetInfo) {
      res["TargetInfo"] = boost::any(*targetInfo);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastCheckTime") != m.end() && !m["LastCheckTime"].empty()) {
      lastCheckTime = make_shared<long>(boost::any_cast<long>(m["LastCheckTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RiskNum") != m.end() && !m["RiskNum"].empty()) {
      riskNum = make_shared<long>(boost::any_cast<long>(m["RiskNum"]));
    }
    if (m.find("TargetInfo") != m.end() && !m["TargetInfo"].empty()) {
      targetInfo = make_shared<string>(boost::any_cast<string>(m["TargetInfo"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Uuids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Uuids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuids = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeLatestScanTaskResponseBody() = default;
};
class DescribeLatestScanTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLatestScanTaskResponseBody> body{};

  DescribeLatestScanTaskResponse() {}

  explicit DescribeLatestScanTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLatestScanTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLatestScanTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLatestScanTaskResponse() = default;
};
class DescribeLogMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  DescribeLogMetaRequest() {}

  explicit DescribeLogMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeLogMetaRequest() = default;
};
class DescribeLogMetaResponseBodyLogMetaList : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> hotTtl{};
  shared_ptr<string> logDesc{};
  shared_ptr<string> logStore{};
  shared_ptr<string> project{};
  shared_ptr<string> status{};
  shared_ptr<string> topic{};
  shared_ptr<long> ttl{};
  shared_ptr<string> userLogStore{};
  shared_ptr<string> userProject{};
  shared_ptr<string> userRegion{};

  DescribeLogMetaResponseBodyLogMetaList() {}

  explicit DescribeLogMetaResponseBodyLogMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (hotTtl) {
      res["HotTtl"] = boost::any(*hotTtl);
    }
    if (logDesc) {
      res["LogDesc"] = boost::any(*logDesc);
    }
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (userLogStore) {
      res["UserLogStore"] = boost::any(*userLogStore);
    }
    if (userProject) {
      res["UserProject"] = boost::any(*userProject);
    }
    if (userRegion) {
      res["UserRegion"] = boost::any(*userRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("HotTtl") != m.end() && !m["HotTtl"].empty()) {
      hotTtl = make_shared<long>(boost::any_cast<long>(m["HotTtl"]));
    }
    if (m.find("LogDesc") != m.end() && !m["LogDesc"].empty()) {
      logDesc = make_shared<string>(boost::any_cast<string>(m["LogDesc"]));
    }
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("UserLogStore") != m.end() && !m["UserLogStore"].empty()) {
      userLogStore = make_shared<string>(boost::any_cast<string>(m["UserLogStore"]));
    }
    if (m.find("UserProject") != m.end() && !m["UserProject"].empty()) {
      userProject = make_shared<string>(boost::any_cast<string>(m["UserProject"]));
    }
    if (m.find("UserRegion") != m.end() && !m["UserRegion"].empty()) {
      userRegion = make_shared<string>(boost::any_cast<string>(m["UserRegion"]));
    }
  }


  virtual ~DescribeLogMetaResponseBodyLogMetaList() = default;
};
class DescribeLogMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLogMetaResponseBodyLogMetaList>> logMetaList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLogMetaResponseBody() {}

  explicit DescribeLogMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*logMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogMetaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogMetaList") != m.end() && !m["LogMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["LogMetaList"].type()) {
        vector<DescribeLogMetaResponseBodyLogMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogMetaResponseBodyLogMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logMetaList = make_shared<vector<DescribeLogMetaResponseBodyLogMetaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLogMetaResponseBody() = default;
};
class DescribeLogMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLogMetaResponseBody> body{};

  DescribeLogMetaResponse() {}

  explicit DescribeLogMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogMetaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogMetaResponse() = default;
};
class DescribeLogShipperStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};

  DescribeLogShipperStatusRequest() {}

  explicit DescribeLogShipperStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~DescribeLogShipperStatusRequest() = default;
};
class DescribeLogShipperStatusResponseBodyLogShipperStatus : public Darabonba::Model {
public:
  shared_ptr<string> authStatus{};
  shared_ptr<string> buyStatus{};
  shared_ptr<string> openStatus{};
  shared_ptr<string> postPaidOpenStatus{};
  shared_ptr<string> postPaidSupportStatus{};
  shared_ptr<string> slsProjectStatus{};
  shared_ptr<string> slsServiceStatus{};

  DescribeLogShipperStatusResponseBodyLogShipperStatus() {}

  explicit DescribeLogShipperStatusResponseBodyLogShipperStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authStatus) {
      res["AuthStatus"] = boost::any(*authStatus);
    }
    if (buyStatus) {
      res["BuyStatus"] = boost::any(*buyStatus);
    }
    if (openStatus) {
      res["OpenStatus"] = boost::any(*openStatus);
    }
    if (postPaidOpenStatus) {
      res["PostPaidOpenStatus"] = boost::any(*postPaidOpenStatus);
    }
    if (postPaidSupportStatus) {
      res["PostPaidSupportStatus"] = boost::any(*postPaidSupportStatus);
    }
    if (slsProjectStatus) {
      res["SlsProjectStatus"] = boost::any(*slsProjectStatus);
    }
    if (slsServiceStatus) {
      res["SlsServiceStatus"] = boost::any(*slsServiceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthStatus") != m.end() && !m["AuthStatus"].empty()) {
      authStatus = make_shared<string>(boost::any_cast<string>(m["AuthStatus"]));
    }
    if (m.find("BuyStatus") != m.end() && !m["BuyStatus"].empty()) {
      buyStatus = make_shared<string>(boost::any_cast<string>(m["BuyStatus"]));
    }
    if (m.find("OpenStatus") != m.end() && !m["OpenStatus"].empty()) {
      openStatus = make_shared<string>(boost::any_cast<string>(m["OpenStatus"]));
    }
    if (m.find("PostPaidOpenStatus") != m.end() && !m["PostPaidOpenStatus"].empty()) {
      postPaidOpenStatus = make_shared<string>(boost::any_cast<string>(m["PostPaidOpenStatus"]));
    }
    if (m.find("PostPaidSupportStatus") != m.end() && !m["PostPaidSupportStatus"].empty()) {
      postPaidSupportStatus = make_shared<string>(boost::any_cast<string>(m["PostPaidSupportStatus"]));
    }
    if (m.find("SlsProjectStatus") != m.end() && !m["SlsProjectStatus"].empty()) {
      slsProjectStatus = make_shared<string>(boost::any_cast<string>(m["SlsProjectStatus"]));
    }
    if (m.find("SlsServiceStatus") != m.end() && !m["SlsServiceStatus"].empty()) {
      slsServiceStatus = make_shared<string>(boost::any_cast<string>(m["SlsServiceStatus"]));
    }
  }


  virtual ~DescribeLogShipperStatusResponseBodyLogShipperStatus() = default;
};
class DescribeLogShipperStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLogShipperStatusResponseBodyLogShipperStatus> logShipperStatus{};
  shared_ptr<string> requestId{};

  DescribeLogShipperStatusResponseBody() {}

  explicit DescribeLogShipperStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logShipperStatus) {
      res["LogShipperStatus"] = logShipperStatus ? boost::any(logShipperStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogShipperStatus") != m.end() && !m["LogShipperStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogShipperStatus"].type()) {
        DescribeLogShipperStatusResponseBodyLogShipperStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogShipperStatus"]));
        logShipperStatus = make_shared<DescribeLogShipperStatusResponseBodyLogShipperStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLogShipperStatusResponseBody() = default;
};
class DescribeLogShipperStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLogShipperStatusResponseBody> body{};

  DescribeLogShipperStatusResponse() {}

  explicit DescribeLogShipperStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogShipperStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogShipperStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogShipperStatusResponse() = default;
};
class DescribeLoginBaseConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  DescribeLoginBaseConfigsRequest() {}

  explicit DescribeLoginBaseConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeLoginBaseConfigsRequest() = default;
};
class DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList : public Darabonba::Model {
public:
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};

  DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList() {}

  explicit DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList() = default;
};
class DescribeLoginBaseConfigsResponseBodyBaseConfigs : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ip{};
  shared_ptr<string> location{};
  shared_ptr<string> startTime{};
  shared_ptr<vector<DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList>> targetList{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> uuidCount{};

  DescribeLoginBaseConfigsResponseBodyBaseConfigs() {}

  explicit DescribeLoginBaseConfigsResponseBodyBaseConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (targetList) {
      vector<boost::any> temp1;
      for(auto item1:*targetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (uuidCount) {
      res["UuidCount"] = boost::any(*uuidCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TargetList") != m.end() && !m["TargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetList"].type()) {
        vector<DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetList = make_shared<vector<DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UuidCount") != m.end() && !m["UuidCount"].empty()) {
      uuidCount = make_shared<long>(boost::any_cast<long>(m["UuidCount"]));
    }
  }


  virtual ~DescribeLoginBaseConfigsResponseBodyBaseConfigs() = default;
};
class DescribeLoginBaseConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLoginBaseConfigsResponseBodyBaseConfigs>> baseConfigs{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeLoginBaseConfigsResponseBody() {}

  explicit DescribeLoginBaseConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*baseConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaseConfigs"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseConfigs") != m.end() && !m["BaseConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["BaseConfigs"].type()) {
        vector<DescribeLoginBaseConfigsResponseBodyBaseConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaseConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoginBaseConfigsResponseBodyBaseConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baseConfigs = make_shared<vector<DescribeLoginBaseConfigsResponseBodyBaseConfigs>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeLoginBaseConfigsResponseBody() = default;
};
class DescribeLoginBaseConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoginBaseConfigsResponseBody> body{};

  DescribeLoginBaseConfigsResponse() {}

  explicit DescribeLoginBaseConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoginBaseConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoginBaseConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoginBaseConfigsResponse() = default;
};
class DescribeLoginSwitchConfigsResponseBodyConfigList : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<long> status{};

  DescribeLoginSwitchConfigsResponseBodyConfigList() {}

  explicit DescribeLoginSwitchConfigsResponseBodyConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeLoginSwitchConfigsResponseBodyConfigList() = default;
};
class DescribeLoginSwitchConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLoginSwitchConfigsResponseBodyConfigList>> configList{};
  shared_ptr<long> count{};
  shared_ptr<string> requestId{};

  DescribeLoginSwitchConfigsResponseBody() {}

  explicit DescribeLoginSwitchConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configList) {
      vector<boost::any> temp1;
      for(auto item1:*configList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigList"] = boost::any(temp1);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigList"].type()) {
        vector<DescribeLoginSwitchConfigsResponseBodyConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLoginSwitchConfigsResponseBodyConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configList = make_shared<vector<DescribeLoginSwitchConfigsResponseBodyConfigList>>(expect1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLoginSwitchConfigsResponseBody() = default;
};
class DescribeLoginSwitchConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLoginSwitchConfigsResponseBody> body{};

  DescribeLoginSwitchConfigsResponse() {}

  explicit DescribeLoginSwitchConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLoginSwitchConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLoginSwitchConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLoginSwitchConfigsResponse() = default;
};
class DescribeLogstoreStorageRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> lang{};

  DescribeLogstoreStorageRequest() {}

  explicit DescribeLogstoreStorageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeLogstoreStorageRequest() = default;
};
class DescribeLogstoreStorageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> logstore{};
  shared_ptr<long> preserve{};
  shared_ptr<string> requestId{};
  shared_ptr<long> ttl{};
  shared_ptr<long> used{};
  shared_ptr<string> userProject{};

  DescribeLogstoreStorageResponseBody() {}

  explicit DescribeLogstoreStorageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstore) {
      res["Logstore"] = boost::any(*logstore);
    }
    if (preserve) {
      res["Preserve"] = boost::any(*preserve);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    if (userProject) {
      res["UserProject"] = boost::any(*userProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logstore") != m.end() && !m["Logstore"].empty()) {
      logstore = make_shared<string>(boost::any_cast<string>(m["Logstore"]));
    }
    if (m.find("Preserve") != m.end() && !m["Preserve"].empty()) {
      preserve = make_shared<long>(boost::any_cast<long>(m["Preserve"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
    if (m.find("UserProject") != m.end() && !m["UserProject"].empty()) {
      userProject = make_shared<string>(boost::any_cast<string>(m["UserProject"]));
    }
  }


  virtual ~DescribeLogstoreStorageResponseBody() = default;
};
class DescribeLogstoreStorageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLogstoreStorageResponseBody> body{};

  DescribeLogstoreStorageResponse() {}

  explicit DescribeLogstoreStorageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogstoreStorageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogstoreStorageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogstoreStorageResponse() = default;
};
class DescribeMachineCanRebootRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  DescribeMachineCanRebootRequest() {}

  explicit DescribeMachineCanRebootRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeMachineCanRebootRequest() = default;
};
class DescribeMachineCanRebootResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> canReboot{};
  shared_ptr<string> requestId{};

  DescribeMachineCanRebootResponseBody() {}

  explicit DescribeMachineCanRebootResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canReboot) {
      res["CanReboot"] = boost::any(*canReboot);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanReboot") != m.end() && !m["CanReboot"].empty()) {
      canReboot = make_shared<bool>(boost::any_cast<bool>(m["CanReboot"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMachineCanRebootResponseBody() = default;
};
class DescribeMachineCanRebootResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMachineCanRebootResponseBody> body{};

  DescribeMachineCanRebootResponse() {}

  explicit DescribeMachineCanRebootResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMachineCanRebootResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMachineCanRebootResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMachineCanRebootResponse() = default;
};
class DescribeModuleConfigResponseBodyModuleConfigListItems : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> ip{};
  shared_ptr<string> region{};
  shared_ptr<string> uuid{};

  DescribeModuleConfigResponseBodyModuleConfigListItems() {}

  explicit DescribeModuleConfigResponseBodyModuleConfigListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeModuleConfigResponseBodyModuleConfigListItems() = default;
};
class DescribeModuleConfigResponseBodyModuleConfigList : public Darabonba::Model {
public:
  shared_ptr<string> configName{};
  shared_ptr<vector<DescribeModuleConfigResponseBodyModuleConfigListItems>> items{};
  shared_ptr<string> moduleName{};

  DescribeModuleConfigResponseBodyModuleConfigList() {}

  explicit DescribeModuleConfigResponseBodyModuleConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<DescribeModuleConfigResponseBodyModuleConfigListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModuleConfigResponseBodyModuleConfigListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<DescribeModuleConfigResponseBodyModuleConfigListItems>>(expect1);
      }
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~DescribeModuleConfigResponseBodyModuleConfigList() = default;
};
class DescribeModuleConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<DescribeModuleConfigResponseBodyModuleConfigList>> moduleConfigList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeModuleConfigResponseBody() {}

  explicit DescribeModuleConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (moduleConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*moduleConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModuleConfigList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ModuleConfigList") != m.end() && !m["ModuleConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ModuleConfigList"].type()) {
        vector<DescribeModuleConfigResponseBodyModuleConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModuleConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModuleConfigResponseBodyModuleConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        moduleConfigList = make_shared<vector<DescribeModuleConfigResponseBodyModuleConfigList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeModuleConfigResponseBody() = default;
};
class DescribeModuleConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeModuleConfigResponseBody> body{};

  DescribeModuleConfigResponse() {}

  explicit DescribeModuleConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeModuleConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeModuleConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeModuleConfigResponse() = default;
};
class DescribeNoticeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  DescribeNoticeConfigRequest() {}

  explicit DescribeNoticeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeNoticeConfigRequest() = default;
};
class DescribeNoticeConfigResponseBodyNoticeConfigList : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> project{};
  shared_ptr<long> route{};
  shared_ptr<long> timeLimit{};

  DescribeNoticeConfigResponseBodyNoticeConfigList() {}

  explicit DescribeNoticeConfigResponseBodyNoticeConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (route) {
      res["Route"] = boost::any(*route);
    }
    if (timeLimit) {
      res["TimeLimit"] = boost::any(*timeLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Route") != m.end() && !m["Route"].empty()) {
      route = make_shared<long>(boost::any_cast<long>(m["Route"]));
    }
    if (m.find("TimeLimit") != m.end() && !m["TimeLimit"].empty()) {
      timeLimit = make_shared<long>(boost::any_cast<long>(m["TimeLimit"]));
    }
  }


  virtual ~DescribeNoticeConfigResponseBodyNoticeConfigList() = default;
};
class DescribeNoticeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNoticeConfigResponseBodyNoticeConfigList>> noticeConfigList{};
  shared_ptr<string> requestId{};

  DescribeNoticeConfigResponseBody() {}

  explicit DescribeNoticeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (noticeConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*noticeConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NoticeConfigList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NoticeConfigList") != m.end() && !m["NoticeConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["NoticeConfigList"].type()) {
        vector<DescribeNoticeConfigResponseBodyNoticeConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NoticeConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNoticeConfigResponseBodyNoticeConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        noticeConfigList = make_shared<vector<DescribeNoticeConfigResponseBodyNoticeConfigList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNoticeConfigResponseBody() = default;
};
class DescribeNoticeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNoticeConfigResponseBody> body{};

  DescribeNoticeConfigResponse() {}

  explicit DescribeNoticeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNoticeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNoticeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNoticeConfigResponse() = default;
};
class DescribeNsasSuspEventTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<string> from{};
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuids{};

  DescribeNsasSuspEventTypeRequest() {}

  explicit DescribeNsasSuspEventTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeNsasSuspEventTypeRequest() = default;
};
class DescribeNsasSuspEventTypeResponseBodyEventTypes : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> suspEventCount{};
  shared_ptr<string> type{};

  DescribeNsasSuspEventTypeResponseBodyEventTypes() {}

  explicit DescribeNsasSuspEventTypeResponseBodyEventTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (suspEventCount) {
      res["SuspEventCount"] = boost::any(*suspEventCount);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SuspEventCount") != m.end() && !m["SuspEventCount"].empty()) {
      suspEventCount = make_shared<long>(boost::any_cast<long>(m["SuspEventCount"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeNsasSuspEventTypeResponseBodyEventTypes() = default;
};
class DescribeNsasSuspEventTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNsasSuspEventTypeResponseBodyEventTypes>> eventTypes{};
  shared_ptr<string> requestId{};

  DescribeNsasSuspEventTypeResponseBody() {}

  explicit DescribeNsasSuspEventTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventTypes) {
      vector<boost::any> temp1;
      for(auto item1:*eventTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventTypes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventTypes") != m.end() && !m["EventTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["EventTypes"].type()) {
        vector<DescribeNsasSuspEventTypeResponseBodyEventTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNsasSuspEventTypeResponseBodyEventTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventTypes = make_shared<vector<DescribeNsasSuspEventTypeResponseBodyEventTypes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeNsasSuspEventTypeResponseBody() = default;
};
class DescribeNsasSuspEventTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNsasSuspEventTypeResponseBody> body{};

  DescribeNsasSuspEventTypeResponse() {}

  explicit DescribeNsasSuspEventTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNsasSuspEventTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNsasSuspEventTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNsasSuspEventTypeResponse() = default;
};
class DescribeOfflineMachinesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> os{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionIdStr{};
  shared_ptr<string> regionNo{};
  shared_ptr<string> remark{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> vendor{};

  DescribeOfflineMachinesRequest() {}

  explicit DescribeOfflineMachinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionIdStr) {
      res["RegionIdStr"] = boost::any(*regionIdStr);
    }
    if (regionNo) {
      res["RegionNo"] = boost::any(*regionNo);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionIdStr") != m.end() && !m["RegionIdStr"].empty()) {
      regionIdStr = make_shared<string>(boost::any_cast<string>(m["RegionIdStr"]));
    }
    if (m.find("RegionNo") != m.end() && !m["RegionNo"].empty()) {
      regionNo = make_shared<string>(boost::any_cast<string>(m["RegionNo"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<long>(boost::any_cast<long>(m["Vendor"]));
    }
  }


  virtual ~DescribeOfflineMachinesRequest() = default;
};
class DescribeOfflineMachinesResponseBodyMachineList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> machineRegion{};
  shared_ptr<string> os{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uuid{};
  shared_ptr<long> vendor{};
  shared_ptr<string> vendorName{};

  DescribeOfflineMachinesResponseBodyMachineList() {}

  explicit DescribeOfflineMachinesResponseBodyMachineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (machineRegion) {
      res["MachineRegion"] = boost::any(*machineRegion);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("MachineRegion") != m.end() && !m["MachineRegion"].empty()) {
      machineRegion = make_shared<string>(boost::any_cast<string>(m["MachineRegion"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<long>(boost::any_cast<long>(m["Vendor"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
  }


  virtual ~DescribeOfflineMachinesResponseBodyMachineList() = default;
};
class DescribeOfflineMachinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeOfflineMachinesResponseBodyMachineList>> machineList{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeOfflineMachinesResponseBody() {}

  explicit DescribeOfflineMachinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (machineList) {
      vector<boost::any> temp1;
      for(auto item1:*machineList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MachineList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("MachineList") != m.end() && !m["MachineList"].empty()) {
      if (typeid(vector<boost::any>) == m["MachineList"].type()) {
        vector<DescribeOfflineMachinesResponseBodyMachineList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MachineList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOfflineMachinesResponseBodyMachineList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machineList = make_shared<vector<DescribeOfflineMachinesResponseBodyMachineList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeOfflineMachinesResponseBody() = default;
};
class DescribeOfflineMachinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOfflineMachinesResponseBody> body{};

  DescribeOfflineMachinesResponse() {}

  explicit DescribeOfflineMachinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOfflineMachinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOfflineMachinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOfflineMachinesResponse() = default;
};
class DescribeOnceTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTimeQuery{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> rootTaskId{};
  shared_ptr<long> startTimeQuery{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};

  DescribeOnceTaskRequest() {}

  explicit DescribeOnceTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTimeQuery) {
      res["EndTimeQuery"] = boost::any(*endTimeQuery);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (rootTaskId) {
      res["RootTaskId"] = boost::any(*rootTaskId);
    }
    if (startTimeQuery) {
      res["StartTimeQuery"] = boost::any(*startTimeQuery);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTimeQuery") != m.end() && !m["EndTimeQuery"].empty()) {
      endTimeQuery = make_shared<long>(boost::any_cast<long>(m["EndTimeQuery"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RootTaskId") != m.end() && !m["RootTaskId"].empty()) {
      rootTaskId = make_shared<string>(boost::any_cast<string>(m["RootTaskId"]));
    }
    if (m.find("StartTimeQuery") != m.end() && !m["StartTimeQuery"].empty()) {
      startTimeQuery = make_shared<long>(boost::any_cast<long>(m["StartTimeQuery"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeOnceTaskRequest() = default;
};
class DescribeOnceTaskResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeOnceTaskResponseBodyPageInfo() {}

  explicit DescribeOnceTaskResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeOnceTaskResponseBodyPageInfo() = default;
};
class DescribeOnceTaskResponseBodyTaskManageResponseList : public Darabonba::Model {
public:
  shared_ptr<string> detailData{};
  shared_ptr<long> failCount{};
  shared_ptr<string> progress{};
  shared_ptr<string> resultInfo{};
  shared_ptr<long> successCount{};
  shared_ptr<long> taskEndTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskStartTime{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> taskStatusText{};
  shared_ptr<string> taskType{};

  DescribeOnceTaskResponseBodyTaskManageResponseList() {}

  explicit DescribeOnceTaskResponseBodyTaskManageResponseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detailData) {
      res["DetailData"] = boost::any(*detailData);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (resultInfo) {
      res["ResultInfo"] = boost::any(*resultInfo);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (taskEndTime) {
      res["TaskEndTime"] = boost::any(*taskEndTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStartTime) {
      res["TaskStartTime"] = boost::any(*taskStartTime);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskStatusText) {
      res["TaskStatusText"] = boost::any(*taskStatusText);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetailData") != m.end() && !m["DetailData"].empty()) {
      detailData = make_shared<string>(boost::any_cast<string>(m["DetailData"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("ResultInfo") != m.end() && !m["ResultInfo"].empty()) {
      resultInfo = make_shared<string>(boost::any_cast<string>(m["ResultInfo"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("TaskEndTime") != m.end() && !m["TaskEndTime"].empty()) {
      taskEndTime = make_shared<long>(boost::any_cast<long>(m["TaskEndTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStartTime") != m.end() && !m["TaskStartTime"].empty()) {
      taskStartTime = make_shared<long>(boost::any_cast<long>(m["TaskStartTime"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TaskStatusText") != m.end() && !m["TaskStatusText"].empty()) {
      taskStatusText = make_shared<string>(boost::any_cast<string>(m["TaskStatusText"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeOnceTaskResponseBodyTaskManageResponseList() = default;
};
class DescribeOnceTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeOnceTaskResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOnceTaskResponseBodyTaskManageResponseList>> taskManageResponseList{};

  DescribeOnceTaskResponseBody() {}

  explicit DescribeOnceTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskManageResponseList) {
      vector<boost::any> temp1;
      for(auto item1:*taskManageResponseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskManageResponseList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeOnceTaskResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeOnceTaskResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskManageResponseList") != m.end() && !m["TaskManageResponseList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskManageResponseList"].type()) {
        vector<DescribeOnceTaskResponseBodyTaskManageResponseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskManageResponseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOnceTaskResponseBodyTaskManageResponseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskManageResponseList = make_shared<vector<DescribeOnceTaskResponseBodyTaskManageResponseList>>(expect1);
      }
    }
  }


  virtual ~DescribeOnceTaskResponseBody() = default;
};
class DescribeOnceTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOnceTaskResponseBody> body{};

  DescribeOnceTaskResponse() {}

  explicit DescribeOnceTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOnceTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOnceTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOnceTaskResponse() = default;
};
class DescribeOnceTaskLeafRecordPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> relateInfo{};
  shared_ptr<string> source{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<string>> statusList{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};

  DescribeOnceTaskLeafRecordPageRequest() {}

  explicit DescribeOnceTaskLeafRecordPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (relateInfo) {
      res["RelateInfo"] = boost::any(*relateInfo);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RelateInfo") != m.end() && !m["RelateInfo"].empty()) {
      relateInfo = make_shared<bool>(boost::any_cast<bool>(m["RelateInfo"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~DescribeOnceTaskLeafRecordPageRequest() = default;
};
class DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> digest{};
  shared_ptr<string> image{};
  shared_ptr<string> nodeInstanceId{};
  shared_ptr<string> nodeIp{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> pod{};
  shared_ptr<string> regionId{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoRegionId{};
  shared_ptr<string> tag{};

  DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo() {}

  explicit DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (nodeInstanceId) {
      res["NodeInstanceId"] = boost::any(*nodeInstanceId);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoRegionId) {
      res["RepoRegionId"] = boost::any(*repoRegionId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("NodeInstanceId") != m.end() && !m["NodeInstanceId"].empty()) {
      nodeInstanceId = make_shared<string>(boost::any_cast<string>(m["NodeInstanceId"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoRegionId") != m.end() && !m["RepoRegionId"].empty()) {
      repoRegionId = make_shared<string>(boost::any_cast<string>(m["RepoRegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo() = default;
};
class DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> finish{};
  shared_ptr<string> finishCount{};
  shared_ptr<long> progress{};
  shared_ptr<long> realRunTime{};
  shared_ptr<string> resultInfo{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> statusText{};
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};
  shared_ptr<string> taskId{};
  shared_ptr<DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo> taskImageInfo{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};
  shared_ptr<string> totalCount{};

  DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks() {}

  explicit DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (finish) {
      res["Finish"] = boost::any(*finish);
    }
    if (finishCount) {
      res["FinishCount"] = boost::any(*finishCount);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (realRunTime) {
      res["RealRunTime"] = boost::any(*realRunTime);
    }
    if (resultInfo) {
      res["ResultInfo"] = boost::any(*resultInfo);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusText) {
      res["StatusText"] = boost::any(*statusText);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskImageInfo) {
      res["TaskImageInfo"] = taskImageInfo ? boost::any(taskImageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Finish") != m.end() && !m["Finish"].empty()) {
      finish = make_shared<long>(boost::any_cast<long>(m["Finish"]));
    }
    if (m.find("FinishCount") != m.end() && !m["FinishCount"].empty()) {
      finishCount = make_shared<string>(boost::any_cast<string>(m["FinishCount"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("RealRunTime") != m.end() && !m["RealRunTime"].empty()) {
      realRunTime = make_shared<long>(boost::any_cast<long>(m["RealRunTime"]));
    }
    if (m.find("ResultInfo") != m.end() && !m["ResultInfo"].empty()) {
      resultInfo = make_shared<string>(boost::any_cast<string>(m["ResultInfo"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StatusText") != m.end() && !m["StatusText"].empty()) {
      statusText = make_shared<string>(boost::any_cast<string>(m["StatusText"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskImageInfo") != m.end() && !m["TaskImageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskImageInfo"].type()) {
        DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskImageInfo"]));
        taskImageInfo = make_shared<DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo>(model1);
      }
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks() = default;
};
class DescribeOnceTaskLeafRecordPageResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeOnceTaskLeafRecordPageResponseBodyPageInfo() {}

  explicit DescribeOnceTaskLeafRecordPageResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeOnceTaskLeafRecordPageResponseBodyPageInfo() = default;
};
class DescribeOnceTaskLeafRecordPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks>> onceTasks{};
  shared_ptr<DescribeOnceTaskLeafRecordPageResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeOnceTaskLeafRecordPageResponseBody() {}

  explicit DescribeOnceTaskLeafRecordPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onceTasks) {
      vector<boost::any> temp1;
      for(auto item1:*onceTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OnceTasks"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnceTasks") != m.end() && !m["OnceTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["OnceTasks"].type()) {
        vector<DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OnceTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        onceTasks = make_shared<vector<DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeOnceTaskLeafRecordPageResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeOnceTaskLeafRecordPageResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeOnceTaskLeafRecordPageResponseBody() = default;
};
class DescribeOnceTaskLeafRecordPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOnceTaskLeafRecordPageResponseBody> body{};

  DescribeOnceTaskLeafRecordPageResponse() {}

  explicit DescribeOnceTaskLeafRecordPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOnceTaskLeafRecordPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOnceTaskLeafRecordPageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOnceTaskLeafRecordPageResponse() = default;
};
class DescribePropertyCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> uuidList{};

  DescribePropertyCountRequest() {}

  explicit DescribePropertyCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      uuidList = make_shared<string>(boost::any_cast<string>(m["UuidList"]));
    }
  }


  virtual ~DescribePropertyCountRequest() = default;
};
class DescribePropertyCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> autorun{};
  shared_ptr<long> cron{};
  shared_ptr<long> database{};
  shared_ptr<long> lkm{};
  shared_ptr<long> port{};
  shared_ptr<long> process{};
  shared_ptr<string> requestId{};
  shared_ptr<long> sca{};
  shared_ptr<long> software{};
  shared_ptr<long> user{};
  shared_ptr<long> web{};
  shared_ptr<long> webserver{};

  DescribePropertyCountResponseBody() {}

  explicit DescribePropertyCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autorun) {
      res["Autorun"] = boost::any(*autorun);
    }
    if (cron) {
      res["Cron"] = boost::any(*cron);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (lkm) {
      res["Lkm"] = boost::any(*lkm);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sca) {
      res["Sca"] = boost::any(*sca);
    }
    if (software) {
      res["Software"] = boost::any(*software);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (web) {
      res["Web"] = boost::any(*web);
    }
    if (webserver) {
      res["Webserver"] = boost::any(*webserver);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Autorun") != m.end() && !m["Autorun"].empty()) {
      autorun = make_shared<long>(boost::any_cast<long>(m["Autorun"]));
    }
    if (m.find("Cron") != m.end() && !m["Cron"].empty()) {
      cron = make_shared<long>(boost::any_cast<long>(m["Cron"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<long>(boost::any_cast<long>(m["Database"]));
    }
    if (m.find("Lkm") != m.end() && !m["Lkm"].empty()) {
      lkm = make_shared<long>(boost::any_cast<long>(m["Lkm"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<long>(boost::any_cast<long>(m["Process"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sca") != m.end() && !m["Sca"].empty()) {
      sca = make_shared<long>(boost::any_cast<long>(m["Sca"]));
    }
    if (m.find("Software") != m.end() && !m["Software"].empty()) {
      software = make_shared<long>(boost::any_cast<long>(m["Software"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<long>(boost::any_cast<long>(m["User"]));
    }
    if (m.find("Web") != m.end() && !m["Web"].empty()) {
      web = make_shared<long>(boost::any_cast<long>(m["Web"]));
    }
    if (m.find("Webserver") != m.end() && !m["Webserver"].empty()) {
      webserver = make_shared<long>(boost::any_cast<long>(m["Webserver"]));
    }
  }


  virtual ~DescribePropertyCountResponseBody() = default;
};
class DescribePropertyCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyCountResponseBody> body{};

  DescribePropertyCountResponse() {}

  explicit DescribePropertyCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyCountResponse() = default;
};
class DescribePropertyCronDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> extend{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<string> source{};
  shared_ptr<string> user{};
  shared_ptr<string> uuid{};

  DescribePropertyCronDetailRequest() {}

  explicit DescribePropertyCronDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribePropertyCronDetailRequest() = default;
};
class DescribePropertyCronDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyCronDetailResponseBodyPageInfo() {}

  explicit DescribePropertyCronDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyCronDetailResponseBodyPageInfo() = default;
};
class DescribePropertyCronDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> cmd{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> md5{};
  shared_ptr<string> period{};
  shared_ptr<string> source{};
  shared_ptr<string> user{};
  shared_ptr<string> uuid{};

  DescribePropertyCronDetailResponseBodyPropertys() {}

  explicit DescribePropertyCronDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cmd) {
      res["Cmd"] = boost::any(*cmd);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cmd") != m.end() && !m["Cmd"].empty()) {
      cmd = make_shared<string>(boost::any_cast<string>(m["Cmd"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribePropertyCronDetailResponseBodyPropertys() = default;
};
class DescribePropertyCronDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyCronDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyCronDetailResponseBodyPropertys>> propertys{};
  shared_ptr<string> requestId{};

  DescribePropertyCronDetailResponseBody() {}

  explicit DescribePropertyCronDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyCronDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyCronDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertyCronDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyCronDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertyCronDetailResponseBodyPropertys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyCronDetailResponseBody() = default;
};
class DescribePropertyCronDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyCronDetailResponseBody> body{};

  DescribePropertyCronDetailResponse() {}

  explicit DescribePropertyCronDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyCronDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyCronDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyCronDetailResponse() = default;
};
class DescribePropertyCronItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<bool> forceFlush{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> source{};

  DescribePropertyCronItemRequest() {}

  explicit DescribePropertyCronItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~DescribePropertyCronItemRequest() = default;
};
class DescribePropertyCronItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyCronItemResponseBodyPageInfo() {}

  explicit DescribePropertyCronItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyCronItemResponseBodyPageInfo() = default;
};
class DescribePropertyCronItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> source{};

  DescribePropertyCronItemResponseBodyPropertyItems() {}

  explicit DescribePropertyCronItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~DescribePropertyCronItemResponseBodyPropertyItems() = default;
};
class DescribePropertyCronItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyCronItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyCronItemResponseBodyPropertyItems>> propertyItems{};
  shared_ptr<string> requestId{};

  DescribePropertyCronItemResponseBody() {}

  explicit DescribePropertyCronItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyCronItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyCronItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<DescribePropertyCronItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyCronItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<DescribePropertyCronItemResponseBodyPropertyItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyCronItemResponseBody() = default;
};
class DescribePropertyCronItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyCronItemResponseBody> body{};

  DescribePropertyCronItemResponse() {}

  explicit DescribePropertyCronItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyCronItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyCronItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyCronItemResponse() = default;
};
class DescribePropertyPortDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bindIp{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> extend{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> port{};
  shared_ptr<string> procName{};
  shared_ptr<string> remark{};
  shared_ptr<string> uuid{};

  DescribePropertyPortDetailRequest() {}

  explicit DescribePropertyPortDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindIp) {
      res["BindIp"] = boost::any(*bindIp);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (procName) {
      res["ProcName"] = boost::any(*procName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindIp") != m.end() && !m["BindIp"].empty()) {
      bindIp = make_shared<string>(boost::any_cast<string>(m["BindIp"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ProcName") != m.end() && !m["ProcName"].empty()) {
      procName = make_shared<string>(boost::any_cast<string>(m["ProcName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribePropertyPortDetailRequest() = default;
};
class DescribePropertyPortDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyPortDetailResponseBodyPageInfo() {}

  explicit DescribePropertyPortDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyPortDetailResponseBodyPageInfo() = default;
};
class DescribePropertyPortDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> bindIp{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> pid{};
  shared_ptr<string> port{};
  shared_ptr<string> procName{};
  shared_ptr<string> proto{};
  shared_ptr<string> uuid{};

  DescribePropertyPortDetailResponseBodyPropertys() {}

  explicit DescribePropertyPortDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindIp) {
      res["BindIp"] = boost::any(*bindIp);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (procName) {
      res["ProcName"] = boost::any(*procName);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindIp") != m.end() && !m["BindIp"].empty()) {
      bindIp = make_shared<string>(boost::any_cast<string>(m["BindIp"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ProcName") != m.end() && !m["ProcName"].empty()) {
      procName = make_shared<string>(boost::any_cast<string>(m["ProcName"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribePropertyPortDetailResponseBodyPropertys() = default;
};
class DescribePropertyPortDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyPortDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyPortDetailResponseBodyPropertys>> propertys{};
  shared_ptr<string> requestId{};

  DescribePropertyPortDetailResponseBody() {}

  explicit DescribePropertyPortDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyPortDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyPortDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertyPortDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyPortDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertyPortDetailResponseBodyPropertys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyPortDetailResponseBody() = default;
};
class DescribePropertyPortDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyPortDetailResponseBody> body{};

  DescribePropertyPortDetailResponse() {}

  explicit DescribePropertyPortDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyPortDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyPortDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyPortDetailResponse() = default;
};
class DescribePropertyPortItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<bool> forceFlush{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> port{};

  DescribePropertyPortItemRequest() {}

  explicit DescribePropertyPortItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
  }


  virtual ~DescribePropertyPortItemRequest() = default;
};
class DescribePropertyPortItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyPortItemResponseBodyPageInfo() {}

  explicit DescribePropertyPortItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyPortItemResponseBodyPageInfo() = default;
};
class DescribePropertyPortItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> port{};
  shared_ptr<string> proto{};

  DescribePropertyPortItemResponseBodyPropertyItems() {}

  explicit DescribePropertyPortItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
  }


  virtual ~DescribePropertyPortItemResponseBodyPropertyItems() = default;
};
class DescribePropertyPortItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyPortItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyPortItemResponseBodyPropertyItems>> propertyItems{};
  shared_ptr<string> requestId{};

  DescribePropertyPortItemResponseBody() {}

  explicit DescribePropertyPortItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyPortItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyPortItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<DescribePropertyPortItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyPortItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<DescribePropertyPortItemResponseBodyPropertyItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyPortItemResponseBody() = default;
};
class DescribePropertyPortItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyPortItemResponseBody> body{};

  DescribePropertyPortItemResponse() {}

  explicit DescribePropertyPortItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyPortItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyPortItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyPortItemResponse() = default;
};
class DescribePropertyProcDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> cmdline{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> extend{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> procTimeEnd{};
  shared_ptr<long> procTimeStart{};
  shared_ptr<string> remark{};
  shared_ptr<string> user{};
  shared_ptr<string> uuid{};

  DescribePropertyProcDetailRequest() {}

  explicit DescribePropertyProcDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cmdline) {
      res["Cmdline"] = boost::any(*cmdline);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (procTimeEnd) {
      res["ProcTimeEnd"] = boost::any(*procTimeEnd);
    }
    if (procTimeStart) {
      res["ProcTimeStart"] = boost::any(*procTimeStart);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cmdline") != m.end() && !m["Cmdline"].empty()) {
      cmdline = make_shared<string>(boost::any_cast<string>(m["Cmdline"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProcTimeEnd") != m.end() && !m["ProcTimeEnd"].empty()) {
      procTimeEnd = make_shared<long>(boost::any_cast<long>(m["ProcTimeEnd"]));
    }
    if (m.find("ProcTimeStart") != m.end() && !m["ProcTimeStart"].empty()) {
      procTimeStart = make_shared<long>(boost::any_cast<long>(m["ProcTimeStart"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribePropertyProcDetailRequest() = default;
};
class DescribePropertyProcDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyProcDetailResponseBodyPageInfo() {}

  explicit DescribePropertyProcDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyProcDetailResponseBodyPageInfo() = default;
};
class DescribePropertyProcDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> cmdline{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> euidName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> isPackage{};
  shared_ptr<string> md5{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> pid{};
  shared_ptr<string> pname{};
  shared_ptr<string> startTime{};
  shared_ptr<long> startTimeDt{};
  shared_ptr<string> state{};
  shared_ptr<string> user{};
  shared_ptr<string> uuid{};

  DescribePropertyProcDetailResponseBodyPropertys() {}

  explicit DescribePropertyProcDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cmdline) {
      res["Cmdline"] = boost::any(*cmdline);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (euidName) {
      res["EuidName"] = boost::any(*euidName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (isPackage) {
      res["IsPackage"] = boost::any(*isPackage);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (pname) {
      res["Pname"] = boost::any(*pname);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (startTimeDt) {
      res["StartTimeDt"] = boost::any(*startTimeDt);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cmdline") != m.end() && !m["Cmdline"].empty()) {
      cmdline = make_shared<string>(boost::any_cast<string>(m["Cmdline"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("EuidName") != m.end() && !m["EuidName"].empty()) {
      euidName = make_shared<string>(boost::any_cast<string>(m["EuidName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("IsPackage") != m.end() && !m["IsPackage"].empty()) {
      isPackage = make_shared<long>(boost::any_cast<long>(m["IsPackage"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Pname") != m.end() && !m["Pname"].empty()) {
      pname = make_shared<string>(boost::any_cast<string>(m["Pname"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StartTimeDt") != m.end() && !m["StartTimeDt"].empty()) {
      startTimeDt = make_shared<long>(boost::any_cast<long>(m["StartTimeDt"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribePropertyProcDetailResponseBodyPropertys() = default;
};
class DescribePropertyProcDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyProcDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyProcDetailResponseBodyPropertys>> propertys{};
  shared_ptr<string> requestId{};

  DescribePropertyProcDetailResponseBody() {}

  explicit DescribePropertyProcDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyProcDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyProcDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertyProcDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyProcDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertyProcDetailResponseBodyPropertys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyProcDetailResponseBody() = default;
};
class DescribePropertyProcDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyProcDetailResponseBody> body{};

  DescribePropertyProcDetailResponse() {}

  explicit DescribePropertyProcDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyProcDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyProcDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyProcDetailResponse() = default;
};
class DescribePropertyProcItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<bool> forceFlush{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};

  DescribePropertyProcItemRequest() {}

  explicit DescribePropertyProcItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertyProcItemRequest() = default;
};
class DescribePropertyProcItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyProcItemResponseBodyPageInfo() {}

  explicit DescribePropertyProcItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyProcItemResponseBodyPageInfo() = default;
};
class DescribePropertyProcItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> name{};

  DescribePropertyProcItemResponseBodyPropertyItems() {}

  explicit DescribePropertyProcItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribePropertyProcItemResponseBodyPropertyItems() = default;
};
class DescribePropertyProcItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyProcItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyProcItemResponseBodyPropertyItems>> propertyItems{};
  shared_ptr<string> requestId{};

  DescribePropertyProcItemResponseBody() {}

  explicit DescribePropertyProcItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyProcItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyProcItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<DescribePropertyProcItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyProcItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<DescribePropertyProcItemResponseBodyPropertyItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyProcItemResponseBody() = default;
};
class DescribePropertyProcItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyProcItemResponseBody> body{};

  DescribePropertyProcItemResponse() {}

  explicit DescribePropertyProcItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyProcItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyProcItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyProcItemResponse() = default;
};
class DescribePropertyScaDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<string> bizType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<long> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pid{};
  shared_ptr<string> port{};
  shared_ptr<long> processStartedEnd{};
  shared_ptr<long> processStartedStart{};
  shared_ptr<string> remark{};
  shared_ptr<string> scaName{};
  shared_ptr<string> scaNamePattern{};
  shared_ptr<string> scaVersion{};
  shared_ptr<string> searchInfo{};
  shared_ptr<string> searchInfoSub{};
  shared_ptr<string> searchItem{};
  shared_ptr<string> searchItemSub{};
  shared_ptr<string> user{};
  shared_ptr<string> uuid{};

  DescribePropertyScaDetailRequest() {}

  explicit DescribePropertyScaDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (processStartedEnd) {
      res["ProcessStartedEnd"] = boost::any(*processStartedEnd);
    }
    if (processStartedStart) {
      res["ProcessStartedStart"] = boost::any(*processStartedStart);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (scaName) {
      res["ScaName"] = boost::any(*scaName);
    }
    if (scaNamePattern) {
      res["ScaNamePattern"] = boost::any(*scaNamePattern);
    }
    if (scaVersion) {
      res["ScaVersion"] = boost::any(*scaVersion);
    }
    if (searchInfo) {
      res["SearchInfo"] = boost::any(*searchInfo);
    }
    if (searchInfoSub) {
      res["SearchInfoSub"] = boost::any(*searchInfoSub);
    }
    if (searchItem) {
      res["SearchItem"] = boost::any(*searchItem);
    }
    if (searchItemSub) {
      res["SearchItemSub"] = boost::any(*searchItemSub);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<long>(boost::any_cast<long>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ProcessStartedEnd") != m.end() && !m["ProcessStartedEnd"].empty()) {
      processStartedEnd = make_shared<long>(boost::any_cast<long>(m["ProcessStartedEnd"]));
    }
    if (m.find("ProcessStartedStart") != m.end() && !m["ProcessStartedStart"].empty()) {
      processStartedStart = make_shared<long>(boost::any_cast<long>(m["ProcessStartedStart"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ScaName") != m.end() && !m["ScaName"].empty()) {
      scaName = make_shared<string>(boost::any_cast<string>(m["ScaName"]));
    }
    if (m.find("ScaNamePattern") != m.end() && !m["ScaNamePattern"].empty()) {
      scaNamePattern = make_shared<string>(boost::any_cast<string>(m["ScaNamePattern"]));
    }
    if (m.find("ScaVersion") != m.end() && !m["ScaVersion"].empty()) {
      scaVersion = make_shared<string>(boost::any_cast<string>(m["ScaVersion"]));
    }
    if (m.find("SearchInfo") != m.end() && !m["SearchInfo"].empty()) {
      searchInfo = make_shared<string>(boost::any_cast<string>(m["SearchInfo"]));
    }
    if (m.find("SearchInfoSub") != m.end() && !m["SearchInfoSub"].empty()) {
      searchInfoSub = make_shared<string>(boost::any_cast<string>(m["SearchInfoSub"]));
    }
    if (m.find("SearchItem") != m.end() && !m["SearchItem"].empty()) {
      searchItem = make_shared<string>(boost::any_cast<string>(m["SearchItem"]));
    }
    if (m.find("SearchItemSub") != m.end() && !m["SearchItemSub"].empty()) {
      searchItemSub = make_shared<string>(boost::any_cast<string>(m["SearchItemSub"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribePropertyScaDetailRequest() = default;
};
class DescribePropertyScaDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyScaDetailResponseBodyPageInfo() {}

  explicit DescribePropertyScaDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyScaDetailResponseBodyPageInfo() = default;
};
class DescribePropertyScaDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> bizTypeDispaly{};
  shared_ptr<string> cmdline{};
  shared_ptr<string> configPath{};
  shared_ptr<string> containerName{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> imageName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> listenIp{};
  shared_ptr<string> listenProtocol{};
  shared_ptr<string> listenStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> pid{};
  shared_ptr<string> port{};
  shared_ptr<string> ppid{};
  shared_ptr<long> processStarted{};
  shared_ptr<string> processUser{};
  shared_ptr<string> proof{};
  shared_ptr<string> runtimeEnvVersion{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<string> version{};
  shared_ptr<string> webPath{};

  DescribePropertyScaDetailResponseBodyPropertys() {}

  explicit DescribePropertyScaDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (bizTypeDispaly) {
      res["BizTypeDispaly"] = boost::any(*bizTypeDispaly);
    }
    if (cmdline) {
      res["Cmdline"] = boost::any(*cmdline);
    }
    if (configPath) {
      res["ConfigPath"] = boost::any(*configPath);
    }
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (listenIp) {
      res["ListenIp"] = boost::any(*listenIp);
    }
    if (listenProtocol) {
      res["ListenProtocol"] = boost::any(*listenProtocol);
    }
    if (listenStatus) {
      res["ListenStatus"] = boost::any(*listenStatus);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (ppid) {
      res["Ppid"] = boost::any(*ppid);
    }
    if (processStarted) {
      res["ProcessStarted"] = boost::any(*processStarted);
    }
    if (processUser) {
      res["ProcessUser"] = boost::any(*processUser);
    }
    if (proof) {
      res["Proof"] = boost::any(*proof);
    }
    if (runtimeEnvVersion) {
      res["RuntimeEnvVersion"] = boost::any(*runtimeEnvVersion);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (webPath) {
      res["WebPath"] = boost::any(*webPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("BizTypeDispaly") != m.end() && !m["BizTypeDispaly"].empty()) {
      bizTypeDispaly = make_shared<string>(boost::any_cast<string>(m["BizTypeDispaly"]));
    }
    if (m.find("Cmdline") != m.end() && !m["Cmdline"].empty()) {
      cmdline = make_shared<string>(boost::any_cast<string>(m["Cmdline"]));
    }
    if (m.find("ConfigPath") != m.end() && !m["ConfigPath"].empty()) {
      configPath = make_shared<string>(boost::any_cast<string>(m["ConfigPath"]));
    }
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("ListenIp") != m.end() && !m["ListenIp"].empty()) {
      listenIp = make_shared<string>(boost::any_cast<string>(m["ListenIp"]));
    }
    if (m.find("ListenProtocol") != m.end() && !m["ListenProtocol"].empty()) {
      listenProtocol = make_shared<string>(boost::any_cast<string>(m["ListenProtocol"]));
    }
    if (m.find("ListenStatus") != m.end() && !m["ListenStatus"].empty()) {
      listenStatus = make_shared<string>(boost::any_cast<string>(m["ListenStatus"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Ppid") != m.end() && !m["Ppid"].empty()) {
      ppid = make_shared<string>(boost::any_cast<string>(m["Ppid"]));
    }
    if (m.find("ProcessStarted") != m.end() && !m["ProcessStarted"].empty()) {
      processStarted = make_shared<long>(boost::any_cast<long>(m["ProcessStarted"]));
    }
    if (m.find("ProcessUser") != m.end() && !m["ProcessUser"].empty()) {
      processUser = make_shared<string>(boost::any_cast<string>(m["ProcessUser"]));
    }
    if (m.find("Proof") != m.end() && !m["Proof"].empty()) {
      proof = make_shared<string>(boost::any_cast<string>(m["Proof"]));
    }
    if (m.find("RuntimeEnvVersion") != m.end() && !m["RuntimeEnvVersion"].empty()) {
      runtimeEnvVersion = make_shared<string>(boost::any_cast<string>(m["RuntimeEnvVersion"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("WebPath") != m.end() && !m["WebPath"].empty()) {
      webPath = make_shared<string>(boost::any_cast<string>(m["WebPath"]));
    }
  }


  virtual ~DescribePropertyScaDetailResponseBodyPropertys() = default;
};
class DescribePropertyScaDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyScaDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyScaDetailResponseBodyPropertys>> propertys{};
  shared_ptr<string> requestId{};

  DescribePropertyScaDetailResponseBody() {}

  explicit DescribePropertyScaDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyScaDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyScaDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertyScaDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyScaDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertyScaDetailResponseBodyPropertys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyScaDetailResponseBody() = default;
};
class DescribePropertyScaDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyScaDetailResponseBody> body{};

  DescribePropertyScaDetailResponse() {}

  explicit DescribePropertyScaDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyScaDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyScaDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyScaDetailResponse() = default;
};
class DescribePropertyScaItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<long> currentPage{};
  shared_ptr<bool> forceFlush{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchInfo{};
  shared_ptr<string> searchItem{};

  DescribePropertyScaItemRequest() {}

  explicit DescribePropertyScaItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchInfo) {
      res["SearchInfo"] = boost::any(*searchInfo);
    }
    if (searchItem) {
      res["SearchItem"] = boost::any(*searchItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchInfo") != m.end() && !m["SearchInfo"].empty()) {
      searchInfo = make_shared<string>(boost::any_cast<string>(m["SearchInfo"]));
    }
    if (m.find("SearchItem") != m.end() && !m["SearchItem"].empty()) {
      searchItem = make_shared<string>(boost::any_cast<string>(m["SearchItem"]));
    }
  }


  virtual ~DescribePropertyScaItemRequest() = default;
};
class DescribePropertyScaItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyScaItemResponseBodyPageInfo() {}

  explicit DescribePropertyScaItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyScaItemResponseBodyPageInfo() = default;
};
class DescribePropertyScaItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> count{};
  shared_ptr<string> name{};
  shared_ptr<string> typeDisplay{};

  DescribePropertyScaItemResponseBodyPropertyItems() {}

  explicit DescribePropertyScaItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (typeDisplay) {
      res["TypeDisplay"] = boost::any(*typeDisplay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TypeDisplay") != m.end() && !m["TypeDisplay"].empty()) {
      typeDisplay = make_shared<string>(boost::any_cast<string>(m["TypeDisplay"]));
    }
  }


  virtual ~DescribePropertyScaItemResponseBodyPropertyItems() = default;
};
class DescribePropertyScaItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyScaItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyScaItemResponseBodyPropertyItems>> propertyItems{};
  shared_ptr<string> requestId{};

  DescribePropertyScaItemResponseBody() {}

  explicit DescribePropertyScaItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyScaItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyScaItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<DescribePropertyScaItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyScaItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<DescribePropertyScaItemResponseBodyPropertyItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyScaItemResponseBody() = default;
};
class DescribePropertyScaItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyScaItemResponseBody> body{};

  DescribePropertyScaItemResponse() {}

  explicit DescribePropertyScaItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyScaItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyScaItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyScaItemResponse() = default;
};
class DescribePropertyScheduleConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  DescribePropertyScheduleConfigRequest() {}

  explicit DescribePropertyScheduleConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePropertyScheduleConfigRequest() = default;
};
class DescribePropertyScheduleConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> requestId{};

  DescribePropertyScheduleConfigResponseBody() {}

  explicit DescribePropertyScheduleConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyScheduleConfigResponseBody() = default;
};
class DescribePropertyScheduleConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyScheduleConfigResponseBody> body{};

  DescribePropertyScheduleConfigResponse() {}

  explicit DescribePropertyScheduleConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyScheduleConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyScheduleConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyScheduleConfigResponse() = default;
};
class DescribePropertySoftwareDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> extend{};
  shared_ptr<long> installTimeEnd{};
  shared_ptr<long> installTimeStart{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> remark{};
  shared_ptr<string> softwareVersion{};
  shared_ptr<string> uuid{};

  DescribePropertySoftwareDetailRequest() {}

  explicit DescribePropertySoftwareDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (installTimeEnd) {
      res["InstallTimeEnd"] = boost::any(*installTimeEnd);
    }
    if (installTimeStart) {
      res["InstallTimeStart"] = boost::any(*installTimeStart);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (softwareVersion) {
      res["SoftwareVersion"] = boost::any(*softwareVersion);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("InstallTimeEnd") != m.end() && !m["InstallTimeEnd"].empty()) {
      installTimeEnd = make_shared<long>(boost::any_cast<long>(m["InstallTimeEnd"]));
    }
    if (m.find("InstallTimeStart") != m.end() && !m["InstallTimeStart"].empty()) {
      installTimeStart = make_shared<long>(boost::any_cast<long>(m["InstallTimeStart"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SoftwareVersion") != m.end() && !m["SoftwareVersion"].empty()) {
      softwareVersion = make_shared<string>(boost::any_cast<string>(m["SoftwareVersion"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribePropertySoftwareDetailRequest() = default;
};
class DescribePropertySoftwareDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertySoftwareDetailResponseBodyPageInfo() {}

  explicit DescribePropertySoftwareDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertySoftwareDetailResponseBodyPageInfo() = default;
};
class DescribePropertySoftwareDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> installTime{};
  shared_ptr<long> installTimeDt{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> uuid{};
  shared_ptr<string> version{};

  DescribePropertySoftwareDetailResponseBodyPropertys() {}

  explicit DescribePropertySoftwareDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (installTime) {
      res["InstallTime"] = boost::any(*installTime);
    }
    if (installTimeDt) {
      res["InstallTimeDt"] = boost::any(*installTimeDt);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("InstallTime") != m.end() && !m["InstallTime"].empty()) {
      installTime = make_shared<string>(boost::any_cast<string>(m["InstallTime"]));
    }
    if (m.find("InstallTimeDt") != m.end() && !m["InstallTimeDt"].empty()) {
      installTimeDt = make_shared<long>(boost::any_cast<long>(m["InstallTimeDt"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribePropertySoftwareDetailResponseBodyPropertys() = default;
};
class DescribePropertySoftwareDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertySoftwareDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertySoftwareDetailResponseBodyPropertys>> propertys{};
  shared_ptr<string> requestId{};

  DescribePropertySoftwareDetailResponseBody() {}

  explicit DescribePropertySoftwareDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertySoftwareDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertySoftwareDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertySoftwareDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertySoftwareDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertySoftwareDetailResponseBodyPropertys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertySoftwareDetailResponseBody() = default;
};
class DescribePropertySoftwareDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertySoftwareDetailResponseBody> body{};

  DescribePropertySoftwareDetailResponse() {}

  explicit DescribePropertySoftwareDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertySoftwareDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertySoftwareDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertySoftwareDetailResponse() = default;
};
class DescribePropertySoftwareItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<bool> forceFlush{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};

  DescribePropertySoftwareItemRequest() {}

  explicit DescribePropertySoftwareItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertySoftwareItemRequest() = default;
};
class DescribePropertySoftwareItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertySoftwareItemResponseBodyPageInfo() {}

  explicit DescribePropertySoftwareItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertySoftwareItemResponseBodyPageInfo() = default;
};
class DescribePropertySoftwareItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> name{};

  DescribePropertySoftwareItemResponseBodyPropertyItems() {}

  explicit DescribePropertySoftwareItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribePropertySoftwareItemResponseBodyPropertyItems() = default;
};
class DescribePropertySoftwareItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertySoftwareItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertySoftwareItemResponseBodyPropertyItems>> propertyItems{};
  shared_ptr<string> requestId{};

  DescribePropertySoftwareItemResponseBody() {}

  explicit DescribePropertySoftwareItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertySoftwareItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertySoftwareItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<DescribePropertySoftwareItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertySoftwareItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<DescribePropertySoftwareItemResponseBodyPropertyItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertySoftwareItemResponseBody() = default;
};
class DescribePropertySoftwareItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertySoftwareItemResponseBody> body{};

  DescribePropertySoftwareItemResponse() {}

  explicit DescribePropertySoftwareItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertySoftwareItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertySoftwareItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertySoftwareItemResponse() = default;
};
class DescribePropertyTypeScaItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};

  DescribePropertyTypeScaItemRequest() {}

  explicit DescribePropertyTypeScaItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePropertyTypeScaItemRequest() = default;
};
class DescribePropertyTypeScaItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyTypeScaItemResponseBodyPageInfo() {}

  explicit DescribePropertyTypeScaItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyTypeScaItemResponseBodyPageInfo() = default;
};
class DescribePropertyTypeScaItemResponseBodyPropertyTypeItems : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribePropertyTypeScaItemResponseBodyPropertyTypeItems() {}

  explicit DescribePropertyTypeScaItemResponseBodyPropertyTypeItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePropertyTypeScaItemResponseBodyPropertyTypeItems() = default;
};
class DescribePropertyTypeScaItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyTypeScaItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyTypeScaItemResponseBodyPropertyTypeItems>> propertyTypeItems{};
  shared_ptr<string> requestId{};

  DescribePropertyTypeScaItemResponseBody() {}

  explicit DescribePropertyTypeScaItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyTypeItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyTypeItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyTypeItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyTypeScaItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyTypeScaItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyTypeItems") != m.end() && !m["PropertyTypeItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyTypeItems"].type()) {
        vector<DescribePropertyTypeScaItemResponseBodyPropertyTypeItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyTypeItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyTypeScaItemResponseBodyPropertyTypeItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyTypeItems = make_shared<vector<DescribePropertyTypeScaItemResponseBodyPropertyTypeItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyTypeScaItemResponseBody() = default;
};
class DescribePropertyTypeScaItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyTypeScaItemResponseBody> body{};

  DescribePropertyTypeScaItemResponse() {}

  explicit DescribePropertyTypeScaItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyTypeScaItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyTypeScaItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyTypeScaItemResponse() = default;
};
class DescribePropertyUsageNewestRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  DescribePropertyUsageNewestRequest() {}

  explicit DescribePropertyUsageNewestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePropertyUsageNewestRequest() = default;
};
class DescribePropertyUsageNewestResponseBodyNewestStatisticItems : public Darabonba::Model {
public:
  shared_ptr<long> create{};
  shared_ptr<string> name{};

  DescribePropertyUsageNewestResponseBodyNewestStatisticItems() {}

  explicit DescribePropertyUsageNewestResponseBodyNewestStatisticItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (create) {
      res["Create"] = boost::any(*create);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Create") != m.end() && !m["Create"].empty()) {
      create = make_shared<long>(boost::any_cast<long>(m["Create"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribePropertyUsageNewestResponseBodyNewestStatisticItems() = default;
};
class DescribePropertyUsageNewestResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> itemCount{};
  shared_ptr<vector<DescribePropertyUsageNewestResponseBodyNewestStatisticItems>> newestStatisticItems{};
  shared_ptr<string> requestId{};
  shared_ptr<string> type{};

  DescribePropertyUsageNewestResponseBody() {}

  explicit DescribePropertyUsageNewestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemCount) {
      res["ItemCount"] = boost::any(*itemCount);
    }
    if (newestStatisticItems) {
      vector<boost::any> temp1;
      for(auto item1:*newestStatisticItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NewestStatisticItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemCount") != m.end() && !m["ItemCount"].empty()) {
      itemCount = make_shared<long>(boost::any_cast<long>(m["ItemCount"]));
    }
    if (m.find("NewestStatisticItems") != m.end() && !m["NewestStatisticItems"].empty()) {
      if (typeid(vector<boost::any>) == m["NewestStatisticItems"].type()) {
        vector<DescribePropertyUsageNewestResponseBodyNewestStatisticItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NewestStatisticItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyUsageNewestResponseBodyNewestStatisticItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        newestStatisticItems = make_shared<vector<DescribePropertyUsageNewestResponseBodyNewestStatisticItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribePropertyUsageNewestResponseBody() = default;
};
class DescribePropertyUsageNewestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyUsageNewestResponseBody> body{};

  DescribePropertyUsageNewestResponse() {}

  explicit DescribePropertyUsageNewestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyUsageNewestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyUsageNewestResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyUsageNewestResponse() = default;
};
class DescribePropertyUserDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> extend{};
  shared_ptr<string> isRoot{};
  shared_ptr<long> lastLoginTimeEnd{};
  shared_ptr<long> lastLoginTimeStart{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<string> user{};
  shared_ptr<string> uuid{};

  DescribePropertyUserDetailRequest() {}

  explicit DescribePropertyUserDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (isRoot) {
      res["IsRoot"] = boost::any(*isRoot);
    }
    if (lastLoginTimeEnd) {
      res["LastLoginTimeEnd"] = boost::any(*lastLoginTimeEnd);
    }
    if (lastLoginTimeStart) {
      res["LastLoginTimeStart"] = boost::any(*lastLoginTimeStart);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("IsRoot") != m.end() && !m["IsRoot"].empty()) {
      isRoot = make_shared<string>(boost::any_cast<string>(m["IsRoot"]));
    }
    if (m.find("LastLoginTimeEnd") != m.end() && !m["LastLoginTimeEnd"].empty()) {
      lastLoginTimeEnd = make_shared<long>(boost::any_cast<long>(m["LastLoginTimeEnd"]));
    }
    if (m.find("LastLoginTimeStart") != m.end() && !m["LastLoginTimeStart"].empty()) {
      lastLoginTimeStart = make_shared<long>(boost::any_cast<long>(m["LastLoginTimeStart"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribePropertyUserDetailRequest() = default;
};
class DescribePropertyUserDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyUserDetailResponseBodyPageInfo() {}

  explicit DescribePropertyUserDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyUserDetailResponseBodyPageInfo() = default;
};
class DescribePropertyUserDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> accountsExpirationDate{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<vector<string>> groupNames{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<long> isCouldLogin{};
  shared_ptr<long> isPasswdExpired{};
  shared_ptr<long> isPasswdLocked{};
  shared_ptr<string> isRoot{};
  shared_ptr<long> isSudoer{};
  shared_ptr<long> isUserExpired{};
  shared_ptr<string> lastLoginIp{};
  shared_ptr<string> lastLoginTime{};
  shared_ptr<long> lastLoginTimeDt{};
  shared_ptr<long> lastLoginTimestamp{};
  shared_ptr<string> passwordExpirationDate{};
  shared_ptr<string> status{};
  shared_ptr<string> user{};
  shared_ptr<string> uuid{};

  DescribePropertyUserDetailResponseBodyPropertys() {}

  explicit DescribePropertyUserDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountsExpirationDate) {
      res["AccountsExpirationDate"] = boost::any(*accountsExpirationDate);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (groupNames) {
      res["GroupNames"] = boost::any(*groupNames);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (isCouldLogin) {
      res["IsCouldLogin"] = boost::any(*isCouldLogin);
    }
    if (isPasswdExpired) {
      res["IsPasswdExpired"] = boost::any(*isPasswdExpired);
    }
    if (isPasswdLocked) {
      res["IsPasswdLocked"] = boost::any(*isPasswdLocked);
    }
    if (isRoot) {
      res["IsRoot"] = boost::any(*isRoot);
    }
    if (isSudoer) {
      res["IsSudoer"] = boost::any(*isSudoer);
    }
    if (isUserExpired) {
      res["IsUserExpired"] = boost::any(*isUserExpired);
    }
    if (lastLoginIp) {
      res["LastLoginIp"] = boost::any(*lastLoginIp);
    }
    if (lastLoginTime) {
      res["LastLoginTime"] = boost::any(*lastLoginTime);
    }
    if (lastLoginTimeDt) {
      res["LastLoginTimeDt"] = boost::any(*lastLoginTimeDt);
    }
    if (lastLoginTimestamp) {
      res["LastLoginTimestamp"] = boost::any(*lastLoginTimestamp);
    }
    if (passwordExpirationDate) {
      res["PasswordExpirationDate"] = boost::any(*passwordExpirationDate);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountsExpirationDate") != m.end() && !m["AccountsExpirationDate"].empty()) {
      accountsExpirationDate = make_shared<string>(boost::any_cast<string>(m["AccountsExpirationDate"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("GroupNames") != m.end() && !m["GroupNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("IsCouldLogin") != m.end() && !m["IsCouldLogin"].empty()) {
      isCouldLogin = make_shared<long>(boost::any_cast<long>(m["IsCouldLogin"]));
    }
    if (m.find("IsPasswdExpired") != m.end() && !m["IsPasswdExpired"].empty()) {
      isPasswdExpired = make_shared<long>(boost::any_cast<long>(m["IsPasswdExpired"]));
    }
    if (m.find("IsPasswdLocked") != m.end() && !m["IsPasswdLocked"].empty()) {
      isPasswdLocked = make_shared<long>(boost::any_cast<long>(m["IsPasswdLocked"]));
    }
    if (m.find("IsRoot") != m.end() && !m["IsRoot"].empty()) {
      isRoot = make_shared<string>(boost::any_cast<string>(m["IsRoot"]));
    }
    if (m.find("IsSudoer") != m.end() && !m["IsSudoer"].empty()) {
      isSudoer = make_shared<long>(boost::any_cast<long>(m["IsSudoer"]));
    }
    if (m.find("IsUserExpired") != m.end() && !m["IsUserExpired"].empty()) {
      isUserExpired = make_shared<long>(boost::any_cast<long>(m["IsUserExpired"]));
    }
    if (m.find("LastLoginIp") != m.end() && !m["LastLoginIp"].empty()) {
      lastLoginIp = make_shared<string>(boost::any_cast<string>(m["LastLoginIp"]));
    }
    if (m.find("LastLoginTime") != m.end() && !m["LastLoginTime"].empty()) {
      lastLoginTime = make_shared<string>(boost::any_cast<string>(m["LastLoginTime"]));
    }
    if (m.find("LastLoginTimeDt") != m.end() && !m["LastLoginTimeDt"].empty()) {
      lastLoginTimeDt = make_shared<long>(boost::any_cast<long>(m["LastLoginTimeDt"]));
    }
    if (m.find("LastLoginTimestamp") != m.end() && !m["LastLoginTimestamp"].empty()) {
      lastLoginTimestamp = make_shared<long>(boost::any_cast<long>(m["LastLoginTimestamp"]));
    }
    if (m.find("PasswordExpirationDate") != m.end() && !m["PasswordExpirationDate"].empty()) {
      passwordExpirationDate = make_shared<string>(boost::any_cast<string>(m["PasswordExpirationDate"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribePropertyUserDetailResponseBodyPropertys() = default;
};
class DescribePropertyUserDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyUserDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyUserDetailResponseBodyPropertys>> propertys{};
  shared_ptr<string> requestId{};

  DescribePropertyUserDetailResponseBody() {}

  explicit DescribePropertyUserDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyUserDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyUserDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<DescribePropertyUserDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyUserDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<DescribePropertyUserDetailResponseBodyPropertys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyUserDetailResponseBody() = default;
};
class DescribePropertyUserDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyUserDetailResponseBody> body{};

  DescribePropertyUserDetailResponse() {}

  explicit DescribePropertyUserDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyUserDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyUserDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyUserDetailResponse() = default;
};
class DescribePropertyUserItemRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<bool> forceFlush{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> user{};

  DescribePropertyUserItemRequest() {}

  explicit DescribePropertyUserItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~DescribePropertyUserItemRequest() = default;
};
class DescribePropertyUserItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribePropertyUserItemResponseBodyPageInfo() {}

  explicit DescribePropertyUserItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePropertyUserItemResponseBodyPageInfo() = default;
};
class DescribePropertyUserItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> user{};

  DescribePropertyUserItemResponseBodyPropertyItems() {}

  explicit DescribePropertyUserItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~DescribePropertyUserItemResponseBodyPropertyItems() = default;
};
class DescribePropertyUserItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePropertyUserItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<DescribePropertyUserItemResponseBodyPropertyItems>> propertyItems{};
  shared_ptr<string> requestId{};

  DescribePropertyUserItemResponseBody() {}

  explicit DescribePropertyUserItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribePropertyUserItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribePropertyUserItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<DescribePropertyUserItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePropertyUserItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<DescribePropertyUserItemResponseBodyPropertyItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePropertyUserItemResponseBody() = default;
};
class DescribePropertyUserItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePropertyUserItemResponseBody> body{};

  DescribePropertyUserItemResponse() {}

  explicit DescribePropertyUserItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePropertyUserItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePropertyUserItemResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePropertyUserItemResponse() = default;
};
class DescribeQuaraFileDownloadInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<long> quaraFileId{};

  DescribeQuaraFileDownloadInfoRequest() {}

  explicit DescribeQuaraFileDownloadInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (quaraFileId) {
      res["QuaraFileId"] = boost::any(*quaraFileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("QuaraFileId") != m.end() && !m["QuaraFileId"].empty()) {
      quaraFileId = make_shared<long>(boost::any_cast<long>(m["QuaraFileId"]));
    }
  }


  virtual ~DescribeQuaraFileDownloadInfoRequest() = default;
};
class DescribeQuaraFileDownloadInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> md5{};
  shared_ptr<string> path{};
  shared_ptr<long> quaraFileId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> tag{};
  shared_ptr<string> uuid{};

  DescribeQuaraFileDownloadInfoResponseBody() {}

  explicit DescribeQuaraFileDownloadInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (quaraFileId) {
      res["QuaraFileId"] = boost::any(*quaraFileId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("QuaraFileId") != m.end() && !m["QuaraFileId"].empty()) {
      quaraFileId = make_shared<long>(boost::any_cast<long>(m["QuaraFileId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeQuaraFileDownloadInfoResponseBody() = default;
};
class DescribeQuaraFileDownloadInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeQuaraFileDownloadInfoResponseBody> body{};

  DescribeQuaraFileDownloadInfoResponse() {}

  explicit DescribeQuaraFileDownloadInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeQuaraFileDownloadInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeQuaraFileDownloadInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeQuaraFileDownloadInfoResponse() = default;
};
class DescribeRestoreJobsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> machineRemark{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  DescribeRestoreJobsRequest() {}

  explicit DescribeRestoreJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (machineRemark) {
      res["MachineRemark"] = boost::any(*machineRemark);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("MachineRemark") != m.end() && !m["MachineRemark"].empty()) {
      machineRemark = make_shared<string>(boost::any_cast<string>(m["MachineRemark"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeRestoreJobsRequest() = default;
};
class DescribeRestoreJobsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeRestoreJobsResponseBodyPageInfo() {}

  explicit DescribeRestoreJobsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRestoreJobsResponseBodyPageInfo() = default;
};
class DescribeRestoreJobsResponseBodyRestoreJobs : public Darabonba::Model {
public:
  shared_ptr<long> actualBytes{};
  shared_ptr<long> bytesDone{};
  shared_ptr<long> bytesTotal{};
  shared_ptr<string> clientId{};
  shared_ptr<long> completeTime{};
  shared_ptr<long> createdTime{};
  shared_ptr<long> duration{};
  shared_ptr<long> errorCount{};
  shared_ptr<string> errorFile{};
  shared_ptr<string> errorFileUrl{};
  shared_ptr<string> errorType{};
  shared_ptr<long> eta{};
  shared_ptr<string> excludes{};
  shared_ptr<string> exitCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> includes{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> itemsDone{};
  shared_ptr<long> itemsTotal{};
  shared_ptr<string> message{};
  shared_ptr<long> percentage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> restoreId{};
  shared_ptr<string> restoreName{};
  shared_ptr<string> restoreType{};
  shared_ptr<string> snapshotHash{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> snapshotVersion{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceClientId{};
  shared_ptr<long> speed{};
  shared_ptr<string> status{};
  shared_ptr<string> target{};
  shared_ptr<long> updatedTime{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vaultId{};

  DescribeRestoreJobsResponseBodyRestoreJobs() {}

  explicit DescribeRestoreJobsResponseBodyRestoreJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualBytes) {
      res["ActualBytes"] = boost::any(*actualBytes);
    }
    if (bytesDone) {
      res["BytesDone"] = boost::any(*bytesDone);
    }
    if (bytesTotal) {
      res["BytesTotal"] = boost::any(*bytesTotal);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (errorFile) {
      res["ErrorFile"] = boost::any(*errorFile);
    }
    if (errorFileUrl) {
      res["ErrorFileUrl"] = boost::any(*errorFileUrl);
    }
    if (errorType) {
      res["ErrorType"] = boost::any(*errorType);
    }
    if (eta) {
      res["Eta"] = boost::any(*eta);
    }
    if (excludes) {
      res["Excludes"] = boost::any(*excludes);
    }
    if (exitCode) {
      res["ExitCode"] = boost::any(*exitCode);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (includes) {
      res["Includes"] = boost::any(*includes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (itemsDone) {
      res["ItemsDone"] = boost::any(*itemsDone);
    }
    if (itemsTotal) {
      res["ItemsTotal"] = boost::any(*itemsTotal);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (restoreId) {
      res["RestoreId"] = boost::any(*restoreId);
    }
    if (restoreName) {
      res["RestoreName"] = boost::any(*restoreName);
    }
    if (restoreType) {
      res["RestoreType"] = boost::any(*restoreType);
    }
    if (snapshotHash) {
      res["SnapshotHash"] = boost::any(*snapshotHash);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (snapshotVersion) {
      res["SnapshotVersion"] = boost::any(*snapshotVersion);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceClientId) {
      res["SourceClientId"] = boost::any(*sourceClientId);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vaultId) {
      res["VaultId"] = boost::any(*vaultId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualBytes") != m.end() && !m["ActualBytes"].empty()) {
      actualBytes = make_shared<long>(boost::any_cast<long>(m["ActualBytes"]));
    }
    if (m.find("BytesDone") != m.end() && !m["BytesDone"].empty()) {
      bytesDone = make_shared<long>(boost::any_cast<long>(m["BytesDone"]));
    }
    if (m.find("BytesTotal") != m.end() && !m["BytesTotal"].empty()) {
      bytesTotal = make_shared<long>(boost::any_cast<long>(m["BytesTotal"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<long>(boost::any_cast<long>(m["CompleteTime"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("ErrorFile") != m.end() && !m["ErrorFile"].empty()) {
      errorFile = make_shared<string>(boost::any_cast<string>(m["ErrorFile"]));
    }
    if (m.find("ErrorFileUrl") != m.end() && !m["ErrorFileUrl"].empty()) {
      errorFileUrl = make_shared<string>(boost::any_cast<string>(m["ErrorFileUrl"]));
    }
    if (m.find("ErrorType") != m.end() && !m["ErrorType"].empty()) {
      errorType = make_shared<string>(boost::any_cast<string>(m["ErrorType"]));
    }
    if (m.find("Eta") != m.end() && !m["Eta"].empty()) {
      eta = make_shared<long>(boost::any_cast<long>(m["Eta"]));
    }
    if (m.find("Excludes") != m.end() && !m["Excludes"].empty()) {
      excludes = make_shared<string>(boost::any_cast<string>(m["Excludes"]));
    }
    if (m.find("ExitCode") != m.end() && !m["ExitCode"].empty()) {
      exitCode = make_shared<string>(boost::any_cast<string>(m["ExitCode"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Includes") != m.end() && !m["Includes"].empty()) {
      includes = make_shared<string>(boost::any_cast<string>(m["Includes"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("ItemsDone") != m.end() && !m["ItemsDone"].empty()) {
      itemsDone = make_shared<long>(boost::any_cast<long>(m["ItemsDone"]));
    }
    if (m.find("ItemsTotal") != m.end() && !m["ItemsTotal"].empty()) {
      itemsTotal = make_shared<long>(boost::any_cast<long>(m["ItemsTotal"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RestoreId") != m.end() && !m["RestoreId"].empty()) {
      restoreId = make_shared<string>(boost::any_cast<string>(m["RestoreId"]));
    }
    if (m.find("RestoreName") != m.end() && !m["RestoreName"].empty()) {
      restoreName = make_shared<string>(boost::any_cast<string>(m["RestoreName"]));
    }
    if (m.find("RestoreType") != m.end() && !m["RestoreType"].empty()) {
      restoreType = make_shared<string>(boost::any_cast<string>(m["RestoreType"]));
    }
    if (m.find("SnapshotHash") != m.end() && !m["SnapshotHash"].empty()) {
      snapshotHash = make_shared<string>(boost::any_cast<string>(m["SnapshotHash"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SnapshotVersion") != m.end() && !m["SnapshotVersion"].empty()) {
      snapshotVersion = make_shared<string>(boost::any_cast<string>(m["SnapshotVersion"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceClientId") != m.end() && !m["SourceClientId"].empty()) {
      sourceClientId = make_shared<string>(boost::any_cast<string>(m["SourceClientId"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<long>(boost::any_cast<long>(m["Speed"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VaultId") != m.end() && !m["VaultId"].empty()) {
      vaultId = make_shared<string>(boost::any_cast<string>(m["VaultId"]));
    }
  }


  virtual ~DescribeRestoreJobsResponseBodyRestoreJobs() = default;
};
class DescribeRestoreJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRestoreJobsResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRestoreJobsResponseBodyRestoreJobs>> restoreJobs{};

  DescribeRestoreJobsResponseBody() {}

  explicit DescribeRestoreJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (restoreJobs) {
      vector<boost::any> temp1;
      for(auto item1:*restoreJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RestoreJobs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeRestoreJobsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeRestoreJobsResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RestoreJobs") != m.end() && !m["RestoreJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["RestoreJobs"].type()) {
        vector<DescribeRestoreJobsResponseBodyRestoreJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RestoreJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRestoreJobsResponseBodyRestoreJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restoreJobs = make_shared<vector<DescribeRestoreJobsResponseBodyRestoreJobs>>(expect1);
      }
    }
  }


  virtual ~DescribeRestoreJobsResponseBody() = default;
};
class DescribeRestoreJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRestoreJobsResponseBody> body{};

  DescribeRestoreJobsResponse() {}

  explicit DescribeRestoreJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRestoreJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRestoreJobsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRestoreJobsResponse() = default;
};
class DescribeRestorePlansRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  DescribeRestorePlansRequest() {}

  explicit DescribeRestorePlansRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeRestorePlansRequest() = default;
};
class DescribeRestorePlansResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeRestorePlansResponseBodyPageInfo() {}

  explicit DescribeRestorePlansResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRestorePlansResponseBodyPageInfo() = default;
};
class DescribeRestorePlansResponseBodyRestorePlans : public Darabonba::Model {
public:
  shared_ptr<long> createdTime{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<long> restorePoint{};
  shared_ptr<string> status{};
  shared_ptr<string> targetDatabaseName{};
  shared_ptr<string> targetInstanceId{};
  shared_ptr<string> targetInstanceName{};
  shared_ptr<long> updatedTime{};

  DescribeRestorePlansResponseBodyRestorePlans() {}

  explicit DescribeRestorePlansResponseBodyRestorePlans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (restorePoint) {
      res["RestorePoint"] = boost::any(*restorePoint);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetDatabaseName) {
      res["TargetDatabaseName"] = boost::any(*targetDatabaseName);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    if (targetInstanceName) {
      res["TargetInstanceName"] = boost::any(*targetInstanceName);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("RestorePoint") != m.end() && !m["RestorePoint"].empty()) {
      restorePoint = make_shared<long>(boost::any_cast<long>(m["RestorePoint"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetDatabaseName") != m.end() && !m["TargetDatabaseName"].empty()) {
      targetDatabaseName = make_shared<string>(boost::any_cast<string>(m["TargetDatabaseName"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
    if (m.find("TargetInstanceName") != m.end() && !m["TargetInstanceName"].empty()) {
      targetInstanceName = make_shared<string>(boost::any_cast<string>(m["TargetInstanceName"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
  }


  virtual ~DescribeRestorePlansResponseBodyRestorePlans() = default;
};
class DescribeRestorePlansResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRestorePlansResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRestorePlansResponseBodyRestorePlans>> restorePlans{};

  DescribeRestorePlansResponseBody() {}

  explicit DescribeRestorePlansResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (restorePlans) {
      vector<boost::any> temp1;
      for(auto item1:*restorePlans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RestorePlans"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeRestorePlansResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeRestorePlansResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RestorePlans") != m.end() && !m["RestorePlans"].empty()) {
      if (typeid(vector<boost::any>) == m["RestorePlans"].type()) {
        vector<DescribeRestorePlansResponseBodyRestorePlans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RestorePlans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRestorePlansResponseBodyRestorePlans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restorePlans = make_shared<vector<DescribeRestorePlansResponseBodyRestorePlans>>(expect1);
      }
    }
  }


  virtual ~DescribeRestorePlansResponseBody() = default;
};
class DescribeRestorePlansResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRestorePlansResponseBody> body{};

  DescribeRestorePlansResponse() {}

  explicit DescribeRestorePlansResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRestorePlansResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRestorePlansResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRestorePlansResponse() = default;
};
class DescribeRiskCheckItemResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> itemId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};

  DescribeRiskCheckItemResultRequest() {}

  explicit DescribeRiskCheckItemResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeRiskCheckItemResultRequest() = default;
};
class DescribeRiskCheckItemResultResponseBodyPageContentResource : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> contentResource{};
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeRiskCheckItemResultResponseBodyPageContentResource() {}

  explicit DescribeRiskCheckItemResultResponseBodyPageContentResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentResource) {
      res["ContentResource"] = boost::any(*contentResource);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentResource") != m.end() && !m["ContentResource"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ContentResource"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      contentResource = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRiskCheckItemResultResponseBodyPageContentResource() = default;
};
class DescribeRiskCheckItemResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRiskCheckItemResultResponseBodyPageContentResource> pageContentResource{};
  shared_ptr<string> requestId{};

  DescribeRiskCheckItemResultResponseBody() {}

  explicit DescribeRiskCheckItemResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageContentResource) {
      res["PageContentResource"] = pageContentResource ? boost::any(pageContentResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageContentResource") != m.end() && !m["PageContentResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageContentResource"].type()) {
        DescribeRiskCheckItemResultResponseBodyPageContentResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageContentResource"]));
        pageContentResource = make_shared<DescribeRiskCheckItemResultResponseBodyPageContentResource>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRiskCheckItemResultResponseBody() = default;
};
class DescribeRiskCheckItemResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRiskCheckItemResultResponseBody> body{};

  DescribeRiskCheckItemResultResponse() {}

  explicit DescribeRiskCheckItemResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskCheckItemResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskCheckItemResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskCheckItemResultResponse() = default;
};
class DescribeRiskCheckResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetType{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> groupId{};
  shared_ptr<vector<string>> itemIds{};
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryFlag{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> status{};

  DescribeRiskCheckResultRequest() {}

  explicit DescribeRiskCheckResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryFlag) {
      res["QueryFlag"] = boost::any(*queryFlag);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      itemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryFlag") != m.end() && !m["QueryFlag"].empty()) {
      queryFlag = make_shared<string>(boost::any_cast<string>(m["QueryFlag"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeRiskCheckResultRequest() = default;
};
class DescribeRiskCheckResultResponseBodyListRiskItemResources : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> contentResource{};
  shared_ptr<string> resourceName{};

  DescribeRiskCheckResultResponseBodyListRiskItemResources() {}

  explicit DescribeRiskCheckResultResponseBodyListRiskItemResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentResource) {
      res["ContentResource"] = boost::any(*contentResource);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentResource") != m.end() && !m["ContentResource"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ContentResource"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      contentResource = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
  }


  virtual ~DescribeRiskCheckResultResponseBodyListRiskItemResources() = default;
};
class DescribeRiskCheckResultResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> affectedCount{};
  shared_ptr<long> checkTime{};
  shared_ptr<long> itemId{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> repairStatus{};
  shared_ptr<string> riskAssertType{};
  shared_ptr<vector<DescribeRiskCheckResultResponseBodyListRiskItemResources>> riskItemResources{};
  shared_ptr<string> riskLevel{};
  shared_ptr<long> sort{};
  shared_ptr<string> startStatus{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};

  DescribeRiskCheckResultResponseBodyList() {}

  explicit DescribeRiskCheckResultResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedCount) {
      res["AffectedCount"] = boost::any(*affectedCount);
    }
    if (checkTime) {
      res["CheckTime"] = boost::any(*checkTime);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (repairStatus) {
      res["RepairStatus"] = boost::any(*repairStatus);
    }
    if (riskAssertType) {
      res["RiskAssertType"] = boost::any(*riskAssertType);
    }
    if (riskItemResources) {
      vector<boost::any> temp1;
      for(auto item1:*riskItemResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RiskItemResources"] = boost::any(temp1);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (startStatus) {
      res["StartStatus"] = boost::any(*startStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedCount") != m.end() && !m["AffectedCount"].empty()) {
      affectedCount = make_shared<long>(boost::any_cast<long>(m["AffectedCount"]));
    }
    if (m.find("CheckTime") != m.end() && !m["CheckTime"].empty()) {
      checkTime = make_shared<long>(boost::any_cast<long>(m["CheckTime"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("RepairStatus") != m.end() && !m["RepairStatus"].empty()) {
      repairStatus = make_shared<string>(boost::any_cast<string>(m["RepairStatus"]));
    }
    if (m.find("RiskAssertType") != m.end() && !m["RiskAssertType"].empty()) {
      riskAssertType = make_shared<string>(boost::any_cast<string>(m["RiskAssertType"]));
    }
    if (m.find("RiskItemResources") != m.end() && !m["RiskItemResources"].empty()) {
      if (typeid(vector<boost::any>) == m["RiskItemResources"].type()) {
        vector<DescribeRiskCheckResultResponseBodyListRiskItemResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RiskItemResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskCheckResultResponseBodyListRiskItemResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        riskItemResources = make_shared<vector<DescribeRiskCheckResultResponseBodyListRiskItemResources>>(expect1);
      }
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("StartStatus") != m.end() && !m["StartStatus"].empty()) {
      startStatus = make_shared<string>(boost::any_cast<string>(m["StartStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeRiskCheckResultResponseBodyList() = default;
};
class DescribeRiskCheckResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeRiskCheckResultResponseBodyList>> list{};
  shared_ptr<long> pageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeRiskCheckResultResponseBody() {}

  explicit DescribeRiskCheckResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeRiskCheckResultResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskCheckResultResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeRiskCheckResultResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRiskCheckResultResponseBody() = default;
};
class DescribeRiskCheckResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRiskCheckResultResponseBody> body{};

  DescribeRiskCheckResultResponse() {}

  explicit DescribeRiskCheckResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskCheckResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskCheckResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskCheckResultResponse() = default;
};
class DescribeRiskCheckSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> resourceDirectoryAccountId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};

  DescribeRiskCheckSummaryRequest() {}

  explicit DescribeRiskCheckSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceDirectoryAccountId) {
      res["ResourceDirectoryAccountId"] = boost::any(*resourceDirectoryAccountId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceDirectoryAccountId") != m.end() && !m["ResourceDirectoryAccountId"].empty()) {
      resourceDirectoryAccountId = make_shared<string>(boost::any_cast<string>(m["ResourceDirectoryAccountId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeRiskCheckSummaryRequest() = default;
};
class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> status{};

  DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus() {}

  explicit DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus() = default;
};
class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus>> countByStatus{};
  shared_ptr<long> id{};
  shared_ptr<long> remainingTime{};
  shared_ptr<long> sort{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};

  DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups() {}

  explicit DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (countByStatus) {
      vector<boost::any> temp1;
      for(auto item1:*countByStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CountByStatus"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CountByStatus") != m.end() && !m["CountByStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["CountByStatus"].type()) {
        vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CountByStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        countByStatus = make_shared<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups() = default;
};
class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> key{};

  DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount() {}

  explicit DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount() = default;
};
class DescribeRiskCheckSummaryResponseBodyRiskCheckSummary : public Darabonba::Model {
public:
  shared_ptr<long> affectedAssetCount{};
  shared_ptr<long> disabledRiskCount{};
  shared_ptr<long> enabledRiskCount{};
  shared_ptr<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups>> groups{};
  shared_ptr<long> itemCount{};
  shared_ptr<long> previousCount{};
  shared_ptr<long> previousTime{};
  shared_ptr<long> riskCount{};
  shared_ptr<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount>> riskLevelCount{};
  shared_ptr<double> riskRate{};

  DescribeRiskCheckSummaryResponseBodyRiskCheckSummary() {}

  explicit DescribeRiskCheckSummaryResponseBodyRiskCheckSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedAssetCount) {
      res["AffectedAssetCount"] = boost::any(*affectedAssetCount);
    }
    if (disabledRiskCount) {
      res["DisabledRiskCount"] = boost::any(*disabledRiskCount);
    }
    if (enabledRiskCount) {
      res["EnabledRiskCount"] = boost::any(*enabledRiskCount);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (itemCount) {
      res["ItemCount"] = boost::any(*itemCount);
    }
    if (previousCount) {
      res["PreviousCount"] = boost::any(*previousCount);
    }
    if (previousTime) {
      res["PreviousTime"] = boost::any(*previousTime);
    }
    if (riskCount) {
      res["RiskCount"] = boost::any(*riskCount);
    }
    if (riskLevelCount) {
      vector<boost::any> temp1;
      for(auto item1:*riskLevelCount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RiskLevelCount"] = boost::any(temp1);
    }
    if (riskRate) {
      res["RiskRate"] = boost::any(*riskRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedAssetCount") != m.end() && !m["AffectedAssetCount"].empty()) {
      affectedAssetCount = make_shared<long>(boost::any_cast<long>(m["AffectedAssetCount"]));
    }
    if (m.find("DisabledRiskCount") != m.end() && !m["DisabledRiskCount"].empty()) {
      disabledRiskCount = make_shared<long>(boost::any_cast<long>(m["DisabledRiskCount"]));
    }
    if (m.find("EnabledRiskCount") != m.end() && !m["EnabledRiskCount"].empty()) {
      enabledRiskCount = make_shared<long>(boost::any_cast<long>(m["EnabledRiskCount"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups>>(expect1);
      }
    }
    if (m.find("ItemCount") != m.end() && !m["ItemCount"].empty()) {
      itemCount = make_shared<long>(boost::any_cast<long>(m["ItemCount"]));
    }
    if (m.find("PreviousCount") != m.end() && !m["PreviousCount"].empty()) {
      previousCount = make_shared<long>(boost::any_cast<long>(m["PreviousCount"]));
    }
    if (m.find("PreviousTime") != m.end() && !m["PreviousTime"].empty()) {
      previousTime = make_shared<long>(boost::any_cast<long>(m["PreviousTime"]));
    }
    if (m.find("RiskCount") != m.end() && !m["RiskCount"].empty()) {
      riskCount = make_shared<long>(boost::any_cast<long>(m["RiskCount"]));
    }
    if (m.find("RiskLevelCount") != m.end() && !m["RiskLevelCount"].empty()) {
      if (typeid(vector<boost::any>) == m["RiskLevelCount"].type()) {
        vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RiskLevelCount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        riskLevelCount = make_shared<vector<DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount>>(expect1);
      }
    }
    if (m.find("RiskRate") != m.end() && !m["RiskRate"].empty()) {
      riskRate = make_shared<double>(boost::any_cast<double>(m["RiskRate"]));
    }
  }


  virtual ~DescribeRiskCheckSummaryResponseBodyRiskCheckSummary() = default;
};
class DescribeRiskCheckSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRiskCheckSummaryResponseBodyRiskCheckSummary> riskCheckSummary{};

  DescribeRiskCheckSummaryResponseBody() {}

  explicit DescribeRiskCheckSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (riskCheckSummary) {
      res["RiskCheckSummary"] = riskCheckSummary ? boost::any(riskCheckSummary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RiskCheckSummary") != m.end() && !m["RiskCheckSummary"].empty()) {
      if (typeid(map<string, boost::any>) == m["RiskCheckSummary"].type()) {
        DescribeRiskCheckSummaryResponseBodyRiskCheckSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RiskCheckSummary"]));
        riskCheckSummary = make_shared<DescribeRiskCheckSummaryResponseBodyRiskCheckSummary>(model1);
      }
    }
  }


  virtual ~DescribeRiskCheckSummaryResponseBody() = default;
};
class DescribeRiskCheckSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRiskCheckSummaryResponseBody> body{};

  DescribeRiskCheckSummaryResponse() {}

  explicit DescribeRiskCheckSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskCheckSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskCheckSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskCheckSummaryResponse() = default;
};
class DescribeRiskItemTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};

  DescribeRiskItemTypeRequest() {}

  explicit DescribeRiskItemTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeRiskItemTypeRequest() = default;
};
class DescribeRiskItemTypeResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  DescribeRiskItemTypeResponseBodyList() {}

  explicit DescribeRiskItemTypeResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeRiskItemTypeResponseBodyList() = default;
};
class DescribeRiskItemTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRiskItemTypeResponseBodyList>> list{};
  shared_ptr<string> requestId{};

  DescribeRiskItemTypeResponseBody() {}

  explicit DescribeRiskItemTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeRiskItemTypeResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskItemTypeResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeRiskItemTypeResponseBodyList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRiskItemTypeResponseBody() = default;
};
class DescribeRiskItemTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRiskItemTypeResponseBody> body{};

  DescribeRiskItemTypeResponse() {}

  explicit DescribeRiskItemTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskItemTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskItemTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskItemTypeResponse() = default;
};
class DescribeRiskListCheckResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};

  DescribeRiskListCheckResultRequest() {}

  explicit DescribeRiskListCheckResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeRiskListCheckResultRequest() = default;
};
class DescribeRiskListCheckResultResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> riskCount{};

  DescribeRiskListCheckResultResponseBodyList() {}

  explicit DescribeRiskListCheckResultResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (riskCount) {
      res["riskCount"] = boost::any(*riskCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("riskCount") != m.end() && !m["riskCount"].empty()) {
      riskCount = make_shared<long>(boost::any_cast<long>(m["riskCount"]));
    }
  }


  virtual ~DescribeRiskListCheckResultResponseBodyList() = default;
};
class DescribeRiskListCheckResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRiskListCheckResultResponseBodyList>> list{};
  shared_ptr<string> requestId{};

  DescribeRiskListCheckResultResponseBody() {}

  explicit DescribeRiskListCheckResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeRiskListCheckResultResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskListCheckResultResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeRiskListCheckResultResponseBodyList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRiskListCheckResultResponseBody() = default;
};
class DescribeRiskListCheckResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRiskListCheckResultResponseBody> body{};

  DescribeRiskListCheckResultResponse() {}

  explicit DescribeRiskListCheckResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskListCheckResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskListCheckResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskListCheckResultResponse() = default;
};
class DescribeRiskTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  DescribeRiskTypeRequest() {}

  explicit DescribeRiskTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeRiskTypeRequest() = default;
};
class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList : public Darabonba::Model {
public:
  shared_ptr<string> enumValue{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minValue{};
  shared_ptr<string> paramDefaultValue{};
  shared_ptr<string> paramDesc{};
  shared_ptr<string> paramName{};
  shared_ptr<long> paramType{};

  DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList() {}

  explicit DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (paramDefaultValue) {
      res["ParamDefaultValue"] = boost::any(*paramDefaultValue);
    }
    if (paramDesc) {
      res["ParamDesc"] = boost::any(*paramDesc);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParamDefaultValue") != m.end() && !m["ParamDefaultValue"].empty()) {
      paramDefaultValue = make_shared<string>(boost::any_cast<string>(m["ParamDefaultValue"]));
    }
    if (m.find("ParamDesc") != m.end() && !m["ParamDesc"].empty()) {
      paramDesc = make_shared<string>(boost::any_cast<string>(m["ParamDesc"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<long>(boost::any_cast<long>(m["ParamType"]));
    }
  }


  virtual ~DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList() = default;
};
class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules : public Darabonba::Model {
public:
  shared_ptr<long> optional{};
  shared_ptr<vector<DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList>> paramList{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> ruleId{};

  DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules() {}

  explicit DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optional) {
      res["Optional"] = boost::any(*optional);
    }
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Optional") != m.end() && !m["Optional"].empty()) {
      optional = make_shared<long>(boost::any_cast<long>(m["Optional"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList>>(expect1);
      }
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules() = default;
};
class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails : public Darabonba::Model {
public:
  shared_ptr<string> checkDesc{};
  shared_ptr<long> checkId{};
  shared_ptr<string> checkItem{};
  shared_ptr<vector<DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules>> rules{};

  DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails() {}

  explicit DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkDesc) {
      res["CheckDesc"] = boost::any(*checkDesc);
    }
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckDesc") != m.end() && !m["CheckDesc"].empty()) {
      checkDesc = make_shared<string>(boost::any_cast<string>(m["CheckDesc"]));
    }
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules>>(expect1);
      }
    }
  }


  virtual ~DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails() = default;
};
class DescribeRiskTypeResponseBodyRiskTypesSubTypes : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<vector<DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails>> checkDetails{};
  shared_ptr<string> typeName_{};

  DescribeRiskTypeResponseBodyRiskTypesSubTypes() {}

  explicit DescribeRiskTypeResponseBodyRiskTypesSubTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (checkDetails) {
      vector<boost::any> temp1;
      for(auto item1:*checkDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CheckDetails"] = boost::any(temp1);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("CheckDetails") != m.end() && !m["CheckDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["CheckDetails"].type()) {
        vector<DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CheckDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkDetails = make_shared<vector<DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails>>(expect1);
      }
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~DescribeRiskTypeResponseBodyRiskTypesSubTypes() = default;
};
class DescribeRiskTypeResponseBodyRiskTypes : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<vector<DescribeRiskTypeResponseBodyRiskTypesSubTypes>> subTypes{};
  shared_ptr<string> typeName_{};

  DescribeRiskTypeResponseBodyRiskTypes() {}

  explicit DescribeRiskTypeResponseBodyRiskTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (subTypes) {
      vector<boost::any> temp1;
      for(auto item1:*subTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubTypes"] = boost::any(temp1);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("SubTypes") != m.end() && !m["SubTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["SubTypes"].type()) {
        vector<DescribeRiskTypeResponseBodyRiskTypesSubTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskTypeResponseBodyRiskTypesSubTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subTypes = make_shared<vector<DescribeRiskTypeResponseBodyRiskTypesSubTypes>>(expect1);
      }
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~DescribeRiskTypeResponseBodyRiskTypes() = default;
};
class DescribeRiskTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRiskTypeResponseBodyRiskTypes>> riskTypes{};

  DescribeRiskTypeResponseBody() {}

  explicit DescribeRiskTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (riskTypes) {
      vector<boost::any> temp1;
      for(auto item1:*riskTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RiskTypes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RiskTypes") != m.end() && !m["RiskTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["RiskTypes"].type()) {
        vector<DescribeRiskTypeResponseBodyRiskTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RiskTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRiskTypeResponseBodyRiskTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        riskTypes = make_shared<vector<DescribeRiskTypeResponseBodyRiskTypes>>(expect1);
      }
    }
  }


  virtual ~DescribeRiskTypeResponseBody() = default;
};
class DescribeRiskTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRiskTypeResponseBody> body{};

  DescribeRiskTypeResponse() {}

  explicit DescribeRiskTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRiskTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRiskTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRiskTypeResponse() = default;
};
class DescribeRisksRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> limit{};
  shared_ptr<long> riskId{};
  shared_ptr<string> riskName{};

  DescribeRisksRequest() {}

  explicit DescribeRisksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
  }


  virtual ~DescribeRisksRequest() = default;
};
class DescribeRisksResponseBodyRisks : public Darabonba::Model {
public:
  shared_ptr<string> riskDetail{};
  shared_ptr<long> riskId{};
  shared_ptr<string> riskName{};
  shared_ptr<string> riskType{};
  shared_ptr<string> subRiskType{};
  shared_ptr<string> subTypeAlias{};
  shared_ptr<string> typeAlias{};

  DescribeRisksResponseBodyRisks() {}

  explicit DescribeRisksResponseBodyRisks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (riskDetail) {
      res["RiskDetail"] = boost::any(*riskDetail);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    if (riskType) {
      res["RiskType"] = boost::any(*riskType);
    }
    if (subRiskType) {
      res["SubRiskType"] = boost::any(*subRiskType);
    }
    if (subTypeAlias) {
      res["SubTypeAlias"] = boost::any(*subTypeAlias);
    }
    if (typeAlias) {
      res["TypeAlias"] = boost::any(*typeAlias);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RiskDetail") != m.end() && !m["RiskDetail"].empty()) {
      riskDetail = make_shared<string>(boost::any_cast<string>(m["RiskDetail"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
    if (m.find("RiskType") != m.end() && !m["RiskType"].empty()) {
      riskType = make_shared<string>(boost::any_cast<string>(m["RiskType"]));
    }
    if (m.find("SubRiskType") != m.end() && !m["SubRiskType"].empty()) {
      subRiskType = make_shared<string>(boost::any_cast<string>(m["SubRiskType"]));
    }
    if (m.find("SubTypeAlias") != m.end() && !m["SubTypeAlias"].empty()) {
      subTypeAlias = make_shared<string>(boost::any_cast<string>(m["SubTypeAlias"]));
    }
    if (m.find("TypeAlias") != m.end() && !m["TypeAlias"].empty()) {
      typeAlias = make_shared<string>(boost::any_cast<string>(m["TypeAlias"]));
    }
  }


  virtual ~DescribeRisksResponseBodyRisks() = default;
};
class DescribeRisksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRisksResponseBodyRisks>> risks{};
  shared_ptr<long> totalCount{};

  DescribeRisksResponseBody() {}

  explicit DescribeRisksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (risks) {
      vector<boost::any> temp1;
      for(auto item1:*risks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Risks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Risks") != m.end() && !m["Risks"].empty()) {
      if (typeid(vector<boost::any>) == m["Risks"].type()) {
        vector<DescribeRisksResponseBodyRisks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Risks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRisksResponseBodyRisks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        risks = make_shared<vector<DescribeRisksResponseBodyRisks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRisksResponseBody() = default;
};
class DescribeRisksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRisksResponseBody> body{};

  DescribeRisksResponse() {}

  explicit DescribeRisksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRisksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRisksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRisksResponse() = default;
};
class DescribeSasPmAgentListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> uuids{};

  DescribeSasPmAgentListRequest() {}

  explicit DescribeSasPmAgentListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeSasPmAgentListRequest() = default;
};
class DescribeSasPmAgentListResponseBodySasPmAgentList : public Darabonba::Model {
public:
  shared_ptr<string> aliyunAssistId{};
  shared_ptr<string> aliyunMonitorId{};
  shared_ptr<long> assistInstallResult{};
  shared_ptr<long> assistInstallStatus{};
  shared_ptr<long> monitorInstallResult{};
  shared_ptr<long> monitorInstallStatus{};
  shared_ptr<string> uuid{};

  DescribeSasPmAgentListResponseBodySasPmAgentList() {}

  explicit DescribeSasPmAgentListResponseBodySasPmAgentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunAssistId) {
      res["AliyunAssistId"] = boost::any(*aliyunAssistId);
    }
    if (aliyunMonitorId) {
      res["AliyunMonitorId"] = boost::any(*aliyunMonitorId);
    }
    if (assistInstallResult) {
      res["AssistInstallResult"] = boost::any(*assistInstallResult);
    }
    if (assistInstallStatus) {
      res["AssistInstallStatus"] = boost::any(*assistInstallStatus);
    }
    if (monitorInstallResult) {
      res["MonitorInstallResult"] = boost::any(*monitorInstallResult);
    }
    if (monitorInstallStatus) {
      res["MonitorInstallStatus"] = boost::any(*monitorInstallStatus);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunAssistId") != m.end() && !m["AliyunAssistId"].empty()) {
      aliyunAssistId = make_shared<string>(boost::any_cast<string>(m["AliyunAssistId"]));
    }
    if (m.find("AliyunMonitorId") != m.end() && !m["AliyunMonitorId"].empty()) {
      aliyunMonitorId = make_shared<string>(boost::any_cast<string>(m["AliyunMonitorId"]));
    }
    if (m.find("AssistInstallResult") != m.end() && !m["AssistInstallResult"].empty()) {
      assistInstallResult = make_shared<long>(boost::any_cast<long>(m["AssistInstallResult"]));
    }
    if (m.find("AssistInstallStatus") != m.end() && !m["AssistInstallStatus"].empty()) {
      assistInstallStatus = make_shared<long>(boost::any_cast<long>(m["AssistInstallStatus"]));
    }
    if (m.find("MonitorInstallResult") != m.end() && !m["MonitorInstallResult"].empty()) {
      monitorInstallResult = make_shared<long>(boost::any_cast<long>(m["MonitorInstallResult"]));
    }
    if (m.find("MonitorInstallStatus") != m.end() && !m["MonitorInstallStatus"].empty()) {
      monitorInstallStatus = make_shared<long>(boost::any_cast<long>(m["MonitorInstallStatus"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeSasPmAgentListResponseBodySasPmAgentList() = default;
};
class DescribeSasPmAgentListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSasPmAgentListResponseBodySasPmAgentList>> sasPmAgentList{};

  DescribeSasPmAgentListResponseBody() {}

  explicit DescribeSasPmAgentListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sasPmAgentList) {
      vector<boost::any> temp1;
      for(auto item1:*sasPmAgentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SasPmAgentList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SasPmAgentList") != m.end() && !m["SasPmAgentList"].empty()) {
      if (typeid(vector<boost::any>) == m["SasPmAgentList"].type()) {
        vector<DescribeSasPmAgentListResponseBodySasPmAgentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SasPmAgentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSasPmAgentListResponseBodySasPmAgentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sasPmAgentList = make_shared<vector<DescribeSasPmAgentListResponseBodySasPmAgentList>>(expect1);
      }
    }
  }


  virtual ~DescribeSasPmAgentListResponseBody() = default;
};
class DescribeSasPmAgentListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSasPmAgentListResponseBody> body{};

  DescribeSasPmAgentListResponse() {}

  explicit DescribeSasPmAgentListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSasPmAgentListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSasPmAgentListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSasPmAgentListResponse() = default;
};
class DescribeScanTaskProgressRequest : public Darabonba::Model {
public:
  shared_ptr<long> taskId{};

  DescribeScanTaskProgressRequest() {}

  explicit DescribeScanTaskProgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DescribeScanTaskProgressRequest() = default;
};
class DescribeScanTaskProgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> scanTaskProgress{};
  shared_ptr<string> targetInfo{};

  DescribeScanTaskProgressResponseBody() {}

  explicit DescribeScanTaskProgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scanTaskProgress) {
      res["ScanTaskProgress"] = boost::any(*scanTaskProgress);
    }
    if (targetInfo) {
      res["TargetInfo"] = boost::any(*targetInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScanTaskProgress") != m.end() && !m["ScanTaskProgress"].empty()) {
      scanTaskProgress = make_shared<string>(boost::any_cast<string>(m["ScanTaskProgress"]));
    }
    if (m.find("TargetInfo") != m.end() && !m["TargetInfo"].empty()) {
      targetInfo = make_shared<string>(boost::any_cast<string>(m["TargetInfo"]));
    }
  }


  virtual ~DescribeScanTaskProgressResponseBody() = default;
};
class DescribeScanTaskProgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScanTaskProgressResponseBody> body{};

  DescribeScanTaskProgressResponse() {}

  explicit DescribeScanTaskProgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScanTaskProgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScanTaskProgressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScanTaskProgressResponse() = default;
};
class DescribeScanTaskStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> levels{};

  DescribeScanTaskStatisticsRequest() {}

  explicit DescribeScanTaskStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (levels) {
      res["Levels"] = boost::any(*levels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Levels") != m.end() && !m["Levels"].empty()) {
      levels = make_shared<string>(boost::any_cast<string>(m["Levels"]));
    }
  }


  virtual ~DescribeScanTaskStatisticsRequest() = default;
};
class DescribeScanTaskStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> dealedRiskNum{};
  shared_ptr<long> personalTaskNum{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalTaskNum{};
  shared_ptr<long> userNum{};

  DescribeScanTaskStatisticsResponseBody() {}

  explicit DescribeScanTaskStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dealedRiskNum) {
      res["DealedRiskNum"] = boost::any(*dealedRiskNum);
    }
    if (personalTaskNum) {
      res["PersonalTaskNum"] = boost::any(*personalTaskNum);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalTaskNum) {
      res["TotalTaskNum"] = boost::any(*totalTaskNum);
    }
    if (userNum) {
      res["UserNum"] = boost::any(*userNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DealedRiskNum") != m.end() && !m["DealedRiskNum"].empty()) {
      dealedRiskNum = make_shared<long>(boost::any_cast<long>(m["DealedRiskNum"]));
    }
    if (m.find("PersonalTaskNum") != m.end() && !m["PersonalTaskNum"].empty()) {
      personalTaskNum = make_shared<long>(boost::any_cast<long>(m["PersonalTaskNum"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalTaskNum") != m.end() && !m["TotalTaskNum"].empty()) {
      totalTaskNum = make_shared<long>(boost::any_cast<long>(m["TotalTaskNum"]));
    }
    if (m.find("UserNum") != m.end() && !m["UserNum"].empty()) {
      userNum = make_shared<long>(boost::any_cast<long>(m["UserNum"]));
    }
  }


  virtual ~DescribeScanTaskStatisticsResponseBody() = default;
};
class DescribeScanTaskStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeScanTaskStatisticsResponseBody> body{};

  DescribeScanTaskStatisticsResponse() {}

  explicit DescribeScanTaskStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeScanTaskStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeScanTaskStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeScanTaskStatisticsResponse() = default;
};
class DescribeSearchConditionRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  DescribeSearchConditionRequest() {}

  explicit DescribeSearchConditionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSearchConditionRequest() = default;
};
class DescribeSearchConditionResponseBodyConditionList : public Darabonba::Model {
public:
  shared_ptr<string> conditionType{};
  shared_ptr<string> filterConditions{};
  shared_ptr<string> name{};
  shared_ptr<string> nameKey{};

  DescribeSearchConditionResponseBodyConditionList() {}

  explicit DescribeSearchConditionResponseBodyConditionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionType) {
      res["ConditionType"] = boost::any(*conditionType);
    }
    if (filterConditions) {
      res["FilterConditions"] = boost::any(*filterConditions);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nameKey) {
      res["NameKey"] = boost::any(*nameKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionType") != m.end() && !m["ConditionType"].empty()) {
      conditionType = make_shared<string>(boost::any_cast<string>(m["ConditionType"]));
    }
    if (m.find("FilterConditions") != m.end() && !m["FilterConditions"].empty()) {
      filterConditions = make_shared<string>(boost::any_cast<string>(m["FilterConditions"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NameKey") != m.end() && !m["NameKey"].empty()) {
      nameKey = make_shared<string>(boost::any_cast<string>(m["NameKey"]));
    }
  }


  virtual ~DescribeSearchConditionResponseBodyConditionList() = default;
};
class DescribeSearchConditionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSearchConditionResponseBodyConditionList>> conditionList{};
  shared_ptr<string> requestId{};

  DescribeSearchConditionResponseBody() {}

  explicit DescribeSearchConditionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionList) {
      vector<boost::any> temp1;
      for(auto item1:*conditionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionList") != m.end() && !m["ConditionList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionList"].type()) {
        vector<DescribeSearchConditionResponseBodyConditionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSearchConditionResponseBodyConditionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionList = make_shared<vector<DescribeSearchConditionResponseBodyConditionList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSearchConditionResponseBody() = default;
};
class DescribeSearchConditionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSearchConditionResponseBody> body{};

  DescribeSearchConditionResponse() {}

  explicit DescribeSearchConditionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSearchConditionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSearchConditionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSearchConditionResponse() = default;
};
class DescribeSecureSuggestionRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  DescribeSecureSuggestionRequest() {}

  explicit DescribeSecureSuggestionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeSecureSuggestionRequest() = default;
};
class DescribeSecureSuggestionResponseBodySuggestionsDetail : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> subType{};
  shared_ptr<string> title{};

  DescribeSecureSuggestionResponseBodySuggestionsDetail() {}

  explicit DescribeSecureSuggestionResponseBodySuggestionsDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeSecureSuggestionResponseBodySuggestionsDetail() = default;
};
class DescribeSecureSuggestionResponseBodySuggestions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecureSuggestionResponseBodySuggestionsDetail>> detail{};
  shared_ptr<long> points{};
  shared_ptr<string> suggestType{};

  DescribeSecureSuggestionResponseBodySuggestions() {}

  explicit DescribeSecureSuggestionResponseBodySuggestions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (points) {
      res["Points"] = boost::any(*points);
    }
    if (suggestType) {
      res["SuggestType"] = boost::any(*suggestType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<DescribeSecureSuggestionResponseBodySuggestionsDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecureSuggestionResponseBodySuggestionsDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<DescribeSecureSuggestionResponseBodySuggestionsDetail>>(expect1);
      }
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      points = make_shared<long>(boost::any_cast<long>(m["Points"]));
    }
    if (m.find("SuggestType") != m.end() && !m["SuggestType"].empty()) {
      suggestType = make_shared<string>(boost::any_cast<string>(m["SuggestType"]));
    }
  }


  virtual ~DescribeSecureSuggestionResponseBodySuggestions() = default;
};
class DescribeSecureSuggestionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSecureSuggestionResponseBodySuggestions>> suggestions{};
  shared_ptr<long> totalCount{};

  DescribeSecureSuggestionResponseBody() {}

  explicit DescribeSecureSuggestionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (suggestions) {
      vector<boost::any> temp1;
      for(auto item1:*suggestions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Suggestions"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Suggestions") != m.end() && !m["Suggestions"].empty()) {
      if (typeid(vector<boost::any>) == m["Suggestions"].type()) {
        vector<DescribeSecureSuggestionResponseBodySuggestions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Suggestions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecureSuggestionResponseBodySuggestions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        suggestions = make_shared<vector<DescribeSecureSuggestionResponseBodySuggestions>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSecureSuggestionResponseBody() = default;
};
class DescribeSecureSuggestionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecureSuggestionResponseBody> body{};

  DescribeSecureSuggestionResponse() {}

  explicit DescribeSecureSuggestionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecureSuggestionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecureSuggestionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecureSuggestionResponse() = default;
};
class DescribeSecurityCheckScheduleConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};

  DescribeSecurityCheckScheduleConfigRequest() {}

  explicit DescribeSecurityCheckScheduleConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeSecurityCheckScheduleConfigRequest() = default;
};
class DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig : public Darabonba::Model {
public:
  shared_ptr<string> daysOfWeek{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig() {}

  explicit DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig() = default;
};
class DescribeSecurityCheckScheduleConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig> riskCheckJobConfig{};

  DescribeSecurityCheckScheduleConfigResponseBody() {}

  explicit DescribeSecurityCheckScheduleConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (riskCheckJobConfig) {
      res["RiskCheckJobConfig"] = riskCheckJobConfig ? boost::any(riskCheckJobConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RiskCheckJobConfig") != m.end() && !m["RiskCheckJobConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RiskCheckJobConfig"].type()) {
        DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RiskCheckJobConfig"]));
        riskCheckJobConfig = make_shared<DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig>(model1);
      }
    }
  }


  virtual ~DescribeSecurityCheckScheduleConfigResponseBody() = default;
};
class DescribeSecurityCheckScheduleConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecurityCheckScheduleConfigResponseBody> body{};

  DescribeSecurityCheckScheduleConfigResponse() {}

  explicit DescribeSecurityCheckScheduleConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityCheckScheduleConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityCheckScheduleConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityCheckScheduleConfigResponse() = default;
};
class DescribeSecurityEventOperationStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<vector<string>> securityEventIds{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> taskId{};

  DescribeSecurityEventOperationStatusRequest() {}

  explicit DescribeSecurityEventOperationStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityEventIds) {
      res["SecurityEventIds"] = boost::any(*securityEventIds);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityEventIds") != m.end() && !m["SecurityEventIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityEventIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityEventIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityEventIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DescribeSecurityEventOperationStatusRequest() = default;
};
class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> securityEventId{};
  shared_ptr<string> status{};

  DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses() {}

  explicit DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<string>(boost::any_cast<string>(m["SecurityEventId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses() = default;
};
class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses>> securityEventOperationStatuses{};
  shared_ptr<string> taskStatus{};

  DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse() {}

  explicit DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityEventOperationStatuses) {
      vector<boost::any> temp1;
      for(auto item1:*securityEventOperationStatuses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityEventOperationStatuses"] = boost::any(temp1);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityEventOperationStatuses") != m.end() && !m["SecurityEventOperationStatuses"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityEventOperationStatuses"].type()) {
        vector<DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityEventOperationStatuses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityEventOperationStatuses = make_shared<vector<DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses>>(expect1);
      }
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse() = default;
};
class DescribeSecurityEventOperationStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse> securityEventOperationStatusResponse{};

  DescribeSecurityEventOperationStatusResponseBody() {}

  explicit DescribeSecurityEventOperationStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEventOperationStatusResponse) {
      res["SecurityEventOperationStatusResponse"] = securityEventOperationStatusResponse ? boost::any(securityEventOperationStatusResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEventOperationStatusResponse") != m.end() && !m["SecurityEventOperationStatusResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityEventOperationStatusResponse"].type()) {
        DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityEventOperationStatusResponse"]));
        securityEventOperationStatusResponse = make_shared<DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventOperationStatusResponseBody() = default;
};
class DescribeSecurityEventOperationStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecurityEventOperationStatusResponseBody> body{};

  DescribeSecurityEventOperationStatusResponse() {}

  explicit DescribeSecurityEventOperationStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityEventOperationStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityEventOperationStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventOperationStatusResponse() = default;
};
class DescribeSecurityEventOperationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> securityEventId{};
  shared_ptr<string> sourceIp{};

  DescribeSecurityEventOperationsRequest() {}

  explicit DescribeSecurityEventOperationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<long>(boost::any_cast<long>(m["SecurityEventId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeSecurityEventOperationsRequest() = default;
};
class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField : public Darabonba::Model {
public:
  shared_ptr<string> filedAliasName{};
  shared_ptr<string> filedName{};
  shared_ptr<string> markMisType{};
  shared_ptr<string> markMisValue{};
  shared_ptr<vector<string>> supportedMisType{};
  shared_ptr<string> uuid{};

  DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField() {}

  explicit DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filedAliasName) {
      res["FiledAliasName"] = boost::any(*filedAliasName);
    }
    if (filedName) {
      res["FiledName"] = boost::any(*filedName);
    }
    if (markMisType) {
      res["MarkMisType"] = boost::any(*markMisType);
    }
    if (markMisValue) {
      res["MarkMisValue"] = boost::any(*markMisValue);
    }
    if (supportedMisType) {
      res["SupportedMisType"] = boost::any(*supportedMisType);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FiledAliasName") != m.end() && !m["FiledAliasName"].empty()) {
      filedAliasName = make_shared<string>(boost::any_cast<string>(m["FiledAliasName"]));
    }
    if (m.find("FiledName") != m.end() && !m["FiledName"].empty()) {
      filedName = make_shared<string>(boost::any_cast<string>(m["FiledName"]));
    }
    if (m.find("MarkMisType") != m.end() && !m["MarkMisType"].empty()) {
      markMisType = make_shared<string>(boost::any_cast<string>(m["MarkMisType"]));
    }
    if (m.find("MarkMisValue") != m.end() && !m["MarkMisValue"].empty()) {
      markMisValue = make_shared<string>(boost::any_cast<string>(m["MarkMisValue"]));
    }
    if (m.find("SupportedMisType") != m.end() && !m["SupportedMisType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedMisType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedMisType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedMisType = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField() = default;
};
class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource : public Darabonba::Model {
public:
  shared_ptr<string> filedAliasName{};
  shared_ptr<string> filedName{};
  shared_ptr<string> markMisValue{};
  shared_ptr<vector<string>> supportedMisType{};

  DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource() {}

  explicit DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filedAliasName) {
      res["FiledAliasName"] = boost::any(*filedAliasName);
    }
    if (filedName) {
      res["FiledName"] = boost::any(*filedName);
    }
    if (markMisValue) {
      res["MarkMisValue"] = boost::any(*markMisValue);
    }
    if (supportedMisType) {
      res["SupportedMisType"] = boost::any(*supportedMisType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FiledAliasName") != m.end() && !m["FiledAliasName"].empty()) {
      filedAliasName = make_shared<string>(boost::any_cast<string>(m["FiledAliasName"]));
    }
    if (m.find("FiledName") != m.end() && !m["FiledName"].empty()) {
      filedName = make_shared<string>(boost::any_cast<string>(m["FiledName"]));
    }
    if (m.find("MarkMisValue") != m.end() && !m["MarkMisValue"].empty()) {
      markMisValue = make_shared<string>(boost::any_cast<string>(m["MarkMisValue"]));
    }
    if (m.find("SupportedMisType") != m.end() && !m["SupportedMisType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportedMisType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportedMisType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportedMisType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource() = default;
};
class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField>> markField{};
  shared_ptr<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource>> markFieldsSource{};
  shared_ptr<string> operationCode{};
  shared_ptr<string> operationParams{};
  shared_ptr<bool> userCanOperate{};

  DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse() {}

  explicit DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (markField) {
      vector<boost::any> temp1;
      for(auto item1:*markField){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MarkField"] = boost::any(temp1);
    }
    if (markFieldsSource) {
      vector<boost::any> temp1;
      for(auto item1:*markFieldsSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MarkFieldsSource"] = boost::any(temp1);
    }
    if (operationCode) {
      res["OperationCode"] = boost::any(*operationCode);
    }
    if (operationParams) {
      res["OperationParams"] = boost::any(*operationParams);
    }
    if (userCanOperate) {
      res["UserCanOperate"] = boost::any(*userCanOperate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MarkField") != m.end() && !m["MarkField"].empty()) {
      if (typeid(vector<boost::any>) == m["MarkField"].type()) {
        vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MarkField"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        markField = make_shared<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField>>(expect1);
      }
    }
    if (m.find("MarkFieldsSource") != m.end() && !m["MarkFieldsSource"].empty()) {
      if (typeid(vector<boost::any>) == m["MarkFieldsSource"].type()) {
        vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MarkFieldsSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        markFieldsSource = make_shared<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource>>(expect1);
      }
    }
    if (m.find("OperationCode") != m.end() && !m["OperationCode"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["OperationCode"]));
    }
    if (m.find("OperationParams") != m.end() && !m["OperationParams"].empty()) {
      operationParams = make_shared<string>(boost::any_cast<string>(m["OperationParams"]));
    }
    if (m.find("UserCanOperate") != m.end() && !m["UserCanOperate"].empty()) {
      userCanOperate = make_shared<bool>(boost::any_cast<bool>(m["UserCanOperate"]));
    }
  }


  virtual ~DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse() = default;
};
class DescribeSecurityEventOperationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse>> securityEventOperationsResponse{};

  DescribeSecurityEventOperationsResponseBody() {}

  explicit DescribeSecurityEventOperationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEventOperationsResponse) {
      vector<boost::any> temp1;
      for(auto item1:*securityEventOperationsResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityEventOperationsResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEventOperationsResponse") != m.end() && !m["SecurityEventOperationsResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityEventOperationsResponse"].type()) {
        vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityEventOperationsResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityEventOperationsResponse = make_shared<vector<DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse>>(expect1);
      }
    }
  }


  virtual ~DescribeSecurityEventOperationsResponseBody() = default;
};
class DescribeSecurityEventOperationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecurityEventOperationsResponseBody> body{};

  DescribeSecurityEventOperationsResponse() {}

  explicit DescribeSecurityEventOperationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityEventOperationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityEventOperationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventOperationsResponse() = default;
};
class DescribeSecurityStatInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> resourceDirectoryAccountId{};
  shared_ptr<string> sourceIp{};

  DescribeSecurityStatInfoRequest() {}

  explicit DescribeSecurityStatInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceDirectoryAccountId) {
      res["ResourceDirectoryAccountId"] = boost::any(*resourceDirectoryAccountId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceDirectoryAccountId") != m.end() && !m["ResourceDirectoryAccountId"].empty()) {
      resourceDirectoryAccountId = make_shared<string>(boost::any_cast<string>(m["ResourceDirectoryAccountId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeSecurityStatInfoRequest() = default;
};
class DescribeSecurityStatInfoResponseBodyAttackEvent : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dateArray{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> valueArray{};

  DescribeSecurityStatInfoResponseBodyAttackEvent() {}

  explicit DescribeSecurityStatInfoResponseBodyAttackEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateArray) {
      res["DateArray"] = boost::any(*dateArray);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (valueArray) {
      res["ValueArray"] = boost::any(*valueArray);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateArray") != m.end() && !m["DateArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DateArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DateArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dateArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ValueArray") != m.end() && !m["ValueArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ValueArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ValueArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueArray = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityStatInfoResponseBodyAttackEvent() = default;
};
class DescribeSecurityStatInfoResponseBodyHealthCheck : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dateArray{};
  shared_ptr<long> highCount{};
  shared_ptr<vector<string>> highList{};
  shared_ptr<vector<string>> levelsOn{};
  shared_ptr<long> lowCount{};
  shared_ptr<vector<string>> lowList{};
  shared_ptr<long> mediumCount{};
  shared_ptr<vector<string>> mediumList{};
  shared_ptr<vector<string>> timeArray{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> valueArray{};

  DescribeSecurityStatInfoResponseBodyHealthCheck() {}

  explicit DescribeSecurityStatInfoResponseBodyHealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateArray) {
      res["DateArray"] = boost::any(*dateArray);
    }
    if (highCount) {
      res["HighCount"] = boost::any(*highCount);
    }
    if (highList) {
      res["HighList"] = boost::any(*highList);
    }
    if (levelsOn) {
      res["LevelsOn"] = boost::any(*levelsOn);
    }
    if (lowCount) {
      res["LowCount"] = boost::any(*lowCount);
    }
    if (lowList) {
      res["LowList"] = boost::any(*lowList);
    }
    if (mediumCount) {
      res["MediumCount"] = boost::any(*mediumCount);
    }
    if (mediumList) {
      res["MediumList"] = boost::any(*mediumList);
    }
    if (timeArray) {
      res["TimeArray"] = boost::any(*timeArray);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (valueArray) {
      res["ValueArray"] = boost::any(*valueArray);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateArray") != m.end() && !m["DateArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DateArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DateArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dateArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HighCount") != m.end() && !m["HighCount"].empty()) {
      highCount = make_shared<long>(boost::any_cast<long>(m["HighCount"]));
    }
    if (m.find("HighList") != m.end() && !m["HighList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HighList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HighList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      highList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LevelsOn") != m.end() && !m["LevelsOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LevelsOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LevelsOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      levelsOn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LowCount") != m.end() && !m["LowCount"].empty()) {
      lowCount = make_shared<long>(boost::any_cast<long>(m["LowCount"]));
    }
    if (m.find("LowList") != m.end() && !m["LowList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LowList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LowList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      lowList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MediumCount") != m.end() && !m["MediumCount"].empty()) {
      mediumCount = make_shared<long>(boost::any_cast<long>(m["MediumCount"]));
    }
    if (m.find("MediumList") != m.end() && !m["MediumList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediumList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediumList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediumList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TimeArray") != m.end() && !m["TimeArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TimeArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TimeArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      timeArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ValueArray") != m.end() && !m["ValueArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ValueArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ValueArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueArray = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityStatInfoResponseBodyHealthCheck() = default;
};
class DescribeSecurityStatInfoResponseBodySecurityEvent : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dateArray{};
  shared_ptr<vector<string>> levelsOn{};
  shared_ptr<long> remindCount{};
  shared_ptr<vector<string>> remindList{};
  shared_ptr<long> seriousCount{};
  shared_ptr<vector<string>> seriousList{};
  shared_ptr<long> suspiciousCount{};
  shared_ptr<vector<string>> suspiciousList{};
  shared_ptr<vector<string>> timeArray{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> valueArray{};

  DescribeSecurityStatInfoResponseBodySecurityEvent() {}

  explicit DescribeSecurityStatInfoResponseBodySecurityEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateArray) {
      res["DateArray"] = boost::any(*dateArray);
    }
    if (levelsOn) {
      res["LevelsOn"] = boost::any(*levelsOn);
    }
    if (remindCount) {
      res["RemindCount"] = boost::any(*remindCount);
    }
    if (remindList) {
      res["RemindList"] = boost::any(*remindList);
    }
    if (seriousCount) {
      res["SeriousCount"] = boost::any(*seriousCount);
    }
    if (seriousList) {
      res["SeriousList"] = boost::any(*seriousList);
    }
    if (suspiciousCount) {
      res["SuspiciousCount"] = boost::any(*suspiciousCount);
    }
    if (suspiciousList) {
      res["SuspiciousList"] = boost::any(*suspiciousList);
    }
    if (timeArray) {
      res["TimeArray"] = boost::any(*timeArray);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (valueArray) {
      res["ValueArray"] = boost::any(*valueArray);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateArray") != m.end() && !m["DateArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DateArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DateArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dateArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LevelsOn") != m.end() && !m["LevelsOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LevelsOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LevelsOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      levelsOn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemindCount") != m.end() && !m["RemindCount"].empty()) {
      remindCount = make_shared<long>(boost::any_cast<long>(m["RemindCount"]));
    }
    if (m.find("RemindList") != m.end() && !m["RemindList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RemindList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RemindList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      remindList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SeriousCount") != m.end() && !m["SeriousCount"].empty()) {
      seriousCount = make_shared<long>(boost::any_cast<long>(m["SeriousCount"]));
    }
    if (m.find("SeriousList") != m.end() && !m["SeriousList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SeriousList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SeriousList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      seriousList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SuspiciousCount") != m.end() && !m["SuspiciousCount"].empty()) {
      suspiciousCount = make_shared<long>(boost::any_cast<long>(m["SuspiciousCount"]));
    }
    if (m.find("SuspiciousList") != m.end() && !m["SuspiciousList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuspiciousList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuspiciousList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      suspiciousList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TimeArray") != m.end() && !m["TimeArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TimeArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TimeArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      timeArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ValueArray") != m.end() && !m["ValueArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ValueArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ValueArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueArray = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityStatInfoResponseBodySecurityEvent() = default;
};
class DescribeSecurityStatInfoResponseBodyVulnerability : public Darabonba::Model {
public:
  shared_ptr<long> asapCount{};
  shared_ptr<vector<string>> asapList{};
  shared_ptr<vector<string>> dateArray{};
  shared_ptr<long> laterCount{};
  shared_ptr<vector<string>> laterList{};
  shared_ptr<vector<string>> levelsOn{};
  shared_ptr<long> nntfCount{};
  shared_ptr<vector<string>> nntfList{};
  shared_ptr<vector<string>> timeArray{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> valueArray{};

  DescribeSecurityStatInfoResponseBodyVulnerability() {}

  explicit DescribeSecurityStatInfoResponseBodyVulnerability(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asapCount) {
      res["AsapCount"] = boost::any(*asapCount);
    }
    if (asapList) {
      res["AsapList"] = boost::any(*asapList);
    }
    if (dateArray) {
      res["DateArray"] = boost::any(*dateArray);
    }
    if (laterCount) {
      res["LaterCount"] = boost::any(*laterCount);
    }
    if (laterList) {
      res["LaterList"] = boost::any(*laterList);
    }
    if (levelsOn) {
      res["LevelsOn"] = boost::any(*levelsOn);
    }
    if (nntfCount) {
      res["NntfCount"] = boost::any(*nntfCount);
    }
    if (nntfList) {
      res["NntfList"] = boost::any(*nntfList);
    }
    if (timeArray) {
      res["TimeArray"] = boost::any(*timeArray);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (valueArray) {
      res["ValueArray"] = boost::any(*valueArray);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsapCount") != m.end() && !m["AsapCount"].empty()) {
      asapCount = make_shared<long>(boost::any_cast<long>(m["AsapCount"]));
    }
    if (m.find("AsapList") != m.end() && !m["AsapList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AsapList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AsapList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      asapList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DateArray") != m.end() && !m["DateArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DateArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DateArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dateArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LaterCount") != m.end() && !m["LaterCount"].empty()) {
      laterCount = make_shared<long>(boost::any_cast<long>(m["LaterCount"]));
    }
    if (m.find("LaterList") != m.end() && !m["LaterList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LaterList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LaterList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      laterList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LevelsOn") != m.end() && !m["LevelsOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LevelsOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LevelsOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      levelsOn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NntfCount") != m.end() && !m["NntfCount"].empty()) {
      nntfCount = make_shared<long>(boost::any_cast<long>(m["NntfCount"]));
    }
    if (m.find("NntfList") != m.end() && !m["NntfList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NntfList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NntfList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nntfList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TimeArray") != m.end() && !m["TimeArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TimeArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TimeArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      timeArray = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ValueArray") != m.end() && !m["ValueArray"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ValueArray"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ValueArray"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueArray = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSecurityStatInfoResponseBodyVulnerability() = default;
};
class DescribeSecurityStatInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSecurityStatInfoResponseBodyAttackEvent> attackEvent{};
  shared_ptr<DescribeSecurityStatInfoResponseBodyHealthCheck> healthCheck{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecurityStatInfoResponseBodySecurityEvent> securityEvent{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeSecurityStatInfoResponseBodyVulnerability> vulnerability{};

  DescribeSecurityStatInfoResponseBody() {}

  explicit DescribeSecurityStatInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attackEvent) {
      res["AttackEvent"] = attackEvent ? boost::any(attackEvent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (healthCheck) {
      res["HealthCheck"] = healthCheck ? boost::any(healthCheck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEvent) {
      res["SecurityEvent"] = securityEvent ? boost::any(securityEvent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (vulnerability) {
      res["Vulnerability"] = vulnerability ? boost::any(vulnerability->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttackEvent") != m.end() && !m["AttackEvent"].empty()) {
      if (typeid(map<string, boost::any>) == m["AttackEvent"].type()) {
        DescribeSecurityStatInfoResponseBodyAttackEvent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AttackEvent"]));
        attackEvent = make_shared<DescribeSecurityStatInfoResponseBodyAttackEvent>(model1);
      }
    }
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthCheck"].type()) {
        DescribeSecurityStatInfoResponseBodyHealthCheck model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthCheck"]));
        healthCheck = make_shared<DescribeSecurityStatInfoResponseBodyHealthCheck>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEvent") != m.end() && !m["SecurityEvent"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityEvent"].type()) {
        DescribeSecurityStatInfoResponseBodySecurityEvent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityEvent"]));
        securityEvent = make_shared<DescribeSecurityStatInfoResponseBodySecurityEvent>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Vulnerability") != m.end() && !m["Vulnerability"].empty()) {
      if (typeid(map<string, boost::any>) == m["Vulnerability"].type()) {
        DescribeSecurityStatInfoResponseBodyVulnerability model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Vulnerability"]));
        vulnerability = make_shared<DescribeSecurityStatInfoResponseBodyVulnerability>(model1);
      }
    }
  }


  virtual ~DescribeSecurityStatInfoResponseBody() = default;
};
class DescribeSecurityStatInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecurityStatInfoResponseBody> body{};

  DescribeSecurityStatInfoResponse() {}

  explicit DescribeSecurityStatInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityStatInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityStatInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityStatInfoResponse() = default;
};
class DescribeServiceLinkedRoleStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> serviceLinkedRole{};

  DescribeServiceLinkedRoleStatusRequest() {}

  explicit DescribeServiceLinkedRoleStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceLinkedRole) {
      res["ServiceLinkedRole"] = boost::any(*serviceLinkedRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceLinkedRole") != m.end() && !m["ServiceLinkedRole"].empty()) {
      serviceLinkedRole = make_shared<string>(boost::any_cast<string>(m["ServiceLinkedRole"]));
    }
  }


  virtual ~DescribeServiceLinkedRoleStatusRequest() = default;
};
class DescribeServiceLinkedRoleStatusResponseBodyRoleStatus : public Darabonba::Model {
public:
  shared_ptr<bool> status{};

  DescribeServiceLinkedRoleStatusResponseBodyRoleStatus() {}

  explicit DescribeServiceLinkedRoleStatusResponseBodyRoleStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~DescribeServiceLinkedRoleStatusResponseBodyRoleStatus() = default;
};
class DescribeServiceLinkedRoleStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeServiceLinkedRoleStatusResponseBodyRoleStatus> roleStatus{};

  DescribeServiceLinkedRoleStatusResponseBody() {}

  explicit DescribeServiceLinkedRoleStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roleStatus) {
      res["RoleStatus"] = roleStatus ? boost::any(roleStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoleStatus") != m.end() && !m["RoleStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["RoleStatus"].type()) {
        DescribeServiceLinkedRoleStatusResponseBodyRoleStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RoleStatus"]));
        roleStatus = make_shared<DescribeServiceLinkedRoleStatusResponseBodyRoleStatus>(model1);
      }
    }
  }


  virtual ~DescribeServiceLinkedRoleStatusResponseBody() = default;
};
class DescribeServiceLinkedRoleStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeServiceLinkedRoleStatusResponseBody> body{};

  DescribeServiceLinkedRoleStatusResponse() {}

  explicit DescribeServiceLinkedRoleStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeServiceLinkedRoleStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeServiceLinkedRoleStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeServiceLinkedRoleStatusResponse() = default;
};
class DescribeSimilarEventScenariosRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> securityEventId{};
  shared_ptr<string> sourceIp{};

  DescribeSimilarEventScenariosRequest() {}

  explicit DescribeSimilarEventScenariosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<long>(boost::any_cast<long>(m["SecurityEventId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeSimilarEventScenariosRequest() = default;
};
class DescribeSimilarEventScenariosResponseBodyScenarios : public Darabonba::Model {
public:
  shared_ptr<string> code{};

  DescribeSimilarEventScenariosResponseBodyScenarios() {}

  explicit DescribeSimilarEventScenariosResponseBodyScenarios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DescribeSimilarEventScenariosResponseBodyScenarios() = default;
};
class DescribeSimilarEventScenariosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSimilarEventScenariosResponseBodyScenarios>> scenarios{};

  DescribeSimilarEventScenariosResponseBody() {}

  explicit DescribeSimilarEventScenariosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scenarios) {
      vector<boost::any> temp1;
      for(auto item1:*scenarios){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Scenarios"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Scenarios") != m.end() && !m["Scenarios"].empty()) {
      if (typeid(vector<boost::any>) == m["Scenarios"].type()) {
        vector<DescribeSimilarEventScenariosResponseBodyScenarios> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Scenarios"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSimilarEventScenariosResponseBodyScenarios model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scenarios = make_shared<vector<DescribeSimilarEventScenariosResponseBodyScenarios>>(expect1);
      }
    }
  }


  virtual ~DescribeSimilarEventScenariosResponseBody() = default;
};
class DescribeSimilarEventScenariosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSimilarEventScenariosResponseBody> body{};

  DescribeSimilarEventScenariosResponse() {}

  explicit DescribeSimilarEventScenariosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSimilarEventScenariosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSimilarEventScenariosResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSimilarEventScenariosResponse() = default;
};
class DescribeSimilarSecurityEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> taskId{};

  DescribeSimilarSecurityEventsRequest() {}

  explicit DescribeSimilarSecurityEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DescribeSimilarSecurityEventsRequest() = default;
};
class DescribeSimilarSecurityEventsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeSimilarSecurityEventsResponseBodyPageInfo() {}

  explicit DescribeSimilarSecurityEventsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSimilarSecurityEventsResponseBodyPageInfo() = default;
};
class DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<long> lastTime{};
  shared_ptr<long> occurrenceTime{};
  shared_ptr<long> securityEventId{};
  shared_ptr<string> uuid{};

  DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse() {}

  explicit DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (occurrenceTime) {
      res["OccurrenceTime"] = boost::any(*occurrenceTime);
    }
    if (securityEventId) {
      res["SecurityEventId"] = boost::any(*securityEventId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
    if (m.find("OccurrenceTime") != m.end() && !m["OccurrenceTime"].empty()) {
      occurrenceTime = make_shared<long>(boost::any_cast<long>(m["OccurrenceTime"]));
    }
    if (m.find("SecurityEventId") != m.end() && !m["SecurityEventId"].empty()) {
      securityEventId = make_shared<long>(boost::any_cast<long>(m["SecurityEventId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse() = default;
};
class DescribeSimilarSecurityEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSimilarSecurityEventsResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse>> securityEventsResponse{};

  DescribeSimilarSecurityEventsResponseBody() {}

  explicit DescribeSimilarSecurityEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEventsResponse) {
      vector<boost::any> temp1;
      for(auto item1:*securityEventsResponse){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityEventsResponse"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeSimilarSecurityEventsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeSimilarSecurityEventsResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEventsResponse") != m.end() && !m["SecurityEventsResponse"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityEventsResponse"].type()) {
        vector<DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityEventsResponse"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityEventsResponse = make_shared<vector<DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse>>(expect1);
      }
    }
  }


  virtual ~DescribeSimilarSecurityEventsResponseBody() = default;
};
class DescribeSimilarSecurityEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSimilarSecurityEventsResponseBody> body{};

  DescribeSimilarSecurityEventsResponse() {}

  explicit DescribeSimilarSecurityEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSimilarSecurityEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSimilarSecurityEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSimilarSecurityEventsResponse() = default;
};
class DescribeSnapshotsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiVersion{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> isAliYunEcs{};
  shared_ptr<string> machineRegion{};
  shared_ptr<string> machineRemark{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> statusList{};
  shared_ptr<string> uuid{};

  DescribeSnapshotsRequest() {}

  explicit DescribeSnapshotsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiVersion) {
      res["ApiVersion"] = boost::any(*apiVersion);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (isAliYunEcs) {
      res["IsAliYunEcs"] = boost::any(*isAliYunEcs);
    }
    if (machineRegion) {
      res["MachineRegion"] = boost::any(*machineRegion);
    }
    if (machineRemark) {
      res["MachineRemark"] = boost::any(*machineRemark);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiVersion") != m.end() && !m["ApiVersion"].empty()) {
      apiVersion = make_shared<string>(boost::any_cast<string>(m["ApiVersion"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IsAliYunEcs") != m.end() && !m["IsAliYunEcs"].empty()) {
      isAliYunEcs = make_shared<string>(boost::any_cast<string>(m["IsAliYunEcs"]));
    }
    if (m.find("MachineRegion") != m.end() && !m["MachineRegion"].empty()) {
      machineRegion = make_shared<string>(boost::any_cast<string>(m["MachineRegion"]));
    }
    if (m.find("MachineRemark") != m.end() && !m["MachineRemark"].empty()) {
      machineRemark = make_shared<string>(boost::any_cast<string>(m["MachineRemark"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      statusList = make_shared<string>(boost::any_cast<string>(m["StatusList"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeSnapshotsRequest() = default;
};
class DescribeSnapshotsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeSnapshotsResponseBodyPageInfo() {}

  explicit DescribeSnapshotsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSnapshotsResponseBodyPageInfo() = default;
};
class DescribeSnapshotsResponseBodySnapshots : public Darabonba::Model {
public:
  shared_ptr<long> actualBytes{};
  shared_ptr<long> actualItems{};
  shared_ptr<long> bytesDone{};
  shared_ptr<long> bytesTotal{};
  shared_ptr<string> clientId{};
  shared_ptr<string> clientVersion{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> errorFile{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> itemsDone{};
  shared_ptr<long> itemsTotal{};
  shared_ptr<string> jobId{};
  shared_ptr<string> parentSnapshotHash{};
  shared_ptr<string> path{};
  shared_ptr<vector<string>> paths{};
  shared_ptr<string> planId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> retention{};
  shared_ptr<string> snapshotHash{};
  shared_ptr<string> snapshotId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> status{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vaultId{};

  DescribeSnapshotsResponseBodySnapshots() {}

  explicit DescribeSnapshotsResponseBodySnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualBytes) {
      res["ActualBytes"] = boost::any(*actualBytes);
    }
    if (actualItems) {
      res["ActualItems"] = boost::any(*actualItems);
    }
    if (bytesDone) {
      res["BytesDone"] = boost::any(*bytesDone);
    }
    if (bytesTotal) {
      res["BytesTotal"] = boost::any(*bytesTotal);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientVersion) {
      res["ClientVersion"] = boost::any(*clientVersion);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (errorFile) {
      res["ErrorFile"] = boost::any(*errorFile);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemsDone) {
      res["ItemsDone"] = boost::any(*itemsDone);
    }
    if (itemsTotal) {
      res["ItemsTotal"] = boost::any(*itemsTotal);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (parentSnapshotHash) {
      res["ParentSnapshotHash"] = boost::any(*parentSnapshotHash);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (paths) {
      res["Paths"] = boost::any(*paths);
    }
    if (planId) {
      res["PlanId"] = boost::any(*planId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (snapshotHash) {
      res["SnapshotHash"] = boost::any(*snapshotHash);
    }
    if (snapshotId) {
      res["SnapshotId"] = boost::any(*snapshotId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vaultId) {
      res["VaultId"] = boost::any(*vaultId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualBytes") != m.end() && !m["ActualBytes"].empty()) {
      actualBytes = make_shared<long>(boost::any_cast<long>(m["ActualBytes"]));
    }
    if (m.find("ActualItems") != m.end() && !m["ActualItems"].empty()) {
      actualItems = make_shared<long>(boost::any_cast<long>(m["ActualItems"]));
    }
    if (m.find("BytesDone") != m.end() && !m["BytesDone"].empty()) {
      bytesDone = make_shared<long>(boost::any_cast<long>(m["BytesDone"]));
    }
    if (m.find("BytesTotal") != m.end() && !m["BytesTotal"].empty()) {
      bytesTotal = make_shared<long>(boost::any_cast<long>(m["BytesTotal"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientVersion") != m.end() && !m["ClientVersion"].empty()) {
      clientVersion = make_shared<string>(boost::any_cast<string>(m["ClientVersion"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("ErrorFile") != m.end() && !m["ErrorFile"].empty()) {
      errorFile = make_shared<string>(boost::any_cast<string>(m["ErrorFile"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemsDone") != m.end() && !m["ItemsDone"].empty()) {
      itemsDone = make_shared<long>(boost::any_cast<long>(m["ItemsDone"]));
    }
    if (m.find("ItemsTotal") != m.end() && !m["ItemsTotal"].empty()) {
      itemsTotal = make_shared<long>(boost::any_cast<long>(m["ItemsTotal"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ParentSnapshotHash") != m.end() && !m["ParentSnapshotHash"].empty()) {
      parentSnapshotHash = make_shared<string>(boost::any_cast<string>(m["ParentSnapshotHash"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Paths") != m.end() && !m["Paths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Paths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Paths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      paths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PlanId") != m.end() && !m["PlanId"].empty()) {
      planId = make_shared<string>(boost::any_cast<string>(m["PlanId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("SnapshotHash") != m.end() && !m["SnapshotHash"].empty()) {
      snapshotHash = make_shared<string>(boost::any_cast<string>(m["SnapshotHash"]));
    }
    if (m.find("SnapshotId") != m.end() && !m["SnapshotId"].empty()) {
      snapshotId = make_shared<string>(boost::any_cast<string>(m["SnapshotId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VaultId") != m.end() && !m["VaultId"].empty()) {
      vaultId = make_shared<string>(boost::any_cast<string>(m["VaultId"]));
    }
  }


  virtual ~DescribeSnapshotsResponseBodySnapshots() = default;
};
class DescribeSnapshotsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSnapshotsResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSnapshotsResponseBodySnapshots>> snapshots{};

  DescribeSnapshotsResponseBody() {}

  explicit DescribeSnapshotsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshots) {
      vector<boost::any> temp1;
      for(auto item1:*snapshots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshots"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeSnapshotsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeSnapshotsResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<DescribeSnapshotsResponseBodySnapshots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnapshotsResponseBodySnapshots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshots = make_shared<vector<DescribeSnapshotsResponseBodySnapshots>>(expect1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponseBody() = default;
};
class DescribeSnapshotsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSnapshotsResponseBody> body{};

  DescribeSnapshotsResponse() {}

  explicit DescribeSnapshotsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotsResponse() = default;
};
class DescribeStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> customType{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> strategyIds{};

  DescribeStrategyRequest() {}

  explicit DescribeStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customType) {
      res["CustomType"] = boost::any(*customType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (strategyIds) {
      res["StrategyIds"] = boost::any(*strategyIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomType") != m.end() && !m["CustomType"].empty()) {
      customType = make_shared<string>(boost::any_cast<string>(m["CustomType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("StrategyIds") != m.end() && !m["StrategyIds"].empty()) {
      strategyIds = make_shared<string>(boost::any_cast<string>(m["StrategyIds"]));
    }
  }


  virtual ~DescribeStrategyRequest() = default;
};
class DescribeStrategyResponseBodyStrategiesConfigTargets : public Darabonba::Model {
public:
  shared_ptr<string> flag{};
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};

  DescribeStrategyResponseBodyStrategiesConfigTargets() {}

  explicit DescribeStrategyResponseBodyStrategiesConfigTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<string>(boost::any_cast<string>(m["Flag"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeStrategyResponseBodyStrategiesConfigTargets() = default;
};
class DescribeStrategyResponseBodyStrategies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeStrategyResponseBodyStrategiesConfigTargets>> configTargets{};
  shared_ptr<string> customType{};
  shared_ptr<long> cycleDays{};
  shared_ptr<long> cycleStartTime{};
  shared_ptr<long> ecsCount{};
  shared_ptr<string> endTime{};
  shared_ptr<long> execStatus{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> passRate{};
  shared_ptr<long> processRate{};
  shared_ptr<long> riskCount{};
  shared_ptr<string> startTime{};
  shared_ptr<long> type{};

  DescribeStrategyResponseBodyStrategies() {}

  explicit DescribeStrategyResponseBodyStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configTargets) {
      vector<boost::any> temp1;
      for(auto item1:*configTargets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigTargets"] = boost::any(temp1);
    }
    if (customType) {
      res["CustomType"] = boost::any(*customType);
    }
    if (cycleDays) {
      res["CycleDays"] = boost::any(*cycleDays);
    }
    if (cycleStartTime) {
      res["CycleStartTime"] = boost::any(*cycleStartTime);
    }
    if (ecsCount) {
      res["EcsCount"] = boost::any(*ecsCount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (execStatus) {
      res["ExecStatus"] = boost::any(*execStatus);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (passRate) {
      res["PassRate"] = boost::any(*passRate);
    }
    if (processRate) {
      res["ProcessRate"] = boost::any(*processRate);
    }
    if (riskCount) {
      res["RiskCount"] = boost::any(*riskCount);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigTargets") != m.end() && !m["ConfigTargets"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigTargets"].type()) {
        vector<DescribeStrategyResponseBodyStrategiesConfigTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigTargets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyResponseBodyStrategiesConfigTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configTargets = make_shared<vector<DescribeStrategyResponseBodyStrategiesConfigTargets>>(expect1);
      }
    }
    if (m.find("CustomType") != m.end() && !m["CustomType"].empty()) {
      customType = make_shared<string>(boost::any_cast<string>(m["CustomType"]));
    }
    if (m.find("CycleDays") != m.end() && !m["CycleDays"].empty()) {
      cycleDays = make_shared<long>(boost::any_cast<long>(m["CycleDays"]));
    }
    if (m.find("CycleStartTime") != m.end() && !m["CycleStartTime"].empty()) {
      cycleStartTime = make_shared<long>(boost::any_cast<long>(m["CycleStartTime"]));
    }
    if (m.find("EcsCount") != m.end() && !m["EcsCount"].empty()) {
      ecsCount = make_shared<long>(boost::any_cast<long>(m["EcsCount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ExecStatus") != m.end() && !m["ExecStatus"].empty()) {
      execStatus = make_shared<long>(boost::any_cast<long>(m["ExecStatus"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PassRate") != m.end() && !m["PassRate"].empty()) {
      passRate = make_shared<long>(boost::any_cast<long>(m["PassRate"]));
    }
    if (m.find("ProcessRate") != m.end() && !m["ProcessRate"].empty()) {
      processRate = make_shared<long>(boost::any_cast<long>(m["ProcessRate"]));
    }
    if (m.find("RiskCount") != m.end() && !m["RiskCount"].empty()) {
      riskCount = make_shared<long>(boost::any_cast<long>(m["RiskCount"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~DescribeStrategyResponseBodyStrategies() = default;
};
class DescribeStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeStrategyResponseBodyStrategies>> strategies{};

  DescribeStrategyResponseBody() {}

  explicit DescribeStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategies) {
      vector<boost::any> temp1;
      for(auto item1:*strategies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Strategies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Strategies") != m.end() && !m["Strategies"].empty()) {
      if (typeid(vector<boost::any>) == m["Strategies"].type()) {
        vector<DescribeStrategyResponseBodyStrategies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Strategies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyResponseBodyStrategies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategies = make_shared<vector<DescribeStrategyResponseBodyStrategies>>(expect1);
      }
    }
  }


  virtual ~DescribeStrategyResponseBody() = default;
};
class DescribeStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStrategyResponseBody> body{};

  DescribeStrategyResponse() {}

  explicit DescribeStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStrategyResponse() = default;
};
class DescribeStrategyDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  DescribeStrategyDetailRequest() {}

  explicit DescribeStrategyDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeStrategyDetailRequest() = default;
};
class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList : public Darabonba::Model {
public:
  shared_ptr<string> enumValue{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minValue{};
  shared_ptr<string> paramDefaultValue{};
  shared_ptr<string> paramDesc{};
  shared_ptr<string> paramName{};
  shared_ptr<long> paramType{};
  shared_ptr<string> value{};

  DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList() {}

  explicit DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (paramDefaultValue) {
      res["ParamDefaultValue"] = boost::any(*paramDefaultValue);
    }
    if (paramDesc) {
      res["ParamDesc"] = boost::any(*paramDesc);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParamDefaultValue") != m.end() && !m["ParamDefaultValue"].empty()) {
      paramDefaultValue = make_shared<string>(boost::any_cast<string>(m["ParamDefaultValue"]));
    }
    if (m.find("ParamDesc") != m.end() && !m["ParamDesc"].empty()) {
      paramDesc = make_shared<string>(boost::any_cast<string>(m["ParamDesc"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<long>(boost::any_cast<long>(m["ParamType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList() = default;
};
class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules : public Darabonba::Model {
public:
  shared_ptr<long> defaultValue{};
  shared_ptr<long> optional{};
  shared_ptr<vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList>> paramList{};
  shared_ptr<string> ruleDesc{};
  shared_ptr<string> ruleId{};

  DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules() {}

  explicit DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (optional) {
      res["Optional"] = boost::any(*optional);
    }
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    if (ruleDesc) {
      res["RuleDesc"] = boost::any(*ruleDesc);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<long>(boost::any_cast<long>(m["DefaultValue"]));
    }
    if (m.find("Optional") != m.end() && !m["Optional"].empty()) {
      optional = make_shared<long>(boost::any_cast<long>(m["Optional"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList>>(expect1);
      }
    }
    if (m.find("RuleDesc") != m.end() && !m["RuleDesc"].empty()) {
      ruleDesc = make_shared<string>(boost::any_cast<string>(m["RuleDesc"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules() = default;
};
class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails : public Darabonba::Model {
public:
  shared_ptr<string> checkDesc{};
  shared_ptr<long> checkId{};
  shared_ptr<string> checkItem{};
  shared_ptr<vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules>> rules{};

  DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails() {}

  explicit DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkDesc) {
      res["CheckDesc"] = boost::any(*checkDesc);
    }
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckDesc") != m.end() && !m["CheckDesc"].empty()) {
      checkDesc = make_shared<string>(boost::any_cast<string>(m["CheckDesc"]));
    }
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules>>(expect1);
      }
    }
  }


  virtual ~DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails() = default;
};
class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails>> checkDetails{};
  shared_ptr<bool> on{};
  shared_ptr<string> typeName_{};

  DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes() {}

  explicit DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (checkDetails) {
      vector<boost::any> temp1;
      for(auto item1:*checkDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CheckDetails"] = boost::any(temp1);
    }
    if (on) {
      res["On"] = boost::any(*on);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("CheckDetails") != m.end() && !m["CheckDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["CheckDetails"].type()) {
        vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CheckDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkDetails = make_shared<vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails>>(expect1);
      }
    }
    if (m.find("On") != m.end() && !m["On"].empty()) {
      on = make_shared<bool>(boost::any_cast<bool>(m["On"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes() = default;
};
class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<bool> on{};
  shared_ptr<vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes>> subTypes{};
  shared_ptr<string> typeName_{};

  DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList() {}

  explicit DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (on) {
      res["On"] = boost::any(*on);
    }
    if (subTypes) {
      vector<boost::any> temp1;
      for(auto item1:*subTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubTypes"] = boost::any(temp1);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("On") != m.end() && !m["On"].empty()) {
      on = make_shared<bool>(boost::any_cast<bool>(m["On"]));
    }
    if (m.find("SubTypes") != m.end() && !m["SubTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["SubTypes"].type()) {
        vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subTypes = make_shared<vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes>>(expect1);
      }
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList() = default;
};
class DescribeStrategyDetailResponseBodyStrategy : public Darabonba::Model {
public:
  shared_ptr<string> customType{};
  shared_ptr<long> cycleDays{};
  shared_ptr<long> cycleStartTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> riskSubTypeName{};
  shared_ptr<vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList>> riskTypeWhiteListQueryResultList{};
  shared_ptr<string> startTime{};
  shared_ptr<string> targetType{};
  shared_ptr<long> type{};

  DescribeStrategyDetailResponseBodyStrategy() {}

  explicit DescribeStrategyDetailResponseBodyStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customType) {
      res["CustomType"] = boost::any(*customType);
    }
    if (cycleDays) {
      res["CycleDays"] = boost::any(*cycleDays);
    }
    if (cycleStartTime) {
      res["CycleStartTime"] = boost::any(*cycleStartTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (riskSubTypeName) {
      res["RiskSubTypeName"] = boost::any(*riskSubTypeName);
    }
    if (riskTypeWhiteListQueryResultList) {
      vector<boost::any> temp1;
      for(auto item1:*riskTypeWhiteListQueryResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RiskTypeWhiteListQueryResultList"] = boost::any(temp1);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomType") != m.end() && !m["CustomType"].empty()) {
      customType = make_shared<string>(boost::any_cast<string>(m["CustomType"]));
    }
    if (m.find("CycleDays") != m.end() && !m["CycleDays"].empty()) {
      cycleDays = make_shared<long>(boost::any_cast<long>(m["CycleDays"]));
    }
    if (m.find("CycleStartTime") != m.end() && !m["CycleStartTime"].empty()) {
      cycleStartTime = make_shared<long>(boost::any_cast<long>(m["CycleStartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RiskSubTypeName") != m.end() && !m["RiskSubTypeName"].empty()) {
      riskSubTypeName = make_shared<string>(boost::any_cast<string>(m["RiskSubTypeName"]));
    }
    if (m.find("RiskTypeWhiteListQueryResultList") != m.end() && !m["RiskTypeWhiteListQueryResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["RiskTypeWhiteListQueryResultList"].type()) {
        vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RiskTypeWhiteListQueryResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        riskTypeWhiteListQueryResultList = make_shared<vector<DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList>>(expect1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~DescribeStrategyDetailResponseBodyStrategy() = default;
};
class DescribeStrategyDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeStrategyDetailResponseBodyStrategy> strategy{};

  DescribeStrategyDetailResponseBody() {}

  explicit DescribeStrategyDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        DescribeStrategyDetailResponseBodyStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<DescribeStrategyDetailResponseBodyStrategy>(model1);
      }
    }
  }


  virtual ~DescribeStrategyDetailResponseBody() = default;
};
class DescribeStrategyDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStrategyDetailResponseBody> body{};

  DescribeStrategyDetailResponse() {}

  explicit DescribeStrategyDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStrategyDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStrategyDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStrategyDetailResponse() = default;
};
class DescribeStrategyExecDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> strategyId{};

  DescribeStrategyExecDetailRequest() {}

  explicit DescribeStrategyExecDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
  }


  virtual ~DescribeStrategyExecDetailRequest() = default;
};
class DescribeStrategyExecDetailResponseBodyFailedEcsList : public Darabonba::Model {
public:
  shared_ptr<string> IP{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> reason{};

  DescribeStrategyExecDetailResponseBodyFailedEcsList() {}

  explicit DescribeStrategyExecDetailResponseBodyFailedEcsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~DescribeStrategyExecDetailResponseBodyFailedEcsList() = default;
};
class DescribeStrategyExecDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> failCount{};
  shared_ptr<vector<DescribeStrategyExecDetailResponseBodyFailedEcsList>> failedEcsList{};
  shared_ptr<long> inProcessCount{};
  shared_ptr<string> percent{};
  shared_ptr<string> requestId{};
  shared_ptr<string> source{};
  shared_ptr<string> startTime{};
  shared_ptr<long> successCount{};

  DescribeStrategyExecDetailResponseBody() {}

  explicit DescribeStrategyExecDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (failedEcsList) {
      vector<boost::any> temp1;
      for(auto item1:*failedEcsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedEcsList"] = boost::any(temp1);
    }
    if (inProcessCount) {
      res["InProcessCount"] = boost::any(*inProcessCount);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("FailedEcsList") != m.end() && !m["FailedEcsList"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedEcsList"].type()) {
        vector<DescribeStrategyExecDetailResponseBodyFailedEcsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedEcsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyExecDetailResponseBodyFailedEcsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedEcsList = make_shared<vector<DescribeStrategyExecDetailResponseBodyFailedEcsList>>(expect1);
      }
    }
    if (m.find("InProcessCount") != m.end() && !m["InProcessCount"].empty()) {
      inProcessCount = make_shared<long>(boost::any_cast<long>(m["InProcessCount"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<string>(boost::any_cast<string>(m["Percent"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
  }


  virtual ~DescribeStrategyExecDetailResponseBody() = default;
};
class DescribeStrategyExecDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStrategyExecDetailResponseBody> body{};

  DescribeStrategyExecDetailResponse() {}

  explicit DescribeStrategyExecDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStrategyExecDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStrategyExecDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStrategyExecDetailResponse() = default;
};
class DescribeStrategyTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  DescribeStrategyTargetRequest() {}

  explicit DescribeStrategyTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeStrategyTargetRequest() = default;
};
class DescribeStrategyTargetResponseBodyStrategyTargets : public Darabonba::Model {
public:
  shared_ptr<long> bindUuidCount{};
  shared_ptr<string> flag{};
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};

  DescribeStrategyTargetResponseBodyStrategyTargets() {}

  explicit DescribeStrategyTargetResponseBodyStrategyTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindUuidCount) {
      res["BindUuidCount"] = boost::any(*bindUuidCount);
    }
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindUuidCount") != m.end() && !m["BindUuidCount"].empty()) {
      bindUuidCount = make_shared<long>(boost::any_cast<long>(m["BindUuidCount"]));
    }
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<string>(boost::any_cast<string>(m["Flag"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeStrategyTargetResponseBodyStrategyTargets() = default;
};
class DescribeStrategyTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeStrategyTargetResponseBodyStrategyTargets>> strategyTargets{};

  DescribeStrategyTargetResponseBody() {}

  explicit DescribeStrategyTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (strategyTargets) {
      vector<boost::any> temp1;
      for(auto item1:*strategyTargets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StrategyTargets"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StrategyTargets") != m.end() && !m["StrategyTargets"].empty()) {
      if (typeid(vector<boost::any>) == m["StrategyTargets"].type()) {
        vector<DescribeStrategyTargetResponseBodyStrategyTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StrategyTargets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeStrategyTargetResponseBodyStrategyTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategyTargets = make_shared<vector<DescribeStrategyTargetResponseBodyStrategyTargets>>(expect1);
      }
    }
  }


  virtual ~DescribeStrategyTargetResponseBody() = default;
};
class DescribeStrategyTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeStrategyTargetResponseBody> body{};

  DescribeStrategyTargetResponse() {}

  explicit DescribeStrategyTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeStrategyTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeStrategyTargetResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeStrategyTargetResponse() = default;
};
class DescribeSummaryInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  DescribeSummaryInfoRequest() {}

  explicit DescribeSummaryInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeSummaryInfoRequest() = default;
};
class DescribeSummaryInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> aegisClientOfflineCount{};
  shared_ptr<long> aegisClientOnlineCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> securityScore{};
  shared_ptr<bool> success{};

  DescribeSummaryInfoResponseBody() {}

  explicit DescribeSummaryInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aegisClientOfflineCount) {
      res["AegisClientOfflineCount"] = boost::any(*aegisClientOfflineCount);
    }
    if (aegisClientOnlineCount) {
      res["AegisClientOnlineCount"] = boost::any(*aegisClientOnlineCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityScore) {
      res["SecurityScore"] = boost::any(*securityScore);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AegisClientOfflineCount") != m.end() && !m["AegisClientOfflineCount"].empty()) {
      aegisClientOfflineCount = make_shared<long>(boost::any_cast<long>(m["AegisClientOfflineCount"]));
    }
    if (m.find("AegisClientOnlineCount") != m.end() && !m["AegisClientOnlineCount"].empty()) {
      aegisClientOnlineCount = make_shared<long>(boost::any_cast<long>(m["AegisClientOnlineCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityScore") != m.end() && !m["SecurityScore"].empty()) {
      securityScore = make_shared<long>(boost::any_cast<long>(m["SecurityScore"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSummaryInfoResponseBody() = default;
};
class DescribeSummaryInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSummaryInfoResponseBody> body{};

  DescribeSummaryInfoResponse() {}

  explicit DescribeSummaryInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSummaryInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSummaryInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSummaryInfoResponse() = default;
};
class DescribeSupportRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> supportRegion{};

  DescribeSupportRegionResponseBody() {}

  explicit DescribeSupportRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportRegion) {
      res["SupportRegion"] = boost::any(*supportRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportRegion") != m.end() && !m["SupportRegion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportRegion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportRegion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportRegion = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSupportRegionResponseBody() = default;
};
class DescribeSupportRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSupportRegionResponseBody> body{};

  DescribeSupportRegionResponse() {}

  explicit DescribeSupportRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSupportRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSupportRegionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSupportRegionResponse() = default;
};
class DescribeSuspEventDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> suspiciousEventId{};

  DescribeSuspEventDetailRequest() {}

  explicit DescribeSuspEventDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (suspiciousEventId) {
      res["SuspiciousEventId"] = boost::any(*suspiciousEventId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("SuspiciousEventId") != m.end() && !m["SuspiciousEventId"].empty()) {
      suspiciousEventId = make_shared<long>(boost::any_cast<long>(m["SuspiciousEventId"]));
    }
  }


  virtual ~DescribeSuspEventDetailRequest() = default;
};
class DescribeSuspEventDetailResponseBodyDetails : public Darabonba::Model {
public:
  shared_ptr<string> nameDisplay{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeSuspEventDetailResponseBodyDetails() {}

  explicit DescribeSuspEventDetailResponseBodyDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameDisplay) {
      res["NameDisplay"] = boost::any(*nameDisplay);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameDisplay") != m.end() && !m["NameDisplay"].empty()) {
      nameDisplay = make_shared<string>(boost::any_cast<string>(m["NameDisplay"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeSuspEventDetailResponseBodyDetails() = default;
};
class DescribeSuspEventDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> canBeDealOnLine{};
  shared_ptr<string> dataSource{};
  shared_ptr<vector<DescribeSuspEventDetailResponseBodyDetails>> details{};
  shared_ptr<string> eventDesc{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventStatus{};
  shared_ptr<string> eventTypeDesc{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> lastTime{};
  shared_ptr<string> level{};
  shared_ptr<string> operateErrorCode{};
  shared_ptr<string> operateMsg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> saleVersion{};
  shared_ptr<string> uuid{};

  DescribeSuspEventDetailResponseBody() {}

  explicit DescribeSuspEventDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canBeDealOnLine) {
      res["CanBeDealOnLine"] = boost::any(*canBeDealOnLine);
    }
    if (dataSource) {
      res["DataSource"] = boost::any(*dataSource);
    }
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (eventDesc) {
      res["EventDesc"] = boost::any(*eventDesc);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventStatus) {
      res["EventStatus"] = boost::any(*eventStatus);
    }
    if (eventTypeDesc) {
      res["EventTypeDesc"] = boost::any(*eventTypeDesc);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (operateErrorCode) {
      res["OperateErrorCode"] = boost::any(*operateErrorCode);
    }
    if (operateMsg) {
      res["OperateMsg"] = boost::any(*operateMsg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (saleVersion) {
      res["SaleVersion"] = boost::any(*saleVersion);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanBeDealOnLine") != m.end() && !m["CanBeDealOnLine"].empty()) {
      canBeDealOnLine = make_shared<bool>(boost::any_cast<bool>(m["CanBeDealOnLine"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSource = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<DescribeSuspEventDetailResponseBodyDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventDetailResponseBodyDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<DescribeSuspEventDetailResponseBodyDetails>>(expect1);
      }
    }
    if (m.find("EventDesc") != m.end() && !m["EventDesc"].empty()) {
      eventDesc = make_shared<string>(boost::any_cast<string>(m["EventDesc"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventStatus") != m.end() && !m["EventStatus"].empty()) {
      eventStatus = make_shared<string>(boost::any_cast<string>(m["EventStatus"]));
    }
    if (m.find("EventTypeDesc") != m.end() && !m["EventTypeDesc"].empty()) {
      eventTypeDesc = make_shared<string>(boost::any_cast<string>(m["EventTypeDesc"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<string>(boost::any_cast<string>(m["LastTime"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("OperateErrorCode") != m.end() && !m["OperateErrorCode"].empty()) {
      operateErrorCode = make_shared<string>(boost::any_cast<string>(m["OperateErrorCode"]));
    }
    if (m.find("OperateMsg") != m.end() && !m["OperateMsg"].empty()) {
      operateMsg = make_shared<string>(boost::any_cast<string>(m["OperateMsg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SaleVersion") != m.end() && !m["SaleVersion"].empty()) {
      saleVersion = make_shared<string>(boost::any_cast<string>(m["SaleVersion"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeSuspEventDetailResponseBody() = default;
};
class DescribeSuspEventDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSuspEventDetailResponseBody> body{};

  DescribeSuspEventDetailResponse() {}

  explicit DescribeSuspEventDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSuspEventDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSuspEventDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSuspEventDetailResponse() = default;
};
class DescribeSuspEventExportInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> exportId{};

  DescribeSuspEventExportInfoRequest() {}

  explicit DescribeSuspEventExportInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportId) {
      res["ExportId"] = boost::any(*exportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportId") != m.end() && !m["ExportId"].empty()) {
      exportId = make_shared<long>(boost::any_cast<long>(m["ExportId"]));
    }
  }


  virtual ~DescribeSuspEventExportInfoRequest() = default;
};
class DescribeSuspEventExportInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> exportStatus{};
  shared_ptr<string> fileName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> link{};
  shared_ptr<long> progress{};
  shared_ptr<string> properties{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> type{};

  DescribeSuspEventExportInfoResponseBody() {}

  explicit DescribeSuspEventExportInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportStatus) {
      res["ExportStatus"] = boost::any(*exportStatus);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (properties) {
      res["Properties"] = boost::any(*properties);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportStatus") != m.end() && !m["ExportStatus"].empty()) {
      exportStatus = make_shared<string>(boost::any_cast<string>(m["ExportStatus"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      properties = make_shared<string>(boost::any_cast<string>(m["Properties"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSuspEventExportInfoResponseBody() = default;
};
class DescribeSuspEventExportInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSuspEventExportInfoResponseBody> body{};

  DescribeSuspEventExportInfoResponse() {}

  explicit DescribeSuspEventExportInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSuspEventExportInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSuspEventExportInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSuspEventExportInfoResponse() = default;
};
class DescribeSuspEventQuaraFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> currentPage{};
  shared_ptr<string> from{};
  shared_ptr<string> groupId{};
  shared_ptr<long> groupingId{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> quaraTag{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> status{};

  DescribeSuspEventQuaraFilesRequest() {}

  explicit DescribeSuspEventQuaraFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupingId) {
      res["GroupingId"] = boost::any(*groupingId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (quaraTag) {
      res["QuaraTag"] = boost::any(*quaraTag);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupingId") != m.end() && !m["GroupingId"].empty()) {
      groupingId = make_shared<long>(boost::any_cast<long>(m["GroupingId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("QuaraTag") != m.end() && !m["QuaraTag"].empty()) {
      quaraTag = make_shared<string>(boost::any_cast<string>(m["QuaraTag"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeSuspEventQuaraFilesRequest() = default;
};
class DescribeSuspEventQuaraFilesResponseBodyQuaraFiles : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> eventType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> link{};
  shared_ptr<string> md5{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> path{};
  shared_ptr<string> status{};
  shared_ptr<string> tag{};
  shared_ptr<string> uuid{};

  DescribeSuspEventQuaraFilesResponseBodyQuaraFiles() {}

  explicit DescribeSuspEventQuaraFilesResponseBodyQuaraFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeSuspEventQuaraFilesResponseBodyQuaraFiles() = default;
};
class DescribeSuspEventQuaraFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeSuspEventQuaraFilesResponseBodyQuaraFiles>> quaraFiles{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeSuspEventQuaraFilesResponseBody() {}

  explicit DescribeSuspEventQuaraFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (quaraFiles) {
      vector<boost::any> temp1;
      for(auto item1:*quaraFiles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QuaraFiles"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QuaraFiles") != m.end() && !m["QuaraFiles"].empty()) {
      if (typeid(vector<boost::any>) == m["QuaraFiles"].type()) {
        vector<DescribeSuspEventQuaraFilesResponseBodyQuaraFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QuaraFiles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventQuaraFilesResponseBodyQuaraFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        quaraFiles = make_shared<vector<DescribeSuspEventQuaraFilesResponseBodyQuaraFiles>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSuspEventQuaraFilesResponseBody() = default;
};
class DescribeSuspEventQuaraFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSuspEventQuaraFilesResponseBody> body{};

  DescribeSuspEventQuaraFilesResponse() {}

  explicit DescribeSuspEventQuaraFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSuspEventQuaraFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSuspEventQuaraFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSuspEventQuaraFilesResponse() = default;
};
class DescribeSuspEventUserSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<long> id{};
  shared_ptr<string> sourceIp{};

  DescribeSuspEventUserSettingRequest() {}

  explicit DescribeSuspEventUserSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeSuspEventUserSettingRequest() = default;
};
class DescribeSuspEventUserSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> levelsOn{};
  shared_ptr<string> requestId{};

  DescribeSuspEventUserSettingResponseBody() {}

  explicit DescribeSuspEventUserSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (levelsOn) {
      res["LevelsOn"] = boost::any(*levelsOn);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LevelsOn") != m.end() && !m["LevelsOn"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LevelsOn"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LevelsOn"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      levelsOn = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSuspEventUserSettingResponseBody() = default;
};
class DescribeSuspEventUserSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSuspEventUserSettingResponseBody> body{};

  DescribeSuspEventUserSettingResponse() {}

  explicit DescribeSuspEventUserSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSuspEventUserSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSuspEventUserSettingResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSuspEventUserSettingResponse() = default;
};
class DescribeSuspEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> alarmUniqueInfo{};
  shared_ptr<vector<string>> assetsTypeList{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> dealed{};
  shared_ptr<string> eventNames{};
  shared_ptr<string> from{};
  shared_ptr<long> groupId{};
  shared_ptr<long> id{};
  shared_ptr<string> lang{};
  shared_ptr<string> levels{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> operateErrorCodeList{};
  shared_ptr<string> operateTimeEnd{};
  shared_ptr<string> operateTimeStart{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> parentEventTypes{};
  shared_ptr<string> remark{};
  shared_ptr<string> sortColumn{};
  shared_ptr<string> sortType{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> status{};
  shared_ptr<string> tacticId{};
  shared_ptr<string> targetType{};
  shared_ptr<string> timeEnd{};
  shared_ptr<string> timeStart{};
  shared_ptr<string> uniqueInfo{};
  shared_ptr<string> uuids{};

  DescribeSuspEventsRequest() {}

  explicit DescribeSuspEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmUniqueInfo) {
      res["AlarmUniqueInfo"] = boost::any(*alarmUniqueInfo);
    }
    if (assetsTypeList) {
      res["AssetsTypeList"] = boost::any(*assetsTypeList);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (eventNames) {
      res["EventNames"] = boost::any(*eventNames);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (levels) {
      res["Levels"] = boost::any(*levels);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operateErrorCodeList) {
      res["OperateErrorCodeList"] = boost::any(*operateErrorCodeList);
    }
    if (operateTimeEnd) {
      res["OperateTimeEnd"] = boost::any(*operateTimeEnd);
    }
    if (operateTimeStart) {
      res["OperateTimeStart"] = boost::any(*operateTimeStart);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentEventTypes) {
      res["ParentEventTypes"] = boost::any(*parentEventTypes);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sortColumn) {
      res["SortColumn"] = boost::any(*sortColumn);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tacticId) {
      res["TacticId"] = boost::any(*tacticId);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (timeEnd) {
      res["TimeEnd"] = boost::any(*timeEnd);
    }
    if (timeStart) {
      res["TimeStart"] = boost::any(*timeStart);
    }
    if (uniqueInfo) {
      res["UniqueInfo"] = boost::any(*uniqueInfo);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmUniqueInfo") != m.end() && !m["AlarmUniqueInfo"].empty()) {
      alarmUniqueInfo = make_shared<string>(boost::any_cast<string>(m["AlarmUniqueInfo"]));
    }
    if (m.find("AssetsTypeList") != m.end() && !m["AssetsTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AssetsTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AssetsTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      assetsTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("EventNames") != m.end() && !m["EventNames"].empty()) {
      eventNames = make_shared<string>(boost::any_cast<string>(m["EventNames"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Levels") != m.end() && !m["Levels"].empty()) {
      levels = make_shared<string>(boost::any_cast<string>(m["Levels"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OperateErrorCodeList") != m.end() && !m["OperateErrorCodeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OperateErrorCodeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OperateErrorCodeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      operateErrorCodeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OperateTimeEnd") != m.end() && !m["OperateTimeEnd"].empty()) {
      operateTimeEnd = make_shared<string>(boost::any_cast<string>(m["OperateTimeEnd"]));
    }
    if (m.find("OperateTimeStart") != m.end() && !m["OperateTimeStart"].empty()) {
      operateTimeStart = make_shared<string>(boost::any_cast<string>(m["OperateTimeStart"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ParentEventTypes") != m.end() && !m["ParentEventTypes"].empty()) {
      parentEventTypes = make_shared<string>(boost::any_cast<string>(m["ParentEventTypes"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SortColumn") != m.end() && !m["SortColumn"].empty()) {
      sortColumn = make_shared<string>(boost::any_cast<string>(m["SortColumn"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<string>(boost::any_cast<string>(m["SortType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TacticId") != m.end() && !m["TacticId"].empty()) {
      tacticId = make_shared<string>(boost::any_cast<string>(m["TacticId"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TimeEnd") != m.end() && !m["TimeEnd"].empty()) {
      timeEnd = make_shared<string>(boost::any_cast<string>(m["TimeEnd"]));
    }
    if (m.find("TimeStart") != m.end() && !m["TimeStart"].empty()) {
      timeStart = make_shared<string>(boost::any_cast<string>(m["TimeStart"]));
    }
    if (m.find("UniqueInfo") != m.end() && !m["UniqueInfo"].empty()) {
      uniqueInfo = make_shared<string>(boost::any_cast<string>(m["UniqueInfo"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeSuspEventsRequest() = default;
};
class DescribeSuspEventsResponseBodySuspEventsDetails : public Darabonba::Model {
public:
  shared_ptr<string> nameDisplay{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<string> valueDisplay{};

  DescribeSuspEventsResponseBodySuspEventsDetails() {}

  explicit DescribeSuspEventsResponseBodySuspEventsDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameDisplay) {
      res["NameDisplay"] = boost::any(*nameDisplay);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueDisplay) {
      res["ValueDisplay"] = boost::any(*valueDisplay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameDisplay") != m.end() && !m["NameDisplay"].empty()) {
      nameDisplay = make_shared<string>(boost::any_cast<string>(m["NameDisplay"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueDisplay") != m.end() && !m["ValueDisplay"].empty()) {
      valueDisplay = make_shared<string>(boost::any_cast<string>(m["ValueDisplay"]));
    }
  }


  virtual ~DescribeSuspEventsResponseBodySuspEventsDetails() = default;
};
class DescribeSuspEventsResponseBodySuspEventsEventNotes : public Darabonba::Model {
public:
  shared_ptr<string> note{};
  shared_ptr<long> noteId{};
  shared_ptr<string> noteTime{};

  DescribeSuspEventsResponseBodySuspEventsEventNotes() {}

  explicit DescribeSuspEventsResponseBodySuspEventsEventNotes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (noteId) {
      res["NoteId"] = boost::any(*noteId);
    }
    if (noteTime) {
      res["NoteTime"] = boost::any(*noteTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("NoteId") != m.end() && !m["NoteId"].empty()) {
      noteId = make_shared<long>(boost::any_cast<long>(m["NoteId"]));
    }
    if (m.find("NoteTime") != m.end() && !m["NoteTime"].empty()) {
      noteTime = make_shared<string>(boost::any_cast<string>(m["NoteTime"]));
    }
  }


  virtual ~DescribeSuspEventsResponseBodySuspEventsEventNotes() = default;
};
class DescribeSuspEventsResponseBodySuspEventsTacticItems : public Darabonba::Model {
public:
  shared_ptr<string> tacticDisplayName{};
  shared_ptr<string> tacticId{};

  DescribeSuspEventsResponseBodySuspEventsTacticItems() {}

  explicit DescribeSuspEventsResponseBodySuspEventsTacticItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tacticDisplayName) {
      res["TacticDisplayName"] = boost::any(*tacticDisplayName);
    }
    if (tacticId) {
      res["TacticId"] = boost::any(*tacticId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TacticDisplayName") != m.end() && !m["TacticDisplayName"].empty()) {
      tacticDisplayName = make_shared<string>(boost::any_cast<string>(m["TacticDisplayName"]));
    }
    if (m.find("TacticId") != m.end() && !m["TacticId"].empty()) {
      tacticId = make_shared<string>(boost::any_cast<string>(m["TacticId"]));
    }
  }


  virtual ~DescribeSuspEventsResponseBodySuspEventsTacticItems() = default;
};
class DescribeSuspEventsResponseBodySuspEvents : public Darabonba::Model {
public:
  shared_ptr<bool> advanced{};
  shared_ptr<string> alarmEventName{};
  shared_ptr<string> alarmEventNameDisplay{};
  shared_ptr<string> alarmEventType{};
  shared_ptr<string> alarmEventTypeDisplay{};
  shared_ptr<string> alarmUniqueInfo{};
  shared_ptr<string> appName{};
  shared_ptr<bool> autoBreaking{};
  shared_ptr<bool> canBeDealOnLine{};
  shared_ptr<bool> canCancelFault{};
  shared_ptr<bool> containHwMode{};
  shared_ptr<string> containerId{};
  shared_ptr<string> containerImageId{};
  shared_ptr<string> containerImageName{};
  shared_ptr<string> dataSource{};
  shared_ptr<string> desc{};
  shared_ptr<vector<DescribeSuspEventsResponseBodySuspEventsDetails>> details{};
  shared_ptr<bool> displaySandboxResult{};
  shared_ptr<vector<DescribeSuspEventsResponseBodySuspEventsEventNotes>> eventNotes{};
  shared_ptr<long> eventStatus{};
  shared_ptr<string> eventSubType{};
  shared_ptr<bool> hasTraceInfo{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> k8sClusterId{};
  shared_ptr<string> k8sClusterName{};
  shared_ptr<string> k8sNamespace{};
  shared_ptr<string> k8sNodeId{};
  shared_ptr<string> k8sNodeName{};
  shared_ptr<string> k8sPodName{};
  shared_ptr<string> lastTime{};
  shared_ptr<long> lastTimeStamp{};
  shared_ptr<string> level{};
  shared_ptr<string> maliciousRuleStatus{};
  shared_ptr<string> markMisRules{};
  shared_ptr<string> name{};
  shared_ptr<string> occurrenceTime{};
  shared_ptr<long> occurrenceTimeStamp{};
  shared_ptr<string> operateErrorCode{};
  shared_ptr<string> operateMsg{};
  shared_ptr<long> operateTime{};
  shared_ptr<string> saleVersion{};
  shared_ptr<string> securityEventIds{};
  shared_ptr<string> stages{};
  shared_ptr<vector<DescribeSuspEventsResponseBodySuspEventsTacticItems>> tacticItems{};
  shared_ptr<string> uniqueInfo{};
  shared_ptr<string> uuid{};
  shared_ptr<string> clusterId{};

  DescribeSuspEventsResponseBodySuspEvents() {}

  explicit DescribeSuspEventsResponseBodySuspEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advanced) {
      res["Advanced"] = boost::any(*advanced);
    }
    if (alarmEventName) {
      res["AlarmEventName"] = boost::any(*alarmEventName);
    }
    if (alarmEventNameDisplay) {
      res["AlarmEventNameDisplay"] = boost::any(*alarmEventNameDisplay);
    }
    if (alarmEventType) {
      res["AlarmEventType"] = boost::any(*alarmEventType);
    }
    if (alarmEventTypeDisplay) {
      res["AlarmEventTypeDisplay"] = boost::any(*alarmEventTypeDisplay);
    }
    if (alarmUniqueInfo) {
      res["AlarmUniqueInfo"] = boost::any(*alarmUniqueInfo);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (autoBreaking) {
      res["AutoBreaking"] = boost::any(*autoBreaking);
    }
    if (canBeDealOnLine) {
      res["CanBeDealOnLine"] = boost::any(*canBeDealOnLine);
    }
    if (canCancelFault) {
      res["CanCancelFault"] = boost::any(*canCancelFault);
    }
    if (containHwMode) {
      res["ContainHwMode"] = boost::any(*containHwMode);
    }
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    if (containerImageId) {
      res["ContainerImageId"] = boost::any(*containerImageId);
    }
    if (containerImageName) {
      res["ContainerImageName"] = boost::any(*containerImageName);
    }
    if (dataSource) {
      res["DataSource"] = boost::any(*dataSource);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (displaySandboxResult) {
      res["DisplaySandboxResult"] = boost::any(*displaySandboxResult);
    }
    if (eventNotes) {
      vector<boost::any> temp1;
      for(auto item1:*eventNotes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventNotes"] = boost::any(temp1);
    }
    if (eventStatus) {
      res["EventStatus"] = boost::any(*eventStatus);
    }
    if (eventSubType) {
      res["EventSubType"] = boost::any(*eventSubType);
    }
    if (hasTraceInfo) {
      res["HasTraceInfo"] = boost::any(*hasTraceInfo);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (k8sClusterId) {
      res["K8sClusterId"] = boost::any(*k8sClusterId);
    }
    if (k8sClusterName) {
      res["K8sClusterName"] = boost::any(*k8sClusterName);
    }
    if (k8sNamespace) {
      res["K8sNamespace"] = boost::any(*k8sNamespace);
    }
    if (k8sNodeId) {
      res["K8sNodeId"] = boost::any(*k8sNodeId);
    }
    if (k8sNodeName) {
      res["K8sNodeName"] = boost::any(*k8sNodeName);
    }
    if (k8sPodName) {
      res["K8sPodName"] = boost::any(*k8sPodName);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (lastTimeStamp) {
      res["LastTimeStamp"] = boost::any(*lastTimeStamp);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (maliciousRuleStatus) {
      res["MaliciousRuleStatus"] = boost::any(*maliciousRuleStatus);
    }
    if (markMisRules) {
      res["MarkMisRules"] = boost::any(*markMisRules);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (occurrenceTime) {
      res["OccurrenceTime"] = boost::any(*occurrenceTime);
    }
    if (occurrenceTimeStamp) {
      res["OccurrenceTimeStamp"] = boost::any(*occurrenceTimeStamp);
    }
    if (operateErrorCode) {
      res["OperateErrorCode"] = boost::any(*operateErrorCode);
    }
    if (operateMsg) {
      res["OperateMsg"] = boost::any(*operateMsg);
    }
    if (operateTime) {
      res["OperateTime"] = boost::any(*operateTime);
    }
    if (saleVersion) {
      res["SaleVersion"] = boost::any(*saleVersion);
    }
    if (securityEventIds) {
      res["SecurityEventIds"] = boost::any(*securityEventIds);
    }
    if (stages) {
      res["Stages"] = boost::any(*stages);
    }
    if (tacticItems) {
      vector<boost::any> temp1;
      for(auto item1:*tacticItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TacticItems"] = boost::any(temp1);
    }
    if (uniqueInfo) {
      res["UniqueInfo"] = boost::any(*uniqueInfo);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (clusterId) {
      res["clusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advanced") != m.end() && !m["Advanced"].empty()) {
      advanced = make_shared<bool>(boost::any_cast<bool>(m["Advanced"]));
    }
    if (m.find("AlarmEventName") != m.end() && !m["AlarmEventName"].empty()) {
      alarmEventName = make_shared<string>(boost::any_cast<string>(m["AlarmEventName"]));
    }
    if (m.find("AlarmEventNameDisplay") != m.end() && !m["AlarmEventNameDisplay"].empty()) {
      alarmEventNameDisplay = make_shared<string>(boost::any_cast<string>(m["AlarmEventNameDisplay"]));
    }
    if (m.find("AlarmEventType") != m.end() && !m["AlarmEventType"].empty()) {
      alarmEventType = make_shared<string>(boost::any_cast<string>(m["AlarmEventType"]));
    }
    if (m.find("AlarmEventTypeDisplay") != m.end() && !m["AlarmEventTypeDisplay"].empty()) {
      alarmEventTypeDisplay = make_shared<string>(boost::any_cast<string>(m["AlarmEventTypeDisplay"]));
    }
    if (m.find("AlarmUniqueInfo") != m.end() && !m["AlarmUniqueInfo"].empty()) {
      alarmUniqueInfo = make_shared<string>(boost::any_cast<string>(m["AlarmUniqueInfo"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AutoBreaking") != m.end() && !m["AutoBreaking"].empty()) {
      autoBreaking = make_shared<bool>(boost::any_cast<bool>(m["AutoBreaking"]));
    }
    if (m.find("CanBeDealOnLine") != m.end() && !m["CanBeDealOnLine"].empty()) {
      canBeDealOnLine = make_shared<bool>(boost::any_cast<bool>(m["CanBeDealOnLine"]));
    }
    if (m.find("CanCancelFault") != m.end() && !m["CanCancelFault"].empty()) {
      canCancelFault = make_shared<bool>(boost::any_cast<bool>(m["CanCancelFault"]));
    }
    if (m.find("ContainHwMode") != m.end() && !m["ContainHwMode"].empty()) {
      containHwMode = make_shared<bool>(boost::any_cast<bool>(m["ContainHwMode"]));
    }
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
    if (m.find("ContainerImageId") != m.end() && !m["ContainerImageId"].empty()) {
      containerImageId = make_shared<string>(boost::any_cast<string>(m["ContainerImageId"]));
    }
    if (m.find("ContainerImageName") != m.end() && !m["ContainerImageName"].empty()) {
      containerImageName = make_shared<string>(boost::any_cast<string>(m["ContainerImageName"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSource = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<DescribeSuspEventsResponseBodySuspEventsDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventsResponseBodySuspEventsDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<DescribeSuspEventsResponseBodySuspEventsDetails>>(expect1);
      }
    }
    if (m.find("DisplaySandboxResult") != m.end() && !m["DisplaySandboxResult"].empty()) {
      displaySandboxResult = make_shared<bool>(boost::any_cast<bool>(m["DisplaySandboxResult"]));
    }
    if (m.find("EventNotes") != m.end() && !m["EventNotes"].empty()) {
      if (typeid(vector<boost::any>) == m["EventNotes"].type()) {
        vector<DescribeSuspEventsResponseBodySuspEventsEventNotes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventNotes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventsResponseBodySuspEventsEventNotes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventNotes = make_shared<vector<DescribeSuspEventsResponseBodySuspEventsEventNotes>>(expect1);
      }
    }
    if (m.find("EventStatus") != m.end() && !m["EventStatus"].empty()) {
      eventStatus = make_shared<long>(boost::any_cast<long>(m["EventStatus"]));
    }
    if (m.find("EventSubType") != m.end() && !m["EventSubType"].empty()) {
      eventSubType = make_shared<string>(boost::any_cast<string>(m["EventSubType"]));
    }
    if (m.find("HasTraceInfo") != m.end() && !m["HasTraceInfo"].empty()) {
      hasTraceInfo = make_shared<bool>(boost::any_cast<bool>(m["HasTraceInfo"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("K8sClusterId") != m.end() && !m["K8sClusterId"].empty()) {
      k8sClusterId = make_shared<string>(boost::any_cast<string>(m["K8sClusterId"]));
    }
    if (m.find("K8sClusterName") != m.end() && !m["K8sClusterName"].empty()) {
      k8sClusterName = make_shared<string>(boost::any_cast<string>(m["K8sClusterName"]));
    }
    if (m.find("K8sNamespace") != m.end() && !m["K8sNamespace"].empty()) {
      k8sNamespace = make_shared<string>(boost::any_cast<string>(m["K8sNamespace"]));
    }
    if (m.find("K8sNodeId") != m.end() && !m["K8sNodeId"].empty()) {
      k8sNodeId = make_shared<string>(boost::any_cast<string>(m["K8sNodeId"]));
    }
    if (m.find("K8sNodeName") != m.end() && !m["K8sNodeName"].empty()) {
      k8sNodeName = make_shared<string>(boost::any_cast<string>(m["K8sNodeName"]));
    }
    if (m.find("K8sPodName") != m.end() && !m["K8sPodName"].empty()) {
      k8sPodName = make_shared<string>(boost::any_cast<string>(m["K8sPodName"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<string>(boost::any_cast<string>(m["LastTime"]));
    }
    if (m.find("LastTimeStamp") != m.end() && !m["LastTimeStamp"].empty()) {
      lastTimeStamp = make_shared<long>(boost::any_cast<long>(m["LastTimeStamp"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("MaliciousRuleStatus") != m.end() && !m["MaliciousRuleStatus"].empty()) {
      maliciousRuleStatus = make_shared<string>(boost::any_cast<string>(m["MaliciousRuleStatus"]));
    }
    if (m.find("MarkMisRules") != m.end() && !m["MarkMisRules"].empty()) {
      markMisRules = make_shared<string>(boost::any_cast<string>(m["MarkMisRules"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OccurrenceTime") != m.end() && !m["OccurrenceTime"].empty()) {
      occurrenceTime = make_shared<string>(boost::any_cast<string>(m["OccurrenceTime"]));
    }
    if (m.find("OccurrenceTimeStamp") != m.end() && !m["OccurrenceTimeStamp"].empty()) {
      occurrenceTimeStamp = make_shared<long>(boost::any_cast<long>(m["OccurrenceTimeStamp"]));
    }
    if (m.find("OperateErrorCode") != m.end() && !m["OperateErrorCode"].empty()) {
      operateErrorCode = make_shared<string>(boost::any_cast<string>(m["OperateErrorCode"]));
    }
    if (m.find("OperateMsg") != m.end() && !m["OperateMsg"].empty()) {
      operateMsg = make_shared<string>(boost::any_cast<string>(m["OperateMsg"]));
    }
    if (m.find("OperateTime") != m.end() && !m["OperateTime"].empty()) {
      operateTime = make_shared<long>(boost::any_cast<long>(m["OperateTime"]));
    }
    if (m.find("SaleVersion") != m.end() && !m["SaleVersion"].empty()) {
      saleVersion = make_shared<string>(boost::any_cast<string>(m["SaleVersion"]));
    }
    if (m.find("SecurityEventIds") != m.end() && !m["SecurityEventIds"].empty()) {
      securityEventIds = make_shared<string>(boost::any_cast<string>(m["SecurityEventIds"]));
    }
    if (m.find("Stages") != m.end() && !m["Stages"].empty()) {
      stages = make_shared<string>(boost::any_cast<string>(m["Stages"]));
    }
    if (m.find("TacticItems") != m.end() && !m["TacticItems"].empty()) {
      if (typeid(vector<boost::any>) == m["TacticItems"].type()) {
        vector<DescribeSuspEventsResponseBodySuspEventsTacticItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TacticItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventsResponseBodySuspEventsTacticItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tacticItems = make_shared<vector<DescribeSuspEventsResponseBodySuspEventsTacticItems>>(expect1);
      }
    }
    if (m.find("UniqueInfo") != m.end() && !m["UniqueInfo"].empty()) {
      uniqueInfo = make_shared<string>(boost::any_cast<string>(m["UniqueInfo"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("clusterId") != m.end() && !m["clusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["clusterId"]));
    }
  }


  virtual ~DescribeSuspEventsResponseBodySuspEvents() = default;
};
class DescribeSuspEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSuspEventsResponseBodySuspEvents>> suspEvents{};
  shared_ptr<long> totalCount{};

  DescribeSuspEventsResponseBody() {}

  explicit DescribeSuspEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (suspEvents) {
      vector<boost::any> temp1;
      for(auto item1:*suspEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuspEvents"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuspEvents") != m.end() && !m["SuspEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["SuspEvents"].type()) {
        vector<DescribeSuspEventsResponseBodySuspEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuspEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSuspEventsResponseBodySuspEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        suspEvents = make_shared<vector<DescribeSuspEventsResponseBodySuspEvents>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSuspEventsResponseBody() = default;
};
class DescribeSuspEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSuspEventsResponseBody> body{};

  DescribeSuspEventsResponse() {}

  explicit DescribeSuspEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSuspEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSuspEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSuspEventsResponse() = default;
};
class DescribeSuspiciousOverallConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  DescribeSuspiciousOverallConfigRequest() {}

  explicit DescribeSuspiciousOverallConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSuspiciousOverallConfigRequest() = default;
};
class DescribeSuspiciousOverallConfigResponseBodyOverallConfig : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> type{};

  DescribeSuspiciousOverallConfigResponseBodyOverallConfig() {}

  explicit DescribeSuspiciousOverallConfigResponseBodyOverallConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSuspiciousOverallConfigResponseBodyOverallConfig() = default;
};
class DescribeSuspiciousOverallConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSuspiciousOverallConfigResponseBodyOverallConfig> overallConfig{};
  shared_ptr<string> requestId{};

  DescribeSuspiciousOverallConfigResponseBody() {}

  explicit DescribeSuspiciousOverallConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overallConfig) {
      res["OverallConfig"] = overallConfig ? boost::any(overallConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverallConfig") != m.end() && !m["OverallConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverallConfig"].type()) {
        DescribeSuspiciousOverallConfigResponseBodyOverallConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverallConfig"]));
        overallConfig = make_shared<DescribeSuspiciousOverallConfigResponseBodyOverallConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSuspiciousOverallConfigResponseBody() = default;
};
class DescribeSuspiciousOverallConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSuspiciousOverallConfigResponseBody> body{};

  DescribeSuspiciousOverallConfigResponse() {}

  explicit DescribeSuspiciousOverallConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSuspiciousOverallConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSuspiciousOverallConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSuspiciousOverallConfigResponse() = default;
};
class DescribeSuspiciousUUIDConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  DescribeSuspiciousUUIDConfigRequest() {}

  explicit DescribeSuspiciousUUIDConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSuspiciousUUIDConfigRequest() = default;
};
class DescribeSuspiciousUUIDConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> UUIDList{};

  DescribeSuspiciousUUIDConfigResponseBody() {}

  explicit DescribeSuspiciousUUIDConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (UUIDList) {
      res["UUIDList"] = boost::any(*UUIDList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UUIDList") != m.end() && !m["UUIDList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UUIDList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UUIDList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      UUIDList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSuspiciousUUIDConfigResponseBody() = default;
};
class DescribeSuspiciousUUIDConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSuspiciousUUIDConfigResponseBody> body{};

  DescribeSuspiciousUUIDConfigResponse() {}

  explicit DescribeSuspiciousUUIDConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSuspiciousUUIDConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSuspiciousUUIDConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSuspiciousUUIDConfigResponse() = default;
};
class DescribeTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> type{};

  DescribeTargetRequest() {}

  explicit DescribeTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTargetRequest() = default;
};
class DescribeTargetResponseBodyTargets : public Darabonba::Model {
public:
  shared_ptr<string> flag{};
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};

  DescribeTargetResponseBodyTargets() {}

  explicit DescribeTargetResponseBodyTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<string>(boost::any_cast<string>(m["Flag"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeTargetResponseBodyTargets() = default;
};
class DescribeTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTargetResponseBodyTargets>> targets{};
  shared_ptr<long> totalCount{};

  DescribeTargetResponseBody() {}

  explicit DescribeTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (targets) {
      vector<boost::any> temp1;
      for(auto item1:*targets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Targets"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(vector<boost::any>) == m["Targets"].type()) {
        vector<DescribeTargetResponseBodyTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Targets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTargetResponseBodyTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targets = make_shared<vector<DescribeTargetResponseBodyTargets>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTargetResponseBody() = default;
};
class DescribeTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTargetResponseBody> body{};

  DescribeTargetResponse() {}

  explicit DescribeTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTargetResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTargetResponse() = default;
};
class DescribeTaskErrorLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> buildTaskId{};

  DescribeTaskErrorLogRequest() {}

  explicit DescribeTaskErrorLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildTaskId) {
      res["BuildTaskId"] = boost::any(*buildTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuildTaskId") != m.end() && !m["BuildTaskId"].empty()) {
      buildTaskId = make_shared<string>(boost::any_cast<string>(m["BuildTaskId"]));
    }
  }


  virtual ~DescribeTaskErrorLogRequest() = default;
};
class DescribeTaskErrorLogResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  DescribeTaskErrorLogResponseBodyLogs() {}

  explicit DescribeTaskErrorLogResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~DescribeTaskErrorLogResponseBodyLogs() = default;
};
class DescribeTaskErrorLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTaskErrorLogResponseBodyLogs>> logs{};
  shared_ptr<string> requestId{};

  DescribeTaskErrorLogResponseBody() {}

  explicit DescribeTaskErrorLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<DescribeTaskErrorLogResponseBodyLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTaskErrorLogResponseBodyLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<DescribeTaskErrorLogResponseBodyLogs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeTaskErrorLogResponseBody() = default;
};
class DescribeTaskErrorLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTaskErrorLogResponseBody> body{};

  DescribeTaskErrorLogResponse() {}

  explicit DescribeTaskErrorLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTaskErrorLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTaskErrorLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTaskErrorLogResponse() = default;
};
class DescribeTotalStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<long> groupId{};
  shared_ptr<string> remark{};

  DescribeTotalStatisticsRequest() {}

  explicit DescribeTotalStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~DescribeTotalStatisticsRequest() = default;
};
class DescribeTotalStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> account{};
  shared_ptr<long> health{};
  shared_ptr<long> healthTotal{};
  shared_ptr<long> healthdealedTotal{};
  shared_ptr<long> healthhighTotal{};
  shared_ptr<long> healthlowTotal{};
  shared_ptr<long> healthmediumTotal{};
  shared_ptr<long> healthseriousTotal{};
  shared_ptr<long> newsuspicious{};
  shared_ptr<bool> online{};
  shared_ptr<long> patch{};
  shared_ptr<string> requestId{};
  shared_ptr<long> suspicious{};
  shared_ptr<long> suspiciousTotal{};
  shared_ptr<long> suspiciousdealedTotal{};
  shared_ptr<long> suspicioushighTotal{};
  shared_ptr<long> suspiciouslowTotal{};
  shared_ptr<long> suspiciousmediumTotal{};
  shared_ptr<long> suspiciousseriousTotal{};
  shared_ptr<long> trojan{};
  shared_ptr<long> vul{};
  shared_ptr<long> vulAsapSum{};
  shared_ptr<long> vulDealedTotal{};
  shared_ptr<long> vulLaterSum{};
  shared_ptr<long> vulNntfSum{};
  shared_ptr<long> vulTotal{};

  DescribeTotalStatisticsResponseBody() {}

  explicit DescribeTotalStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (health) {
      res["Health"] = boost::any(*health);
    }
    if (healthTotal) {
      res["HealthTotal"] = boost::any(*healthTotal);
    }
    if (healthdealedTotal) {
      res["HealthdealedTotal"] = boost::any(*healthdealedTotal);
    }
    if (healthhighTotal) {
      res["HealthhighTotal"] = boost::any(*healthhighTotal);
    }
    if (healthlowTotal) {
      res["HealthlowTotal"] = boost::any(*healthlowTotal);
    }
    if (healthmediumTotal) {
      res["HealthmediumTotal"] = boost::any(*healthmediumTotal);
    }
    if (healthseriousTotal) {
      res["HealthseriousTotal"] = boost::any(*healthseriousTotal);
    }
    if (newsuspicious) {
      res["Newsuspicious"] = boost::any(*newsuspicious);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (patch) {
      res["Patch"] = boost::any(*patch);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (suspicious) {
      res["Suspicious"] = boost::any(*suspicious);
    }
    if (suspiciousTotal) {
      res["SuspiciousTotal"] = boost::any(*suspiciousTotal);
    }
    if (suspiciousdealedTotal) {
      res["SuspiciousdealedTotal"] = boost::any(*suspiciousdealedTotal);
    }
    if (suspicioushighTotal) {
      res["SuspicioushighTotal"] = boost::any(*suspicioushighTotal);
    }
    if (suspiciouslowTotal) {
      res["SuspiciouslowTotal"] = boost::any(*suspiciouslowTotal);
    }
    if (suspiciousmediumTotal) {
      res["SuspiciousmediumTotal"] = boost::any(*suspiciousmediumTotal);
    }
    if (suspiciousseriousTotal) {
      res["SuspiciousseriousTotal"] = boost::any(*suspiciousseriousTotal);
    }
    if (trojan) {
      res["Trojan"] = boost::any(*trojan);
    }
    if (vul) {
      res["Vul"] = boost::any(*vul);
    }
    if (vulAsapSum) {
      res["VulAsapSum"] = boost::any(*vulAsapSum);
    }
    if (vulDealedTotal) {
      res["VulDealedTotal"] = boost::any(*vulDealedTotal);
    }
    if (vulLaterSum) {
      res["VulLaterSum"] = boost::any(*vulLaterSum);
    }
    if (vulNntfSum) {
      res["VulNntfSum"] = boost::any(*vulNntfSum);
    }
    if (vulTotal) {
      res["VulTotal"] = boost::any(*vulTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<long>(boost::any_cast<long>(m["Account"]));
    }
    if (m.find("Health") != m.end() && !m["Health"].empty()) {
      health = make_shared<long>(boost::any_cast<long>(m["Health"]));
    }
    if (m.find("HealthTotal") != m.end() && !m["HealthTotal"].empty()) {
      healthTotal = make_shared<long>(boost::any_cast<long>(m["HealthTotal"]));
    }
    if (m.find("HealthdealedTotal") != m.end() && !m["HealthdealedTotal"].empty()) {
      healthdealedTotal = make_shared<long>(boost::any_cast<long>(m["HealthdealedTotal"]));
    }
    if (m.find("HealthhighTotal") != m.end() && !m["HealthhighTotal"].empty()) {
      healthhighTotal = make_shared<long>(boost::any_cast<long>(m["HealthhighTotal"]));
    }
    if (m.find("HealthlowTotal") != m.end() && !m["HealthlowTotal"].empty()) {
      healthlowTotal = make_shared<long>(boost::any_cast<long>(m["HealthlowTotal"]));
    }
    if (m.find("HealthmediumTotal") != m.end() && !m["HealthmediumTotal"].empty()) {
      healthmediumTotal = make_shared<long>(boost::any_cast<long>(m["HealthmediumTotal"]));
    }
    if (m.find("HealthseriousTotal") != m.end() && !m["HealthseriousTotal"].empty()) {
      healthseriousTotal = make_shared<long>(boost::any_cast<long>(m["HealthseriousTotal"]));
    }
    if (m.find("Newsuspicious") != m.end() && !m["Newsuspicious"].empty()) {
      newsuspicious = make_shared<long>(boost::any_cast<long>(m["Newsuspicious"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("Patch") != m.end() && !m["Patch"].empty()) {
      patch = make_shared<long>(boost::any_cast<long>(m["Patch"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Suspicious") != m.end() && !m["Suspicious"].empty()) {
      suspicious = make_shared<long>(boost::any_cast<long>(m["Suspicious"]));
    }
    if (m.find("SuspiciousTotal") != m.end() && !m["SuspiciousTotal"].empty()) {
      suspiciousTotal = make_shared<long>(boost::any_cast<long>(m["SuspiciousTotal"]));
    }
    if (m.find("SuspiciousdealedTotal") != m.end() && !m["SuspiciousdealedTotal"].empty()) {
      suspiciousdealedTotal = make_shared<long>(boost::any_cast<long>(m["SuspiciousdealedTotal"]));
    }
    if (m.find("SuspicioushighTotal") != m.end() && !m["SuspicioushighTotal"].empty()) {
      suspicioushighTotal = make_shared<long>(boost::any_cast<long>(m["SuspicioushighTotal"]));
    }
    if (m.find("SuspiciouslowTotal") != m.end() && !m["SuspiciouslowTotal"].empty()) {
      suspiciouslowTotal = make_shared<long>(boost::any_cast<long>(m["SuspiciouslowTotal"]));
    }
    if (m.find("SuspiciousmediumTotal") != m.end() && !m["SuspiciousmediumTotal"].empty()) {
      suspiciousmediumTotal = make_shared<long>(boost::any_cast<long>(m["SuspiciousmediumTotal"]));
    }
    if (m.find("SuspiciousseriousTotal") != m.end() && !m["SuspiciousseriousTotal"].empty()) {
      suspiciousseriousTotal = make_shared<long>(boost::any_cast<long>(m["SuspiciousseriousTotal"]));
    }
    if (m.find("Trojan") != m.end() && !m["Trojan"].empty()) {
      trojan = make_shared<long>(boost::any_cast<long>(m["Trojan"]));
    }
    if (m.find("Vul") != m.end() && !m["Vul"].empty()) {
      vul = make_shared<long>(boost::any_cast<long>(m["Vul"]));
    }
    if (m.find("VulAsapSum") != m.end() && !m["VulAsapSum"].empty()) {
      vulAsapSum = make_shared<long>(boost::any_cast<long>(m["VulAsapSum"]));
    }
    if (m.find("VulDealedTotal") != m.end() && !m["VulDealedTotal"].empty()) {
      vulDealedTotal = make_shared<long>(boost::any_cast<long>(m["VulDealedTotal"]));
    }
    if (m.find("VulLaterSum") != m.end() && !m["VulLaterSum"].empty()) {
      vulLaterSum = make_shared<long>(boost::any_cast<long>(m["VulLaterSum"]));
    }
    if (m.find("VulNntfSum") != m.end() && !m["VulNntfSum"].empty()) {
      vulNntfSum = make_shared<long>(boost::any_cast<long>(m["VulNntfSum"]));
    }
    if (m.find("VulTotal") != m.end() && !m["VulTotal"].empty()) {
      vulTotal = make_shared<long>(boost::any_cast<long>(m["VulTotal"]));
    }
  }


  virtual ~DescribeTotalStatisticsResponseBody() = default;
};
class DescribeTotalStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTotalStatisticsResponseBody> body{};

  DescribeTotalStatisticsResponse() {}

  explicit DescribeTotalStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTotalStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTotalStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTotalStatisticsResponse() = default;
};
class DescribeTraceInfoDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<long> incidentTime{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vertexId{};

  DescribeTraceInfoDetailRequest() {}

  explicit DescribeTraceInfoDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (incidentTime) {
      res["IncidentTime"] = boost::any(*incidentTime);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vertexId) {
      res["VertexId"] = boost::any(*vertexId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("IncidentTime") != m.end() && !m["IncidentTime"].empty()) {
      incidentTime = make_shared<long>(boost::any_cast<long>(m["IncidentTime"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VertexId") != m.end() && !m["VertexId"].empty()) {
      vertexId = make_shared<string>(boost::any_cast<string>(m["VertexId"]));
    }
  }


  virtual ~DescribeTraceInfoDetailRequest() = default;
};
class DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> endId{};
  shared_ptr<string> startId{};
  shared_ptr<string> time{};
  shared_ptr<string> type{};

  DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList() {}

  explicit DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (endId) {
      res["EndId"] = boost::any(*endId);
    }
    if (startId) {
      res["StartId"] = boost::any(*startId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("EndId") != m.end() && !m["EndId"].empty()) {
      endId = make_shared<string>(boost::any_cast<string>(m["EndId"]));
    }
    if (m.find("StartId") != m.end() && !m["StartId"].empty()) {
      startId = make_shared<string>(boost::any_cast<string>(m["StartId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList() = default;
};
class DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList : public Darabonba::Model {
public:
  shared_ptr<long> dbId{};
  shared_ptr<string> displayColor{};
  shared_ptr<string> displayIcon{};
  shared_ptr<string> displayTemplate{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<long> limit{};
  shared_ptr<string> name{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> offset{};

  DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList() {}

  explicit DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbId) {
      res["DbId"] = boost::any(*dbId);
    }
    if (displayColor) {
      res["DisplayColor"] = boost::any(*displayColor);
    }
    if (displayIcon) {
      res["DisplayIcon"] = boost::any(*displayIcon);
    }
    if (displayTemplate) {
      res["DisplayTemplate"] = boost::any(*displayTemplate);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbId") != m.end() && !m["DbId"].empty()) {
      dbId = make_shared<long>(boost::any_cast<long>(m["DbId"]));
    }
    if (m.find("DisplayColor") != m.end() && !m["DisplayColor"].empty()) {
      displayColor = make_shared<string>(boost::any_cast<string>(m["DisplayColor"]));
    }
    if (m.find("DisplayIcon") != m.end() && !m["DisplayIcon"].empty()) {
      displayIcon = make_shared<string>(boost::any_cast<string>(m["DisplayIcon"]));
    }
    if (m.find("DisplayTemplate") != m.end() && !m["DisplayTemplate"].empty()) {
      displayTemplate = make_shared<string>(boost::any_cast<string>(m["DisplayTemplate"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
  }


  virtual ~DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList() = default;
};
class DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList : public Darabonba::Model {
public:
  shared_ptr<long> directed{};
  shared_ptr<string> displayColor{};
  shared_ptr<string> name{};
  shared_ptr<string> relationTypeId{};
  shared_ptr<string> showType{};

  DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList() {}

  explicit DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directed) {
      res["Directed"] = boost::any(*directed);
    }
    if (displayColor) {
      res["DisplayColor"] = boost::any(*displayColor);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (relationTypeId) {
      res["RelationTypeId"] = boost::any(*relationTypeId);
    }
    if (showType) {
      res["ShowType"] = boost::any(*showType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Directed") != m.end() && !m["Directed"].empty()) {
      directed = make_shared<long>(boost::any_cast<long>(m["Directed"]));
    }
    if (m.find("DisplayColor") != m.end() && !m["DisplayColor"].empty()) {
      displayColor = make_shared<string>(boost::any_cast<string>(m["DisplayColor"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RelationTypeId") != m.end() && !m["RelationTypeId"].empty()) {
      relationTypeId = make_shared<string>(boost::any_cast<string>(m["RelationTypeId"]));
    }
    if (m.find("ShowType") != m.end() && !m["ShowType"].empty()) {
      showType = make_shared<string>(boost::any_cast<string>(m["ShowType"]));
    }
  }


  virtual ~DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList() = default;
};
class DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<bool> hasMore{};
  shared_ptr<string> type{};

  DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList() {}

  explicit DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (hasMore) {
      res["HasMore"] = boost::any(*hasMore);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("HasMore") != m.end() && !m["HasMore"].empty()) {
      hasMore = make_shared<bool>(boost::any_cast<bool>(m["HasMore"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList() = default;
};
class DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList>> neighborList{};
  shared_ptr<string> time{};
  shared_ptr<string> type{};

  DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList() {}

  explicit DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (neighborList) {
      vector<boost::any> temp1;
      for(auto item1:*neighborList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NeighborList"] = boost::any(temp1);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeighborList") != m.end() && !m["NeighborList"].empty()) {
      if (typeid(vector<boost::any>) == m["NeighborList"].type()) {
        vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NeighborList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        neighborList = make_shared<vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList>>(expect1);
      }
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList() = default;
};
class DescribeTraceInfoDetailResponseBodyTraceInfoDetail : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList>> edgeList{};
  shared_ptr<vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList>> entityTypeList{};
  shared_ptr<vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList>> relationTypeList{};
  shared_ptr<vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList>> vertexList{};

  DescribeTraceInfoDetailResponseBodyTraceInfoDetail() {}

  explicit DescribeTraceInfoDetailResponseBodyTraceInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edgeList) {
      vector<boost::any> temp1;
      for(auto item1:*edgeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EdgeList"] = boost::any(temp1);
    }
    if (entityTypeList) {
      vector<boost::any> temp1;
      for(auto item1:*entityTypeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EntityTypeList"] = boost::any(temp1);
    }
    if (relationTypeList) {
      vector<boost::any> temp1;
      for(auto item1:*relationTypeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelationTypeList"] = boost::any(temp1);
    }
    if (vertexList) {
      vector<boost::any> temp1;
      for(auto item1:*vertexList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VertexList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdgeList") != m.end() && !m["EdgeList"].empty()) {
      if (typeid(vector<boost::any>) == m["EdgeList"].type()) {
        vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EdgeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        edgeList = make_shared<vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList>>(expect1);
      }
    }
    if (m.find("EntityTypeList") != m.end() && !m["EntityTypeList"].empty()) {
      if (typeid(vector<boost::any>) == m["EntityTypeList"].type()) {
        vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EntityTypeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entityTypeList = make_shared<vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList>>(expect1);
      }
    }
    if (m.find("RelationTypeList") != m.end() && !m["RelationTypeList"].empty()) {
      if (typeid(vector<boost::any>) == m["RelationTypeList"].type()) {
        vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelationTypeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relationTypeList = make_shared<vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList>>(expect1);
      }
    }
    if (m.find("VertexList") != m.end() && !m["VertexList"].empty()) {
      if (typeid(vector<boost::any>) == m["VertexList"].type()) {
        vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VertexList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vertexList = make_shared<vector<DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList>>(expect1);
      }
    }
  }


  virtual ~DescribeTraceInfoDetailResponseBodyTraceInfoDetail() = default;
};
class DescribeTraceInfoDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<DescribeTraceInfoDetailResponseBodyTraceInfoDetail> traceInfoDetail{};

  DescribeTraceInfoDetailResponseBody() {}

  explicit DescribeTraceInfoDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (traceInfoDetail) {
      res["TraceInfoDetail"] = traceInfoDetail ? boost::any(traceInfoDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TraceInfoDetail") != m.end() && !m["TraceInfoDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["TraceInfoDetail"].type()) {
        DescribeTraceInfoDetailResponseBodyTraceInfoDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TraceInfoDetail"]));
        traceInfoDetail = make_shared<DescribeTraceInfoDetailResponseBodyTraceInfoDetail>(model1);
      }
    }
  }


  virtual ~DescribeTraceInfoDetailResponseBody() = default;
};
class DescribeTraceInfoDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTraceInfoDetailResponseBody> body{};

  DescribeTraceInfoDetailResponse() {}

  explicit DescribeTraceInfoDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTraceInfoDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTraceInfoDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTraceInfoDetailResponse() = default;
};
class DescribeTraceInfoNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventName{};
  shared_ptr<string> from{};
  shared_ptr<long> incidentTime{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vertexId{};

  DescribeTraceInfoNodeRequest() {}

  explicit DescribeTraceInfoNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (incidentTime) {
      res["IncidentTime"] = boost::any(*incidentTime);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vertexId) {
      res["VertexId"] = boost::any(*vertexId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("IncidentTime") != m.end() && !m["IncidentTime"].empty()) {
      incidentTime = make_shared<long>(boost::any_cast<long>(m["IncidentTime"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VertexId") != m.end() && !m["VertexId"].empty()) {
      vertexId = make_shared<string>(boost::any_cast<string>(m["VertexId"]));
    }
  }


  virtual ~DescribeTraceInfoNodeRequest() = default;
};
class DescribeTraceInfoNodeResponseBodyNodePropertyList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeTraceInfoNodeResponseBodyNodePropertyList() {}

  explicit DescribeTraceInfoNodeResponseBodyNodePropertyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeTraceInfoNodeResponseBodyNodePropertyList() = default;
};
class DescribeTraceInfoNodeResponseBodyNode : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeTraceInfoNodeResponseBodyNodePropertyList>> propertyList{};
  shared_ptr<string> type{};

  DescribeTraceInfoNodeResponseBodyNode() {}

  explicit DescribeTraceInfoNodeResponseBodyNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (propertyList) {
      vector<boost::any> temp1;
      for(auto item1:*propertyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyList"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PropertyList") != m.end() && !m["PropertyList"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyList"].type()) {
        vector<DescribeTraceInfoNodeResponseBodyNodePropertyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTraceInfoNodeResponseBodyNodePropertyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyList = make_shared<vector<DescribeTraceInfoNodeResponseBodyNodePropertyList>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTraceInfoNodeResponseBodyNode() = default;
};
class DescribeTraceInfoNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeTraceInfoNodeResponseBodyNode> node{};
  shared_ptr<string> requestId{};

  DescribeTraceInfoNodeResponseBody() {}

  explicit DescribeTraceInfoNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (node) {
      res["Node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(map<string, boost::any>) == m["Node"].type()) {
        DescribeTraceInfoNodeResponseBodyNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Node"]));
        node = make_shared<DescribeTraceInfoNodeResponseBodyNode>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeTraceInfoNodeResponseBody() = default;
};
class DescribeTraceInfoNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTraceInfoNodeResponseBody> body{};

  DescribeTraceInfoNodeResponse() {}

  explicit DescribeTraceInfoNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTraceInfoNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTraceInfoNodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTraceInfoNodeResponse() = default;
};
class DescribeUniBackupDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryType{};
  shared_ptr<string> uniRegionId{};

  DescribeUniBackupDatabaseRequest() {}

  explicit DescribeUniBackupDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (uniRegionId) {
      res["UniRegionId"] = boost::any(*uniRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("UniRegionId") != m.end() && !m["UniRegionId"].empty()) {
      uniRegionId = make_shared<string>(boost::any_cast<string>(m["UniRegionId"]));
    }
  }


  virtual ~DescribeUniBackupDatabaseRequest() = default;
};
class DescribeUniBackupDatabaseResponseBodyDatabaseList : public Darabonba::Model {
public:
  shared_ptr<string> agentStatus{};
  shared_ptr<string> createdByProduct{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> databaseVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceUuid{};
  shared_ptr<long> policyId{};
  shared_ptr<string> status{};

  DescribeUniBackupDatabaseResponseBodyDatabaseList() {}

  explicit DescribeUniBackupDatabaseResponseBodyDatabaseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStatus) {
      res["AgentStatus"] = boost::any(*agentStatus);
    }
    if (createdByProduct) {
      res["CreatedByProduct"] = boost::any(*createdByProduct);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (databaseVersion) {
      res["DatabaseVersion"] = boost::any(*databaseVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceUuid) {
      res["InstanceUuid"] = boost::any(*instanceUuid);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentStatus") != m.end() && !m["AgentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["AgentStatus"]));
    }
    if (m.find("CreatedByProduct") != m.end() && !m["CreatedByProduct"].empty()) {
      createdByProduct = make_shared<string>(boost::any_cast<string>(m["CreatedByProduct"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("DatabaseVersion") != m.end() && !m["DatabaseVersion"].empty()) {
      databaseVersion = make_shared<string>(boost::any_cast<string>(m["DatabaseVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceUuid") != m.end() && !m["InstanceUuid"].empty()) {
      instanceUuid = make_shared<string>(boost::any_cast<string>(m["InstanceUuid"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeUniBackupDatabaseResponseBodyDatabaseList() = default;
};
class DescribeUniBackupDatabaseResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeUniBackupDatabaseResponseBodyPageInfo() {}

  explicit DescribeUniBackupDatabaseResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeUniBackupDatabaseResponseBodyPageInfo() = default;
};
class DescribeUniBackupDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUniBackupDatabaseResponseBodyDatabaseList>> databaseList{};
  shared_ptr<DescribeUniBackupDatabaseResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  DescribeUniBackupDatabaseResponseBody() {}

  explicit DescribeUniBackupDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseList) {
      vector<boost::any> temp1;
      for(auto item1:*databaseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseList") != m.end() && !m["DatabaseList"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseList"].type()) {
        vector<DescribeUniBackupDatabaseResponseBodyDatabaseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUniBackupDatabaseResponseBodyDatabaseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseList = make_shared<vector<DescribeUniBackupDatabaseResponseBodyDatabaseList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeUniBackupDatabaseResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeUniBackupDatabaseResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUniBackupDatabaseResponseBody() = default;
};
class DescribeUniBackupDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUniBackupDatabaseResponseBody> body{};

  DescribeUniBackupDatabaseResponse() {}

  explicit DescribeUniBackupDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUniBackupDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUniBackupDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUniBackupDatabaseResponse() = default;
};
class DescribeUniBackupPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> policyName{};

  DescribeUniBackupPoliciesRequest() {}

  explicit DescribeUniBackupPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
  }


  virtual ~DescribeUniBackupPoliciesRequest() = default;
};
class DescribeUniBackupPoliciesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeUniBackupPoliciesResponseBodyPageInfo() {}

  explicit DescribeUniBackupPoliciesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeUniBackupPoliciesResponseBodyPageInfo() = default;
};
class DescribeUniBackupPoliciesResponseBodyUniBackupPolicies : public Darabonba::Model {
public:
  shared_ptr<string> agentErrorMessage{};
  shared_ptr<string> agentStatus{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> databaseType{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> instanceUuid{};
  shared_ptr<string> latestBackResult{};
  shared_ptr<string> latestBackupTime{};
  shared_ptr<string> planStatus{};
  shared_ptr<long> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyStatus{};
  shared_ptr<string> uniRegionId{};

  DescribeUniBackupPoliciesResponseBodyUniBackupPolicies() {}

  explicit DescribeUniBackupPoliciesResponseBodyUniBackupPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentErrorMessage) {
      res["AgentErrorMessage"] = boost::any(*agentErrorMessage);
    }
    if (agentStatus) {
      res["AgentStatus"] = boost::any(*agentStatus);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (instanceUuid) {
      res["InstanceUuid"] = boost::any(*instanceUuid);
    }
    if (latestBackResult) {
      res["LatestBackResult"] = boost::any(*latestBackResult);
    }
    if (latestBackupTime) {
      res["LatestBackupTime"] = boost::any(*latestBackupTime);
    }
    if (planStatus) {
      res["PlanStatus"] = boost::any(*planStatus);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (policyStatus) {
      res["PolicyStatus"] = boost::any(*policyStatus);
    }
    if (uniRegionId) {
      res["UniRegionId"] = boost::any(*uniRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentErrorMessage") != m.end() && !m["AgentErrorMessage"].empty()) {
      agentErrorMessage = make_shared<string>(boost::any_cast<string>(m["AgentErrorMessage"]));
    }
    if (m.find("AgentStatus") != m.end() && !m["AgentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["AgentStatus"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("InstanceUuid") != m.end() && !m["InstanceUuid"].empty()) {
      instanceUuid = make_shared<string>(boost::any_cast<string>(m["InstanceUuid"]));
    }
    if (m.find("LatestBackResult") != m.end() && !m["LatestBackResult"].empty()) {
      latestBackResult = make_shared<string>(boost::any_cast<string>(m["LatestBackResult"]));
    }
    if (m.find("LatestBackupTime") != m.end() && !m["LatestBackupTime"].empty()) {
      latestBackupTime = make_shared<string>(boost::any_cast<string>(m["LatestBackupTime"]));
    }
    if (m.find("PlanStatus") != m.end() && !m["PlanStatus"].empty()) {
      planStatus = make_shared<string>(boost::any_cast<string>(m["PlanStatus"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("PolicyStatus") != m.end() && !m["PolicyStatus"].empty()) {
      policyStatus = make_shared<string>(boost::any_cast<string>(m["PolicyStatus"]));
    }
    if (m.find("UniRegionId") != m.end() && !m["UniRegionId"].empty()) {
      uniRegionId = make_shared<string>(boost::any_cast<string>(m["UniRegionId"]));
    }
  }


  virtual ~DescribeUniBackupPoliciesResponseBodyUniBackupPolicies() = default;
};
class DescribeUniBackupPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUniBackupPoliciesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeUniBackupPoliciesResponseBodyUniBackupPolicies>> uniBackupPolicies{};

  DescribeUniBackupPoliciesResponseBody() {}

  explicit DescribeUniBackupPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uniBackupPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*uniBackupPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UniBackupPolicies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeUniBackupPoliciesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeUniBackupPoliciesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UniBackupPolicies") != m.end() && !m["UniBackupPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["UniBackupPolicies"].type()) {
        vector<DescribeUniBackupPoliciesResponseBodyUniBackupPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UniBackupPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUniBackupPoliciesResponseBodyUniBackupPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uniBackupPolicies = make_shared<vector<DescribeUniBackupPoliciesResponseBodyUniBackupPolicies>>(expect1);
      }
    }
  }


  virtual ~DescribeUniBackupPoliciesResponseBody() = default;
};
class DescribeUniBackupPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUniBackupPoliciesResponseBody> body{};

  DescribeUniBackupPoliciesResponse() {}

  explicit DescribeUniBackupPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUniBackupPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUniBackupPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUniBackupPoliciesResponse() = default;
};
class DescribeUniBackupPolicyDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> policyId{};

  DescribeUniBackupPolicyDetailRequest() {}

  explicit DescribeUniBackupPolicyDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
  }


  virtual ~DescribeUniBackupPolicyDetailRequest() = default;
};
class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan : public Darabonba::Model {
public:
  shared_ptr<vector<string>> days{};
  shared_ptr<long> interval{};
  shared_ptr<string> planType{};
  shared_ptr<string> startTime{};

  DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan() {}

  explicit DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (planType) {
      res["PlanType"] = boost::any(*planType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Days"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Days"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      days = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("PlanType") != m.end() && !m["PlanType"].empty()) {
      planType = make_shared<string>(boost::any_cast<string>(m["PlanType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan() = default;
};
class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan : public Darabonba::Model {
public:
  shared_ptr<vector<string>> days{};
  shared_ptr<long> interval{};
  shared_ptr<string> planType{};
  shared_ptr<string> startTime{};

  DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan() {}

  explicit DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (planType) {
      res["PlanType"] = boost::any(*planType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Days"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Days"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      days = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("PlanType") != m.end() && !m["PlanType"].empty()) {
      planType = make_shared<string>(boost::any_cast<string>(m["PlanType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan() = default;
};
class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> agentStatus{};
  shared_ptr<string> databaseType{};
  shared_ptr<DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan> fullPlan{};
  shared_ptr<DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan> incPlan{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyStatus{};
  shared_ptr<long> retention{};
  shared_ptr<long> speedLimiter{};

  DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO() {}

  explicit DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (agentStatus) {
      res["AgentStatus"] = boost::any(*agentStatus);
    }
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (fullPlan) {
      res["FullPlan"] = fullPlan ? boost::any(fullPlan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (incPlan) {
      res["IncPlan"] = incPlan ? boost::any(incPlan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (policyStatus) {
      res["PolicyStatus"] = boost::any(*policyStatus);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (speedLimiter) {
      res["SpeedLimiter"] = boost::any(*speedLimiter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AgentStatus") != m.end() && !m["AgentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["AgentStatus"]));
    }
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("FullPlan") != m.end() && !m["FullPlan"].empty()) {
      if (typeid(map<string, boost::any>) == m["FullPlan"].type()) {
        DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FullPlan"]));
        fullPlan = make_shared<DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan>(model1);
      }
    }
    if (m.find("IncPlan") != m.end() && !m["IncPlan"].empty()) {
      if (typeid(map<string, boost::any>) == m["IncPlan"].type()) {
        DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IncPlan"]));
        incPlan = make_shared<DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("PolicyStatus") != m.end() && !m["PolicyStatus"].empty()) {
      policyStatus = make_shared<string>(boost::any_cast<string>(m["PolicyStatus"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("SpeedLimiter") != m.end() && !m["SpeedLimiter"].empty()) {
      speedLimiter = make_shared<long>(boost::any_cast<long>(m["SpeedLimiter"]));
    }
  }


  virtual ~DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO() = default;
};
class DescribeUniBackupPolicyDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO> uniBackupPolicyDTO{};

  DescribeUniBackupPolicyDetailResponseBody() {}

  explicit DescribeUniBackupPolicyDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uniBackupPolicyDTO) {
      res["UniBackupPolicyDTO"] = uniBackupPolicyDTO ? boost::any(uniBackupPolicyDTO->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UniBackupPolicyDTO") != m.end() && !m["UniBackupPolicyDTO"].empty()) {
      if (typeid(map<string, boost::any>) == m["UniBackupPolicyDTO"].type()) {
        DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UniBackupPolicyDTO"]));
        uniBackupPolicyDTO = make_shared<DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO>(model1);
      }
    }
  }


  virtual ~DescribeUniBackupPolicyDetailResponseBody() = default;
};
class DescribeUniBackupPolicyDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUniBackupPolicyDetailResponseBody> body{};

  DescribeUniBackupPolicyDetailResponse() {}

  explicit DescribeUniBackupPolicyDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUniBackupPolicyDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUniBackupPolicyDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUniBackupPolicyDetailResponse() = default;
};
class DescribeUniRecoverableListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> database{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> policyId{};

  DescribeUniRecoverableListRequest() {}

  explicit DescribeUniRecoverableListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
  }


  virtual ~DescribeUniRecoverableListRequest() = default;
};
class DescribeUniRecoverableListResponseBodyRecoverableInfoList : public Darabonba::Model {
public:
  shared_ptr<long> firstTime{};
  shared_ptr<long> lastTime{};
  shared_ptr<string> resetScn{};
  shared_ptr<long> resetTime{};
  shared_ptr<string> restoreInfo{};

  DescribeUniRecoverableListResponseBodyRecoverableInfoList() {}

  explicit DescribeUniRecoverableListResponseBodyRecoverableInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstTime) {
      res["FirstTime"] = boost::any(*firstTime);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (resetScn) {
      res["ResetScn"] = boost::any(*resetScn);
    }
    if (resetTime) {
      res["ResetTime"] = boost::any(*resetTime);
    }
    if (restoreInfo) {
      res["RestoreInfo"] = boost::any(*restoreInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstTime") != m.end() && !m["FirstTime"].empty()) {
      firstTime = make_shared<long>(boost::any_cast<long>(m["FirstTime"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
    if (m.find("ResetScn") != m.end() && !m["ResetScn"].empty()) {
      resetScn = make_shared<string>(boost::any_cast<string>(m["ResetScn"]));
    }
    if (m.find("ResetTime") != m.end() && !m["ResetTime"].empty()) {
      resetTime = make_shared<long>(boost::any_cast<long>(m["ResetTime"]));
    }
    if (m.find("RestoreInfo") != m.end() && !m["RestoreInfo"].empty()) {
      restoreInfo = make_shared<string>(boost::any_cast<string>(m["RestoreInfo"]));
    }
  }


  virtual ~DescribeUniRecoverableListResponseBodyRecoverableInfoList() = default;
};
class DescribeUniRecoverableListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> database{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeUniRecoverableListResponseBodyRecoverableInfoList>> recoverableInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeUniRecoverableListResponseBody() {}

  explicit DescribeUniRecoverableListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recoverableInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*recoverableInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecoverableInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecoverableInfoList") != m.end() && !m["RecoverableInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecoverableInfoList"].type()) {
        vector<DescribeUniRecoverableListResponseBodyRecoverableInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecoverableInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUniRecoverableListResponseBodyRecoverableInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recoverableInfoList = make_shared<vector<DescribeUniRecoverableListResponseBodyRecoverableInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeUniRecoverableListResponseBody() = default;
};
class DescribeUniRecoverableListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUniRecoverableListResponseBody> body{};

  DescribeUniRecoverableListResponse() {}

  explicit DescribeUniRecoverableListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUniRecoverableListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUniRecoverableListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUniRecoverableListResponse() = default;
};
class DescribeUniSupportRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> uniSupportRegion{};

  DescribeUniSupportRegionResponseBody() {}

  explicit DescribeUniSupportRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uniSupportRegion) {
      res["UniSupportRegion"] = boost::any(*uniSupportRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UniSupportRegion") != m.end() && !m["UniSupportRegion"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UniSupportRegion"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UniSupportRegion"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uniSupportRegion = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeUniSupportRegionResponseBody() = default;
};
class DescribeUniSupportRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUniSupportRegionResponseBody> body{};

  DescribeUniSupportRegionResponse() {}

  explicit DescribeUniSupportRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUniSupportRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUniSupportRegionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUniSupportRegionResponse() = default;
};
class DescribeUserBackupMachinesResponseBodyMachines : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> policyName{};
  shared_ptr<string> uuid{};

  DescribeUserBackupMachinesResponseBodyMachines() {}

  explicit DescribeUserBackupMachinesResponseBodyMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeUserBackupMachinesResponseBodyMachines() = default;
};
class DescribeUserBackupMachinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserBackupMachinesResponseBodyMachines>> machines{};
  shared_ptr<string> requestId{};

  DescribeUserBackupMachinesResponseBody() {}

  explicit DescribeUserBackupMachinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machines) {
      vector<boost::any> temp1;
      for(auto item1:*machines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Machines"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Machines") != m.end() && !m["Machines"].empty()) {
      if (typeid(vector<boost::any>) == m["Machines"].type()) {
        vector<DescribeUserBackupMachinesResponseBodyMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Machines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserBackupMachinesResponseBodyMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machines = make_shared<vector<DescribeUserBackupMachinesResponseBodyMachines>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserBackupMachinesResponseBody() = default;
};
class DescribeUserBackupMachinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserBackupMachinesResponseBody> body{};

  DescribeUserBackupMachinesResponse() {}

  explicit DescribeUserBackupMachinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserBackupMachinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserBackupMachinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserBackupMachinesResponse() = default;
};
class DescribeUserBaselineAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};

  DescribeUserBaselineAuthorizationRequest() {}

  explicit DescribeUserBaselineAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeUserBaselineAuthorizationRequest() = default;
};
class DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization : public Darabonba::Model {
public:
  shared_ptr<long> status{};

  DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization() {}

  explicit DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization() = default;
};
class DescribeUserBaselineAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization> userBaselineAuthorization{};

  DescribeUserBaselineAuthorizationResponseBody() {}

  explicit DescribeUserBaselineAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userBaselineAuthorization) {
      res["UserBaselineAuthorization"] = userBaselineAuthorization ? boost::any(userBaselineAuthorization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserBaselineAuthorization") != m.end() && !m["UserBaselineAuthorization"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserBaselineAuthorization"].type()) {
        DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserBaselineAuthorization"]));
        userBaselineAuthorization = make_shared<DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization>(model1);
      }
    }
  }


  virtual ~DescribeUserBaselineAuthorizationResponseBody() = default;
};
class DescribeUserBaselineAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserBaselineAuthorizationResponseBody> body{};

  DescribeUserBaselineAuthorizationResponse() {}

  explicit DescribeUserBaselineAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserBaselineAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserBaselineAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserBaselineAuthorizationResponse() = default;
};
class DescribeUserLayoutAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};

  DescribeUserLayoutAuthorizationRequest() {}

  explicit DescribeUserLayoutAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeUserLayoutAuthorizationRequest() = default;
};
class DescribeUserLayoutAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> authorized{};
  shared_ptr<string> requestId{};

  DescribeUserLayoutAuthorizationResponseBody() {}

  explicit DescribeUserLayoutAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorized) {
      res["Authorized"] = boost::any(*authorized);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authorized") != m.end() && !m["Authorized"].empty()) {
      authorized = make_shared<bool>(boost::any_cast<bool>(m["Authorized"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserLayoutAuthorizationResponseBody() = default;
};
class DescribeUserLayoutAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserLayoutAuthorizationResponseBody> body{};

  DescribeUserLayoutAuthorizationResponse() {}

  explicit DescribeUserLayoutAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserLayoutAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserLayoutAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserLayoutAuthorizationResponse() = default;
};
class DescribeUuidsByVulNamesRequest : public Darabonba::Model {
public:
  shared_ptr<string> dealed{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<long> groupId{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> necessity{};
  shared_ptr<string> remark{};
  shared_ptr<string> searchTags{};
  shared_ptr<string> statusList{};
  shared_ptr<string> tag{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};
  shared_ptr<string> vpcInstanceIds{};
  shared_ptr<vector<string>> vulNames{};

  DescribeUuidsByVulNamesRequest() {}

  explicit DescribeUuidsByVulNamesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (searchTags) {
      res["SearchTags"] = boost::any(*searchTags);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vpcInstanceIds) {
      res["VpcInstanceIds"] = boost::any(*vpcInstanceIds);
    }
    if (vulNames) {
      res["VulNames"] = boost::any(*vulNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SearchTags") != m.end() && !m["SearchTags"].empty()) {
      searchTags = make_shared<string>(boost::any_cast<string>(m["SearchTags"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      statusList = make_shared<string>(boost::any_cast<string>(m["StatusList"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VpcInstanceIds") != m.end() && !m["VpcInstanceIds"].empty()) {
      vpcInstanceIds = make_shared<string>(boost::any_cast<string>(m["VpcInstanceIds"]));
    }
    if (m.find("VulNames") != m.end() && !m["VulNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VulNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VulNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vulNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeUuidsByVulNamesRequest() = default;
};
class DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics : public Darabonba::Model {
public:
  shared_ptr<string> machineInstanceId{};
  shared_ptr<string> machineIp{};
  shared_ptr<string> machineName{};
  shared_ptr<string> os{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uuid{};

  DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics() {}

  explicit DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineInstanceId) {
      res["MachineInstanceId"] = boost::any(*machineInstanceId);
    }
    if (machineIp) {
      res["MachineIp"] = boost::any(*machineIp);
    }
    if (machineName) {
      res["MachineName"] = boost::any(*machineName);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineInstanceId") != m.end() && !m["MachineInstanceId"].empty()) {
      machineInstanceId = make_shared<string>(boost::any_cast<string>(m["MachineInstanceId"]));
    }
    if (m.find("MachineIp") != m.end() && !m["MachineIp"].empty()) {
      machineIp = make_shared<string>(boost::any_cast<string>(m["MachineIp"]));
    }
    if (m.find("MachineName") != m.end() && !m["MachineName"].empty()) {
      machineName = make_shared<string>(boost::any_cast<string>(m["MachineName"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics() = default;
};
class DescribeUuidsByVulNamesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics>> machineInfoStatistics{};
  shared_ptr<string> requestId{};

  DescribeUuidsByVulNamesResponseBody() {}

  explicit DescribeUuidsByVulNamesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineInfoStatistics) {
      vector<boost::any> temp1;
      for(auto item1:*machineInfoStatistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MachineInfoStatistics"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineInfoStatistics") != m.end() && !m["MachineInfoStatistics"].empty()) {
      if (typeid(vector<boost::any>) == m["MachineInfoStatistics"].type()) {
        vector<DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MachineInfoStatistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machineInfoStatistics = make_shared<vector<DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUuidsByVulNamesResponseBody() = default;
};
class DescribeUuidsByVulNamesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUuidsByVulNamesResponseBody> body{};

  DescribeUuidsByVulNamesResponse() {}

  explicit DescribeUuidsByVulNamesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUuidsByVulNamesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUuidsByVulNamesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUuidsByVulNamesResponse() = default;
};
class DescribeVendorListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> vendorNameList{};

  DescribeVendorListResponseBody() {}

  explicit DescribeVendorListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vendorNameList) {
      res["VendorNameList"] = boost::any(*vendorNameList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VendorNameList") != m.end() && !m["VendorNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VendorNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VendorNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vendorNameList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVendorListResponseBody() = default;
};
class DescribeVendorListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVendorListResponseBody> body{};

  DescribeVendorListResponse() {}

  explicit DescribeVendorListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVendorListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVendorListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVendorListResponse() = default;
};
class DescribeVersionConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceDirectoryAccountId{};
  shared_ptr<string> sourceIp{};

  DescribeVersionConfigRequest() {}

  explicit DescribeVersionConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceDirectoryAccountId) {
      res["ResourceDirectoryAccountId"] = boost::any(*resourceDirectoryAccountId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceDirectoryAccountId") != m.end() && !m["ResourceDirectoryAccountId"].empty()) {
      resourceDirectoryAccountId = make_shared<string>(boost::any_cast<string>(m["ResourceDirectoryAccountId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeVersionConfigRequest() = default;
};
class DescribeVersionConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> allowPartialBuy{};
  shared_ptr<long> appWhiteList{};
  shared_ptr<long> appWhiteListAuthCount{};
  shared_ptr<long> assetLevel{};
  shared_ptr<long> highestVersion{};
  shared_ptr<long> honeypotCapacity{};
  shared_ptr<long> imageScanCapacity{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isNewContainerVersion{};
  shared_ptr<bool> isNewMultiVersion{};
  shared_ptr<bool> isOverBalance{};
  shared_ptr<long> isTrialVersion{};
  shared_ptr<long> lastTrailEndTime{};
  shared_ptr<long> MVAuthCount{};
  shared_ptr<long> MVUnusedAuthCount{};
  shared_ptr<long> openTime{};
  shared_ptr<long> releaseTime{};
  shared_ptr<string> requestId{};
  shared_ptr<long> sasLog{};
  shared_ptr<long> sasScreen{};
  shared_ptr<long> slsCapacity{};
  shared_ptr<long> threatAnalysisCapacity{};
  shared_ptr<long> userDefinedAlarms{};
  shared_ptr<long> version{};
  shared_ptr<long> vmCores{};
  shared_ptr<long> webLock{};
  shared_ptr<long> webLockAuthCount{};

  DescribeVersionConfigResponseBody() {}

  explicit DescribeVersionConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowPartialBuy) {
      res["AllowPartialBuy"] = boost::any(*allowPartialBuy);
    }
    if (appWhiteList) {
      res["AppWhiteList"] = boost::any(*appWhiteList);
    }
    if (appWhiteListAuthCount) {
      res["AppWhiteListAuthCount"] = boost::any(*appWhiteListAuthCount);
    }
    if (assetLevel) {
      res["AssetLevel"] = boost::any(*assetLevel);
    }
    if (highestVersion) {
      res["HighestVersion"] = boost::any(*highestVersion);
    }
    if (honeypotCapacity) {
      res["HoneypotCapacity"] = boost::any(*honeypotCapacity);
    }
    if (imageScanCapacity) {
      res["ImageScanCapacity"] = boost::any(*imageScanCapacity);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isNewContainerVersion) {
      res["IsNewContainerVersion"] = boost::any(*isNewContainerVersion);
    }
    if (isNewMultiVersion) {
      res["IsNewMultiVersion"] = boost::any(*isNewMultiVersion);
    }
    if (isOverBalance) {
      res["IsOverBalance"] = boost::any(*isOverBalance);
    }
    if (isTrialVersion) {
      res["IsTrialVersion"] = boost::any(*isTrialVersion);
    }
    if (lastTrailEndTime) {
      res["LastTrailEndTime"] = boost::any(*lastTrailEndTime);
    }
    if (MVAuthCount) {
      res["MVAuthCount"] = boost::any(*MVAuthCount);
    }
    if (MVUnusedAuthCount) {
      res["MVUnusedAuthCount"] = boost::any(*MVUnusedAuthCount);
    }
    if (openTime) {
      res["OpenTime"] = boost::any(*openTime);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sasLog) {
      res["SasLog"] = boost::any(*sasLog);
    }
    if (sasScreen) {
      res["SasScreen"] = boost::any(*sasScreen);
    }
    if (slsCapacity) {
      res["SlsCapacity"] = boost::any(*slsCapacity);
    }
    if (threatAnalysisCapacity) {
      res["ThreatAnalysisCapacity"] = boost::any(*threatAnalysisCapacity);
    }
    if (userDefinedAlarms) {
      res["UserDefinedAlarms"] = boost::any(*userDefinedAlarms);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (vmCores) {
      res["VmCores"] = boost::any(*vmCores);
    }
    if (webLock) {
      res["WebLock"] = boost::any(*webLock);
    }
    if (webLockAuthCount) {
      res["WebLockAuthCount"] = boost::any(*webLockAuthCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowPartialBuy") != m.end() && !m["AllowPartialBuy"].empty()) {
      allowPartialBuy = make_shared<long>(boost::any_cast<long>(m["AllowPartialBuy"]));
    }
    if (m.find("AppWhiteList") != m.end() && !m["AppWhiteList"].empty()) {
      appWhiteList = make_shared<long>(boost::any_cast<long>(m["AppWhiteList"]));
    }
    if (m.find("AppWhiteListAuthCount") != m.end() && !m["AppWhiteListAuthCount"].empty()) {
      appWhiteListAuthCount = make_shared<long>(boost::any_cast<long>(m["AppWhiteListAuthCount"]));
    }
    if (m.find("AssetLevel") != m.end() && !m["AssetLevel"].empty()) {
      assetLevel = make_shared<long>(boost::any_cast<long>(m["AssetLevel"]));
    }
    if (m.find("HighestVersion") != m.end() && !m["HighestVersion"].empty()) {
      highestVersion = make_shared<long>(boost::any_cast<long>(m["HighestVersion"]));
    }
    if (m.find("HoneypotCapacity") != m.end() && !m["HoneypotCapacity"].empty()) {
      honeypotCapacity = make_shared<long>(boost::any_cast<long>(m["HoneypotCapacity"]));
    }
    if (m.find("ImageScanCapacity") != m.end() && !m["ImageScanCapacity"].empty()) {
      imageScanCapacity = make_shared<long>(boost::any_cast<long>(m["ImageScanCapacity"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsNewContainerVersion") != m.end() && !m["IsNewContainerVersion"].empty()) {
      isNewContainerVersion = make_shared<bool>(boost::any_cast<bool>(m["IsNewContainerVersion"]));
    }
    if (m.find("IsNewMultiVersion") != m.end() && !m["IsNewMultiVersion"].empty()) {
      isNewMultiVersion = make_shared<bool>(boost::any_cast<bool>(m["IsNewMultiVersion"]));
    }
    if (m.find("IsOverBalance") != m.end() && !m["IsOverBalance"].empty()) {
      isOverBalance = make_shared<bool>(boost::any_cast<bool>(m["IsOverBalance"]));
    }
    if (m.find("IsTrialVersion") != m.end() && !m["IsTrialVersion"].empty()) {
      isTrialVersion = make_shared<long>(boost::any_cast<long>(m["IsTrialVersion"]));
    }
    if (m.find("LastTrailEndTime") != m.end() && !m["LastTrailEndTime"].empty()) {
      lastTrailEndTime = make_shared<long>(boost::any_cast<long>(m["LastTrailEndTime"]));
    }
    if (m.find("MVAuthCount") != m.end() && !m["MVAuthCount"].empty()) {
      MVAuthCount = make_shared<long>(boost::any_cast<long>(m["MVAuthCount"]));
    }
    if (m.find("MVUnusedAuthCount") != m.end() && !m["MVUnusedAuthCount"].empty()) {
      MVUnusedAuthCount = make_shared<long>(boost::any_cast<long>(m["MVUnusedAuthCount"]));
    }
    if (m.find("OpenTime") != m.end() && !m["OpenTime"].empty()) {
      openTime = make_shared<long>(boost::any_cast<long>(m["OpenTime"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<long>(boost::any_cast<long>(m["ReleaseTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SasLog") != m.end() && !m["SasLog"].empty()) {
      sasLog = make_shared<long>(boost::any_cast<long>(m["SasLog"]));
    }
    if (m.find("SasScreen") != m.end() && !m["SasScreen"].empty()) {
      sasScreen = make_shared<long>(boost::any_cast<long>(m["SasScreen"]));
    }
    if (m.find("SlsCapacity") != m.end() && !m["SlsCapacity"].empty()) {
      slsCapacity = make_shared<long>(boost::any_cast<long>(m["SlsCapacity"]));
    }
    if (m.find("ThreatAnalysisCapacity") != m.end() && !m["ThreatAnalysisCapacity"].empty()) {
      threatAnalysisCapacity = make_shared<long>(boost::any_cast<long>(m["ThreatAnalysisCapacity"]));
    }
    if (m.find("UserDefinedAlarms") != m.end() && !m["UserDefinedAlarms"].empty()) {
      userDefinedAlarms = make_shared<long>(boost::any_cast<long>(m["UserDefinedAlarms"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
    if (m.find("VmCores") != m.end() && !m["VmCores"].empty()) {
      vmCores = make_shared<long>(boost::any_cast<long>(m["VmCores"]));
    }
    if (m.find("WebLock") != m.end() && !m["WebLock"].empty()) {
      webLock = make_shared<long>(boost::any_cast<long>(m["WebLock"]));
    }
    if (m.find("WebLockAuthCount") != m.end() && !m["WebLockAuthCount"].empty()) {
      webLockAuthCount = make_shared<long>(boost::any_cast<long>(m["WebLockAuthCount"]));
    }
  }


  virtual ~DescribeVersionConfigResponseBody() = default;
};
class DescribeVersionConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVersionConfigResponseBody> body{};

  DescribeVersionConfigResponse() {}

  explicit DescribeVersionConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVersionConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVersionConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVersionConfigResponse() = default;
};
class DescribeVpcHoneyPotCriteriaRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeVpcHoneyPotCriteriaRequest() {}

  explicit DescribeVpcHoneyPotCriteriaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeVpcHoneyPotCriteriaRequest() = default;
};
class DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> values{};

  DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList() {}

  explicit DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList() = default;
};
class DescribeVpcHoneyPotCriteriaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList>> criteriaList{};
  shared_ptr<string> requestId{};

  DescribeVpcHoneyPotCriteriaResponseBody() {}

  explicit DescribeVpcHoneyPotCriteriaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*criteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CriteriaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CriteriaList") != m.end() && !m["CriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["CriteriaList"].type()) {
        vector<DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteriaList = make_shared<vector<DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVpcHoneyPotCriteriaResponseBody() = default;
};
class DescribeVpcHoneyPotCriteriaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpcHoneyPotCriteriaResponseBody> body{};

  DescribeVpcHoneyPotCriteriaResponse() {}

  explicit DescribeVpcHoneyPotCriteriaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcHoneyPotCriteriaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcHoneyPotCriteriaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcHoneyPotCriteriaResponse() = default;
};
class DescribeVpcHoneyPotListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<bool> honeyPotExistence{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> vpcRegionId{};

  DescribeVpcHoneyPotListRequest() {}

  explicit DescribeVpcHoneyPotListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (honeyPotExistence) {
      res["HoneyPotExistence"] = boost::any(*honeyPotExistence);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (vpcRegionId) {
      res["VpcRegionId"] = boost::any(*vpcRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("HoneyPotExistence") != m.end() && !m["HoneyPotExistence"].empty()) {
      honeyPotExistence = make_shared<bool>(boost::any_cast<bool>(m["HoneyPotExistence"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("VpcRegionId") != m.end() && !m["VpcRegionId"].empty()) {
      vpcRegionId = make_shared<string>(boost::any_cast<string>(m["VpcRegionId"]));
    }
  }


  virtual ~DescribeVpcHoneyPotListRequest() = default;
};
class DescribeVpcHoneyPotListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeVpcHoneyPotListResponseBodyPageInfo() {}

  explicit DescribeVpcHoneyPotListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeVpcHoneyPotListResponseBodyPageInfo() = default;
};
class DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList : public Darabonba::Model {
public:
  shared_ptr<string> vpcSwitchId{};
  shared_ptr<string> vpcSwitchName{};
  shared_ptr<string> zoneId{};

  DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList() {}

  explicit DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcSwitchId) {
      res["VpcSwitchId"] = boost::any(*vpcSwitchId);
    }
    if (vpcSwitchName) {
      res["VpcSwitchName"] = boost::any(*vpcSwitchName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcSwitchId") != m.end() && !m["VpcSwitchId"].empty()) {
      vpcSwitchId = make_shared<string>(boost::any_cast<string>(m["VpcSwitchId"]));
    }
    if (m.find("VpcSwitchName") != m.end() && !m["VpcSwitchName"].empty()) {
      vpcSwitchName = make_shared<string>(boost::any_cast<string>(m["VpcSwitchName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList() = default;
};
class DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<long> createTime{};
  shared_ptr<string> honeyPotEcsInstanceStatus{};
  shared_ptr<string> honeyPotEniInstanceId{};
  shared_ptr<bool> honeyPotExistence{};
  shared_ptr<string> honeyPotInstanceStatus{};
  shared_ptr<string> honeyPotVpcSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};
  shared_ptr<string> vpcRegionId{};
  shared_ptr<string> vpcStatus{};
  shared_ptr<vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList>> vpcSwitchIdList{};

  DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList() {}

  explicit DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (honeyPotEcsInstanceStatus) {
      res["HoneyPotEcsInstanceStatus"] = boost::any(*honeyPotEcsInstanceStatus);
    }
    if (honeyPotEniInstanceId) {
      res["HoneyPotEniInstanceId"] = boost::any(*honeyPotEniInstanceId);
    }
    if (honeyPotExistence) {
      res["HoneyPotExistence"] = boost::any(*honeyPotExistence);
    }
    if (honeyPotInstanceStatus) {
      res["HoneyPotInstanceStatus"] = boost::any(*honeyPotInstanceStatus);
    }
    if (honeyPotVpcSwitchId) {
      res["HoneyPotVpcSwitchId"] = boost::any(*honeyPotVpcSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    if (vpcRegionId) {
      res["VpcRegionId"] = boost::any(*vpcRegionId);
    }
    if (vpcStatus) {
      res["VpcStatus"] = boost::any(*vpcStatus);
    }
    if (vpcSwitchIdList) {
      vector<boost::any> temp1;
      for(auto item1:*vpcSwitchIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcSwitchIdList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("HoneyPotEcsInstanceStatus") != m.end() && !m["HoneyPotEcsInstanceStatus"].empty()) {
      honeyPotEcsInstanceStatus = make_shared<string>(boost::any_cast<string>(m["HoneyPotEcsInstanceStatus"]));
    }
    if (m.find("HoneyPotEniInstanceId") != m.end() && !m["HoneyPotEniInstanceId"].empty()) {
      honeyPotEniInstanceId = make_shared<string>(boost::any_cast<string>(m["HoneyPotEniInstanceId"]));
    }
    if (m.find("HoneyPotExistence") != m.end() && !m["HoneyPotExistence"].empty()) {
      honeyPotExistence = make_shared<bool>(boost::any_cast<bool>(m["HoneyPotExistence"]));
    }
    if (m.find("HoneyPotInstanceStatus") != m.end() && !m["HoneyPotInstanceStatus"].empty()) {
      honeyPotInstanceStatus = make_shared<string>(boost::any_cast<string>(m["HoneyPotInstanceStatus"]));
    }
    if (m.find("HoneyPotVpcSwitchId") != m.end() && !m["HoneyPotVpcSwitchId"].empty()) {
      honeyPotVpcSwitchId = make_shared<string>(boost::any_cast<string>(m["HoneyPotVpcSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
    if (m.find("VpcRegionId") != m.end() && !m["VpcRegionId"].empty()) {
      vpcRegionId = make_shared<string>(boost::any_cast<string>(m["VpcRegionId"]));
    }
    if (m.find("VpcStatus") != m.end() && !m["VpcStatus"].empty()) {
      vpcStatus = make_shared<string>(boost::any_cast<string>(m["VpcStatus"]));
    }
    if (m.find("VpcSwitchIdList") != m.end() && !m["VpcSwitchIdList"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcSwitchIdList"].type()) {
        vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcSwitchIdList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcSwitchIdList = make_shared<vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList() = default;
};
class DescribeVpcHoneyPotListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVpcHoneyPotListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList>> vpcHoneyPotDTOList{};

  DescribeVpcHoneyPotListResponseBody() {}

  explicit DescribeVpcHoneyPotListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpcHoneyPotDTOList) {
      vector<boost::any> temp1;
      for(auto item1:*vpcHoneyPotDTOList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcHoneyPotDTOList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        DescribeVpcHoneyPotListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<DescribeVpcHoneyPotListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpcHoneyPotDTOList") != m.end() && !m["VpcHoneyPotDTOList"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcHoneyPotDTOList"].type()) {
        vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcHoneyPotDTOList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcHoneyPotDTOList = make_shared<vector<DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcHoneyPotListResponseBody() = default;
};
class DescribeVpcHoneyPotListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpcHoneyPotListResponseBody> body{};

  DescribeVpcHoneyPotListResponse() {}

  explicit DescribeVpcHoneyPotListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcHoneyPotListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcHoneyPotListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcHoneyPotListResponse() = default;
};
class DescribeVpcListResponseBodyVpcList : public Darabonba::Model {
public:
  shared_ptr<long> ecsCount{};
  shared_ptr<string> instanceDesc{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> regionId{};

  DescribeVpcListResponseBodyVpcList() {}

  explicit DescribeVpcListResponseBodyVpcList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsCount) {
      res["EcsCount"] = boost::any(*ecsCount);
    }
    if (instanceDesc) {
      res["InstanceDesc"] = boost::any(*instanceDesc);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsCount") != m.end() && !m["EcsCount"].empty()) {
      ecsCount = make_shared<long>(boost::any_cast<long>(m["EcsCount"]));
    }
    if (m.find("InstanceDesc") != m.end() && !m["InstanceDesc"].empty()) {
      instanceDesc = make_shared<string>(boost::any_cast<string>(m["InstanceDesc"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeVpcListResponseBodyVpcList() = default;
};
class DescribeVpcListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVpcListResponseBodyVpcList>> vpcList{};

  DescribeVpcListResponseBody() {}

  explicit DescribeVpcListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpcList) {
      vector<boost::any> temp1;
      for(auto item1:*vpcList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpcList") != m.end() && !m["VpcList"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcList"].type()) {
        vector<DescribeVpcListResponseBodyVpcList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcListResponseBodyVpcList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcList = make_shared<vector<DescribeVpcListResponseBodyVpcList>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcListResponseBody() = default;
};
class DescribeVpcListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpcListResponseBody> body{};

  DescribeVpcListResponse() {}

  explicit DescribeVpcListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcListResponse() = default;
};
class DescribeVulCheckTaskStatusDetailRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> taskIds{};
  shared_ptr<vector<string>> types{};
  shared_ptr<string> uuid{};

  DescribeVulCheckTaskStatusDetailRequest() {}

  explicit DescribeVulCheckTaskStatusDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeVulCheckTaskStatusDetailRequest() = default;
};
class DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList() {}

  explicit DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList() = default;
};
class DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<vector<DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList>> taskStatusList{};

  DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses() {}

  explicit DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatusList) {
      vector<boost::any> temp1;
      for(auto item1:*taskStatusList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStatusList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatusList") != m.end() && !m["TaskStatusList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStatusList"].type()) {
        vector<DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStatusList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStatusList = make_shared<vector<DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList>>(expect1);
      }
    }
  }


  virtual ~DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses() = default;
};
class DescribeVulCheckTaskStatusDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses>> taskStatuses{};
  shared_ptr<long> totalCount{};

  DescribeVulCheckTaskStatusDetailResponseBody() {}

  explicit DescribeVulCheckTaskStatusDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskStatuses) {
      vector<boost::any> temp1;
      for(auto item1:*taskStatuses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStatuses"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskStatuses") != m.end() && !m["TaskStatuses"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStatuses"].type()) {
        vector<DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStatuses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStatuses = make_shared<vector<DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeVulCheckTaskStatusDetailResponseBody() = default;
};
class DescribeVulCheckTaskStatusDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulCheckTaskStatusDetailResponseBody> body{};

  DescribeVulCheckTaskStatusDetailResponse() {}

  explicit DescribeVulCheckTaskStatusDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulCheckTaskStatusDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulCheckTaskStatusDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulCheckTaskStatusDetailResponse() = default;
};
class DescribeVulConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  DescribeVulConfigRequest() {}

  explicit DescribeVulConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeVulConfigRequest() = default;
};
class DescribeVulConfigResponseBodyTargetConfigs : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> overAllConfig{};
  shared_ptr<string> type{};

  DescribeVulConfigResponseBodyTargetConfigs() {}

  explicit DescribeVulConfigResponseBodyTargetConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (overAllConfig) {
      res["OverAllConfig"] = boost::any(*overAllConfig);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("OverAllConfig") != m.end() && !m["OverAllConfig"].empty()) {
      overAllConfig = make_shared<string>(boost::any_cast<string>(m["OverAllConfig"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeVulConfigResponseBodyTargetConfigs() = default;
};
class DescribeVulConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVulConfigResponseBodyTargetConfigs>> targetConfigs{};
  shared_ptr<long> totalCount{};

  DescribeVulConfigResponseBody() {}

  explicit DescribeVulConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (targetConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*targetConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetConfigs"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TargetConfigs") != m.end() && !m["TargetConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetConfigs"].type()) {
        vector<DescribeVulConfigResponseBodyTargetConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulConfigResponseBodyTargetConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetConfigs = make_shared<vector<DescribeVulConfigResponseBodyTargetConfigs>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeVulConfigResponseBody() = default;
};
class DescribeVulConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulConfigResponseBody> body{};

  DescribeVulConfigResponse() {}

  explicit DescribeVulConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulConfigResponse() = default;
};
class DescribeVulDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribeVulDetailsRequest() {}

  explicit DescribeVulDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeVulDetailsRequest() = default;
};
class DescribeVulDetailsResponseBodyCvesClassifys : public Darabonba::Model {
public:
  shared_ptr<string> classify{};
  shared_ptr<string> demoVideoUrl{};
  shared_ptr<string> description{};

  DescribeVulDetailsResponseBodyCvesClassifys() {}

  explicit DescribeVulDetailsResponseBodyCvesClassifys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (demoVideoUrl) {
      res["DemoVideoUrl"] = boost::any(*demoVideoUrl);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("DemoVideoUrl") != m.end() && !m["DemoVideoUrl"].empty()) {
      demoVideoUrl = make_shared<string>(boost::any_cast<string>(m["DemoVideoUrl"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeVulDetailsResponseBodyCvesClassifys() = default;
};
class DescribeVulDetailsResponseBodyCves : public Darabonba::Model {
public:
  shared_ptr<string> classify{};
  shared_ptr<vector<DescribeVulDetailsResponseBodyCvesClassifys>> classifys{};
  shared_ptr<string> cnvdId{};
  shared_ptr<string> complexity{};
  shared_ptr<string> content{};
  shared_ptr<string> cveId{};
  shared_ptr<string> cvssScore{};
  shared_ptr<string> cvssVector{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> poc{};
  shared_ptr<long> pocCreateTime{};
  shared_ptr<long> pocDisclosureTime{};
  shared_ptr<string> product{};
  shared_ptr<string> reference{};
  shared_ptr<long> releaseTime{};
  shared_ptr<string> solution{};
  shared_ptr<string> summary{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> title{};
  shared_ptr<string> vendor{};
  shared_ptr<string> vulLevel{};

  DescribeVulDetailsResponseBodyCves() {}

  explicit DescribeVulDetailsResponseBodyCves(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (classify) {
      res["Classify"] = boost::any(*classify);
    }
    if (classifys) {
      vector<boost::any> temp1;
      for(auto item1:*classifys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Classifys"] = boost::any(temp1);
    }
    if (cnvdId) {
      res["CnvdId"] = boost::any(*cnvdId);
    }
    if (complexity) {
      res["Complexity"] = boost::any(*complexity);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (cveId) {
      res["CveId"] = boost::any(*cveId);
    }
    if (cvssScore) {
      res["CvssScore"] = boost::any(*cvssScore);
    }
    if (cvssVector) {
      res["CvssVector"] = boost::any(*cvssVector);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (poc) {
      res["Poc"] = boost::any(*poc);
    }
    if (pocCreateTime) {
      res["PocCreateTime"] = boost::any(*pocCreateTime);
    }
    if (pocDisclosureTime) {
      res["PocDisclosureTime"] = boost::any(*pocDisclosureTime);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (reference) {
      res["Reference"] = boost::any(*reference);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (solution) {
      res["Solution"] = boost::any(*solution);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    if (vulLevel) {
      res["VulLevel"] = boost::any(*vulLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Classify") != m.end() && !m["Classify"].empty()) {
      classify = make_shared<string>(boost::any_cast<string>(m["Classify"]));
    }
    if (m.find("Classifys") != m.end() && !m["Classifys"].empty()) {
      if (typeid(vector<boost::any>) == m["Classifys"].type()) {
        vector<DescribeVulDetailsResponseBodyCvesClassifys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Classifys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulDetailsResponseBodyCvesClassifys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        classifys = make_shared<vector<DescribeVulDetailsResponseBodyCvesClassifys>>(expect1);
      }
    }
    if (m.find("CnvdId") != m.end() && !m["CnvdId"].empty()) {
      cnvdId = make_shared<string>(boost::any_cast<string>(m["CnvdId"]));
    }
    if (m.find("Complexity") != m.end() && !m["Complexity"].empty()) {
      complexity = make_shared<string>(boost::any_cast<string>(m["Complexity"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CveId") != m.end() && !m["CveId"].empty()) {
      cveId = make_shared<string>(boost::any_cast<string>(m["CveId"]));
    }
    if (m.find("CvssScore") != m.end() && !m["CvssScore"].empty()) {
      cvssScore = make_shared<string>(boost::any_cast<string>(m["CvssScore"]));
    }
    if (m.find("CvssVector") != m.end() && !m["CvssVector"].empty()) {
      cvssVector = make_shared<string>(boost::any_cast<string>(m["CvssVector"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Poc") != m.end() && !m["Poc"].empty()) {
      poc = make_shared<string>(boost::any_cast<string>(m["Poc"]));
    }
    if (m.find("PocCreateTime") != m.end() && !m["PocCreateTime"].empty()) {
      pocCreateTime = make_shared<long>(boost::any_cast<long>(m["PocCreateTime"]));
    }
    if (m.find("PocDisclosureTime") != m.end() && !m["PocDisclosureTime"].empty()) {
      pocDisclosureTime = make_shared<long>(boost::any_cast<long>(m["PocDisclosureTime"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("Reference") != m.end() && !m["Reference"].empty()) {
      reference = make_shared<string>(boost::any_cast<string>(m["Reference"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<long>(boost::any_cast<long>(m["ReleaseTime"]));
    }
    if (m.find("Solution") != m.end() && !m["Solution"].empty()) {
      solution = make_shared<string>(boost::any_cast<string>(m["Solution"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
    if (m.find("VulLevel") != m.end() && !m["VulLevel"].empty()) {
      vulLevel = make_shared<string>(boost::any_cast<string>(m["VulLevel"]));
    }
  }


  virtual ~DescribeVulDetailsResponseBodyCves() = default;
};
class DescribeVulDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVulDetailsResponseBodyCves>> cves{};
  shared_ptr<string> requestId{};

  DescribeVulDetailsResponseBody() {}

  explicit DescribeVulDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cves) {
      vector<boost::any> temp1;
      for(auto item1:*cves){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cves"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cves") != m.end() && !m["Cves"].empty()) {
      if (typeid(vector<boost::any>) == m["Cves"].type()) {
        vector<DescribeVulDetailsResponseBodyCves> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cves"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulDetailsResponseBodyCves model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cves = make_shared<vector<DescribeVulDetailsResponseBodyCves>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVulDetailsResponseBody() = default;
};
class DescribeVulDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulDetailsResponseBody> body{};

  DescribeVulDetailsResponse() {}

  explicit DescribeVulDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulDetailsResponse() = default;
};
class DescribeVulExportInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> exportId{};

  DescribeVulExportInfoRequest() {}

  explicit DescribeVulExportInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportId) {
      res["ExportId"] = boost::any(*exportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportId") != m.end() && !m["ExportId"].empty()) {
      exportId = make_shared<long>(boost::any_cast<long>(m["ExportId"]));
    }
  }


  virtual ~DescribeVulExportInfoRequest() = default;
};
class DescribeVulExportInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentCount{};
  shared_ptr<string> exportStatus{};
  shared_ptr<string> fileName{};
  shared_ptr<long> id{};
  shared_ptr<string> link{};
  shared_ptr<string> message{};
  shared_ptr<long> progress{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeVulExportInfoResponseBody() {}

  explicit DescribeVulExportInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (exportStatus) {
      res["ExportStatus"] = boost::any(*exportStatus);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("ExportStatus") != m.end() && !m["ExportStatus"].empty()) {
      exportStatus = make_shared<string>(boost::any_cast<string>(m["ExportStatus"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeVulExportInfoResponseBody() = default;
};
class DescribeVulExportInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulExportInfoResponseBody> body{};

  DescribeVulExportInfoResponse() {}

  explicit DescribeVulExportInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulExportInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulExportInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulExportInfoResponse() = default;
};
class DescribeVulFixStatisticsResponseBodyFixStat : public Darabonba::Model {
public:
  shared_ptr<long> fixedTodayNum{};
  shared_ptr<long> fixedTotalNum{};
  shared_ptr<long> fixingNum{};
  shared_ptr<long> needFixNum{};
  shared_ptr<string> type{};

  DescribeVulFixStatisticsResponseBodyFixStat() {}

  explicit DescribeVulFixStatisticsResponseBodyFixStat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedTodayNum) {
      res["FixedTodayNum"] = boost::any(*fixedTodayNum);
    }
    if (fixedTotalNum) {
      res["FixedTotalNum"] = boost::any(*fixedTotalNum);
    }
    if (fixingNum) {
      res["FixingNum"] = boost::any(*fixingNum);
    }
    if (needFixNum) {
      res["NeedFixNum"] = boost::any(*needFixNum);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedTodayNum") != m.end() && !m["FixedTodayNum"].empty()) {
      fixedTodayNum = make_shared<long>(boost::any_cast<long>(m["FixedTodayNum"]));
    }
    if (m.find("FixedTotalNum") != m.end() && !m["FixedTotalNum"].empty()) {
      fixedTotalNum = make_shared<long>(boost::any_cast<long>(m["FixedTotalNum"]));
    }
    if (m.find("FixingNum") != m.end() && !m["FixingNum"].empty()) {
      fixingNum = make_shared<long>(boost::any_cast<long>(m["FixingNum"]));
    }
    if (m.find("NeedFixNum") != m.end() && !m["NeedFixNum"].empty()) {
      needFixNum = make_shared<long>(boost::any_cast<long>(m["NeedFixNum"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeVulFixStatisticsResponseBodyFixStat() = default;
};
class DescribeVulFixStatisticsResponseBodyFixTotal : public Darabonba::Model {
public:
  shared_ptr<long> fixedTodayNum{};
  shared_ptr<long> fixedTotalNum{};
  shared_ptr<long> fixingNum{};
  shared_ptr<long> needFixNum{};

  DescribeVulFixStatisticsResponseBodyFixTotal() {}

  explicit DescribeVulFixStatisticsResponseBodyFixTotal(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixedTodayNum) {
      res["FixedTodayNum"] = boost::any(*fixedTodayNum);
    }
    if (fixedTotalNum) {
      res["FixedTotalNum"] = boost::any(*fixedTotalNum);
    }
    if (fixingNum) {
      res["FixingNum"] = boost::any(*fixingNum);
    }
    if (needFixNum) {
      res["NeedFixNum"] = boost::any(*needFixNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixedTodayNum") != m.end() && !m["FixedTodayNum"].empty()) {
      fixedTodayNum = make_shared<long>(boost::any_cast<long>(m["FixedTodayNum"]));
    }
    if (m.find("FixedTotalNum") != m.end() && !m["FixedTotalNum"].empty()) {
      fixedTotalNum = make_shared<long>(boost::any_cast<long>(m["FixedTotalNum"]));
    }
    if (m.find("FixingNum") != m.end() && !m["FixingNum"].empty()) {
      fixingNum = make_shared<long>(boost::any_cast<long>(m["FixingNum"]));
    }
    if (m.find("NeedFixNum") != m.end() && !m["NeedFixNum"].empty()) {
      needFixNum = make_shared<long>(boost::any_cast<long>(m["NeedFixNum"]));
    }
  }


  virtual ~DescribeVulFixStatisticsResponseBodyFixTotal() = default;
};
class DescribeVulFixStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVulFixStatisticsResponseBodyFixStat>> fixStat{};
  shared_ptr<DescribeVulFixStatisticsResponseBodyFixTotal> fixTotal{};
  shared_ptr<string> requestId{};

  DescribeVulFixStatisticsResponseBody() {}

  explicit DescribeVulFixStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fixStat) {
      vector<boost::any> temp1;
      for(auto item1:*fixStat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FixStat"] = boost::any(temp1);
    }
    if (fixTotal) {
      res["FixTotal"] = fixTotal ? boost::any(fixTotal->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FixStat") != m.end() && !m["FixStat"].empty()) {
      if (typeid(vector<boost::any>) == m["FixStat"].type()) {
        vector<DescribeVulFixStatisticsResponseBodyFixStat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FixStat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulFixStatisticsResponseBodyFixStat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fixStat = make_shared<vector<DescribeVulFixStatisticsResponseBodyFixStat>>(expect1);
      }
    }
    if (m.find("FixTotal") != m.end() && !m["FixTotal"].empty()) {
      if (typeid(map<string, boost::any>) == m["FixTotal"].type()) {
        DescribeVulFixStatisticsResponseBodyFixTotal model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FixTotal"]));
        fixTotal = make_shared<DescribeVulFixStatisticsResponseBodyFixTotal>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVulFixStatisticsResponseBody() = default;
};
class DescribeVulFixStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulFixStatisticsResponseBody> body{};

  DescribeVulFixStatisticsResponse() {}

  explicit DescribeVulFixStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulFixStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulFixStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulFixStatisticsResponse() = default;
};
class DescribeVulListRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> attachTypes{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> dealed{};
  shared_ptr<string> groupId{};
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<string> necessity{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<string> type{};
  shared_ptr<string> uuids{};
  shared_ptr<string> vpcInstanceIds{};

  DescribeVulListRequest() {}

  explicit DescribeVulListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (attachTypes) {
      res["AttachTypes"] = boost::any(*attachTypes);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (vpcInstanceIds) {
      res["VpcInstanceIds"] = boost::any(*vpcInstanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("AttachTypes") != m.end() && !m["AttachTypes"].empty()) {
      attachTypes = make_shared<string>(boost::any_cast<string>(m["AttachTypes"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("VpcInstanceIds") != m.end() && !m["VpcInstanceIds"].empty()) {
      vpcInstanceIds = make_shared<string>(boost::any_cast<string>(m["VpcInstanceIds"]));
    }
  }


  virtual ~DescribeVulListRequest() = default;
};
class DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity : public Darabonba::Model {
public:
  shared_ptr<string> assetsFactor{};
  shared_ptr<string> cvssFactor{};
  shared_ptr<string> enviromentFactor{};
  shared_ptr<string> isCalc{};
  shared_ptr<string> status{};
  shared_ptr<string> timeFactor{};
  shared_ptr<string> totalScore{};

  DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity() {}

  explicit DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetsFactor) {
      res["Assets_factor"] = boost::any(*assetsFactor);
    }
    if (cvssFactor) {
      res["Cvss_factor"] = boost::any(*cvssFactor);
    }
    if (enviromentFactor) {
      res["Enviroment_factor"] = boost::any(*enviromentFactor);
    }
    if (isCalc) {
      res["Is_calc"] = boost::any(*isCalc);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timeFactor) {
      res["Time_factor"] = boost::any(*timeFactor);
    }
    if (totalScore) {
      res["Total_score"] = boost::any(*totalScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assets_factor") != m.end() && !m["Assets_factor"].empty()) {
      assetsFactor = make_shared<string>(boost::any_cast<string>(m["Assets_factor"]));
    }
    if (m.find("Cvss_factor") != m.end() && !m["Cvss_factor"].empty()) {
      cvssFactor = make_shared<string>(boost::any_cast<string>(m["Cvss_factor"]));
    }
    if (m.find("Enviroment_factor") != m.end() && !m["Enviroment_factor"].empty()) {
      enviromentFactor = make_shared<string>(boost::any_cast<string>(m["Enviroment_factor"]));
    }
    if (m.find("Is_calc") != m.end() && !m["Is_calc"].empty()) {
      isCalc = make_shared<string>(boost::any_cast<string>(m["Is_calc"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Time_factor") != m.end() && !m["Time_factor"].empty()) {
      timeFactor = make_shared<string>(boost::any_cast<string>(m["Time_factor"]));
    }
    if (m.find("Total_score") != m.end() && !m["Total_score"].empty()) {
      totalScore = make_shared<string>(boost::any_cast<string>(m["Total_score"]));
    }
  }


  virtual ~DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity() = default;
};
class DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList : public Darabonba::Model {
public:
  shared_ptr<string> containerName{};
  shared_ptr<string> fullVersion{};
  shared_ptr<string> imageName{};
  shared_ptr<string> matchDetail{};
  shared_ptr<vector<string>> matchList{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> pid{};
  shared_ptr<string> updateCmd{};
  shared_ptr<string> version{};

  DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList() {}

  explicit DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (fullVersion) {
      res["FullVersion"] = boost::any(*fullVersion);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (matchDetail) {
      res["MatchDetail"] = boost::any(*matchDetail);
    }
    if (matchList) {
      res["MatchList"] = boost::any(*matchList);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (updateCmd) {
      res["UpdateCmd"] = boost::any(*updateCmd);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("FullVersion") != m.end() && !m["FullVersion"].empty()) {
      fullVersion = make_shared<string>(boost::any_cast<string>(m["FullVersion"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("MatchDetail") != m.end() && !m["MatchDetail"].empty()) {
      matchDetail = make_shared<string>(boost::any_cast<string>(m["MatchDetail"]));
    }
    if (m.find("MatchList") != m.end() && !m["MatchList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MatchList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MatchList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      matchList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("UpdateCmd") != m.end() && !m["UpdateCmd"].empty()) {
      updateCmd = make_shared<string>(boost::any_cast<string>(m["UpdateCmd"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList() = default;
};
class DescribeVulListResponseBodyVulRecordsExtendContentJson : public Darabonba::Model {
public:
  shared_ptr<string> absolutePath{};
  shared_ptr<string> aliasName{};
  shared_ptr<string> description{};
  shared_ptr<string> ip{};
  shared_ptr<long> lastTs{};
  shared_ptr<DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity> necessity{};
  shared_ptr<string> os{};
  shared_ptr<string> osRelease{};
  shared_ptr<long> primaryId{};
  shared_ptr<vector<DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList>> rpmEntityList{};
  shared_ptr<string> status{};
  shared_ptr<string> tag{};
  shared_ptr<vector<string>> cveList{};

  DescribeVulListResponseBodyVulRecordsExtendContentJson() {}

  explicit DescribeVulListResponseBodyVulRecordsExtendContentJson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (absolutePath) {
      res["AbsolutePath"] = boost::any(*absolutePath);
    }
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (lastTs) {
      res["LastTs"] = boost::any(*lastTs);
    }
    if (necessity) {
      res["Necessity"] = necessity ? boost::any(necessity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (osRelease) {
      res["OsRelease"] = boost::any(*osRelease);
    }
    if (primaryId) {
      res["PrimaryId"] = boost::any(*primaryId);
    }
    if (rpmEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*rpmEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RpmEntityList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (cveList) {
      res["cveList"] = boost::any(*cveList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbsolutePath") != m.end() && !m["AbsolutePath"].empty()) {
      absolutePath = make_shared<string>(boost::any_cast<string>(m["AbsolutePath"]));
    }
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("LastTs") != m.end() && !m["LastTs"].empty()) {
      lastTs = make_shared<long>(boost::any_cast<long>(m["LastTs"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      if (typeid(map<string, boost::any>) == m["Necessity"].type()) {
        DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Necessity"]));
        necessity = make_shared<DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity>(model1);
      }
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("OsRelease") != m.end() && !m["OsRelease"].empty()) {
      osRelease = make_shared<string>(boost::any_cast<string>(m["OsRelease"]));
    }
    if (m.find("PrimaryId") != m.end() && !m["PrimaryId"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["PrimaryId"]));
    }
    if (m.find("RpmEntityList") != m.end() && !m["RpmEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["RpmEntityList"].type()) {
        vector<DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RpmEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rpmEntityList = make_shared<vector<DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("cveList") != m.end() && !m["cveList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["cveList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["cveList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cveList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeVulListResponseBodyVulRecordsExtendContentJson() = default;
};
class DescribeVulListResponseBodyVulRecords : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> authVersion{};
  shared_ptr<bool> bind{};
  shared_ptr<DescribeVulListResponseBodyVulRecordsExtendContentJson> extendContentJson{};
  shared_ptr<long> firstTs{};
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> lastTs{};
  shared_ptr<long> modifyTs{};
  shared_ptr<string> name{};
  shared_ptr<string> necessity{};
  shared_ptr<bool> online{};
  shared_ptr<string> osName{};
  shared_ptr<string> osVersion{};
  shared_ptr<long> primaryId{};
  shared_ptr<long> raspDefend{};
  shared_ptr<long> raspStatus{};
  shared_ptr<string> regionId{};
  shared_ptr<string> related{};
  shared_ptr<long> repairTs{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<long> status{};
  shared_ptr<string> tag{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  DescribeVulListResponseBodyVulRecords() {}

  explicit DescribeVulListResponseBodyVulRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (authVersion) {
      res["AuthVersion"] = boost::any(*authVersion);
    }
    if (bind) {
      res["Bind"] = boost::any(*bind);
    }
    if (extendContentJson) {
      res["ExtendContentJson"] = extendContentJson ? boost::any(extendContentJson->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (firstTs) {
      res["FirstTs"] = boost::any(*firstTs);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (lastTs) {
      res["LastTs"] = boost::any(*lastTs);
    }
    if (modifyTs) {
      res["ModifyTs"] = boost::any(*modifyTs);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (osName) {
      res["OsName"] = boost::any(*osName);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (primaryId) {
      res["PrimaryId"] = boost::any(*primaryId);
    }
    if (raspDefend) {
      res["RaspDefend"] = boost::any(*raspDefend);
    }
    if (raspStatus) {
      res["RaspStatus"] = boost::any(*raspStatus);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (related) {
      res["Related"] = boost::any(*related);
    }
    if (repairTs) {
      res["RepairTs"] = boost::any(*repairTs);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("AuthVersion") != m.end() && !m["AuthVersion"].empty()) {
      authVersion = make_shared<string>(boost::any_cast<string>(m["AuthVersion"]));
    }
    if (m.find("Bind") != m.end() && !m["Bind"].empty()) {
      bind = make_shared<bool>(boost::any_cast<bool>(m["Bind"]));
    }
    if (m.find("ExtendContentJson") != m.end() && !m["ExtendContentJson"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtendContentJson"].type()) {
        DescribeVulListResponseBodyVulRecordsExtendContentJson model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtendContentJson"]));
        extendContentJson = make_shared<DescribeVulListResponseBodyVulRecordsExtendContentJson>(model1);
      }
    }
    if (m.find("FirstTs") != m.end() && !m["FirstTs"].empty()) {
      firstTs = make_shared<long>(boost::any_cast<long>(m["FirstTs"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("LastTs") != m.end() && !m["LastTs"].empty()) {
      lastTs = make_shared<long>(boost::any_cast<long>(m["LastTs"]));
    }
    if (m.find("ModifyTs") != m.end() && !m["ModifyTs"].empty()) {
      modifyTs = make_shared<long>(boost::any_cast<long>(m["ModifyTs"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("OsName") != m.end() && !m["OsName"].empty()) {
      osName = make_shared<string>(boost::any_cast<string>(m["OsName"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("PrimaryId") != m.end() && !m["PrimaryId"].empty()) {
      primaryId = make_shared<long>(boost::any_cast<long>(m["PrimaryId"]));
    }
    if (m.find("RaspDefend") != m.end() && !m["RaspDefend"].empty()) {
      raspDefend = make_shared<long>(boost::any_cast<long>(m["RaspDefend"]));
    }
    if (m.find("RaspStatus") != m.end() && !m["RaspStatus"].empty()) {
      raspStatus = make_shared<long>(boost::any_cast<long>(m["RaspStatus"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Related") != m.end() && !m["Related"].empty()) {
      related = make_shared<string>(boost::any_cast<string>(m["Related"]));
    }
    if (m.find("RepairTs") != m.end() && !m["RepairTs"].empty()) {
      repairTs = make_shared<long>(boost::any_cast<long>(m["RepairTs"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeVulListResponseBodyVulRecords() = default;
};
class DescribeVulListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeVulListResponseBodyVulRecords>> vulRecords{};

  DescribeVulListResponseBody() {}

  explicit DescribeVulListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vulRecords) {
      vector<boost::any> temp1;
      for(auto item1:*vulRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VulRecords"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VulRecords") != m.end() && !m["VulRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["VulRecords"].type()) {
        vector<DescribeVulListResponseBodyVulRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VulRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulListResponseBodyVulRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulRecords = make_shared<vector<DescribeVulListResponseBodyVulRecords>>(expect1);
      }
    }
  }


  virtual ~DescribeVulListResponseBody() = default;
};
class DescribeVulListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulListResponseBody> body{};

  DescribeVulListResponse() {}

  explicit DescribeVulListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulListResponse() = default;
};
class DescribeVulListPageRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> cveId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> vulNameLike{};

  DescribeVulListPageRequest() {}

  explicit DescribeVulListPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (cveId) {
      res["CveId"] = boost::any(*cveId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (vulNameLike) {
      res["VulNameLike"] = boost::any(*vulNameLike);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("CveId") != m.end() && !m["CveId"].empty()) {
      cveId = make_shared<string>(boost::any_cast<string>(m["CveId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VulNameLike") != m.end() && !m["VulNameLike"].empty()) {
      vulNameLike = make_shared<string>(boost::any_cast<string>(m["VulNameLike"]));
    }
  }


  virtual ~DescribeVulListPageRequest() = default;
};
class DescribeVulListPageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> cveId{};
  shared_ptr<string> extAegis{};
  shared_ptr<long> id{};
  shared_ptr<long> isAegis{};
  shared_ptr<long> isSas{};
  shared_ptr<string> otherId{};
  shared_ptr<long> releaseTime{};
  shared_ptr<string> title{};

  DescribeVulListPageResponseBodyData() {}

  explicit DescribeVulListPageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cveId) {
      res["CveId"] = boost::any(*cveId);
    }
    if (extAegis) {
      res["ExtAegis"] = boost::any(*extAegis);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isAegis) {
      res["IsAegis"] = boost::any(*isAegis);
    }
    if (isSas) {
      res["IsSas"] = boost::any(*isSas);
    }
    if (otherId) {
      res["OtherId"] = boost::any(*otherId);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CveId") != m.end() && !m["CveId"].empty()) {
      cveId = make_shared<string>(boost::any_cast<string>(m["CveId"]));
    }
    if (m.find("ExtAegis") != m.end() && !m["ExtAegis"].empty()) {
      extAegis = make_shared<string>(boost::any_cast<string>(m["ExtAegis"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsAegis") != m.end() && !m["IsAegis"].empty()) {
      isAegis = make_shared<long>(boost::any_cast<long>(m["IsAegis"]));
    }
    if (m.find("IsSas") != m.end() && !m["IsSas"].empty()) {
      isSas = make_shared<long>(boost::any_cast<long>(m["IsSas"]));
    }
    if (m.find("OtherId") != m.end() && !m["OtherId"].empty()) {
      otherId = make_shared<string>(boost::any_cast<string>(m["OtherId"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<long>(boost::any_cast<long>(m["ReleaseTime"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeVulListPageResponseBodyData() = default;
};
class DescribeVulListPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVulListPageResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeVulListPageResponseBody() {}

  explicit DescribeVulListPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeVulListPageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulListPageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeVulListPageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeVulListPageResponseBody() = default;
};
class DescribeVulListPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulListPageResponseBody> body{};

  DescribeVulListPageResponse() {}

  explicit DescribeVulListPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulListPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulListPageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulListPageResponse() = default;
};
class DescribeVulNumStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};

  DescribeVulNumStatisticsRequest() {}

  explicit DescribeVulNumStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~DescribeVulNumStatisticsRequest() = default;
};
class DescribeVulNumStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> appCnt{};
  shared_ptr<long> appNum{};
  shared_ptr<long> cmsDealedTotalNum{};
  shared_ptr<long> cmsNum{};
  shared_ptr<long> cveNum{};
  shared_ptr<long> emgNum{};
  shared_ptr<string> requestId{};
  shared_ptr<long> scaNum{};
  shared_ptr<long> sysNum{};
  shared_ptr<long> vulAsapSum{};
  shared_ptr<long> vulDealedTotalNum{};
  shared_ptr<long> vulLaterSum{};
  shared_ptr<long> vulNntfSum{};

  DescribeVulNumStatisticsResponseBody() {}

  explicit DescribeVulNumStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCnt) {
      res["AppCnt"] = boost::any(*appCnt);
    }
    if (appNum) {
      res["AppNum"] = boost::any(*appNum);
    }
    if (cmsDealedTotalNum) {
      res["CmsDealedTotalNum"] = boost::any(*cmsDealedTotalNum);
    }
    if (cmsNum) {
      res["CmsNum"] = boost::any(*cmsNum);
    }
    if (cveNum) {
      res["CveNum"] = boost::any(*cveNum);
    }
    if (emgNum) {
      res["EmgNum"] = boost::any(*emgNum);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scaNum) {
      res["ScaNum"] = boost::any(*scaNum);
    }
    if (sysNum) {
      res["SysNum"] = boost::any(*sysNum);
    }
    if (vulAsapSum) {
      res["VulAsapSum"] = boost::any(*vulAsapSum);
    }
    if (vulDealedTotalNum) {
      res["VulDealedTotalNum"] = boost::any(*vulDealedTotalNum);
    }
    if (vulLaterSum) {
      res["VulLaterSum"] = boost::any(*vulLaterSum);
    }
    if (vulNntfSum) {
      res["VulNntfSum"] = boost::any(*vulNntfSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCnt") != m.end() && !m["AppCnt"].empty()) {
      appCnt = make_shared<long>(boost::any_cast<long>(m["AppCnt"]));
    }
    if (m.find("AppNum") != m.end() && !m["AppNum"].empty()) {
      appNum = make_shared<long>(boost::any_cast<long>(m["AppNum"]));
    }
    if (m.find("CmsDealedTotalNum") != m.end() && !m["CmsDealedTotalNum"].empty()) {
      cmsDealedTotalNum = make_shared<long>(boost::any_cast<long>(m["CmsDealedTotalNum"]));
    }
    if (m.find("CmsNum") != m.end() && !m["CmsNum"].empty()) {
      cmsNum = make_shared<long>(boost::any_cast<long>(m["CmsNum"]));
    }
    if (m.find("CveNum") != m.end() && !m["CveNum"].empty()) {
      cveNum = make_shared<long>(boost::any_cast<long>(m["CveNum"]));
    }
    if (m.find("EmgNum") != m.end() && !m["EmgNum"].empty()) {
      emgNum = make_shared<long>(boost::any_cast<long>(m["EmgNum"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScaNum") != m.end() && !m["ScaNum"].empty()) {
      scaNum = make_shared<long>(boost::any_cast<long>(m["ScaNum"]));
    }
    if (m.find("SysNum") != m.end() && !m["SysNum"].empty()) {
      sysNum = make_shared<long>(boost::any_cast<long>(m["SysNum"]));
    }
    if (m.find("VulAsapSum") != m.end() && !m["VulAsapSum"].empty()) {
      vulAsapSum = make_shared<long>(boost::any_cast<long>(m["VulAsapSum"]));
    }
    if (m.find("VulDealedTotalNum") != m.end() && !m["VulDealedTotalNum"].empty()) {
      vulDealedTotalNum = make_shared<long>(boost::any_cast<long>(m["VulDealedTotalNum"]));
    }
    if (m.find("VulLaterSum") != m.end() && !m["VulLaterSum"].empty()) {
      vulLaterSum = make_shared<long>(boost::any_cast<long>(m["VulLaterSum"]));
    }
    if (m.find("VulNntfSum") != m.end() && !m["VulNntfSum"].empty()) {
      vulNntfSum = make_shared<long>(boost::any_cast<long>(m["VulNntfSum"]));
    }
  }


  virtual ~DescribeVulNumStatisticsResponseBody() = default;
};
class DescribeVulNumStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulNumStatisticsResponseBody> body{};

  DescribeVulNumStatisticsResponse() {}

  explicit DescribeVulNumStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulNumStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulNumStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulNumStatisticsResponse() = default;
};
class DescribeVulTargetConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  DescribeVulTargetConfigRequest() {}

  explicit DescribeVulTargetConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeVulTargetConfigRequest() = default;
};
class DescribeVulTargetConfigResponseBodyTargetConfigs : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> overAllConfig{};
  shared_ptr<string> type{};

  DescribeVulTargetConfigResponseBodyTargetConfigs() {}

  explicit DescribeVulTargetConfigResponseBodyTargetConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (overAllConfig) {
      res["OverAllConfig"] = boost::any(*overAllConfig);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("OverAllConfig") != m.end() && !m["OverAllConfig"].empty()) {
      overAllConfig = make_shared<string>(boost::any_cast<string>(m["OverAllConfig"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeVulTargetConfigResponseBodyTargetConfigs() = default;
};
class DescribeVulTargetConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVulTargetConfigResponseBodyTargetConfigs>> targetConfigs{};
  shared_ptr<long> totalCount{};

  DescribeVulTargetConfigResponseBody() {}

  explicit DescribeVulTargetConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (targetConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*targetConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetConfigs"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TargetConfigs") != m.end() && !m["TargetConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetConfigs"].type()) {
        vector<DescribeVulTargetConfigResponseBodyTargetConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulTargetConfigResponseBodyTargetConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetConfigs = make_shared<vector<DescribeVulTargetConfigResponseBodyTargetConfigs>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeVulTargetConfigResponseBody() = default;
};
class DescribeVulTargetConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulTargetConfigResponseBody> body{};

  DescribeVulTargetConfigResponse() {}

  explicit DescribeVulTargetConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulTargetConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulTargetConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulTargetConfigResponse() = default;
};
class DescribeVulTargetStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  DescribeVulTargetStatisticsRequest() {}

  explicit DescribeVulTargetStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeVulTargetStatisticsRequest() = default;
};
class DescribeVulTargetStatisticsResponseBodyTargetStatsTargets : public Darabonba::Model {
public:
  shared_ptr<string> flag{};
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};

  DescribeVulTargetStatisticsResponseBodyTargetStatsTargets() {}

  explicit DescribeVulTargetStatisticsResponseBodyTargetStatsTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flag) {
      res["Flag"] = boost::any(*flag);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flag") != m.end() && !m["Flag"].empty()) {
      flag = make_shared<string>(boost::any_cast<string>(m["Flag"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeVulTargetStatisticsResponseBodyTargetStatsTargets() = default;
};
class DescribeVulTargetStatisticsResponseBodyTargetStats : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVulTargetStatisticsResponseBodyTargetStatsTargets>> targets{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> uuidCount{};
  shared_ptr<string> vulType{};

  DescribeVulTargetStatisticsResponseBodyTargetStats() {}

  explicit DescribeVulTargetStatisticsResponseBodyTargetStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targets) {
      vector<boost::any> temp1;
      for(auto item1:*targets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Targets"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (uuidCount) {
      res["UuidCount"] = boost::any(*uuidCount);
    }
    if (vulType) {
      res["VulType"] = boost::any(*vulType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(vector<boost::any>) == m["Targets"].type()) {
        vector<DescribeVulTargetStatisticsResponseBodyTargetStatsTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Targets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulTargetStatisticsResponseBodyTargetStatsTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targets = make_shared<vector<DescribeVulTargetStatisticsResponseBodyTargetStatsTargets>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UuidCount") != m.end() && !m["UuidCount"].empty()) {
      uuidCount = make_shared<long>(boost::any_cast<long>(m["UuidCount"]));
    }
    if (m.find("VulType") != m.end() && !m["VulType"].empty()) {
      vulType = make_shared<string>(boost::any_cast<string>(m["VulType"]));
    }
  }


  virtual ~DescribeVulTargetStatisticsResponseBodyTargetStats() = default;
};
class DescribeVulTargetStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVulTargetStatisticsResponseBodyTargetStats>> targetStats{};
  shared_ptr<long> totalCount{};

  DescribeVulTargetStatisticsResponseBody() {}

  explicit DescribeVulTargetStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (targetStats) {
      vector<boost::any> temp1;
      for(auto item1:*targetStats){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetStats"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TargetStats") != m.end() && !m["TargetStats"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetStats"].type()) {
        vector<DescribeVulTargetStatisticsResponseBodyTargetStats> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetStats"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulTargetStatisticsResponseBodyTargetStats model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetStats = make_shared<vector<DescribeVulTargetStatisticsResponseBodyTargetStats>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeVulTargetStatisticsResponseBody() = default;
};
class DescribeVulTargetStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulTargetStatisticsResponseBody> body{};

  DescribeVulTargetStatisticsResponse() {}

  explicit DescribeVulTargetStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulTargetStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulTargetStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulTargetStatisticsResponse() = default;
};
class DescribeVulWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeVulWhitelistRequest() {}

  explicit DescribeVulWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeVulWhitelistRequest() = default;
};
class DescribeVulWhitelistResponseBodyVulWhitelists : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> reason{};
  shared_ptr<string> targetInfo{};
  shared_ptr<string> type{};
  shared_ptr<string> whitelist{};

  DescribeVulWhitelistResponseBodyVulWhitelists() {}

  explicit DescribeVulWhitelistResponseBodyVulWhitelists(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (targetInfo) {
      res["TargetInfo"] = boost::any(*targetInfo);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (whitelist) {
      res["Whitelist"] = boost::any(*whitelist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("TargetInfo") != m.end() && !m["TargetInfo"].empty()) {
      targetInfo = make_shared<string>(boost::any_cast<string>(m["TargetInfo"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Whitelist") != m.end() && !m["Whitelist"].empty()) {
      whitelist = make_shared<string>(boost::any_cast<string>(m["Whitelist"]));
    }
  }


  virtual ~DescribeVulWhitelistResponseBodyVulWhitelists() = default;
};
class DescribeVulWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeVulWhitelistResponseBodyVulWhitelists>> vulWhitelists{};

  DescribeVulWhitelistResponseBody() {}

  explicit DescribeVulWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vulWhitelists) {
      vector<boost::any> temp1;
      for(auto item1:*vulWhitelists){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VulWhitelists"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VulWhitelists") != m.end() && !m["VulWhitelists"].empty()) {
      if (typeid(vector<boost::any>) == m["VulWhitelists"].type()) {
        vector<DescribeVulWhitelistResponseBodyVulWhitelists> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VulWhitelists"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVulWhitelistResponseBodyVulWhitelists model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulWhitelists = make_shared<vector<DescribeVulWhitelistResponseBodyVulWhitelists>>(expect1);
      }
    }
  }


  virtual ~DescribeVulWhitelistResponseBody() = default;
};
class DescribeVulWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVulWhitelistResponseBody> body{};

  DescribeVulWhitelistResponse() {}

  explicit DescribeVulWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVulWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVulWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVulWhitelistResponse() = default;
};
class DescribeWarningExportInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> exportId{};

  DescribeWarningExportInfoRequest() {}

  explicit DescribeWarningExportInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportId) {
      res["ExportId"] = boost::any(*exportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportId") != m.end() && !m["ExportId"].empty()) {
      exportId = make_shared<long>(boost::any_cast<long>(m["ExportId"]));
    }
  }


  virtual ~DescribeWarningExportInfoRequest() = default;
};
class DescribeWarningExportInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentCount{};
  shared_ptr<string> exportStatus{};
  shared_ptr<string> fileName{};
  shared_ptr<long> id{};
  shared_ptr<string> link{};
  shared_ptr<string> message{};
  shared_ptr<long> progress{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWarningExportInfoResponseBody() {}

  explicit DescribeWarningExportInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentCount) {
      res["CurrentCount"] = boost::any(*currentCount);
    }
    if (exportStatus) {
      res["ExportStatus"] = boost::any(*exportStatus);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentCount") != m.end() && !m["CurrentCount"].empty()) {
      currentCount = make_shared<long>(boost::any_cast<long>(m["CurrentCount"]));
    }
    if (m.find("ExportStatus") != m.end() && !m["ExportStatus"].empty()) {
      exportStatus = make_shared<string>(boost::any_cast<string>(m["ExportStatus"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWarningExportInfoResponseBody() = default;
};
class DescribeWarningExportInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWarningExportInfoResponseBody> body{};

  DescribeWarningExportInfoResponse() {}

  explicit DescribeWarningExportInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWarningExportInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWarningExportInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWarningExportInfoResponse() = default;
};
class DescribeWarningMachinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> groupId{};
  shared_ptr<long> haveRisk{};
  shared_ptr<string> lang{};
  shared_ptr<string> machineName{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> riskId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> strategyId{};
  shared_ptr<string> targetType{};
  shared_ptr<string> uuids{};

  DescribeWarningMachinesRequest() {}

  explicit DescribeWarningMachinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (haveRisk) {
      res["HaveRisk"] = boost::any(*haveRisk);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (machineName) {
      res["MachineName"] = boost::any(*machineName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("HaveRisk") != m.end() && !m["HaveRisk"].empty()) {
      haveRisk = make_shared<long>(boost::any_cast<long>(m["HaveRisk"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("MachineName") != m.end() && !m["MachineName"].empty()) {
      machineName = make_shared<string>(boost::any_cast<string>(m["MachineName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~DescribeWarningMachinesRequest() = default;
};
class DescribeWarningMachinesResponseBodyWarningMachines : public Darabonba::Model {
public:
  shared_ptr<long> authVersion{};
  shared_ptr<bool> bind{};
  shared_ptr<long> highWarningCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<long> lowWarningCount{};
  shared_ptr<long> mediumWarningCount{};
  shared_ptr<long> passCount{};
  shared_ptr<bool> portOpen{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};
  shared_ptr<string> uuid{};

  DescribeWarningMachinesResponseBodyWarningMachines() {}

  explicit DescribeWarningMachinesResponseBodyWarningMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authVersion) {
      res["AuthVersion"] = boost::any(*authVersion);
    }
    if (bind) {
      res["Bind"] = boost::any(*bind);
    }
    if (highWarningCount) {
      res["HighWarningCount"] = boost::any(*highWarningCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (lowWarningCount) {
      res["LowWarningCount"] = boost::any(*lowWarningCount);
    }
    if (mediumWarningCount) {
      res["MediumWarningCount"] = boost::any(*mediumWarningCount);
    }
    if (passCount) {
      res["PassCount"] = boost::any(*passCount);
    }
    if (portOpen) {
      res["PortOpen"] = boost::any(*portOpen);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthVersion") != m.end() && !m["AuthVersion"].empty()) {
      authVersion = make_shared<long>(boost::any_cast<long>(m["AuthVersion"]));
    }
    if (m.find("Bind") != m.end() && !m["Bind"].empty()) {
      bind = make_shared<bool>(boost::any_cast<bool>(m["Bind"]));
    }
    if (m.find("HighWarningCount") != m.end() && !m["HighWarningCount"].empty()) {
      highWarningCount = make_shared<long>(boost::any_cast<long>(m["HighWarningCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("LowWarningCount") != m.end() && !m["LowWarningCount"].empty()) {
      lowWarningCount = make_shared<long>(boost::any_cast<long>(m["LowWarningCount"]));
    }
    if (m.find("MediumWarningCount") != m.end() && !m["MediumWarningCount"].empty()) {
      mediumWarningCount = make_shared<long>(boost::any_cast<long>(m["MediumWarningCount"]));
    }
    if (m.find("PassCount") != m.end() && !m["PassCount"].empty()) {
      passCount = make_shared<long>(boost::any_cast<long>(m["PassCount"]));
    }
    if (m.find("PortOpen") != m.end() && !m["PortOpen"].empty()) {
      portOpen = make_shared<bool>(boost::any_cast<bool>(m["PortOpen"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeWarningMachinesResponseBodyWarningMachines() = default;
};
class DescribeWarningMachinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeWarningMachinesResponseBodyWarningMachines>> warningMachines{};

  DescribeWarningMachinesResponseBody() {}

  explicit DescribeWarningMachinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (warningMachines) {
      vector<boost::any> temp1;
      for(auto item1:*warningMachines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WarningMachines"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WarningMachines") != m.end() && !m["WarningMachines"].empty()) {
      if (typeid(vector<boost::any>) == m["WarningMachines"].type()) {
        vector<DescribeWarningMachinesResponseBodyWarningMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WarningMachines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWarningMachinesResponseBodyWarningMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        warningMachines = make_shared<vector<DescribeWarningMachinesResponseBodyWarningMachines>>(expect1);
      }
    }
  }


  virtual ~DescribeWarningMachinesResponseBody() = default;
};
class DescribeWarningMachinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWarningMachinesResponseBody> body{};

  DescribeWarningMachinesResponse() {}

  explicit DescribeWarningMachinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWarningMachinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWarningMachinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWarningMachinesResponse() = default;
};
class DescribeWebLockBindListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> status{};

  DescribeWebLockBindListRequest() {}

  explicit DescribeWebLockBindListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeWebLockBindListRequest() = default;
};
class DescribeWebLockBindListResponseBodyBindList : public Darabonba::Model {
public:
  shared_ptr<string> auditCount{};
  shared_ptr<string> blockCount{};
  shared_ptr<string> dirCount{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> os{};
  shared_ptr<long> percent{};
  shared_ptr<string> serviceCode{};
  shared_ptr<string> serviceDetail{};
  shared_ptr<string> serviceStatus{};
  shared_ptr<string> status{};
  shared_ptr<string> uuid{};

  DescribeWebLockBindListResponseBodyBindList() {}

  explicit DescribeWebLockBindListResponseBodyBindList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditCount) {
      res["AuditCount"] = boost::any(*auditCount);
    }
    if (blockCount) {
      res["BlockCount"] = boost::any(*blockCount);
    }
    if (dirCount) {
      res["DirCount"] = boost::any(*dirCount);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (serviceCode) {
      res["ServiceCode"] = boost::any(*serviceCode);
    }
    if (serviceDetail) {
      res["ServiceDetail"] = boost::any(*serviceDetail);
    }
    if (serviceStatus) {
      res["ServiceStatus"] = boost::any(*serviceStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditCount") != m.end() && !m["AuditCount"].empty()) {
      auditCount = make_shared<string>(boost::any_cast<string>(m["AuditCount"]));
    }
    if (m.find("BlockCount") != m.end() && !m["BlockCount"].empty()) {
      blockCount = make_shared<string>(boost::any_cast<string>(m["BlockCount"]));
    }
    if (m.find("DirCount") != m.end() && !m["DirCount"].empty()) {
      dirCount = make_shared<string>(boost::any_cast<string>(m["DirCount"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("ServiceCode") != m.end() && !m["ServiceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["ServiceCode"]));
    }
    if (m.find("ServiceDetail") != m.end() && !m["ServiceDetail"].empty()) {
      serviceDetail = make_shared<string>(boost::any_cast<string>(m["ServiceDetail"]));
    }
    if (m.find("ServiceStatus") != m.end() && !m["ServiceStatus"].empty()) {
      serviceStatus = make_shared<string>(boost::any_cast<string>(m["ServiceStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeWebLockBindListResponseBodyBindList() = default;
};
class DescribeWebLockBindListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebLockBindListResponseBodyBindList>> bindList{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebLockBindListResponseBody() {}

  explicit DescribeWebLockBindListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindList) {
      vector<boost::any> temp1;
      for(auto item1:*bindList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BindList"] = boost::any(temp1);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindList") != m.end() && !m["BindList"].empty()) {
      if (typeid(vector<boost::any>) == m["BindList"].type()) {
        vector<DescribeWebLockBindListResponseBodyBindList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BindList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebLockBindListResponseBodyBindList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bindList = make_shared<vector<DescribeWebLockBindListResponseBodyBindList>>(expect1);
      }
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebLockBindListResponseBody() = default;
};
class DescribeWebLockBindListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockBindListResponseBody> body{};

  DescribeWebLockBindListResponse() {}

  explicit DescribeWebLockBindListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockBindListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockBindListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockBindListResponse() = default;
};
class DescribeWebLockConfigListRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuid{};

  DescribeWebLockConfigListRequest() {}

  explicit DescribeWebLockConfigListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeWebLockConfigListRequest() = default;
};
class DescribeWebLockConfigListResponseBodyConfigList : public Darabonba::Model {
public:
  shared_ptr<string> defenceMode{};
  shared_ptr<string> dir{};
  shared_ptr<string> exclusiveDir{};
  shared_ptr<string> exclusiveFile{};
  shared_ptr<string> exclusiveFileType{};
  shared_ptr<string> id{};
  shared_ptr<string> inclusiveFile{};
  shared_ptr<string> inclusiveFileType{};
  shared_ptr<string> localBackupDir{};
  shared_ptr<string> mode{};
  shared_ptr<string> uuid{};

  DescribeWebLockConfigListResponseBodyConfigList() {}

  explicit DescribeWebLockConfigListResponseBodyConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenceMode) {
      res["DefenceMode"] = boost::any(*defenceMode);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (exclusiveDir) {
      res["ExclusiveDir"] = boost::any(*exclusiveDir);
    }
    if (exclusiveFile) {
      res["ExclusiveFile"] = boost::any(*exclusiveFile);
    }
    if (exclusiveFileType) {
      res["ExclusiveFileType"] = boost::any(*exclusiveFileType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inclusiveFile) {
      res["InclusiveFile"] = boost::any(*inclusiveFile);
    }
    if (inclusiveFileType) {
      res["InclusiveFileType"] = boost::any(*inclusiveFileType);
    }
    if (localBackupDir) {
      res["LocalBackupDir"] = boost::any(*localBackupDir);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenceMode") != m.end() && !m["DefenceMode"].empty()) {
      defenceMode = make_shared<string>(boost::any_cast<string>(m["DefenceMode"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("ExclusiveDir") != m.end() && !m["ExclusiveDir"].empty()) {
      exclusiveDir = make_shared<string>(boost::any_cast<string>(m["ExclusiveDir"]));
    }
    if (m.find("ExclusiveFile") != m.end() && !m["ExclusiveFile"].empty()) {
      exclusiveFile = make_shared<string>(boost::any_cast<string>(m["ExclusiveFile"]));
    }
    if (m.find("ExclusiveFileType") != m.end() && !m["ExclusiveFileType"].empty()) {
      exclusiveFileType = make_shared<string>(boost::any_cast<string>(m["ExclusiveFileType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InclusiveFile") != m.end() && !m["InclusiveFile"].empty()) {
      inclusiveFile = make_shared<string>(boost::any_cast<string>(m["InclusiveFile"]));
    }
    if (m.find("InclusiveFileType") != m.end() && !m["InclusiveFileType"].empty()) {
      inclusiveFileType = make_shared<string>(boost::any_cast<string>(m["InclusiveFileType"]));
    }
    if (m.find("LocalBackupDir") != m.end() && !m["LocalBackupDir"].empty()) {
      localBackupDir = make_shared<string>(boost::any_cast<string>(m["LocalBackupDir"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeWebLockConfigListResponseBodyConfigList() = default;
};
class DescribeWebLockConfigListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebLockConfigListResponseBodyConfigList>> configList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebLockConfigListResponseBody() {}

  explicit DescribeWebLockConfigListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configList) {
      vector<boost::any> temp1;
      for(auto item1:*configList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigList"].type()) {
        vector<DescribeWebLockConfigListResponseBodyConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebLockConfigListResponseBodyConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configList = make_shared<vector<DescribeWebLockConfigListResponseBodyConfigList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebLockConfigListResponseBody() = default;
};
class DescribeWebLockConfigListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockConfigListResponseBody> body{};

  DescribeWebLockConfigListResponse() {}

  explicit DescribeWebLockConfigListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockConfigListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockConfigListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockConfigListResponse() = default;
};
class DescribeWebLockExclusiveFileTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> exclusiveFileType{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebLockExclusiveFileTypeResponseBody() {}

  explicit DescribeWebLockExclusiveFileTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exclusiveFileType) {
      res["ExclusiveFileType"] = boost::any(*exclusiveFileType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExclusiveFileType") != m.end() && !m["ExclusiveFileType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExclusiveFileType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExclusiveFileType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      exclusiveFileType = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebLockExclusiveFileTypeResponseBody() = default;
};
class DescribeWebLockExclusiveFileTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockExclusiveFileTypeResponseBody> body{};

  DescribeWebLockExclusiveFileTypeResponse() {}

  explicit DescribeWebLockExclusiveFileTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockExclusiveFileTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockExclusiveFileTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockExclusiveFileTypeResponse() = default;
};
class DescribeWebLockFileChangeStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeWebLockFileChangeStatisticsRequest() {}

  explicit DescribeWebLockFileChangeStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeWebLockFileChangeStatisticsRequest() = default;
};
class DescribeWebLockFileChangeStatisticsResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> file{};

  DescribeWebLockFileChangeStatisticsResponseBodyList() {}

  explicit DescribeWebLockFileChangeStatisticsResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (file) {
      res["File"] = boost::any(*file);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      file = make_shared<string>(boost::any_cast<string>(m["File"]));
    }
  }


  virtual ~DescribeWebLockFileChangeStatisticsResponseBodyList() = default;
};
class DescribeWebLockFileChangeStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeWebLockFileChangeStatisticsResponseBodyList>> list{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebLockFileChangeStatisticsResponseBody() {}

  explicit DescribeWebLockFileChangeStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeWebLockFileChangeStatisticsResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebLockFileChangeStatisticsResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeWebLockFileChangeStatisticsResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebLockFileChangeStatisticsResponseBody() = default;
};
class DescribeWebLockFileChangeStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockFileChangeStatisticsResponseBody> body{};

  DescribeWebLockFileChangeStatisticsResponse() {}

  explicit DescribeWebLockFileChangeStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockFileChangeStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockFileChangeStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockFileChangeStatisticsResponse() = default;
};
class DescribeWebLockFileEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> dealed{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> processName{};
  shared_ptr<string> remark{};
  shared_ptr<long> tsBegin{};
  shared_ptr<long> tsEnd{};

  DescribeWebLockFileEventsRequest() {}

  explicit DescribeWebLockFileEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (tsBegin) {
      res["TsBegin"] = boost::any(*tsBegin);
    }
    if (tsEnd) {
      res["TsEnd"] = boost::any(*tsEnd);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("TsBegin") != m.end() && !m["TsBegin"].empty()) {
      tsBegin = make_shared<long>(boost::any_cast<long>(m["TsBegin"]));
    }
    if (m.find("TsEnd") != m.end() && !m["TsEnd"].empty()) {
      tsEnd = make_shared<long>(boost::any_cast<long>(m["TsEnd"]));
    }
  }


  virtual ~DescribeWebLockFileEventsRequest() = default;
};
class DescribeWebLockFileEventsResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> ds{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventStatus{};
  shared_ptr<string> eventType{};
  shared_ptr<long> gmtEvent{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> level{};
  shared_ptr<string> path{};
  shared_ptr<string> processName{};
  shared_ptr<string> processPath{};
  shared_ptr<string> status{};
  shared_ptr<string> uuid{};

  DescribeWebLockFileEventsResponseBodyList() {}

  explicit DescribeWebLockFileEventsResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (ds) {
      res["Ds"] = boost::any(*ds);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventStatus) {
      res["EventStatus"] = boost::any(*eventStatus);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (gmtEvent) {
      res["GmtEvent"] = boost::any(*gmtEvent);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (processPath) {
      res["ProcessPath"] = boost::any(*processPath);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Ds") != m.end() && !m["Ds"].empty()) {
      ds = make_shared<long>(boost::any_cast<long>(m["Ds"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventStatus") != m.end() && !m["EventStatus"].empty()) {
      eventStatus = make_shared<string>(boost::any_cast<string>(m["EventStatus"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("GmtEvent") != m.end() && !m["GmtEvent"].empty()) {
      gmtEvent = make_shared<long>(boost::any_cast<long>(m["GmtEvent"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("ProcessPath") != m.end() && !m["ProcessPath"].empty()) {
      processPath = make_shared<string>(boost::any_cast<string>(m["ProcessPath"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeWebLockFileEventsResponseBodyList() = default;
};
class DescribeWebLockFileEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeWebLockFileEventsResponseBodyList>> list{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebLockFileEventsResponseBody() {}

  explicit DescribeWebLockFileEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeWebLockFileEventsResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebLockFileEventsResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeWebLockFileEventsResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebLockFileEventsResponseBody() = default;
};
class DescribeWebLockFileEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockFileEventsResponseBody> body{};

  DescribeWebLockFileEventsResponse() {}

  explicit DescribeWebLockFileEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockFileEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockFileEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockFileEventsResponse() = default;
};
class DescribeWebLockFileTypeSummaryResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> type{};

  DescribeWebLockFileTypeSummaryResponseBodyList() {}

  explicit DescribeWebLockFileTypeSummaryResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeWebLockFileTypeSummaryResponseBodyList() = default;
};
class DescribeWebLockFileTypeSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebLockFileTypeSummaryResponseBodyList>> list{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebLockFileTypeSummaryResponseBody() {}

  explicit DescribeWebLockFileTypeSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeWebLockFileTypeSummaryResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebLockFileTypeSummaryResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeWebLockFileTypeSummaryResponseBodyList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebLockFileTypeSummaryResponseBody() = default;
};
class DescribeWebLockFileTypeSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockFileTypeSummaryResponseBody> body{};

  DescribeWebLockFileTypeSummaryResponse() {}

  explicit DescribeWebLockFileTypeSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockFileTypeSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockFileTypeSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockFileTypeSummaryResponse() = default;
};
class DescribeWebLockInclusiveFileTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> inclusiveFileType{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebLockInclusiveFileTypeResponseBody() {}

  explicit DescribeWebLockInclusiveFileTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inclusiveFileType) {
      res["InclusiveFileType"] = boost::any(*inclusiveFileType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InclusiveFileType") != m.end() && !m["InclusiveFileType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InclusiveFileType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InclusiveFileType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      inclusiveFileType = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebLockInclusiveFileTypeResponseBody() = default;
};
class DescribeWebLockInclusiveFileTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockInclusiveFileTypeResponseBody> body{};

  DescribeWebLockInclusiveFileTypeResponse() {}

  explicit DescribeWebLockInclusiveFileTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockInclusiveFileTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockInclusiveFileTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockInclusiveFileTypeResponse() = default;
};
class DescribeWebLockProcessBlockStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  DescribeWebLockProcessBlockStatisticsRequest() {}

  explicit DescribeWebLockProcessBlockStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeWebLockProcessBlockStatisticsRequest() = default;
};
class DescribeWebLockProcessBlockStatisticsResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> process{};

  DescribeWebLockProcessBlockStatisticsResponseBodyList() {}

  explicit DescribeWebLockProcessBlockStatisticsResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
  }


  virtual ~DescribeWebLockProcessBlockStatisticsResponseBodyList() = default;
};
class DescribeWebLockProcessBlockStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeWebLockProcessBlockStatisticsResponseBodyList>> list{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebLockProcessBlockStatisticsResponseBody() {}

  explicit DescribeWebLockProcessBlockStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeWebLockProcessBlockStatisticsResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebLockProcessBlockStatisticsResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeWebLockProcessBlockStatisticsResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebLockProcessBlockStatisticsResponseBody() = default;
};
class DescribeWebLockProcessBlockStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockProcessBlockStatisticsResponseBody> body{};

  DescribeWebLockProcessBlockStatisticsResponse() {}

  explicit DescribeWebLockProcessBlockStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockProcessBlockStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockProcessBlockStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockProcessBlockStatisticsResponse() = default;
};
class DescribeWebLockProcessListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> processName{};
  shared_ptr<long> status{};

  DescribeWebLockProcessListRequest() {}

  explicit DescribeWebLockProcessListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeWebLockProcessListRequest() = default;
};
class DescribeWebLockProcessListResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> processName{};
  shared_ptr<string> processPath{};
  shared_ptr<long> status{};
  shared_ptr<string> uuid{};

  DescribeWebLockProcessListResponseBodyList() {}

  explicit DescribeWebLockProcessListResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (processPath) {
      res["ProcessPath"] = boost::any(*processPath);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("ProcessPath") != m.end() && !m["ProcessPath"].empty()) {
      processPath = make_shared<string>(boost::any_cast<string>(m["ProcessPath"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DescribeWebLockProcessListResponseBodyList() = default;
};
class DescribeWebLockProcessListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<DescribeWebLockProcessListResponseBodyList>> list{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebLockProcessListResponseBody() {}

  explicit DescribeWebLockProcessListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeWebLockProcessListResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebLockProcessListResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeWebLockProcessListResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebLockProcessListResponseBody() = default;
};
class DescribeWebLockProcessListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockProcessListResponseBody> body{};

  DescribeWebLockProcessListResponse() {}

  explicit DescribeWebLockProcessListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockProcessListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockProcessListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockProcessListResponse() = default;
};
class DescribeWebLockStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  DescribeWebLockStatusRequest() {}

  explicit DescribeWebLockStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeWebLockStatusRequest() = default;
};
class DescribeWebLockStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> authCount{};
  shared_ptr<long> bindCount{};
  shared_ptr<long> blockCount{};
  shared_ptr<long> dirCount{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> requestId{};
  shared_ptr<long> whiteCount{};

  DescribeWebLockStatusResponseBody() {}

  explicit DescribeWebLockStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authCount) {
      res["AuthCount"] = boost::any(*authCount);
    }
    if (bindCount) {
      res["BindCount"] = boost::any(*bindCount);
    }
    if (blockCount) {
      res["BlockCount"] = boost::any(*blockCount);
    }
    if (dirCount) {
      res["DirCount"] = boost::any(*dirCount);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (whiteCount) {
      res["WhiteCount"] = boost::any(*whiteCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthCount") != m.end() && !m["AuthCount"].empty()) {
      authCount = make_shared<long>(boost::any_cast<long>(m["AuthCount"]));
    }
    if (m.find("BindCount") != m.end() && !m["BindCount"].empty()) {
      bindCount = make_shared<long>(boost::any_cast<long>(m["BindCount"]));
    }
    if (m.find("BlockCount") != m.end() && !m["BlockCount"].empty()) {
      blockCount = make_shared<long>(boost::any_cast<long>(m["BlockCount"]));
    }
    if (m.find("DirCount") != m.end() && !m["DirCount"].empty()) {
      dirCount = make_shared<long>(boost::any_cast<long>(m["DirCount"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WhiteCount") != m.end() && !m["WhiteCount"].empty()) {
      whiteCount = make_shared<long>(boost::any_cast<long>(m["WhiteCount"]));
    }
  }


  virtual ~DescribeWebLockStatusResponseBody() = default;
};
class DescribeWebLockStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockStatusResponseBody> body{};

  DescribeWebLockStatusResponse() {}

  explicit DescribeWebLockStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockStatusResponse() = default;
};
class DescribeWebLockTotalFileChangeCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebLockTotalFileChangeCountResponseBody() {}

  explicit DescribeWebLockTotalFileChangeCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebLockTotalFileChangeCountResponseBody() = default;
};
class DescribeWebLockTotalFileChangeCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebLockTotalFileChangeCountResponseBody> body{};

  DescribeWebLockTotalFileChangeCountResponse() {}

  explicit DescribeWebLockTotalFileChangeCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebLockTotalFileChangeCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebLockTotalFileChangeCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebLockTotalFileChangeCountResponse() = default;
};
class DescribeWebPathRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> type{};

  DescribeWebPathRequest() {}

  explicit DescribeWebPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeWebPathRequest() = default;
};
class DescribeWebPathResponseBodyConfigListTargetList : public Darabonba::Model {
public:
  shared_ptr<string> target{};
  shared_ptr<string> targetType{};

  DescribeWebPathResponseBodyConfigListTargetList() {}

  explicit DescribeWebPathResponseBodyConfigListTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~DescribeWebPathResponseBodyConfigListTargetList() = default;
};
class DescribeWebPathResponseBodyConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebPathResponseBodyConfigListTargetList>> targetList{};
  shared_ptr<string> webPath{};
  shared_ptr<string> webPathType{};

  DescribeWebPathResponseBodyConfigList() {}

  explicit DescribeWebPathResponseBodyConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetList) {
      vector<boost::any> temp1;
      for(auto item1:*targetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TargetList"] = boost::any(temp1);
    }
    if (webPath) {
      res["WebPath"] = boost::any(*webPath);
    }
    if (webPathType) {
      res["WebPathType"] = boost::any(*webPathType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetList") != m.end() && !m["TargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["TargetList"].type()) {
        vector<DescribeWebPathResponseBodyConfigListTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebPathResponseBodyConfigListTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targetList = make_shared<vector<DescribeWebPathResponseBodyConfigListTargetList>>(expect1);
      }
    }
    if (m.find("WebPath") != m.end() && !m["WebPath"].empty()) {
      webPath = make_shared<string>(boost::any_cast<string>(m["WebPath"]));
    }
    if (m.find("WebPathType") != m.end() && !m["WebPathType"].empty()) {
      webPathType = make_shared<string>(boost::any_cast<string>(m["WebPathType"]));
    }
  }


  virtual ~DescribeWebPathResponseBodyConfigList() = default;
};
class DescribeWebPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeWebPathResponseBodyConfigList>> configList{};
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeWebPathResponseBody() {}

  explicit DescribeWebPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configList) {
      vector<boost::any> temp1;
      for(auto item1:*configList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigList"] = boost::any(temp1);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigList") != m.end() && !m["ConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigList"].type()) {
        vector<DescribeWebPathResponseBodyConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeWebPathResponseBodyConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configList = make_shared<vector<DescribeWebPathResponseBodyConfigList>>(expect1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeWebPathResponseBody() = default;
};
class DescribeWebPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWebPathResponseBody> body{};

  DescribeWebPathResponse() {}

  explicit DescribeWebPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWebPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWebPathResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWebPathResponse() = default;
};
class DisableBruteForceRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> blockIp{};
  shared_ptr<string> bound{};
  shared_ptr<long> id{};
  shared_ptr<string> port{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuid{};

  DisableBruteForceRecordRequest() {}

  explicit DisableBruteForceRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockIp) {
      res["BlockIp"] = boost::any(*blockIp);
    }
    if (bound) {
      res["Bound"] = boost::any(*bound);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockIp") != m.end() && !m["BlockIp"].empty()) {
      blockIp = make_shared<string>(boost::any_cast<string>(m["BlockIp"]));
    }
    if (m.find("Bound") != m.end() && !m["Bound"].empty()) {
      bound = make_shared<string>(boost::any_cast<string>(m["Bound"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~DisableBruteForceRecordRequest() = default;
};
class DisableBruteForceRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableBruteForceRecordResponseBody() {}

  explicit DisableBruteForceRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableBruteForceRecordResponseBody() = default;
};
class DisableBruteForceRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableBruteForceRecordResponseBody> body{};

  DisableBruteForceRecordResponse() {}

  explicit DisableBruteForceRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableBruteForceRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableBruteForceRecordResponseBody>(model1);
      }
    }
  }


  virtual ~DisableBruteForceRecordResponse() = default;
};
class DisableCustomBlockRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> blockIp{};
  shared_ptr<string> bound{};
  shared_ptr<long> resourceOwnerId{};

  DisableCustomBlockRecordRequest() {}

  explicit DisableCustomBlockRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockIp) {
      res["BlockIp"] = boost::any(*blockIp);
    }
    if (bound) {
      res["Bound"] = boost::any(*bound);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockIp") != m.end() && !m["BlockIp"].empty()) {
      blockIp = make_shared<string>(boost::any_cast<string>(m["BlockIp"]));
    }
    if (m.find("Bound") != m.end() && !m["Bound"].empty()) {
      bound = make_shared<string>(boost::any_cast<string>(m["Bound"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DisableCustomBlockRecordRequest() = default;
};
class DisableCustomBlockRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableCustomBlockRecordResponseBody() {}

  explicit DisableCustomBlockRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableCustomBlockRecordResponseBody() = default;
};
class DisableCustomBlockRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableCustomBlockRecordResponseBody> body{};

  DisableCustomBlockRecordResponse() {}

  explicit DisableCustomBlockRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableCustomBlockRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableCustomBlockRecordResponseBody>(model1);
      }
    }
  }


  virtual ~DisableCustomBlockRecordResponse() = default;
};
class EnableBruteForceRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> blockIp{};
  shared_ptr<string> bound{};
  shared_ptr<long> id{};
  shared_ptr<string> port{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuid{};

  EnableBruteForceRecordRequest() {}

  explicit EnableBruteForceRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockIp) {
      res["BlockIp"] = boost::any(*blockIp);
    }
    if (bound) {
      res["Bound"] = boost::any(*bound);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockIp") != m.end() && !m["BlockIp"].empty()) {
      blockIp = make_shared<string>(boost::any_cast<string>(m["BlockIp"]));
    }
    if (m.find("Bound") != m.end() && !m["Bound"].empty()) {
      bound = make_shared<string>(boost::any_cast<string>(m["Bound"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~EnableBruteForceRecordRequest() = default;
};
class EnableBruteForceRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableBruteForceRecordResponseBody() {}

  explicit EnableBruteForceRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableBruteForceRecordResponseBody() = default;
};
class EnableBruteForceRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableBruteForceRecordResponseBody> body{};

  EnableBruteForceRecordResponse() {}

  explicit EnableBruteForceRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableBruteForceRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableBruteForceRecordResponseBody>(model1);
      }
    }
  }


  virtual ~EnableBruteForceRecordResponse() = default;
};
class EnableCustomBlockRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> blockIp{};
  shared_ptr<string> bound{};
  shared_ptr<long> resourceOwnerId{};

  EnableCustomBlockRecordRequest() {}

  explicit EnableCustomBlockRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockIp) {
      res["BlockIp"] = boost::any(*blockIp);
    }
    if (bound) {
      res["Bound"] = boost::any(*bound);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockIp") != m.end() && !m["BlockIp"].empty()) {
      blockIp = make_shared<string>(boost::any_cast<string>(m["BlockIp"]));
    }
    if (m.find("Bound") != m.end() && !m["Bound"].empty()) {
      bound = make_shared<string>(boost::any_cast<string>(m["Bound"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~EnableCustomBlockRecordRequest() = default;
};
class EnableCustomBlockRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableCustomBlockRecordResponseBody() {}

  explicit EnableCustomBlockRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableCustomBlockRecordResponseBody() = default;
};
class EnableCustomBlockRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableCustomBlockRecordResponseBody> body{};

  EnableCustomBlockRecordResponse() {}

  explicit EnableCustomBlockRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableCustomBlockRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableCustomBlockRecordResponseBody>(model1);
      }
    }
  }


  virtual ~EnableCustomBlockRecordResponse() = default;
};
class ExecStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<long> strategyId{};

  ExecStrategyRequest() {}

  explicit ExecStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
  }


  virtual ~ExecStrategyRequest() = default;
};
class ExecStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ExecStrategyResponseBody() {}

  explicit ExecStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExecStrategyResponseBody() = default;
};
class ExecStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecStrategyResponseBody> body{};

  ExecStrategyResponse() {}

  explicit ExecStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~ExecStrategyResponse() = default;
};
class ExportRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> exportType{};
  shared_ptr<string> lang{};
  shared_ptr<string> params{};

  ExportRecordRequest() {}

  explicit ExportRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
  }


  virtual ~ExportRecordRequest() = default;
};
class ExportRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  ExportRecordResponseBody() {}

  explicit ExportRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportRecordResponseBody() = default;
};
class ExportRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportRecordResponseBody> body{};

  ExportRecordResponse() {}

  explicit ExportRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportRecordResponseBody>(model1);
      }
    }
  }


  virtual ~ExportRecordResponse() = default;
};
class ExportSuspEventsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> assetsTypeList{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<string> currentPage{};
  shared_ptr<string> dealed{};
  shared_ptr<string> from{};
  shared_ptr<string> lang{};
  shared_ptr<string> levels{};
  shared_ptr<string> name{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> parentEventTypes{};
  shared_ptr<string> remark{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> status{};
  shared_ptr<string> targetType{};
  shared_ptr<string> timeEnd{};
  shared_ptr<string> timeStart{};

  ExportSuspEventsRequest() {}

  explicit ExportSuspEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetsTypeList) {
      res["AssetsTypeList"] = boost::any(*assetsTypeList);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (levels) {
      res["Levels"] = boost::any(*levels);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentEventTypes) {
      res["ParentEventTypes"] = boost::any(*parentEventTypes);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (timeEnd) {
      res["TimeEnd"] = boost::any(*timeEnd);
    }
    if (timeStart) {
      res["TimeStart"] = boost::any(*timeStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetsTypeList") != m.end() && !m["AssetsTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AssetsTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AssetsTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      assetsTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Levels") != m.end() && !m["Levels"].empty()) {
      levels = make_shared<string>(boost::any_cast<string>(m["Levels"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ParentEventTypes") != m.end() && !m["ParentEventTypes"].empty()) {
      parentEventTypes = make_shared<string>(boost::any_cast<string>(m["ParentEventTypes"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TimeEnd") != m.end() && !m["TimeEnd"].empty()) {
      timeEnd = make_shared<string>(boost::any_cast<string>(m["TimeEnd"]));
    }
    if (m.find("TimeStart") != m.end() && !m["TimeStart"].empty()) {
      timeStart = make_shared<string>(boost::any_cast<string>(m["TimeStart"]));
    }
  }


  virtual ~ExportSuspEventsRequest() = default;
};
class ExportSuspEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  ExportSuspEventsResponseBody() {}

  explicit ExportSuspEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportSuspEventsResponseBody() = default;
};
class ExportSuspEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportSuspEventsResponseBody> body{};

  ExportSuspEventsResponse() {}

  explicit ExportSuspEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportSuspEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportSuspEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ExportSuspEventsResponse() = default;
};
class ExportVulRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<string> attachTypes{};
  shared_ptr<string> dealed{};
  shared_ptr<string> groupId{};
  shared_ptr<string> lang{};
  shared_ptr<string> necessity{};
  shared_ptr<string> searchTags{};
  shared_ptr<string> type{};
  shared_ptr<string> uuids{};
  shared_ptr<string> vpcInstanceIds{};

  ExportVulRequest() {}

  explicit ExportVulRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (attachTypes) {
      res["AttachTypes"] = boost::any(*attachTypes);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (necessity) {
      res["Necessity"] = boost::any(*necessity);
    }
    if (searchTags) {
      res["SearchTags"] = boost::any(*searchTags);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (vpcInstanceIds) {
      res["VpcInstanceIds"] = boost::any(*vpcInstanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("AttachTypes") != m.end() && !m["AttachTypes"].empty()) {
      attachTypes = make_shared<string>(boost::any_cast<string>(m["AttachTypes"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Necessity") != m.end() && !m["Necessity"].empty()) {
      necessity = make_shared<string>(boost::any_cast<string>(m["Necessity"]));
    }
    if (m.find("SearchTags") != m.end() && !m["SearchTags"].empty()) {
      searchTags = make_shared<string>(boost::any_cast<string>(m["SearchTags"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("VpcInstanceIds") != m.end() && !m["VpcInstanceIds"].empty()) {
      vpcInstanceIds = make_shared<string>(boost::any_cast<string>(m["VpcInstanceIds"]));
    }
  }


  virtual ~ExportVulRequest() = default;
};
class ExportVulResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  ExportVulResponseBody() {}

  explicit ExportVulResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportVulResponseBody() = default;
};
class ExportVulResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportVulResponseBody> body{};

  ExportVulResponse() {}

  explicit ExportVulResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportVulResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportVulResponseBody>(model1);
      }
    }
  }


  virtual ~ExportVulResponse() = default;
};
class ExportWarningRequest : public Darabonba::Model {
public:
  shared_ptr<string> dealed{};
  shared_ptr<string> exportType{};
  shared_ptr<long> isCleartextPwd{};
  shared_ptr<long> isSummaryExport{};
  shared_ptr<string> lang{};
  shared_ptr<string> riskIds{};
  shared_ptr<string> riskLevels{};
  shared_ptr<string> riskName{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> statusList{};
  shared_ptr<long> strategyId{};
  shared_ptr<string> subTypeNames{};
  shared_ptr<string> typeName_{};
  shared_ptr<string> typeNames{};
  shared_ptr<string> uuids{};

  ExportWarningRequest() {}

  explicit ExportWarningRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (isCleartextPwd) {
      res["IsCleartextPwd"] = boost::any(*isCleartextPwd);
    }
    if (isSummaryExport) {
      res["IsSummaryExport"] = boost::any(*isSummaryExport);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (riskIds) {
      res["RiskIds"] = boost::any(*riskIds);
    }
    if (riskLevels) {
      res["RiskLevels"] = boost::any(*riskLevels);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (subTypeNames) {
      res["SubTypeNames"] = boost::any(*subTypeNames);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    if (typeNames) {
      res["TypeNames"] = boost::any(*typeNames);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("IsCleartextPwd") != m.end() && !m["IsCleartextPwd"].empty()) {
      isCleartextPwd = make_shared<long>(boost::any_cast<long>(m["IsCleartextPwd"]));
    }
    if (m.find("IsSummaryExport") != m.end() && !m["IsSummaryExport"].empty()) {
      isSummaryExport = make_shared<long>(boost::any_cast<long>(m["IsSummaryExport"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RiskIds") != m.end() && !m["RiskIds"].empty()) {
      riskIds = make_shared<string>(boost::any_cast<string>(m["RiskIds"]));
    }
    if (m.find("RiskLevels") != m.end() && !m["RiskLevels"].empty()) {
      riskLevels = make_shared<string>(boost::any_cast<string>(m["RiskLevels"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      statusList = make_shared<string>(boost::any_cast<string>(m["StatusList"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
    if (m.find("SubTypeNames") != m.end() && !m["SubTypeNames"].empty()) {
      subTypeNames = make_shared<string>(boost::any_cast<string>(m["SubTypeNames"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
    if (m.find("TypeNames") != m.end() && !m["TypeNames"].empty()) {
      typeNames = make_shared<string>(boost::any_cast<string>(m["TypeNames"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~ExportWarningRequest() = default;
};
class ExportWarningResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  ExportWarningResponseBody() {}

  explicit ExportWarningResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportWarningResponseBody() = default;
};
class ExportWarningResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportWarningResponseBody> body{};

  ExportWarningResponse() {}

  explicit ExportWarningResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportWarningResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportWarningResponseBody>(model1);
      }
    }
  }


  virtual ~ExportWarningResponse() = default;
};
class FindContainerNetworkConnectRequestDstNode : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<string>> nodeIds{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> podName{};

  FindContainerNetworkConnectRequestDstNode() {}

  explicit FindContainerNetworkConnectRequestDstNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
  }


  virtual ~FindContainerNetworkConnectRequestDstNode() = default;
};
class FindContainerNetworkConnectRequestSrcNode : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<string>> nodeIds{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> podName{};

  FindContainerNetworkConnectRequestSrcNode() {}

  explicit FindContainerNetworkConnectRequestSrcNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
  }


  virtual ~FindContainerNetworkConnectRequestSrcNode() = default;
};
class FindContainerNetworkConnectRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteriaType{};
  shared_ptr<long> currentPage{};
  shared_ptr<FindContainerNetworkConnectRequestDstNode> dstNode{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<FindContainerNetworkConnectRequestSrcNode> srcNode{};
  shared_ptr<long> startTime{};

  FindContainerNetworkConnectRequest() {}

  explicit FindContainerNetworkConnectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteriaType) {
      res["CriteriaType"] = boost::any(*criteriaType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (dstNode) {
      res["DstNode"] = dstNode ? boost::any(dstNode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (srcNode) {
      res["SrcNode"] = srcNode ? boost::any(srcNode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CriteriaType") != m.end() && !m["CriteriaType"].empty()) {
      criteriaType = make_shared<string>(boost::any_cast<string>(m["CriteriaType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DstNode") != m.end() && !m["DstNode"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstNode"].type()) {
        FindContainerNetworkConnectRequestDstNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstNode"]));
        dstNode = make_shared<FindContainerNetworkConnectRequestDstNode>(model1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SrcNode") != m.end() && !m["SrcNode"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcNode"].type()) {
        FindContainerNetworkConnectRequestSrcNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcNode"]));
        srcNode = make_shared<FindContainerNetworkConnectRequestSrcNode>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~FindContainerNetworkConnectRequest() = default;
};
class FindContainerNetworkConnectShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteriaType{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> dstNodeShrink{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> srcNodeShrink{};
  shared_ptr<long> startTime{};

  FindContainerNetworkConnectShrinkRequest() {}

  explicit FindContainerNetworkConnectShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteriaType) {
      res["CriteriaType"] = boost::any(*criteriaType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (dstNodeShrink) {
      res["DstNode"] = boost::any(*dstNodeShrink);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (srcNodeShrink) {
      res["SrcNode"] = boost::any(*srcNodeShrink);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CriteriaType") != m.end() && !m["CriteriaType"].empty()) {
      criteriaType = make_shared<string>(boost::any_cast<string>(m["CriteriaType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DstNode") != m.end() && !m["DstNode"].empty()) {
      dstNodeShrink = make_shared<string>(boost::any_cast<string>(m["DstNode"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SrcNode") != m.end() && !m["SrcNode"].empty()) {
      srcNodeShrink = make_shared<string>(boost::any_cast<string>(m["SrcNode"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~FindContainerNetworkConnectShrinkRequest() = default;
};
class FindContainerNetworkConnectResponseBodyConnectsDstContainer : public Darabonba::Model {
public:
  shared_ptr<string> containerId{};

  FindContainerNetworkConnectResponseBodyConnectsDstContainer() {}

  explicit FindContainerNetworkConnectResponseBodyConnectsDstContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
  }


  virtual ~FindContainerNetworkConnectResponseBodyConnectsDstContainer() = default;
};
class FindContainerNetworkConnectResponseBodyConnectsSrcContainer : public Darabonba::Model {
public:
  shared_ptr<string> containerId{};

  FindContainerNetworkConnectResponseBodyConnectsSrcContainer() {}

  explicit FindContainerNetworkConnectResponseBodyConnectsSrcContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerId) {
      res["ContainerId"] = boost::any(*containerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerId") != m.end() && !m["ContainerId"].empty()) {
      containerId = make_shared<string>(boost::any_cast<string>(m["ContainerId"]));
    }
  }


  virtual ~FindContainerNetworkConnectResponseBodyConnectsSrcContainer() = default;
};
class FindContainerNetworkConnectResponseBodyConnects : public Darabonba::Model {
public:
  shared_ptr<FindContainerNetworkConnectResponseBodyConnectsDstContainer> dstContainer{};
  shared_ptr<string> dstIp{};
  shared_ptr<string> dstPort{};
  shared_ptr<long> firstTime{};
  shared_ptr<long> id{};
  shared_ptr<long> lastTime{};
  shared_ptr<FindContainerNetworkConnectResponseBodyConnectsSrcContainer> srcContainer{};
  shared_ptr<string> srcIp{};
  shared_ptr<string> srcPort{};

  FindContainerNetworkConnectResponseBodyConnects() {}

  explicit FindContainerNetworkConnectResponseBodyConnects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstContainer) {
      res["DstContainer"] = dstContainer ? boost::any(dstContainer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dstIp) {
      res["DstIp"] = boost::any(*dstIp);
    }
    if (dstPort) {
      res["DstPort"] = boost::any(*dstPort);
    }
    if (firstTime) {
      res["FirstTime"] = boost::any(*firstTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (srcContainer) {
      res["SrcContainer"] = srcContainer ? boost::any(srcContainer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (srcIp) {
      res["SrcIp"] = boost::any(*srcIp);
    }
    if (srcPort) {
      res["SrcPort"] = boost::any(*srcPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstContainer") != m.end() && !m["DstContainer"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstContainer"].type()) {
        FindContainerNetworkConnectResponseBodyConnectsDstContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstContainer"]));
        dstContainer = make_shared<FindContainerNetworkConnectResponseBodyConnectsDstContainer>(model1);
      }
    }
    if (m.find("DstIp") != m.end() && !m["DstIp"].empty()) {
      dstIp = make_shared<string>(boost::any_cast<string>(m["DstIp"]));
    }
    if (m.find("DstPort") != m.end() && !m["DstPort"].empty()) {
      dstPort = make_shared<string>(boost::any_cast<string>(m["DstPort"]));
    }
    if (m.find("FirstTime") != m.end() && !m["FirstTime"].empty()) {
      firstTime = make_shared<long>(boost::any_cast<long>(m["FirstTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
    if (m.find("SrcContainer") != m.end() && !m["SrcContainer"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcContainer"].type()) {
        FindContainerNetworkConnectResponseBodyConnectsSrcContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcContainer"]));
        srcContainer = make_shared<FindContainerNetworkConnectResponseBodyConnectsSrcContainer>(model1);
      }
    }
    if (m.find("SrcIp") != m.end() && !m["SrcIp"].empty()) {
      srcIp = make_shared<string>(boost::any_cast<string>(m["SrcIp"]));
    }
    if (m.find("SrcPort") != m.end() && !m["SrcPort"].empty()) {
      srcPort = make_shared<string>(boost::any_cast<string>(m["SrcPort"]));
    }
  }


  virtual ~FindContainerNetworkConnectResponseBodyConnects() = default;
};
class FindContainerNetworkConnectResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  FindContainerNetworkConnectResponseBodyPageInfo() {}

  explicit FindContainerNetworkConnectResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindContainerNetworkConnectResponseBodyPageInfo() = default;
};
class FindContainerNetworkConnectResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<FindContainerNetworkConnectResponseBodyConnects>> connects{};
  shared_ptr<FindContainerNetworkConnectResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  FindContainerNetworkConnectResponseBody() {}

  explicit FindContainerNetworkConnectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connects) {
      vector<boost::any> temp1;
      for(auto item1:*connects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Connects"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Connects") != m.end() && !m["Connects"].empty()) {
      if (typeid(vector<boost::any>) == m["Connects"].type()) {
        vector<FindContainerNetworkConnectResponseBodyConnects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Connects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindContainerNetworkConnectResponseBodyConnects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        connects = make_shared<vector<FindContainerNetworkConnectResponseBodyConnects>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        FindContainerNetworkConnectResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<FindContainerNetworkConnectResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FindContainerNetworkConnectResponseBody() = default;
};
class FindContainerNetworkConnectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FindContainerNetworkConnectResponseBody> body{};

  FindContainerNetworkConnectResponse() {}

  explicit FindContainerNetworkConnectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindContainerNetworkConnectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindContainerNetworkConnectResponseBody>(model1);
      }
    }
  }


  virtual ~FindContainerNetworkConnectResponse() = default;
};
class FixCheckWarningsRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkParams{};
  shared_ptr<string> lang{};
  shared_ptr<long> riskId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuids{};

  FixCheckWarningsRequest() {}

  explicit FixCheckWarningsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkParams) {
      res["CheckParams"] = boost::any(*checkParams);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckParams") != m.end() && !m["CheckParams"].empty()) {
      checkParams = make_shared<string>(boost::any_cast<string>(m["CheckParams"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~FixCheckWarningsRequest() = default;
};
class FixCheckWarningsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> batchId{};
  shared_ptr<string> requestId{};

  FixCheckWarningsResponseBody() {}

  explicit FixCheckWarningsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchId) {
      res["BatchId"] = boost::any(*batchId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchId") != m.end() && !m["BatchId"].empty()) {
      batchId = make_shared<long>(boost::any_cast<long>(m["BatchId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FixCheckWarningsResponseBody() = default;
};
class FixCheckWarningsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FixCheckWarningsResponseBody> body{};

  FixCheckWarningsResponse() {}

  explicit FixCheckWarningsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FixCheckWarningsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FixCheckWarningsResponseBody>(model1);
      }
    }
  }


  virtual ~FixCheckWarningsResponse() = default;
};
class GenerateOnceTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> param{};
  shared_ptr<string> source{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};

  GenerateOnceTaskRequest() {}

  explicit GenerateOnceTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~GenerateOnceTaskRequest() = default;
};
class GenerateOnceTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> canCreate{};
  shared_ptr<long> collectTime{};
  shared_ptr<long> finishCount{};
  shared_ptr<string> lastTask{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};
  shared_ptr<long> totalCount{};

  GenerateOnceTaskResponseBody() {}

  explicit GenerateOnceTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canCreate) {
      res["CanCreate"] = boost::any(*canCreate);
    }
    if (collectTime) {
      res["CollectTime"] = boost::any(*collectTime);
    }
    if (finishCount) {
      res["FinishCount"] = boost::any(*finishCount);
    }
    if (lastTask) {
      res["LastTask"] = boost::any(*lastTask);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanCreate") != m.end() && !m["CanCreate"].empty()) {
      canCreate = make_shared<bool>(boost::any_cast<bool>(m["CanCreate"]));
    }
    if (m.find("CollectTime") != m.end() && !m["CollectTime"].empty()) {
      collectTime = make_shared<long>(boost::any_cast<long>(m["CollectTime"]));
    }
    if (m.find("FinishCount") != m.end() && !m["FinishCount"].empty()) {
      finishCount = make_shared<long>(boost::any_cast<long>(m["FinishCount"]));
    }
    if (m.find("LastTask") != m.end() && !m["LastTask"].empty()) {
      lastTask = make_shared<string>(boost::any_cast<string>(m["LastTask"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GenerateOnceTaskResponseBody() = default;
};
class GenerateOnceTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateOnceTaskResponseBody> body{};

  GenerateOnceTaskResponse() {}

  explicit GenerateOnceTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateOnceTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateOnceTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateOnceTaskResponse() = default;
};
class GetAlarmMachineCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};

  GetAlarmMachineCountRequest() {}

  explicit GetAlarmMachineCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~GetAlarmMachineCountRequest() = default;
};
class GetAlarmMachineCountResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> machineCount{};

  GetAlarmMachineCountResponseBodyData() {}

  explicit GetAlarmMachineCountResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineCount) {
      res["MachineCount"] = boost::any(*machineCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineCount") != m.end() && !m["MachineCount"].empty()) {
      machineCount = make_shared<long>(boost::any_cast<long>(m["MachineCount"]));
    }
  }


  virtual ~GetAlarmMachineCountResponseBodyData() = default;
};
class GetAlarmMachineCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAlarmMachineCountResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetAlarmMachineCountResponseBody() {}

  explicit GetAlarmMachineCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAlarmMachineCountResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAlarmMachineCountResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAlarmMachineCountResponseBody() = default;
};
class GetAlarmMachineCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAlarmMachineCountResponseBody> body{};

  GetAlarmMachineCountResponse() {}

  explicit GetAlarmMachineCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAlarmMachineCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAlarmMachineCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetAlarmMachineCountResponse() = default;
};
class GetAppNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};

  GetAppNetworkRequest() {}

  explicit GetAppNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetAppNetworkRequest() = default;
};
class GetAppNetworkResponseBodyAppNetworkEdge : public Darabonba::Model {
public:
  shared_ptr<string> dstNodeId{};
  shared_ptr<string> dstNodeType{};
  shared_ptr<string> id{};
  shared_ptr<string> port{};
  shared_ptr<string> srcNodeId{};
  shared_ptr<string> srcNodeType{};

  GetAppNetworkResponseBodyAppNetworkEdge() {}

  explicit GetAppNetworkResponseBodyAppNetworkEdge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstNodeId) {
      res["DstNodeId"] = boost::any(*dstNodeId);
    }
    if (dstNodeType) {
      res["DstNodeType"] = boost::any(*dstNodeType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (srcNodeId) {
      res["SrcNodeId"] = boost::any(*srcNodeId);
    }
    if (srcNodeType) {
      res["SrcNodeType"] = boost::any(*srcNodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstNodeId") != m.end() && !m["DstNodeId"].empty()) {
      dstNodeId = make_shared<string>(boost::any_cast<string>(m["DstNodeId"]));
    }
    if (m.find("DstNodeType") != m.end() && !m["DstNodeType"].empty()) {
      dstNodeType = make_shared<string>(boost::any_cast<string>(m["DstNodeType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("SrcNodeId") != m.end() && !m["SrcNodeId"].empty()) {
      srcNodeId = make_shared<string>(boost::any_cast<string>(m["SrcNodeId"]));
    }
    if (m.find("SrcNodeType") != m.end() && !m["SrcNodeType"].empty()) {
      srcNodeType = make_shared<string>(boost::any_cast<string>(m["SrcNodeType"]));
    }
  }


  virtual ~GetAppNetworkResponseBodyAppNetworkEdge() = default;
};
class GetAppNetworkResponseBodyAppNetworkNamespace : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetAppNetworkResponseBodyAppNetworkNamespace() {}

  explicit GetAppNetworkResponseBodyAppNetworkNamespace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetAppNetworkResponseBodyAppNetworkNamespace() = default;
};
class GetAppNetworkResponseBodyAppNetworkNode : public Darabonba::Model {
public:
  shared_ptr<vector<string>> containerIds{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> type{};

  GetAppNetworkResponseBodyAppNetworkNode() {}

  explicit GetAppNetworkResponseBodyAppNetworkNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerIds) {
      res["ContainerIds"] = boost::any(*containerIds);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerIds") != m.end() && !m["ContainerIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ContainerIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ContainerIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      containerIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAppNetworkResponseBodyAppNetworkNode() = default;
};
class GetAppNetworkResponseBodyAppNetwork : public Darabonba::Model {
public:
  shared_ptr<vector<GetAppNetworkResponseBodyAppNetworkEdge>> edge{};
  shared_ptr<vector<GetAppNetworkResponseBodyAppNetworkNamespace>> namespace_{};
  shared_ptr<vector<GetAppNetworkResponseBodyAppNetworkNode>> node{};

  GetAppNetworkResponseBodyAppNetwork() {}

  explicit GetAppNetworkResponseBodyAppNetwork(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edge) {
      vector<boost::any> temp1;
      for(auto item1:*edge){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Edge"] = boost::any(temp1);
    }
    if (namespace_) {
      vector<boost::any> temp1;
      for(auto item1:*namespace_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Namespace"] = boost::any(temp1);
    }
    if (node) {
      vector<boost::any> temp1;
      for(auto item1:*node){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Node"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edge") != m.end() && !m["Edge"].empty()) {
      if (typeid(vector<boost::any>) == m["Edge"].type()) {
        vector<GetAppNetworkResponseBodyAppNetworkEdge> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Edge"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAppNetworkResponseBodyAppNetworkEdge model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        edge = make_shared<vector<GetAppNetworkResponseBodyAppNetworkEdge>>(expect1);
      }
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      if (typeid(vector<boost::any>) == m["Namespace"].type()) {
        vector<GetAppNetworkResponseBodyAppNetworkNamespace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Namespace"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAppNetworkResponseBodyAppNetworkNamespace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        namespace_ = make_shared<vector<GetAppNetworkResponseBodyAppNetworkNamespace>>(expect1);
      }
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(vector<boost::any>) == m["Node"].type()) {
        vector<GetAppNetworkResponseBodyAppNetworkNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Node"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAppNetworkResponseBodyAppNetworkNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        node = make_shared<vector<GetAppNetworkResponseBodyAppNetworkNode>>(expect1);
      }
    }
  }


  virtual ~GetAppNetworkResponseBodyAppNetwork() = default;
};
class GetAppNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAppNetworkResponseBodyAppNetwork> appNetwork{};
  shared_ptr<string> requestId{};

  GetAppNetworkResponseBody() {}

  explicit GetAppNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appNetwork) {
      res["AppNetwork"] = appNetwork ? boost::any(appNetwork->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppNetwork") != m.end() && !m["AppNetwork"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppNetwork"].type()) {
        GetAppNetworkResponseBodyAppNetwork model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppNetwork"]));
        appNetwork = make_shared<GetAppNetworkResponseBodyAppNetwork>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAppNetworkResponseBody() = default;
};
class GetAppNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAppNetworkResponseBody> body{};

  GetAppNetworkResponse() {}

  explicit GetAppNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAppNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAppNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~GetAppNetworkResponse() = default;
};
class GetAssetsPropertyDetailRequestSearchCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  GetAssetsPropertyDetailRequestSearchCriteriaList() {}

  explicit GetAssetsPropertyDetailRequestSearchCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAssetsPropertyDetailRequestSearchCriteriaList() = default;
};
class GetAssetsPropertyDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> itemName{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<vector<GetAssetsPropertyDetailRequestSearchCriteriaList>> searchCriteriaList{};
  shared_ptr<string> uuid{};

  GetAssetsPropertyDetailRequest() {}

  explicit GetAssetsPropertyDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (searchCriteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*searchCriteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchCriteriaList"] = boost::any(temp1);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SearchCriteriaList") != m.end() && !m["SearchCriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchCriteriaList"].type()) {
        vector<GetAssetsPropertyDetailRequestSearchCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchCriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAssetsPropertyDetailRequestSearchCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchCriteriaList = make_shared<vector<GetAssetsPropertyDetailRequestSearchCriteriaList>>(expect1);
      }
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~GetAssetsPropertyDetailRequest() = default;
};
class GetAssetsPropertyDetailResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetAssetsPropertyDetailResponseBodyPageInfo() {}

  explicit GetAssetsPropertyDetailResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetAssetsPropertyDetailResponseBodyPageInfo() = default;
};
class GetAssetsPropertyDetailResponseBodyPropertys : public Darabonba::Model {
public:
  shared_ptr<string> containerName{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> domain{};
  shared_ptr<string> filepath{};
  shared_ptr<string> imageName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> ip{};
  shared_ptr<string> listenProtocol{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> path{};
  shared_ptr<string> pathMode{};
  shared_ptr<string> pid{};
  shared_ptr<string> port{};
  shared_ptr<long> processStarted{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serverType{};
  shared_ptr<long> size{};
  shared_ptr<long> usedByCount{};
  shared_ptr<string> user{};
  shared_ptr<string> uuid{};
  shared_ptr<string> webPath{};

  GetAssetsPropertyDetailResponseBodyPropertys() {}

  explicit GetAssetsPropertyDetailResponseBodyPropertys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containerName) {
      res["ContainerName"] = boost::any(*containerName);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (filepath) {
      res["Filepath"] = boost::any(*filepath);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (listenProtocol) {
      res["ListenProtocol"] = boost::any(*listenProtocol);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pathMode) {
      res["PathMode"] = boost::any(*pathMode);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (processStarted) {
      res["ProcessStarted"] = boost::any(*processStarted);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serverType) {
      res["ServerType"] = boost::any(*serverType);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (usedByCount) {
      res["UsedByCount"] = boost::any(*usedByCount);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (webPath) {
      res["WebPath"] = boost::any(*webPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainerName") != m.end() && !m["ContainerName"].empty()) {
      containerName = make_shared<string>(boost::any_cast<string>(m["ContainerName"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Filepath") != m.end() && !m["Filepath"].empty()) {
      filepath = make_shared<string>(boost::any_cast<string>(m["Filepath"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("ListenProtocol") != m.end() && !m["ListenProtocol"].empty()) {
      listenProtocol = make_shared<string>(boost::any_cast<string>(m["ListenProtocol"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PathMode") != m.end() && !m["PathMode"].empty()) {
      pathMode = make_shared<string>(boost::any_cast<string>(m["PathMode"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("ProcessStarted") != m.end() && !m["ProcessStarted"].empty()) {
      processStarted = make_shared<long>(boost::any_cast<long>(m["ProcessStarted"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServerType") != m.end() && !m["ServerType"].empty()) {
      serverType = make_shared<string>(boost::any_cast<string>(m["ServerType"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("UsedByCount") != m.end() && !m["UsedByCount"].empty()) {
      usedByCount = make_shared<long>(boost::any_cast<long>(m["UsedByCount"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("WebPath") != m.end() && !m["WebPath"].empty()) {
      webPath = make_shared<string>(boost::any_cast<string>(m["WebPath"]));
    }
  }


  virtual ~GetAssetsPropertyDetailResponseBodyPropertys() = default;
};
class GetAssetsPropertyDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAssetsPropertyDetailResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<GetAssetsPropertyDetailResponseBodyPropertys>> propertys{};
  shared_ptr<string> requestId{};

  GetAssetsPropertyDetailResponseBody() {}

  explicit GetAssetsPropertyDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertys) {
      vector<boost::any> temp1;
      for(auto item1:*propertys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Propertys"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        GetAssetsPropertyDetailResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<GetAssetsPropertyDetailResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("Propertys") != m.end() && !m["Propertys"].empty()) {
      if (typeid(vector<boost::any>) == m["Propertys"].type()) {
        vector<GetAssetsPropertyDetailResponseBodyPropertys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Propertys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAssetsPropertyDetailResponseBodyPropertys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertys = make_shared<vector<GetAssetsPropertyDetailResponseBodyPropertys>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAssetsPropertyDetailResponseBody() = default;
};
class GetAssetsPropertyDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAssetsPropertyDetailResponseBody> body{};

  GetAssetsPropertyDetailResponse() {}

  explicit GetAssetsPropertyDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAssetsPropertyDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAssetsPropertyDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetAssetsPropertyDetailResponse() = default;
};
class GetAssetsPropertyItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<long> currentPage{};
  shared_ptr<bool> forceFlush{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchInfo{};
  shared_ptr<string> searchItem{};

  GetAssetsPropertyItemRequest() {}

  explicit GetAssetsPropertyItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (forceFlush) {
      res["ForceFlush"] = boost::any(*forceFlush);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchInfo) {
      res["SearchInfo"] = boost::any(*searchInfo);
    }
    if (searchItem) {
      res["SearchItem"] = boost::any(*searchItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ForceFlush") != m.end() && !m["ForceFlush"].empty()) {
      forceFlush = make_shared<bool>(boost::any_cast<bool>(m["ForceFlush"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchInfo") != m.end() && !m["SearchInfo"].empty()) {
      searchInfo = make_shared<string>(boost::any_cast<string>(m["SearchInfo"]));
    }
    if (m.find("SearchItem") != m.end() && !m["SearchItem"].empty()) {
      searchItem = make_shared<string>(boost::any_cast<string>(m["SearchItem"]));
    }
  }


  virtual ~GetAssetsPropertyItemRequest() = default;
};
class GetAssetsPropertyItemResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetAssetsPropertyItemResponseBodyPageInfo() {}

  explicit GetAssetsPropertyItemResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetAssetsPropertyItemResponseBodyPageInfo() = default;
};
class GetAssetsPropertyItemResponseBodyPropertyItems : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> domain{};
  shared_ptr<string> moduleName{};
  shared_ptr<string> path{};

  GetAssetsPropertyItemResponseBodyPropertyItems() {}

  explicit GetAssetsPropertyItemResponseBodyPropertyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~GetAssetsPropertyItemResponseBodyPropertyItems() = default;
};
class GetAssetsPropertyItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAssetsPropertyItemResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<GetAssetsPropertyItemResponseBodyPropertyItems>> propertyItems{};
  shared_ptr<string> requestId{};

  GetAssetsPropertyItemResponseBody() {}

  explicit GetAssetsPropertyItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (propertyItems) {
      vector<boost::any> temp1;
      for(auto item1:*propertyItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyItems"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        GetAssetsPropertyItemResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<GetAssetsPropertyItemResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PropertyItems") != m.end() && !m["PropertyItems"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyItems"].type()) {
        vector<GetAssetsPropertyItemResponseBodyPropertyItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAssetsPropertyItemResponseBodyPropertyItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyItems = make_shared<vector<GetAssetsPropertyItemResponseBodyPropertyItems>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAssetsPropertyItemResponseBody() = default;
};
class GetAssetsPropertyItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAssetsPropertyItemResponseBody> body{};

  GetAssetsPropertyItemResponse() {}

  explicit GetAssetsPropertyItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAssetsPropertyItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAssetsPropertyItemResponseBody>(model1);
      }
    }
  }


  virtual ~GetAssetsPropertyItemResponse() = default;
};
class GetBackupStorageCountResponseBodyBackupStorageCount : public Darabonba::Model {
public:
  shared_ptr<long> buyStorageByte{};
  shared_ptr<long> ecsUsageStorageByte{};
  shared_ptr<long> overflow{};
  shared_ptr<long> uniUsageStorageByte{};
  shared_ptr<long> usageStorageByte{};

  GetBackupStorageCountResponseBodyBackupStorageCount() {}

  explicit GetBackupStorageCountResponseBodyBackupStorageCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buyStorageByte) {
      res["BuyStorageByte"] = boost::any(*buyStorageByte);
    }
    if (ecsUsageStorageByte) {
      res["EcsUsageStorageByte"] = boost::any(*ecsUsageStorageByte);
    }
    if (overflow) {
      res["Overflow"] = boost::any(*overflow);
    }
    if (uniUsageStorageByte) {
      res["UniUsageStorageByte"] = boost::any(*uniUsageStorageByte);
    }
    if (usageStorageByte) {
      res["UsageStorageByte"] = boost::any(*usageStorageByte);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuyStorageByte") != m.end() && !m["BuyStorageByte"].empty()) {
      buyStorageByte = make_shared<long>(boost::any_cast<long>(m["BuyStorageByte"]));
    }
    if (m.find("EcsUsageStorageByte") != m.end() && !m["EcsUsageStorageByte"].empty()) {
      ecsUsageStorageByte = make_shared<long>(boost::any_cast<long>(m["EcsUsageStorageByte"]));
    }
    if (m.find("Overflow") != m.end() && !m["Overflow"].empty()) {
      overflow = make_shared<long>(boost::any_cast<long>(m["Overflow"]));
    }
    if (m.find("UniUsageStorageByte") != m.end() && !m["UniUsageStorageByte"].empty()) {
      uniUsageStorageByte = make_shared<long>(boost::any_cast<long>(m["UniUsageStorageByte"]));
    }
    if (m.find("UsageStorageByte") != m.end() && !m["UsageStorageByte"].empty()) {
      usageStorageByte = make_shared<long>(boost::any_cast<long>(m["UsageStorageByte"]));
    }
  }


  virtual ~GetBackupStorageCountResponseBodyBackupStorageCount() = default;
};
class GetBackupStorageCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetBackupStorageCountResponseBodyBackupStorageCount> backupStorageCount{};
  shared_ptr<string> requestId{};

  GetBackupStorageCountResponseBody() {}

  explicit GetBackupStorageCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupStorageCount) {
      res["BackupStorageCount"] = backupStorageCount ? boost::any(backupStorageCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupStorageCount") != m.end() && !m["BackupStorageCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackupStorageCount"].type()) {
        GetBackupStorageCountResponseBodyBackupStorageCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackupStorageCount"]));
        backupStorageCount = make_shared<GetBackupStorageCountResponseBodyBackupStorageCount>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetBackupStorageCountResponseBody() = default;
};
class GetBackupStorageCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBackupStorageCountResponseBody> body{};

  GetBackupStorageCountResponse() {}

  explicit GetBackupStorageCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBackupStorageCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBackupStorageCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetBackupStorageCountResponse() = default;
};
class GetCheckConfigResponseBodyStandards : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> showName{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetCheckConfigResponseBodyStandards() {}

  explicit GetCheckConfigResponseBodyStandards(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCheckConfigResponseBodyStandards() = default;
};
class GetCheckConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> cycleDays{};
  shared_ptr<long> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetCheckConfigResponseBodyStandards>> standards{};
  shared_ptr<long> startTime{};

  GetCheckConfigResponseBody() {}

  explicit GetCheckConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDays) {
      res["CycleDays"] = boost::any(*cycleDays);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (standards) {
      vector<boost::any> temp1;
      for(auto item1:*standards){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Standards"] = boost::any(temp1);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDays") != m.end() && !m["CycleDays"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CycleDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CycleDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      cycleDays = make_shared<vector<long>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Standards") != m.end() && !m["Standards"].empty()) {
      if (typeid(vector<boost::any>) == m["Standards"].type()) {
        vector<GetCheckConfigResponseBodyStandards> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Standards"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCheckConfigResponseBodyStandards model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        standards = make_shared<vector<GetCheckConfigResponseBodyStandards>>(expect1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetCheckConfigResponseBody() = default;
};
class GetCheckConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCheckConfigResponseBody> body{};

  GetCheckConfigResponse() {}

  explicit GetCheckConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCheckConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCheckConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetCheckConfigResponse() = default;
};
class GetCheckDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<string> lang{};
  shared_ptr<string> regionId{};

  GetCheckDetailRequest() {}

  explicit GetCheckDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetCheckDetailRequest() = default;
};
class GetCheckDetailResponseBodyAssistInfo : public Darabonba::Model {
public:
  shared_ptr<string> link{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetCheckDetailResponseBodyAssistInfo() {}

  explicit GetCheckDetailResponseBodyAssistInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetCheckDetailResponseBodyAssistInfo() = default;
};
class GetCheckDetailResponseBodyCustomConfigs : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> name{};
  shared_ptr<string> showName{};
  shared_ptr<string> typeDefine{};
  shared_ptr<string> value{};

  GetCheckDetailResponseBodyCustomConfigs() {}

  explicit GetCheckDetailResponseBodyCustomConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (typeDefine) {
      res["TypeDefine"] = boost::any(*typeDefine);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("TypeDefine") != m.end() && !m["TypeDefine"].empty()) {
      typeDefine = make_shared<string>(boost::any_cast<string>(m["TypeDefine"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetCheckDetailResponseBodyCustomConfigs() = default;
};
class GetCheckDetailResponseBodyDescription : public Darabonba::Model {
public:
  shared_ptr<string> link{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetCheckDetailResponseBodyDescription() {}

  explicit GetCheckDetailResponseBodyDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetCheckDetailResponseBodyDescription() = default;
};
class GetCheckDetailResponseBodySolution : public Darabonba::Model {
public:
  shared_ptr<string> link{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  GetCheckDetailResponseBodySolution() {}

  explicit GetCheckDetailResponseBodySolution(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetCheckDetailResponseBodySolution() = default;
};
class GetCheckDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCheckDetailResponseBodyAssistInfo> assistInfo{};
  shared_ptr<vector<GetCheckDetailResponseBodyCustomConfigs>> customConfigs{};
  shared_ptr<GetCheckDetailResponseBodyDescription> description{};
  shared_ptr<string> requestId{};
  shared_ptr<GetCheckDetailResponseBodySolution> solution{};

  GetCheckDetailResponseBody() {}

  explicit GetCheckDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assistInfo) {
      res["AssistInfo"] = assistInfo ? boost::any(assistInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*customConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomConfigs"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = description ? boost::any(description->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (solution) {
      res["Solution"] = solution ? boost::any(solution->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssistInfo") != m.end() && !m["AssistInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AssistInfo"].type()) {
        GetCheckDetailResponseBodyAssistInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AssistInfo"]));
        assistInfo = make_shared<GetCheckDetailResponseBodyAssistInfo>(model1);
      }
    }
    if (m.find("CustomConfigs") != m.end() && !m["CustomConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomConfigs"].type()) {
        vector<GetCheckDetailResponseBodyCustomConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCheckDetailResponseBodyCustomConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customConfigs = make_shared<vector<GetCheckDetailResponseBodyCustomConfigs>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      if (typeid(map<string, boost::any>) == m["Description"].type()) {
        GetCheckDetailResponseBodyDescription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Description"]));
        description = make_shared<GetCheckDetailResponseBodyDescription>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Solution") != m.end() && !m["Solution"].empty()) {
      if (typeid(map<string, boost::any>) == m["Solution"].type()) {
        GetCheckDetailResponseBodySolution model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Solution"]));
        solution = make_shared<GetCheckDetailResponseBodySolution>(model1);
      }
    }
  }


  virtual ~GetCheckDetailResponseBody() = default;
};
class GetCheckDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCheckDetailResponseBody> body{};

  GetCheckDetailResponse() {}

  explicit GetCheckDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCheckDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCheckDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetCheckDetailResponse() = default;
};
class GetCheckProcessRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  GetCheckProcessRequest() {}

  explicit GetCheckProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetCheckProcessRequest() = default;
};
class GetCheckProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> finishCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  GetCheckProcessResponseBody() {}

  explicit GetCheckProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finishCount) {
      res["FinishCount"] = boost::any(*finishCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinishCount") != m.end() && !m["FinishCount"].empty()) {
      finishCount = make_shared<long>(boost::any_cast<long>(m["FinishCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetCheckProcessResponseBody() = default;
};
class GetCheckProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCheckProcessResponseBody> body{};

  GetCheckProcessResponse() {}

  explicit GetCheckProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCheckProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCheckProcessResponseBody>(model1);
      }
    }
  }


  virtual ~GetCheckProcessResponse() = default;
};
class GetCheckRiskStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};

  GetCheckRiskStatisticsRequest() {}

  explicit GetCheckRiskStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetCheckRiskStatisticsRequest() = default;
};
class GetCheckRiskStatisticsResponseBodyDataSubStatistics : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<long> highWarningCount{};
  shared_ptr<long> lowWarningCount{};
  shared_ptr<long> mediumWarningCount{};
  shared_ptr<long> passCount{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> typeName_{};

  GetCheckRiskStatisticsResponseBodyDataSubStatistics() {}

  explicit GetCheckRiskStatisticsResponseBodyDataSubStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (highWarningCount) {
      res["HighWarningCount"] = boost::any(*highWarningCount);
    }
    if (lowWarningCount) {
      res["LowWarningCount"] = boost::any(*lowWarningCount);
    }
    if (mediumWarningCount) {
      res["MediumWarningCount"] = boost::any(*mediumWarningCount);
    }
    if (passCount) {
      res["PassCount"] = boost::any(*passCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("HighWarningCount") != m.end() && !m["HighWarningCount"].empty()) {
      highWarningCount = make_shared<long>(boost::any_cast<long>(m["HighWarningCount"]));
    }
    if (m.find("LowWarningCount") != m.end() && !m["LowWarningCount"].empty()) {
      lowWarningCount = make_shared<long>(boost::any_cast<long>(m["LowWarningCount"]));
    }
    if (m.find("MediumWarningCount") != m.end() && !m["MediumWarningCount"].empty()) {
      mediumWarningCount = make_shared<long>(boost::any_cast<long>(m["MediumWarningCount"]));
    }
    if (m.find("PassCount") != m.end() && !m["PassCount"].empty()) {
      passCount = make_shared<long>(boost::any_cast<long>(m["PassCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~GetCheckRiskStatisticsResponseBodyDataSubStatistics() = default;
};
class GetCheckRiskStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> highWarningCount{};
  shared_ptr<long> lowWarningCount{};
  shared_ptr<long> mediumWarningCount{};
  shared_ptr<long> passCount{};
  shared_ptr<string> sceneName{};
  shared_ptr<vector<GetCheckRiskStatisticsResponseBodyDataSubStatistics>> subStatistics{};
  shared_ptr<long> totalCount{};

  GetCheckRiskStatisticsResponseBodyData() {}

  explicit GetCheckRiskStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (highWarningCount) {
      res["HighWarningCount"] = boost::any(*highWarningCount);
    }
    if (lowWarningCount) {
      res["LowWarningCount"] = boost::any(*lowWarningCount);
    }
    if (mediumWarningCount) {
      res["MediumWarningCount"] = boost::any(*mediumWarningCount);
    }
    if (passCount) {
      res["PassCount"] = boost::any(*passCount);
    }
    if (sceneName) {
      res["SceneName"] = boost::any(*sceneName);
    }
    if (subStatistics) {
      vector<boost::any> temp1;
      for(auto item1:*subStatistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubStatistics"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HighWarningCount") != m.end() && !m["HighWarningCount"].empty()) {
      highWarningCount = make_shared<long>(boost::any_cast<long>(m["HighWarningCount"]));
    }
    if (m.find("LowWarningCount") != m.end() && !m["LowWarningCount"].empty()) {
      lowWarningCount = make_shared<long>(boost::any_cast<long>(m["LowWarningCount"]));
    }
    if (m.find("MediumWarningCount") != m.end() && !m["MediumWarningCount"].empty()) {
      mediumWarningCount = make_shared<long>(boost::any_cast<long>(m["MediumWarningCount"]));
    }
    if (m.find("PassCount") != m.end() && !m["PassCount"].empty()) {
      passCount = make_shared<long>(boost::any_cast<long>(m["PassCount"]));
    }
    if (m.find("SceneName") != m.end() && !m["SceneName"].empty()) {
      sceneName = make_shared<string>(boost::any_cast<string>(m["SceneName"]));
    }
    if (m.find("SubStatistics") != m.end() && !m["SubStatistics"].empty()) {
      if (typeid(vector<boost::any>) == m["SubStatistics"].type()) {
        vector<GetCheckRiskStatisticsResponseBodyDataSubStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubStatistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCheckRiskStatisticsResponseBodyDataSubStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subStatistics = make_shared<vector<GetCheckRiskStatisticsResponseBodyDataSubStatistics>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetCheckRiskStatisticsResponseBodyData() = default;
};
class GetCheckRiskStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<GetCheckRiskStatisticsResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  GetCheckRiskStatisticsResponseBody() {}

  explicit GetCheckRiskStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetCheckRiskStatisticsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCheckRiskStatisticsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetCheckRiskStatisticsResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCheckRiskStatisticsResponseBody() = default;
};
class GetCheckRiskStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCheckRiskStatisticsResponseBody> body{};

  GetCheckRiskStatisticsResponse() {}

  explicit GetCheckRiskStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCheckRiskStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCheckRiskStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetCheckRiskStatisticsResponse() = default;
};
class GetCheckSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> resourceDirectoryAccountId{};

  GetCheckSummaryRequest() {}

  explicit GetCheckSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceDirectoryAccountId) {
      res["ResourceDirectoryAccountId"] = boost::any(*resourceDirectoryAccountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceDirectoryAccountId") != m.end() && !m["ResourceDirectoryAccountId"].empty()) {
      resourceDirectoryAccountId = make_shared<string>(boost::any_cast<string>(m["ResourceDirectoryAccountId"]));
    }
  }


  virtual ~GetCheckSummaryRequest() = default;
};
class GetCheckSummaryResponseBodySummarysStandards : public Darabonba::Model {
public:
  shared_ptr<long> failCount{};
  shared_ptr<long> id{};
  shared_ptr<long> passCount{};
  shared_ptr<long> riskLevelHighCount{};
  shared_ptr<long> riskLevelLowCount{};
  shared_ptr<long> riskLevelMediumCount{};
  shared_ptr<string> showName{};

  GetCheckSummaryResponseBodySummarysStandards() {}

  explicit GetCheckSummaryResponseBodySummarysStandards(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (passCount) {
      res["PassCount"] = boost::any(*passCount);
    }
    if (riskLevelHighCount) {
      res["RiskLevelHighCount"] = boost::any(*riskLevelHighCount);
    }
    if (riskLevelLowCount) {
      res["RiskLevelLowCount"] = boost::any(*riskLevelLowCount);
    }
    if (riskLevelMediumCount) {
      res["RiskLevelMediumCount"] = boost::any(*riskLevelMediumCount);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PassCount") != m.end() && !m["PassCount"].empty()) {
      passCount = make_shared<long>(boost::any_cast<long>(m["PassCount"]));
    }
    if (m.find("RiskLevelHighCount") != m.end() && !m["RiskLevelHighCount"].empty()) {
      riskLevelHighCount = make_shared<long>(boost::any_cast<long>(m["RiskLevelHighCount"]));
    }
    if (m.find("RiskLevelLowCount") != m.end() && !m["RiskLevelLowCount"].empty()) {
      riskLevelLowCount = make_shared<long>(boost::any_cast<long>(m["RiskLevelLowCount"]));
    }
    if (m.find("RiskLevelMediumCount") != m.end() && !m["RiskLevelMediumCount"].empty()) {
      riskLevelMediumCount = make_shared<long>(boost::any_cast<long>(m["RiskLevelMediumCount"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
  }


  virtual ~GetCheckSummaryResponseBodySummarysStandards() = default;
};
class GetCheckSummaryResponseBodySummarys : public Darabonba::Model {
public:
  shared_ptr<long> failCount{};
  shared_ptr<long> passCount{};
  shared_ptr<vector<GetCheckSummaryResponseBodySummarysStandards>> standards{};
  shared_ptr<string> type{};

  GetCheckSummaryResponseBodySummarys() {}

  explicit GetCheckSummaryResponseBodySummarys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (passCount) {
      res["PassCount"] = boost::any(*passCount);
    }
    if (standards) {
      vector<boost::any> temp1;
      for(auto item1:*standards){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Standards"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("PassCount") != m.end() && !m["PassCount"].empty()) {
      passCount = make_shared<long>(boost::any_cast<long>(m["PassCount"]));
    }
    if (m.find("Standards") != m.end() && !m["Standards"].empty()) {
      if (typeid(vector<boost::any>) == m["Standards"].type()) {
        vector<GetCheckSummaryResponseBodySummarysStandards> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Standards"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCheckSummaryResponseBodySummarysStandards model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        standards = make_shared<vector<GetCheckSummaryResponseBodySummarysStandards>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCheckSummaryResponseBodySummarys() = default;
};
class GetCheckSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetCheckSummaryResponseBodySummarys>> summarys{};

  GetCheckSummaryResponseBody() {}

  explicit GetCheckSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (summarys) {
      vector<boost::any> temp1;
      for(auto item1:*summarys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summarys"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Summarys") != m.end() && !m["Summarys"].empty()) {
      if (typeid(vector<boost::any>) == m["Summarys"].type()) {
        vector<GetCheckSummaryResponseBodySummarys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summarys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCheckSummaryResponseBodySummarys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summarys = make_shared<vector<GetCheckSummaryResponseBodySummarys>>(expect1);
      }
    }
  }


  virtual ~GetCheckSummaryResponseBody() = default;
};
class GetCheckSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCheckSummaryResponseBody> body{};

  GetCheckSummaryResponse() {}

  explicit GetCheckSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCheckSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCheckSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetCheckSummaryResponse() = default;
};
class GetClientUserDefineRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  GetClientUserDefineRuleRequest() {}

  explicit GetClientUserDefineRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetClientUserDefineRuleRequest() = default;
};
class GetClientUserDefineRuleResponseBodyUserDefineRuleDetail : public Darabonba::Model {
public:
  shared_ptr<string> actionType{};
  shared_ptr<string> cmdline{};
  shared_ptr<string> filePath{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> IP{};
  shared_ptr<long> id{};
  shared_ptr<string> md5List{};
  shared_ptr<string> name{};
  shared_ptr<string> newFilePath{};
  shared_ptr<string> parentCmdline{};
  shared_ptr<string> parentProcPath{};
  shared_ptr<string> platform{};
  shared_ptr<long> port{};
  shared_ptr<string> portStr{};
  shared_ptr<string> procPath{};
  shared_ptr<string> registryContent{};
  shared_ptr<string> registryKey{};
  shared_ptr<long> type{};

  GetClientUserDefineRuleResponseBodyUserDefineRuleDetail() {}

  explicit GetClientUserDefineRuleResponseBodyUserDefineRuleDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (cmdline) {
      res["Cmdline"] = boost::any(*cmdline);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (md5List) {
      res["Md5List"] = boost::any(*md5List);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newFilePath) {
      res["NewFilePath"] = boost::any(*newFilePath);
    }
    if (parentCmdline) {
      res["ParentCmdline"] = boost::any(*parentCmdline);
    }
    if (parentProcPath) {
      res["ParentProcPath"] = boost::any(*parentProcPath);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (portStr) {
      res["PortStr"] = boost::any(*portStr);
    }
    if (procPath) {
      res["ProcPath"] = boost::any(*procPath);
    }
    if (registryContent) {
      res["RegistryContent"] = boost::any(*registryContent);
    }
    if (registryKey) {
      res["RegistryKey"] = boost::any(*registryKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["ActionType"]));
    }
    if (m.find("Cmdline") != m.end() && !m["Cmdline"].empty()) {
      cmdline = make_shared<string>(boost::any_cast<string>(m["Cmdline"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Md5List") != m.end() && !m["Md5List"].empty()) {
      md5List = make_shared<string>(boost::any_cast<string>(m["Md5List"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewFilePath") != m.end() && !m["NewFilePath"].empty()) {
      newFilePath = make_shared<string>(boost::any_cast<string>(m["NewFilePath"]));
    }
    if (m.find("ParentCmdline") != m.end() && !m["ParentCmdline"].empty()) {
      parentCmdline = make_shared<string>(boost::any_cast<string>(m["ParentCmdline"]));
    }
    if (m.find("ParentProcPath") != m.end() && !m["ParentProcPath"].empty()) {
      parentProcPath = make_shared<string>(boost::any_cast<string>(m["ParentProcPath"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("PortStr") != m.end() && !m["PortStr"].empty()) {
      portStr = make_shared<string>(boost::any_cast<string>(m["PortStr"]));
    }
    if (m.find("ProcPath") != m.end() && !m["ProcPath"].empty()) {
      procPath = make_shared<string>(boost::any_cast<string>(m["ProcPath"]));
    }
    if (m.find("RegistryContent") != m.end() && !m["RegistryContent"].empty()) {
      registryContent = make_shared<string>(boost::any_cast<string>(m["RegistryContent"]));
    }
    if (m.find("RegistryKey") != m.end() && !m["RegistryKey"].empty()) {
      registryKey = make_shared<string>(boost::any_cast<string>(m["RegistryKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~GetClientUserDefineRuleResponseBodyUserDefineRuleDetail() = default;
};
class GetClientUserDefineRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetClientUserDefineRuleResponseBodyUserDefineRuleDetail> userDefineRuleDetail{};

  GetClientUserDefineRuleResponseBody() {}

  explicit GetClientUserDefineRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userDefineRuleDetail) {
      res["UserDefineRuleDetail"] = userDefineRuleDetail ? boost::any(userDefineRuleDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserDefineRuleDetail") != m.end() && !m["UserDefineRuleDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserDefineRuleDetail"].type()) {
        GetClientUserDefineRuleResponseBodyUserDefineRuleDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserDefineRuleDetail"]));
        userDefineRuleDetail = make_shared<GetClientUserDefineRuleResponseBodyUserDefineRuleDetail>(model1);
      }
    }
  }


  virtual ~GetClientUserDefineRuleResponseBody() = default;
};
class GetClientUserDefineRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClientUserDefineRuleResponseBody> body{};

  GetClientUserDefineRuleResponse() {}

  explicit GetClientUserDefineRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClientUserDefineRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClientUserDefineRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetClientUserDefineRuleResponse() = default;
};
class GetCloudAssetCriteriaRequestCloudAssetTypes : public Darabonba::Model {
public:
  shared_ptr<long> assetSubType{};
  shared_ptr<long> assetType{};

  GetCloudAssetCriteriaRequestCloudAssetTypes() {}

  explicit GetCloudAssetCriteriaRequestCloudAssetTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetSubType) {
      res["AssetSubType"] = boost::any(*assetSubType);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetSubType") != m.end() && !m["AssetSubType"].empty()) {
      assetSubType = make_shared<long>(boost::any_cast<long>(m["AssetSubType"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<long>(boost::any_cast<long>(m["AssetType"]));
    }
  }


  virtual ~GetCloudAssetCriteriaRequestCloudAssetTypes() = default;
};
class GetCloudAssetCriteriaRequest : public Darabonba::Model {
public:
  shared_ptr<vector<GetCloudAssetCriteriaRequestCloudAssetTypes>> cloudAssetTypes{};
  shared_ptr<string> value{};

  GetCloudAssetCriteriaRequest() {}

  explicit GetCloudAssetCriteriaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudAssetTypes) {
      vector<boost::any> temp1;
      for(auto item1:*cloudAssetTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudAssetTypes"] = boost::any(temp1);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudAssetTypes") != m.end() && !m["CloudAssetTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudAssetTypes"].type()) {
        vector<GetCloudAssetCriteriaRequestCloudAssetTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudAssetTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCloudAssetCriteriaRequestCloudAssetTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudAssetTypes = make_shared<vector<GetCloudAssetCriteriaRequestCloudAssetTypes>>(expect1);
      }
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetCloudAssetCriteriaRequest() = default;
};
class GetCloudAssetCriteriaResponseBodyCriteriaList : public Darabonba::Model {
public:
  shared_ptr<string> multiValues{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> values{};

  GetCloudAssetCriteriaResponseBodyCriteriaList() {}

  explicit GetCloudAssetCriteriaResponseBodyCriteriaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (multiValues) {
      res["MultiValues"] = boost::any(*multiValues);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MultiValues") != m.end() && !m["MultiValues"].empty()) {
      multiValues = make_shared<string>(boost::any_cast<string>(m["MultiValues"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<string>(boost::any_cast<string>(m["Values"]));
    }
  }


  virtual ~GetCloudAssetCriteriaResponseBodyCriteriaList() = default;
};
class GetCloudAssetCriteriaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetCloudAssetCriteriaResponseBodyCriteriaList>> criteriaList{};
  shared_ptr<string> requestId{};

  GetCloudAssetCriteriaResponseBody() {}

  explicit GetCloudAssetCriteriaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteriaList) {
      vector<boost::any> temp1;
      for(auto item1:*criteriaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CriteriaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CriteriaList") != m.end() && !m["CriteriaList"].empty()) {
      if (typeid(vector<boost::any>) == m["CriteriaList"].type()) {
        vector<GetCloudAssetCriteriaResponseBodyCriteriaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CriteriaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCloudAssetCriteriaResponseBodyCriteriaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        criteriaList = make_shared<vector<GetCloudAssetCriteriaResponseBodyCriteriaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCloudAssetCriteriaResponseBody() = default;
};
class GetCloudAssetCriteriaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCloudAssetCriteriaResponseBody> body{};

  GetCloudAssetCriteriaResponse() {}

  explicit GetCloudAssetCriteriaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCloudAssetCriteriaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCloudAssetCriteriaResponseBody>(model1);
      }
    }
  }


  virtual ~GetCloudAssetCriteriaResponse() = default;
};
class GetCloudAssetDetailRequestCloudAssetInstances : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  GetCloudAssetDetailRequestCloudAssetInstances() {}

  explicit GetCloudAssetDetailRequestCloudAssetInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetCloudAssetDetailRequestCloudAssetInstances() = default;
};
class GetCloudAssetDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> assetSubType{};
  shared_ptr<long> assetType{};
  shared_ptr<vector<GetCloudAssetDetailRequestCloudAssetInstances>> cloudAssetInstances{};
  shared_ptr<long> vendor{};

  GetCloudAssetDetailRequest() {}

  explicit GetCloudAssetDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetSubType) {
      res["AssetSubType"] = boost::any(*assetSubType);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (cloudAssetInstances) {
      vector<boost::any> temp1;
      for(auto item1:*cloudAssetInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudAssetInstances"] = boost::any(temp1);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetSubType") != m.end() && !m["AssetSubType"].empty()) {
      assetSubType = make_shared<long>(boost::any_cast<long>(m["AssetSubType"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<long>(boost::any_cast<long>(m["AssetType"]));
    }
    if (m.find("CloudAssetInstances") != m.end() && !m["CloudAssetInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudAssetInstances"].type()) {
        vector<GetCloudAssetDetailRequestCloudAssetInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudAssetInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCloudAssetDetailRequestCloudAssetInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudAssetInstances = make_shared<vector<GetCloudAssetDetailRequestCloudAssetInstances>>(expect1);
      }
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<long>(boost::any_cast<long>(m["Vendor"]));
    }
  }


  virtual ~GetCloudAssetDetailRequest() = default;
};
class GetCloudAssetDetailResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<long> assetSubType{};
  shared_ptr<string> assetSubTypeName{};
  shared_ptr<long> assetType{};
  shared_ptr<string> assetTypeName{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> detailLink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> riskStatus{};
  shared_ptr<string> securityInfo{};
  shared_ptr<long> vendor{};

  GetCloudAssetDetailResponseBodyInstances() {}

  explicit GetCloudAssetDetailResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (assetSubType) {
      res["AssetSubType"] = boost::any(*assetSubType);
    }
    if (assetSubTypeName) {
      res["AssetSubTypeName"] = boost::any(*assetSubTypeName);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (assetTypeName) {
      res["AssetTypeName"] = boost::any(*assetTypeName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (detailLink) {
      res["DetailLink"] = boost::any(*detailLink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (securityInfo) {
      res["SecurityInfo"] = boost::any(*securityInfo);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("AssetSubType") != m.end() && !m["AssetSubType"].empty()) {
      assetSubType = make_shared<long>(boost::any_cast<long>(m["AssetSubType"]));
    }
    if (m.find("AssetSubTypeName") != m.end() && !m["AssetSubTypeName"].empty()) {
      assetSubTypeName = make_shared<string>(boost::any_cast<string>(m["AssetSubTypeName"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<long>(boost::any_cast<long>(m["AssetType"]));
    }
    if (m.find("AssetTypeName") != m.end() && !m["AssetTypeName"].empty()) {
      assetTypeName = make_shared<string>(boost::any_cast<string>(m["AssetTypeName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("DetailLink") != m.end() && !m["DetailLink"].empty()) {
      detailLink = make_shared<string>(boost::any_cast<string>(m["DetailLink"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("SecurityInfo") != m.end() && !m["SecurityInfo"].empty()) {
      securityInfo = make_shared<string>(boost::any_cast<string>(m["SecurityInfo"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<long>(boost::any_cast<long>(m["Vendor"]));
    }
  }


  virtual ~GetCloudAssetDetailResponseBodyInstances() = default;
};
class GetCloudAssetDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<GetCloudAssetDetailResponseBodyInstances>> instances{};
  shared_ptr<string> requestId{};

  GetCloudAssetDetailResponseBody() {}

  explicit GetCloudAssetDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<GetCloudAssetDetailResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCloudAssetDetailResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<GetCloudAssetDetailResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCloudAssetDetailResponseBody() = default;
};
class GetCloudAssetDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCloudAssetDetailResponseBody> body{};

  GetCloudAssetDetailResponse() {}

  explicit GetCloudAssetDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCloudAssetDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCloudAssetDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetCloudAssetDetailResponse() = default;
};
class GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas : public Darabonba::Model {
public:
  shared_ptr<long> assetSubType{};
  shared_ptr<long> assetType{};
  shared_ptr<long> instanceCount{};
  shared_ptr<long> instanceRiskCount{};

  GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas() {}

  explicit GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetSubType) {
      res["AssetSubType"] = boost::any(*assetSubType);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceRiskCount) {
      res["InstanceRiskCount"] = boost::any(*instanceRiskCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetSubType") != m.end() && !m["AssetSubType"].empty()) {
      assetSubType = make_shared<long>(boost::any_cast<long>(m["AssetSubType"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<long>(boost::any_cast<long>(m["AssetType"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InstanceRiskCount") != m.end() && !m["InstanceRiskCount"].empty()) {
      instanceRiskCount = make_shared<long>(boost::any_cast<long>(m["InstanceRiskCount"]));
    }
  }


  virtual ~GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas() = default;
};
class GetCloudAssetSummaryResponseBodyGroupedFields : public Darabonba::Model {
public:
  shared_ptr<vector<GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas>> cloudAssetSummaryMetas{};
  shared_ptr<long> instanceCountTotal{};
  shared_ptr<long> instanceRiskCountTotal{};

  GetCloudAssetSummaryResponseBodyGroupedFields() {}

  explicit GetCloudAssetSummaryResponseBodyGroupedFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudAssetSummaryMetas) {
      vector<boost::any> temp1;
      for(auto item1:*cloudAssetSummaryMetas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudAssetSummaryMetas"] = boost::any(temp1);
    }
    if (instanceCountTotal) {
      res["InstanceCountTotal"] = boost::any(*instanceCountTotal);
    }
    if (instanceRiskCountTotal) {
      res["InstanceRiskCountTotal"] = boost::any(*instanceRiskCountTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudAssetSummaryMetas") != m.end() && !m["CloudAssetSummaryMetas"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudAssetSummaryMetas"].type()) {
        vector<GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudAssetSummaryMetas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudAssetSummaryMetas = make_shared<vector<GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas>>(expect1);
      }
    }
    if (m.find("InstanceCountTotal") != m.end() && !m["InstanceCountTotal"].empty()) {
      instanceCountTotal = make_shared<long>(boost::any_cast<long>(m["InstanceCountTotal"]));
    }
    if (m.find("InstanceRiskCountTotal") != m.end() && !m["InstanceRiskCountTotal"].empty()) {
      instanceRiskCountTotal = make_shared<long>(boost::any_cast<long>(m["InstanceRiskCountTotal"]));
    }
  }


  virtual ~GetCloudAssetSummaryResponseBodyGroupedFields() = default;
};
class GetCloudAssetSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCloudAssetSummaryResponseBodyGroupedFields> groupedFields{};
  shared_ptr<string> requestId{};

  GetCloudAssetSummaryResponseBody() {}

  explicit GetCloudAssetSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupedFields) {
      res["GroupedFields"] = groupedFields ? boost::any(groupedFields->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupedFields") != m.end() && !m["GroupedFields"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupedFields"].type()) {
        GetCloudAssetSummaryResponseBodyGroupedFields model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupedFields"]));
        groupedFields = make_shared<GetCloudAssetSummaryResponseBodyGroupedFields>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCloudAssetSummaryResponseBody() = default;
};
class GetCloudAssetSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCloudAssetSummaryResponseBody> body{};

  GetCloudAssetSummaryResponse() {}

  explicit GetCloudAssetSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCloudAssetSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCloudAssetSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetCloudAssetSummaryResponse() = default;
};
class GetClusterCheckItemWarningStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  GetClusterCheckItemWarningStatisticsRequest() {}

  explicit GetClusterCheckItemWarningStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~GetClusterCheckItemWarningStatisticsRequest() = default;
};
class GetClusterCheckItemWarningStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> highWarningCount{};
  shared_ptr<long> lowWarningCount{};
  shared_ptr<long> mediumWarningCount{};

  GetClusterCheckItemWarningStatisticsResponseBodyData() {}

  explicit GetClusterCheckItemWarningStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (highWarningCount) {
      res["HighWarningCount"] = boost::any(*highWarningCount);
    }
    if (lowWarningCount) {
      res["LowWarningCount"] = boost::any(*lowWarningCount);
    }
    if (mediumWarningCount) {
      res["MediumWarningCount"] = boost::any(*mediumWarningCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HighWarningCount") != m.end() && !m["HighWarningCount"].empty()) {
      highWarningCount = make_shared<long>(boost::any_cast<long>(m["HighWarningCount"]));
    }
    if (m.find("LowWarningCount") != m.end() && !m["LowWarningCount"].empty()) {
      lowWarningCount = make_shared<long>(boost::any_cast<long>(m["LowWarningCount"]));
    }
    if (m.find("MediumWarningCount") != m.end() && !m["MediumWarningCount"].empty()) {
      mediumWarningCount = make_shared<long>(boost::any_cast<long>(m["MediumWarningCount"]));
    }
  }


  virtual ~GetClusterCheckItemWarningStatisticsResponseBodyData() = default;
};
class GetClusterCheckItemWarningStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetClusterCheckItemWarningStatisticsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetClusterCheckItemWarningStatisticsResponseBody() {}

  explicit GetClusterCheckItemWarningStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetClusterCheckItemWarningStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetClusterCheckItemWarningStatisticsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetClusterCheckItemWarningStatisticsResponseBody() = default;
};
class GetClusterCheckItemWarningStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterCheckItemWarningStatisticsResponseBody> body{};

  GetClusterCheckItemWarningStatisticsResponse() {}

  explicit GetClusterCheckItemWarningStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterCheckItemWarningStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterCheckItemWarningStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterCheckItemWarningStatisticsResponse() = default;
};
class GetClusterRuleSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  GetClusterRuleSummaryRequest() {}

  explicit GetClusterRuleSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~GetClusterRuleSummaryRequest() = default;
};
class GetClusterRuleSummaryResponseBodyClusterRuleSummary : public Darabonba::Model {
public:
  shared_ptr<long> closeRuleCount{};
  shared_ptr<long> interceptionCount7Day{};
  shared_ptr<long> interceptionSwitch{};
  shared_ptr<long> interceptionType{};
  shared_ptr<long> openRuleCount{};
  shared_ptr<long> ruleCount{};
  shared_ptr<long> suggestRuleCount{};

  GetClusterRuleSummaryResponseBodyClusterRuleSummary() {}

  explicit GetClusterRuleSummaryResponseBodyClusterRuleSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (closeRuleCount) {
      res["CloseRuleCount"] = boost::any(*closeRuleCount);
    }
    if (interceptionCount7Day) {
      res["InterceptionCount7Day"] = boost::any(*interceptionCount7Day);
    }
    if (interceptionSwitch) {
      res["InterceptionSwitch"] = boost::any(*interceptionSwitch);
    }
    if (interceptionType) {
      res["InterceptionType"] = boost::any(*interceptionType);
    }
    if (openRuleCount) {
      res["OpenRuleCount"] = boost::any(*openRuleCount);
    }
    if (ruleCount) {
      res["RuleCount"] = boost::any(*ruleCount);
    }
    if (suggestRuleCount) {
      res["SuggestRuleCount"] = boost::any(*suggestRuleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloseRuleCount") != m.end() && !m["CloseRuleCount"].empty()) {
      closeRuleCount = make_shared<long>(boost::any_cast<long>(m["CloseRuleCount"]));
    }
    if (m.find("InterceptionCount7Day") != m.end() && !m["InterceptionCount7Day"].empty()) {
      interceptionCount7Day = make_shared<long>(boost::any_cast<long>(m["InterceptionCount7Day"]));
    }
    if (m.find("InterceptionSwitch") != m.end() && !m["InterceptionSwitch"].empty()) {
      interceptionSwitch = make_shared<long>(boost::any_cast<long>(m["InterceptionSwitch"]));
    }
    if (m.find("InterceptionType") != m.end() && !m["InterceptionType"].empty()) {
      interceptionType = make_shared<long>(boost::any_cast<long>(m["InterceptionType"]));
    }
    if (m.find("OpenRuleCount") != m.end() && !m["OpenRuleCount"].empty()) {
      openRuleCount = make_shared<long>(boost::any_cast<long>(m["OpenRuleCount"]));
    }
    if (m.find("RuleCount") != m.end() && !m["RuleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["RuleCount"]));
    }
    if (m.find("SuggestRuleCount") != m.end() && !m["SuggestRuleCount"].empty()) {
      suggestRuleCount = make_shared<long>(boost::any_cast<long>(m["SuggestRuleCount"]));
    }
  }


  virtual ~GetClusterRuleSummaryResponseBodyClusterRuleSummary() = default;
};
class GetClusterRuleSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetClusterRuleSummaryResponseBodyClusterRuleSummary> clusterRuleSummary{};
  shared_ptr<string> requestId{};

  GetClusterRuleSummaryResponseBody() {}

  explicit GetClusterRuleSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterRuleSummary) {
      res["ClusterRuleSummary"] = clusterRuleSummary ? boost::any(clusterRuleSummary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterRuleSummary") != m.end() && !m["ClusterRuleSummary"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterRuleSummary"].type()) {
        GetClusterRuleSummaryResponseBodyClusterRuleSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterRuleSummary"]));
        clusterRuleSummary = make_shared<GetClusterRuleSummaryResponseBodyClusterRuleSummary>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetClusterRuleSummaryResponseBody() = default;
};
class GetClusterRuleSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterRuleSummaryResponseBody> body{};

  GetClusterRuleSummaryResponse() {}

  explicit GetClusterRuleSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterRuleSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterRuleSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterRuleSummaryResponse() = default;
};
class GetClusterSuspEventStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> from{};

  GetClusterSuspEventStatisticsRequest() {}

  explicit GetClusterSuspEventStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~GetClusterSuspEventStatisticsRequest() = default;
};
class GetClusterSuspEventStatisticsResponseBodySuspStatistics : public Darabonba::Model {
public:
  shared_ptr<long> remind{};
  shared_ptr<long> serious{};
  shared_ptr<long> suspicious{};

  GetClusterSuspEventStatisticsResponseBodySuspStatistics() {}

  explicit GetClusterSuspEventStatisticsResponseBodySuspStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remind) {
      res["Remind"] = boost::any(*remind);
    }
    if (serious) {
      res["Serious"] = boost::any(*serious);
    }
    if (suspicious) {
      res["Suspicious"] = boost::any(*suspicious);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Remind") != m.end() && !m["Remind"].empty()) {
      remind = make_shared<long>(boost::any_cast<long>(m["Remind"]));
    }
    if (m.find("Serious") != m.end() && !m["Serious"].empty()) {
      serious = make_shared<long>(boost::any_cast<long>(m["Serious"]));
    }
    if (m.find("Suspicious") != m.end() && !m["Suspicious"].empty()) {
      suspicious = make_shared<long>(boost::any_cast<long>(m["Suspicious"]));
    }
  }


  virtual ~GetClusterSuspEventStatisticsResponseBodySuspStatistics() = default;
};
class GetClusterSuspEventStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetClusterSuspEventStatisticsResponseBodySuspStatistics> suspStatistics{};

  GetClusterSuspEventStatisticsResponseBody() {}

  explicit GetClusterSuspEventStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (suspStatistics) {
      res["SuspStatistics"] = suspStatistics ? boost::any(suspStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuspStatistics") != m.end() && !m["SuspStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuspStatistics"].type()) {
        GetClusterSuspEventStatisticsResponseBodySuspStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuspStatistics"]));
        suspStatistics = make_shared<GetClusterSuspEventStatisticsResponseBodySuspStatistics>(model1);
      }
    }
  }


  virtual ~GetClusterSuspEventStatisticsResponseBody() = default;
};
class GetClusterSuspEventStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterSuspEventStatisticsResponseBody> body{};

  GetClusterSuspEventStatisticsResponse() {}

  explicit GetClusterSuspEventStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterSuspEventStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterSuspEventStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterSuspEventStatisticsResponse() = default;
};
class GetFileDetectApiInvokeInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> authCount{};
  shared_ptr<long> expire{};
  shared_ptr<long> flowRate{};
  shared_ptr<long> remainAuthCount{};
  shared_ptr<long> saleVersion{};
  shared_ptr<string> timeUnit{};

  GetFileDetectApiInvokeInfoResponseBodyData() {}

  explicit GetFileDetectApiInvokeInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authCount) {
      res["AuthCount"] = boost::any(*authCount);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (flowRate) {
      res["FlowRate"] = boost::any(*flowRate);
    }
    if (remainAuthCount) {
      res["RemainAuthCount"] = boost::any(*remainAuthCount);
    }
    if (saleVersion) {
      res["SaleVersion"] = boost::any(*saleVersion);
    }
    if (timeUnit) {
      res["TimeUnit"] = boost::any(*timeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthCount") != m.end() && !m["AuthCount"].empty()) {
      authCount = make_shared<long>(boost::any_cast<long>(m["AuthCount"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("FlowRate") != m.end() && !m["FlowRate"].empty()) {
      flowRate = make_shared<long>(boost::any_cast<long>(m["FlowRate"]));
    }
    if (m.find("RemainAuthCount") != m.end() && !m["RemainAuthCount"].empty()) {
      remainAuthCount = make_shared<long>(boost::any_cast<long>(m["RemainAuthCount"]));
    }
    if (m.find("SaleVersion") != m.end() && !m["SaleVersion"].empty()) {
      saleVersion = make_shared<long>(boost::any_cast<long>(m["SaleVersion"]));
    }
    if (m.find("TimeUnit") != m.end() && !m["TimeUnit"].empty()) {
      timeUnit = make_shared<string>(boost::any_cast<string>(m["TimeUnit"]));
    }
  }


  virtual ~GetFileDetectApiInvokeInfoResponseBodyData() = default;
};
class GetFileDetectApiInvokeInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetFileDetectApiInvokeInfoResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetFileDetectApiInvokeInfoResponseBody() {}

  explicit GetFileDetectApiInvokeInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFileDetectApiInvokeInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFileDetectApiInvokeInfoResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetFileDetectApiInvokeInfoResponseBody() = default;
};
class GetFileDetectApiInvokeInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFileDetectApiInvokeInfoResponseBody> body{};

  GetFileDetectApiInvokeInfoResponse() {}

  explicit GetFileDetectApiInvokeInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileDetectApiInvokeInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileDetectApiInvokeInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileDetectApiInvokeInfoResponse() = default;
};
class GetFileDetectResultRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> hashKeyList{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> type{};

  GetFileDetectResultRequest() {}

  explicit GetFileDetectResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hashKeyList) {
      res["HashKeyList"] = boost::any(*hashKeyList);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HashKeyList") != m.end() && !m["HashKeyList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HashKeyList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HashKeyList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hashKeyList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~GetFileDetectResultRequest() = default;
};
class GetFileDetectResultResponseBodyResultList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> ext{};
  shared_ptr<string> hashKey{};
  shared_ptr<string> message{};
  shared_ptr<long> result{};
  shared_ptr<long> score{};
  shared_ptr<string> virusType{};

  GetFileDetectResultResponseBodyResultList() {}

  explicit GetFileDetectResultResponseBodyResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ext) {
      res["Ext"] = boost::any(*ext);
    }
    if (hashKey) {
      res["HashKey"] = boost::any(*hashKey);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (virusType) {
      res["VirusType"] = boost::any(*virusType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Ext") != m.end() && !m["Ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["Ext"]));
    }
    if (m.find("HashKey") != m.end() && !m["HashKey"].empty()) {
      hashKey = make_shared<string>(boost::any_cast<string>(m["HashKey"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<long>(boost::any_cast<long>(m["Score"]));
    }
    if (m.find("VirusType") != m.end() && !m["VirusType"].empty()) {
      virusType = make_shared<string>(boost::any_cast<string>(m["VirusType"]));
    }
  }


  virtual ~GetFileDetectResultResponseBodyResultList() = default;
};
class GetFileDetectResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetFileDetectResultResponseBodyResultList>> resultList{};

  GetFileDetectResultResponseBody() {}

  explicit GetFileDetectResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultList) {
      vector<boost::any> temp1;
      for(auto item1:*resultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResultList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResultList"].type()) {
        vector<GetFileDetectResultResponseBodyResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileDetectResultResponseBodyResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultList = make_shared<vector<GetFileDetectResultResponseBodyResultList>>(expect1);
      }
    }
  }


  virtual ~GetFileDetectResultResponseBody() = default;
};
class GetFileDetectResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFileDetectResultResponseBody> body{};

  GetFileDetectResultResponse() {}

  explicit GetFileDetectResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileDetectResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileDetectResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileDetectResultResponse() = default;
};
class GetHoneypotNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> nodeId{};

  GetHoneypotNodeRequest() {}

  explicit GetHoneypotNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~GetHoneypotNodeRequest() = default;
};
class GetHoneypotNodeResponseBodyHoneypotNode : public Darabonba::Model {
public:
  shared_ptr<bool> allowHoneypotAccessInternet{};
  shared_ptr<string> createTime{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<long> honeypotTotalCount{};
  shared_ptr<long> honeypotUsedCount{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeIp{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> probeTotalCount{};
  shared_ptr<long> probeUsedCount{};
  shared_ptr<vector<string>> securityGroupProbeIpList{};
  shared_ptr<long> totalStatus{};
  shared_ptr<bool> upgradeAvailable{};

  GetHoneypotNodeResponseBodyHoneypotNode() {}

  explicit GetHoneypotNodeResponseBodyHoneypotNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowHoneypotAccessInternet) {
      res["AllowHoneypotAccessInternet"] = boost::any(*allowHoneypotAccessInternet);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (honeypotTotalCount) {
      res["HoneypotTotalCount"] = boost::any(*honeypotTotalCount);
    }
    if (honeypotUsedCount) {
      res["HoneypotUsedCount"] = boost::any(*honeypotUsedCount);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (probeTotalCount) {
      res["ProbeTotalCount"] = boost::any(*probeTotalCount);
    }
    if (probeUsedCount) {
      res["ProbeUsedCount"] = boost::any(*probeUsedCount);
    }
    if (securityGroupProbeIpList) {
      res["SecurityGroupProbeIpList"] = boost::any(*securityGroupProbeIpList);
    }
    if (totalStatus) {
      res["TotalStatus"] = boost::any(*totalStatus);
    }
    if (upgradeAvailable) {
      res["UpgradeAvailable"] = boost::any(*upgradeAvailable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowHoneypotAccessInternet") != m.end() && !m["AllowHoneypotAccessInternet"].empty()) {
      allowHoneypotAccessInternet = make_shared<bool>(boost::any_cast<bool>(m["AllowHoneypotAccessInternet"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("HoneypotTotalCount") != m.end() && !m["HoneypotTotalCount"].empty()) {
      honeypotTotalCount = make_shared<long>(boost::any_cast<long>(m["HoneypotTotalCount"]));
    }
    if (m.find("HoneypotUsedCount") != m.end() && !m["HoneypotUsedCount"].empty()) {
      honeypotUsedCount = make_shared<long>(boost::any_cast<long>(m["HoneypotUsedCount"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ProbeTotalCount") != m.end() && !m["ProbeTotalCount"].empty()) {
      probeTotalCount = make_shared<long>(boost::any_cast<long>(m["ProbeTotalCount"]));
    }
    if (m.find("ProbeUsedCount") != m.end() && !m["ProbeUsedCount"].empty()) {
      probeUsedCount = make_shared<long>(boost::any_cast<long>(m["ProbeUsedCount"]));
    }
    if (m.find("SecurityGroupProbeIpList") != m.end() && !m["SecurityGroupProbeIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupProbeIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupProbeIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupProbeIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalStatus") != m.end() && !m["TotalStatus"].empty()) {
      totalStatus = make_shared<long>(boost::any_cast<long>(m["TotalStatus"]));
    }
    if (m.find("UpgradeAvailable") != m.end() && !m["UpgradeAvailable"].empty()) {
      upgradeAvailable = make_shared<bool>(boost::any_cast<bool>(m["UpgradeAvailable"]));
    }
  }


  virtual ~GetHoneypotNodeResponseBodyHoneypotNode() = default;
};
class GetHoneypotNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHoneypotNodeResponseBodyHoneypotNode> honeypotNode{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetHoneypotNodeResponseBody() {}

  explicit GetHoneypotNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (honeypotNode) {
      res["HoneypotNode"] = honeypotNode ? boost::any(honeypotNode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HoneypotNode") != m.end() && !m["HoneypotNode"].empty()) {
      if (typeid(map<string, boost::any>) == m["HoneypotNode"].type()) {
        GetHoneypotNodeResponseBodyHoneypotNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HoneypotNode"]));
        honeypotNode = make_shared<GetHoneypotNodeResponseBodyHoneypotNode>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetHoneypotNodeResponseBody() = default;
};
class GetHoneypotNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHoneypotNodeResponseBody> body{};

  GetHoneypotNodeResponse() {}

  explicit GetHoneypotNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHoneypotNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHoneypotNodeResponseBody>(model1);
      }
    }
  }


  virtual ~GetHoneypotNodeResponse() = default;
};
class GetHoneypotPresetRequest : public Darabonba::Model {
public:
  shared_ptr<string> honeypotPresetId{};
  shared_ptr<string> lang{};

  GetHoneypotPresetRequest() {}

  explicit GetHoneypotPresetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotPresetId) {
      res["HoneypotPresetId"] = boost::any(*honeypotPresetId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotPresetId") != m.end() && !m["HoneypotPresetId"].empty()) {
      honeypotPresetId = make_shared<string>(boost::any_cast<string>(m["HoneypotPresetId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~GetHoneypotPresetRequest() = default;
};
class GetHoneypotPresetResponseBodyDataFileInfoList : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> ossUrl{};

  GetHoneypotPresetResponseBodyDataFileInfoList() {}

  explicit GetHoneypotPresetResponseBodyDataFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
  }


  virtual ~GetHoneypotPresetResponseBodyDataFileInfoList() = default;
};
class GetHoneypotPresetResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> controlNodeName{};
  shared_ptr<vector<GetHoneypotPresetResponseBodyDataFileInfoList>> fileInfoList{};
  shared_ptr<string> honeypotImageDisplayName{};
  shared_ptr<string> honeypotImageName{};
  shared_ptr<string> honeypotPresetId{};
  shared_ptr<string> meta{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> presetName{};
  shared_ptr<string> presetType{};

  GetHoneypotPresetResponseBodyData() {}

  explicit GetHoneypotPresetResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (controlNodeName) {
      res["ControlNodeName"] = boost::any(*controlNodeName);
    }
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (honeypotImageDisplayName) {
      res["HoneypotImageDisplayName"] = boost::any(*honeypotImageDisplayName);
    }
    if (honeypotImageName) {
      res["HoneypotImageName"] = boost::any(*honeypotImageName);
    }
    if (honeypotPresetId) {
      res["HoneypotPresetId"] = boost::any(*honeypotPresetId);
    }
    if (meta) {
      res["Meta"] = boost::any(*meta);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (presetName) {
      res["PresetName"] = boost::any(*presetName);
    }
    if (presetType) {
      res["PresetType"] = boost::any(*presetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ControlNodeName") != m.end() && !m["ControlNodeName"].empty()) {
      controlNodeName = make_shared<string>(boost::any_cast<string>(m["ControlNodeName"]));
    }
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<GetHoneypotPresetResponseBodyDataFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHoneypotPresetResponseBodyDataFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<GetHoneypotPresetResponseBodyDataFileInfoList>>(expect1);
      }
    }
    if (m.find("HoneypotImageDisplayName") != m.end() && !m["HoneypotImageDisplayName"].empty()) {
      honeypotImageDisplayName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageDisplayName"]));
    }
    if (m.find("HoneypotImageName") != m.end() && !m["HoneypotImageName"].empty()) {
      honeypotImageName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageName"]));
    }
    if (m.find("HoneypotPresetId") != m.end() && !m["HoneypotPresetId"].empty()) {
      honeypotPresetId = make_shared<string>(boost::any_cast<string>(m["HoneypotPresetId"]));
    }
    if (m.find("Meta") != m.end() && !m["Meta"].empty()) {
      meta = make_shared<string>(boost::any_cast<string>(m["Meta"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PresetName") != m.end() && !m["PresetName"].empty()) {
      presetName = make_shared<string>(boost::any_cast<string>(m["PresetName"]));
    }
    if (m.find("PresetType") != m.end() && !m["PresetType"].empty()) {
      presetType = make_shared<string>(boost::any_cast<string>(m["PresetType"]));
    }
  }


  virtual ~GetHoneypotPresetResponseBodyData() = default;
};
class GetHoneypotPresetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHoneypotPresetResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetHoneypotPresetResponseBody() {}

  explicit GetHoneypotPresetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHoneypotPresetResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHoneypotPresetResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetHoneypotPresetResponseBody() = default;
};
class GetHoneypotPresetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHoneypotPresetResponseBody> body{};

  GetHoneypotPresetResponse() {}

  explicit GetHoneypotPresetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHoneypotPresetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHoneypotPresetResponseBody>(model1);
      }
    }
  }


  virtual ~GetHoneypotPresetResponse() = default;
};
class GetHoneypotProbeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> probeId{};

  GetHoneypotProbeRequest() {}

  explicit GetHoneypotProbeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (probeId) {
      res["ProbeId"] = boost::any(*probeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ProbeId") != m.end() && !m["ProbeId"].empty()) {
      probeId = make_shared<string>(boost::any_cast<string>(m["ProbeId"]));
    }
  }


  virtual ~GetHoneypotProbeRequest() = default;
};
class GetHoneypotProbeResponseBodyDataControlNode : public Darabonba::Model {
public:
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};

  GetHoneypotProbeResponseBodyDataControlNode() {}

  explicit GetHoneypotProbeResponseBodyDataControlNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~GetHoneypotProbeResponseBodyDataControlNode() = default;
};
class GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> ports{};
  shared_ptr<string> probeId{};
  shared_ptr<vector<string>> serviceIpList{};
  shared_ptr<long> status{};

  GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort() {}

  explicit GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ports) {
      res["Ports"] = boost::any(*ports);
    }
    if (probeId) {
      res["ProbeId"] = boost::any(*probeId);
    }
    if (serviceIpList) {
      res["ServiceIpList"] = boost::any(*serviceIpList);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      ports = make_shared<string>(boost::any_cast<string>(m["Ports"]));
    }
    if (m.find("ProbeId") != m.end() && !m["ProbeId"].empty()) {
      probeId = make_shared<string>(boost::any_cast<string>(m["ProbeId"]));
    }
    if (m.find("ServiceIpList") != m.end() && !m["ServiceIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort() = default;
};
class GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList : public Darabonba::Model {
public:
  shared_ptr<bool> bindPort{};
  shared_ptr<long> endPort{};
  shared_ptr<string> err{};
  shared_ptr<bool> fixed{};
  shared_ptr<long> id{};
  shared_ptr<string> msg{};
  shared_ptr<string> proto{};
  shared_ptr<long> startPort{};
  shared_ptr<long> status{};
  shared_ptr<long> targetPort{};

  GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList() {}

  explicit GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindPort) {
      res["BindPort"] = boost::any(*bindPort);
    }
    if (endPort) {
      res["EndPort"] = boost::any(*endPort);
    }
    if (err) {
      res["Err"] = boost::any(*err);
    }
    if (fixed) {
      res["Fixed"] = boost::any(*fixed);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (startPort) {
      res["StartPort"] = boost::any(*startPort);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetPort) {
      res["TargetPort"] = boost::any(*targetPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindPort") != m.end() && !m["BindPort"].empty()) {
      bindPort = make_shared<bool>(boost::any_cast<bool>(m["BindPort"]));
    }
    if (m.find("EndPort") != m.end() && !m["EndPort"].empty()) {
      endPort = make_shared<long>(boost::any_cast<long>(m["EndPort"]));
    }
    if (m.find("Err") != m.end() && !m["Err"].empty()) {
      err = make_shared<string>(boost::any_cast<string>(m["Err"]));
    }
    if (m.find("Fixed") != m.end() && !m["Fixed"].empty()) {
      fixed = make_shared<bool>(boost::any_cast<bool>(m["Fixed"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("StartPort") != m.end() && !m["StartPort"].empty()) {
      startPort = make_shared<long>(boost::any_cast<long>(m["StartPort"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TargetPort") != m.end() && !m["TargetPort"].empty()) {
      targetPort = make_shared<long>(boost::any_cast<long>(m["TargetPort"]));
    }
  }


  virtual ~GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList() = default;
};
class GetHoneypotProbeResponseBodyDataHoneypotProbeBindList : public Darabonba::Model {
public:
  shared_ptr<string> bindId{};
  shared_ptr<vector<GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList>> bindPortList{};
  shared_ptr<string> honeypotId{};
  shared_ptr<vector<string>> serviceIpList{};
  shared_ptr<long> status{};

  GetHoneypotProbeResponseBodyDataHoneypotProbeBindList() {}

  explicit GetHoneypotProbeResponseBodyDataHoneypotProbeBindList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindId) {
      res["BindId"] = boost::any(*bindId);
    }
    if (bindPortList) {
      vector<boost::any> temp1;
      for(auto item1:*bindPortList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BindPortList"] = boost::any(temp1);
    }
    if (honeypotId) {
      res["HoneypotId"] = boost::any(*honeypotId);
    }
    if (serviceIpList) {
      res["ServiceIpList"] = boost::any(*serviceIpList);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindId") != m.end() && !m["BindId"].empty()) {
      bindId = make_shared<string>(boost::any_cast<string>(m["BindId"]));
    }
    if (m.find("BindPortList") != m.end() && !m["BindPortList"].empty()) {
      if (typeid(vector<boost::any>) == m["BindPortList"].type()) {
        vector<GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BindPortList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bindPortList = make_shared<vector<GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList>>(expect1);
      }
    }
    if (m.find("HoneypotId") != m.end() && !m["HoneypotId"].empty()) {
      honeypotId = make_shared<string>(boost::any_cast<string>(m["HoneypotId"]));
    }
    if (m.find("ServiceIpList") != m.end() && !m["ServiceIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~GetHoneypotProbeResponseBodyDataHoneypotProbeBindList() = default;
};
class GetHoneypotProbeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> arp{};
  shared_ptr<vector<string>> canListenIpList{};
  shared_ptr<vector<string>> cidrList{};
  shared_ptr<GetHoneypotProbeResponseBodyDataControlNode> controlNode{};
  shared_ptr<double> cpuLoad{};
  shared_ptr<long> deployTime{};
  shared_ptr<string> displayName{};
  shared_ptr<GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort> honeyPotProbeScanPort{};
  shared_ptr<vector<GetHoneypotProbeResponseBodyDataHoneypotProbeBindList>> honeypotProbeBindList{};
  shared_ptr<string> hostIp{};
  shared_ptr<vector<string>> listenIpList{};
  shared_ptr<double> memoryLoad{};
  shared_ptr<string> osType{};
  shared_ptr<bool> ping{};
  shared_ptr<string> probeId{};
  shared_ptr<string> probeType{};
  shared_ptr<string> probeVersion{};
  shared_ptr<string> proxyIp{};
  shared_ptr<long> status{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vpcId{};

  GetHoneypotProbeResponseBodyData() {}

  explicit GetHoneypotProbeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arp) {
      res["Arp"] = boost::any(*arp);
    }
    if (canListenIpList) {
      res["CanListenIpList"] = boost::any(*canListenIpList);
    }
    if (cidrList) {
      res["CidrList"] = boost::any(*cidrList);
    }
    if (controlNode) {
      res["ControlNode"] = controlNode ? boost::any(controlNode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cpuLoad) {
      res["CpuLoad"] = boost::any(*cpuLoad);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (honeyPotProbeScanPort) {
      res["HoneyPotProbeScanPort"] = honeyPotProbeScanPort ? boost::any(honeyPotProbeScanPort->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (honeypotProbeBindList) {
      vector<boost::any> temp1;
      for(auto item1:*honeypotProbeBindList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HoneypotProbeBindList"] = boost::any(temp1);
    }
    if (hostIp) {
      res["HostIp"] = boost::any(*hostIp);
    }
    if (listenIpList) {
      res["ListenIpList"] = boost::any(*listenIpList);
    }
    if (memoryLoad) {
      res["MemoryLoad"] = boost::any(*memoryLoad);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (ping) {
      res["Ping"] = boost::any(*ping);
    }
    if (probeId) {
      res["ProbeId"] = boost::any(*probeId);
    }
    if (probeType) {
      res["ProbeType"] = boost::any(*probeType);
    }
    if (probeVersion) {
      res["ProbeVersion"] = boost::any(*probeVersion);
    }
    if (proxyIp) {
      res["ProxyIp"] = boost::any(*proxyIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arp") != m.end() && !m["Arp"].empty()) {
      arp = make_shared<bool>(boost::any_cast<bool>(m["Arp"]));
    }
    if (m.find("CanListenIpList") != m.end() && !m["CanListenIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CanListenIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CanListenIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      canListenIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CidrList") != m.end() && !m["CidrList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CidrList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CidrList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      cidrList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ControlNode") != m.end() && !m["ControlNode"].empty()) {
      if (typeid(map<string, boost::any>) == m["ControlNode"].type()) {
        GetHoneypotProbeResponseBodyDataControlNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ControlNode"]));
        controlNode = make_shared<GetHoneypotProbeResponseBodyDataControlNode>(model1);
      }
    }
    if (m.find("CpuLoad") != m.end() && !m["CpuLoad"].empty()) {
      cpuLoad = make_shared<double>(boost::any_cast<double>(m["CpuLoad"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<long>(boost::any_cast<long>(m["DeployTime"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("HoneyPotProbeScanPort") != m.end() && !m["HoneyPotProbeScanPort"].empty()) {
      if (typeid(map<string, boost::any>) == m["HoneyPotProbeScanPort"].type()) {
        GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HoneyPotProbeScanPort"]));
        honeyPotProbeScanPort = make_shared<GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort>(model1);
      }
    }
    if (m.find("HoneypotProbeBindList") != m.end() && !m["HoneypotProbeBindList"].empty()) {
      if (typeid(vector<boost::any>) == m["HoneypotProbeBindList"].type()) {
        vector<GetHoneypotProbeResponseBodyDataHoneypotProbeBindList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HoneypotProbeBindList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHoneypotProbeResponseBodyDataHoneypotProbeBindList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        honeypotProbeBindList = make_shared<vector<GetHoneypotProbeResponseBodyDataHoneypotProbeBindList>>(expect1);
      }
    }
    if (m.find("HostIp") != m.end() && !m["HostIp"].empty()) {
      hostIp = make_shared<string>(boost::any_cast<string>(m["HostIp"]));
    }
    if (m.find("ListenIpList") != m.end() && !m["ListenIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ListenIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ListenIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      listenIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MemoryLoad") != m.end() && !m["MemoryLoad"].empty()) {
      memoryLoad = make_shared<double>(boost::any_cast<double>(m["MemoryLoad"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("Ping") != m.end() && !m["Ping"].empty()) {
      ping = make_shared<bool>(boost::any_cast<bool>(m["Ping"]));
    }
    if (m.find("ProbeId") != m.end() && !m["ProbeId"].empty()) {
      probeId = make_shared<string>(boost::any_cast<string>(m["ProbeId"]));
    }
    if (m.find("ProbeType") != m.end() && !m["ProbeType"].empty()) {
      probeType = make_shared<string>(boost::any_cast<string>(m["ProbeType"]));
    }
    if (m.find("ProbeVersion") != m.end() && !m["ProbeVersion"].empty()) {
      probeVersion = make_shared<string>(boost::any_cast<string>(m["ProbeVersion"]));
    }
    if (m.find("ProxyIp") != m.end() && !m["ProxyIp"].empty()) {
      proxyIp = make_shared<string>(boost::any_cast<string>(m["ProxyIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~GetHoneypotProbeResponseBodyData() = default;
};
class GetHoneypotProbeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHoneypotProbeResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetHoneypotProbeResponseBody() {}

  explicit GetHoneypotProbeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHoneypotProbeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHoneypotProbeResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetHoneypotProbeResponseBody() = default;
};
class GetHoneypotProbeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHoneypotProbeResponseBody> body{};

  GetHoneypotProbeResponse() {}

  explicit GetHoneypotProbeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHoneypotProbeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHoneypotProbeResponseBody>(model1);
      }
    }
  }


  virtual ~GetHoneypotProbeResponse() = default;
};
class GetImageScanNumInPeriodRequest : public Darabonba::Model {
public:
  shared_ptr<string> pastDay{};

  GetImageScanNumInPeriodRequest() {}

  explicit GetImageScanNumInPeriodRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pastDay) {
      res["PastDay"] = boost::any(*pastDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PastDay") != m.end() && !m["PastDay"].empty()) {
      pastDay = make_shared<string>(boost::any_cast<string>(m["PastDay"]));
    }
  }


  virtual ~GetImageScanNumInPeriodRequest() = default;
};
class GetImageScanNumInPeriodResponseBodyImageScanData : public Darabonba::Model {
public:
  shared_ptr<long> imageScanCount{};

  GetImageScanNumInPeriodResponseBodyImageScanData() {}

  explicit GetImageScanNumInPeriodResponseBodyImageScanData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageScanCount) {
      res["ImageScanCount"] = boost::any(*imageScanCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageScanCount") != m.end() && !m["ImageScanCount"].empty()) {
      imageScanCount = make_shared<long>(boost::any_cast<long>(m["ImageScanCount"]));
    }
  }


  virtual ~GetImageScanNumInPeriodResponseBodyImageScanData() = default;
};
class GetImageScanNumInPeriodResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetImageScanNumInPeriodResponseBodyImageScanData> imageScanData{};
  shared_ptr<string> requestId{};

  GetImageScanNumInPeriodResponseBody() {}

  explicit GetImageScanNumInPeriodResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageScanData) {
      res["ImageScanData"] = imageScanData ? boost::any(imageScanData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageScanData") != m.end() && !m["ImageScanData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageScanData"].type()) {
        GetImageScanNumInPeriodResponseBodyImageScanData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageScanData"]));
        imageScanData = make_shared<GetImageScanNumInPeriodResponseBodyImageScanData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetImageScanNumInPeriodResponseBody() = default;
};
class GetImageScanNumInPeriodResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetImageScanNumInPeriodResponseBody> body{};

  GetImageScanNumInPeriodResponse() {}

  explicit GetImageScanNumInPeriodResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetImageScanNumInPeriodResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetImageScanNumInPeriodResponseBody>(model1);
      }
    }
  }


  virtual ~GetImageScanNumInPeriodResponse() = default;
};
class GetInterceptionRuleDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> ruleId{};

  GetInterceptionRuleDetailRequest() {}

  explicit GetInterceptionRuleDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~GetInterceptionRuleDetailRequest() = default;
};
class GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<vector<string>> imageList{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<string>> ports{};
  shared_ptr<string> ruleType{};
  shared_ptr<vector<string>> tagList{};
  shared_ptr<long> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};

  GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget() {}

  explicit GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (imageList) {
      res["ImageList"] = boost::any(*imageList);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (ports) {
      res["Ports"] = boost::any(*ports);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ImageList") != m.end() && !m["ImageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ports"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ports = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<long>(boost::any_cast<long>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget() = default;
};
class GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<vector<string>> imageList{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> ruleType{};
  shared_ptr<vector<string>> tagList{};
  shared_ptr<long> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};

  GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget() {}

  explicit GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (imageList) {
      res["ImageList"] = boost::any(*imageList);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ImageList") != m.end() && !m["ImageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<long>(boost::any_cast<long>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget() = default;
};
class GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail : public Darabonba::Model {
public:
  shared_ptr<GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget> dstTarget{};
  shared_ptr<long> interceptType{};
  shared_ptr<long> orderIndex{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleSwitch{};
  shared_ptr<string> ruleType{};
  shared_ptr<GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget> srcTarget{};

  GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail() {}

  explicit GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstTarget) {
      res["DstTarget"] = dstTarget ? boost::any(dstTarget->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interceptType) {
      res["InterceptType"] = boost::any(*interceptType);
    }
    if (orderIndex) {
      res["OrderIndex"] = boost::any(*orderIndex);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleSwitch) {
      res["RuleSwitch"] = boost::any(*ruleSwitch);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (srcTarget) {
      res["SrcTarget"] = srcTarget ? boost::any(srcTarget->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstTarget") != m.end() && !m["DstTarget"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstTarget"].type()) {
        GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstTarget"]));
        dstTarget = make_shared<GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget>(model1);
      }
    }
    if (m.find("InterceptType") != m.end() && !m["InterceptType"].empty()) {
      interceptType = make_shared<long>(boost::any_cast<long>(m["InterceptType"]));
    }
    if (m.find("OrderIndex") != m.end() && !m["OrderIndex"].empty()) {
      orderIndex = make_shared<long>(boost::any_cast<long>(m["OrderIndex"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleSwitch") != m.end() && !m["RuleSwitch"].empty()) {
      ruleSwitch = make_shared<long>(boost::any_cast<long>(m["RuleSwitch"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("SrcTarget") != m.end() && !m["SrcTarget"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcTarget"].type()) {
        GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcTarget"]));
        srcTarget = make_shared<GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget>(model1);
      }
    }
  }


  virtual ~GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail() = default;
};
class GetInterceptionRuleDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail> interceptionRuleDetail{};
  shared_ptr<string> requestId{};

  GetInterceptionRuleDetailResponseBody() {}

  explicit GetInterceptionRuleDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interceptionRuleDetail) {
      res["InterceptionRuleDetail"] = interceptionRuleDetail ? boost::any(interceptionRuleDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InterceptionRuleDetail") != m.end() && !m["InterceptionRuleDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["InterceptionRuleDetail"].type()) {
        GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InterceptionRuleDetail"]));
        interceptionRuleDetail = make_shared<GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInterceptionRuleDetailResponseBody() = default;
};
class GetInterceptionRuleDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInterceptionRuleDetailResponseBody> body{};

  GetInterceptionRuleDetailResponse() {}

  explicit GetInterceptionRuleDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInterceptionRuleDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInterceptionRuleDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetInterceptionRuleDetailResponse() = default;
};
class GetInterceptionSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  GetInterceptionSummaryRequest() {}

  explicit GetInterceptionSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~GetInterceptionSummaryRequest() = default;
};
class GetInterceptionSummaryResponseBodyInterceptionSummary : public Darabonba::Model {
public:
  shared_ptr<long> closeClusterCount{};
  shared_ptr<long> closeRuleCount{};
  shared_ptr<long> clusterCount{};
  shared_ptr<long> interceptionCountInDays{};
  shared_ptr<long> openClusterCount{};
  shared_ptr<long> openRuleCount{};
  shared_ptr<long> riskCount180Day{};
  shared_ptr<long> riskCount30Day{};
  shared_ptr<long> riskCountToday{};
  shared_ptr<long> ruleCount{};

  GetInterceptionSummaryResponseBodyInterceptionSummary() {}

  explicit GetInterceptionSummaryResponseBodyInterceptionSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (closeClusterCount) {
      res["CloseClusterCount"] = boost::any(*closeClusterCount);
    }
    if (closeRuleCount) {
      res["CloseRuleCount"] = boost::any(*closeRuleCount);
    }
    if (clusterCount) {
      res["ClusterCount"] = boost::any(*clusterCount);
    }
    if (interceptionCountInDays) {
      res["InterceptionCountInDays"] = boost::any(*interceptionCountInDays);
    }
    if (openClusterCount) {
      res["OpenClusterCount"] = boost::any(*openClusterCount);
    }
    if (openRuleCount) {
      res["OpenRuleCount"] = boost::any(*openRuleCount);
    }
    if (riskCount180Day) {
      res["RiskCount180Day"] = boost::any(*riskCount180Day);
    }
    if (riskCount30Day) {
      res["RiskCount30Day"] = boost::any(*riskCount30Day);
    }
    if (riskCountToday) {
      res["RiskCountToday"] = boost::any(*riskCountToday);
    }
    if (ruleCount) {
      res["RuleCount"] = boost::any(*ruleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloseClusterCount") != m.end() && !m["CloseClusterCount"].empty()) {
      closeClusterCount = make_shared<long>(boost::any_cast<long>(m["CloseClusterCount"]));
    }
    if (m.find("CloseRuleCount") != m.end() && !m["CloseRuleCount"].empty()) {
      closeRuleCount = make_shared<long>(boost::any_cast<long>(m["CloseRuleCount"]));
    }
    if (m.find("ClusterCount") != m.end() && !m["ClusterCount"].empty()) {
      clusterCount = make_shared<long>(boost::any_cast<long>(m["ClusterCount"]));
    }
    if (m.find("InterceptionCountInDays") != m.end() && !m["InterceptionCountInDays"].empty()) {
      interceptionCountInDays = make_shared<long>(boost::any_cast<long>(m["InterceptionCountInDays"]));
    }
    if (m.find("OpenClusterCount") != m.end() && !m["OpenClusterCount"].empty()) {
      openClusterCount = make_shared<long>(boost::any_cast<long>(m["OpenClusterCount"]));
    }
    if (m.find("OpenRuleCount") != m.end() && !m["OpenRuleCount"].empty()) {
      openRuleCount = make_shared<long>(boost::any_cast<long>(m["OpenRuleCount"]));
    }
    if (m.find("RiskCount180Day") != m.end() && !m["RiskCount180Day"].empty()) {
      riskCount180Day = make_shared<long>(boost::any_cast<long>(m["RiskCount180Day"]));
    }
    if (m.find("RiskCount30Day") != m.end() && !m["RiskCount30Day"].empty()) {
      riskCount30Day = make_shared<long>(boost::any_cast<long>(m["RiskCount30Day"]));
    }
    if (m.find("RiskCountToday") != m.end() && !m["RiskCountToday"].empty()) {
      riskCountToday = make_shared<long>(boost::any_cast<long>(m["RiskCountToday"]));
    }
    if (m.find("RuleCount") != m.end() && !m["RuleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["RuleCount"]));
    }
  }


  virtual ~GetInterceptionSummaryResponseBodyInterceptionSummary() = default;
};
class GetInterceptionSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetInterceptionSummaryResponseBodyInterceptionSummary> interceptionSummary{};
  shared_ptr<string> requestId{};

  GetInterceptionSummaryResponseBody() {}

  explicit GetInterceptionSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interceptionSummary) {
      res["InterceptionSummary"] = interceptionSummary ? boost::any(interceptionSummary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InterceptionSummary") != m.end() && !m["InterceptionSummary"].empty()) {
      if (typeid(map<string, boost::any>) == m["InterceptionSummary"].type()) {
        GetInterceptionSummaryResponseBodyInterceptionSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InterceptionSummary"]));
        interceptionSummary = make_shared<GetInterceptionSummaryResponseBodyInterceptionSummary>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInterceptionSummaryResponseBody() = default;
};
class GetInterceptionSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInterceptionSummaryResponseBody> body{};

  GetInterceptionSummaryResponse() {}

  explicit GetInterceptionSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInterceptionSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInterceptionSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetInterceptionSummaryResponse() = default;
};
class GetInterceptionTargetDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> targetId{};

  GetInterceptionTargetDetailRequest() {}

  explicit GetInterceptionTargetDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<long>(boost::any_cast<long>(m["TargetId"]));
    }
  }


  virtual ~GetInterceptionTargetDetailRequest() = default;
};
class GetInterceptionTargetDetailResponseBodyRuleTarget : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<vector<string>> imageList{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<string>> tagList{};
  shared_ptr<long> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};

  GetInterceptionTargetDetailResponseBodyRuleTarget() {}

  explicit GetInterceptionTargetDetailResponseBodyRuleTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (imageList) {
      res["ImageList"] = boost::any(*imageList);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ImageList") != m.end() && !m["ImageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<long>(boost::any_cast<long>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~GetInterceptionTargetDetailResponseBodyRuleTarget() = default;
};
class GetInterceptionTargetDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetInterceptionTargetDetailResponseBodyRuleTarget> ruleTarget{};

  GetInterceptionTargetDetailResponseBody() {}

  explicit GetInterceptionTargetDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleTarget) {
      res["RuleTarget"] = ruleTarget ? boost::any(ruleTarget->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleTarget") != m.end() && !m["RuleTarget"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleTarget"].type()) {
        GetInterceptionTargetDetailResponseBodyRuleTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleTarget"]));
        ruleTarget = make_shared<GetInterceptionTargetDetailResponseBodyRuleTarget>(model1);
      }
    }
  }


  virtual ~GetInterceptionTargetDetailResponseBody() = default;
};
class GetInterceptionTargetDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInterceptionTargetDetailResponseBody> body{};

  GetInterceptionTargetDetailResponse() {}

  explicit GetInterceptionTargetDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInterceptionTargetDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInterceptionTargetDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetInterceptionTargetDetailResponse() = default;
};
class GetLastOnceTaskInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> source{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};

  GetLastOnceTaskInfoRequest() {}

  explicit GetLastOnceTaskInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~GetLastOnceTaskInfoRequest() = default;
};
class GetLastOnceTaskInfoResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<long> progress{};
  shared_ptr<string> result{};
  shared_ptr<string> status{};

  GetLastOnceTaskInfoResponseBodyTaskInfo() {}

  explicit GetLastOnceTaskInfoResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetLastOnceTaskInfoResponseBodyTaskInfo() = default;
};
class GetLastOnceTaskInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> collectTime{};
  shared_ptr<long> finishCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};
  shared_ptr<GetLastOnceTaskInfoResponseBodyTaskInfo> taskInfo{};
  shared_ptr<long> totalCount{};

  GetLastOnceTaskInfoResponseBody() {}

  explicit GetLastOnceTaskInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectTime) {
      res["CollectTime"] = boost::any(*collectTime);
    }
    if (finishCount) {
      res["FinishCount"] = boost::any(*finishCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CollectTime") != m.end() && !m["CollectTime"].empty()) {
      collectTime = make_shared<long>(boost::any_cast<long>(m["CollectTime"]));
    }
    if (m.find("FinishCount") != m.end() && !m["FinishCount"].empty()) {
      finishCount = make_shared<long>(boost::any_cast<long>(m["FinishCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        GetLastOnceTaskInfoResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<GetLastOnceTaskInfoResponseBodyTaskInfo>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetLastOnceTaskInfoResponseBody() = default;
};
class GetLastOnceTaskInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLastOnceTaskInfoResponseBody> body{};

  GetLastOnceTaskInfoResponse() {}

  explicit GetLastOnceTaskInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLastOnceTaskInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLastOnceTaskInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetLastOnceTaskInfoResponse() = default;
};
class GetModuleConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> currentPage{};
  shared_ptr<string> pageSize{};

  GetModuleConfigRequest() {}

  explicit GetModuleConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<string>(boost::any_cast<string>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~GetModuleConfigRequest() = default;
};
class GetModuleConfigResponseBodyModuleConfigListItems : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> ip{};
  shared_ptr<string> region{};
  shared_ptr<string> uuid{};

  GetModuleConfigResponseBodyModuleConfigListItems() {}

  explicit GetModuleConfigResponseBodyModuleConfigListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~GetModuleConfigResponseBodyModuleConfigListItems() = default;
};
class GetModuleConfigResponseBodyModuleConfigList : public Darabonba::Model {
public:
  shared_ptr<string> configName{};
  shared_ptr<vector<GetModuleConfigResponseBodyModuleConfigListItems>> items{};
  shared_ptr<string> moduleName{};

  GetModuleConfigResponseBodyModuleConfigList() {}

  explicit GetModuleConfigResponseBodyModuleConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<GetModuleConfigResponseBodyModuleConfigListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetModuleConfigResponseBodyModuleConfigListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<GetModuleConfigResponseBodyModuleConfigListItems>>(expect1);
      }
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
  }


  virtual ~GetModuleConfigResponseBodyModuleConfigList() = default;
};
class GetModuleConfigResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetModuleConfigResponseBodyPageInfo() {}

  explicit GetModuleConfigResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetModuleConfigResponseBodyPageInfo() = default;
};
class GetModuleConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<GetModuleConfigResponseBodyModuleConfigList>> moduleConfigList{};
  shared_ptr<GetModuleConfigResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetModuleConfigResponseBody() {}

  explicit GetModuleConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (moduleConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*moduleConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModuleConfigList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ModuleConfigList") != m.end() && !m["ModuleConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ModuleConfigList"].type()) {
        vector<GetModuleConfigResponseBodyModuleConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModuleConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetModuleConfigResponseBodyModuleConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        moduleConfigList = make_shared<vector<GetModuleConfigResponseBodyModuleConfigList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        GetModuleConfigResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<GetModuleConfigResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetModuleConfigResponseBody() = default;
};
class GetModuleConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetModuleConfigResponseBody> body{};

  GetModuleConfigResponse() {}

  explicit GetModuleConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetModuleConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetModuleConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetModuleConfigResponse() = default;
};
class GetOnceTaskResultInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};

  GetOnceTaskResultInfoRequest() {}

  explicit GetOnceTaskResultInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~GetOnceTaskResultInfoRequest() = default;
};
class GetOnceTaskResultInfoResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};

  GetOnceTaskResultInfoResponseBodyTaskInfo() {}

  explicit GetOnceTaskResultInfoResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetOnceTaskResultInfoResponseBodyTaskInfo() = default;
};
class GetOnceTaskResultInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> collectTime{};
  shared_ptr<long> finishCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};
  shared_ptr<GetOnceTaskResultInfoResponseBodyTaskInfo> taskInfo{};
  shared_ptr<long> totalCount{};

  GetOnceTaskResultInfoResponseBody() {}

  explicit GetOnceTaskResultInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectTime) {
      res["CollectTime"] = boost::any(*collectTime);
    }
    if (finishCount) {
      res["FinishCount"] = boost::any(*finishCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CollectTime") != m.end() && !m["CollectTime"].empty()) {
      collectTime = make_shared<long>(boost::any_cast<long>(m["CollectTime"]));
    }
    if (m.find("FinishCount") != m.end() && !m["FinishCount"].empty()) {
      finishCount = make_shared<long>(boost::any_cast<long>(m["FinishCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        GetOnceTaskResultInfoResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<GetOnceTaskResultInfoResponseBodyTaskInfo>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetOnceTaskResultInfoResponseBody() = default;
};
class GetOnceTaskResultInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOnceTaskResultInfoResponseBody> body{};

  GetOnceTaskResultInfoResponse() {}

  explicit GetOnceTaskResultInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOnceTaskResultInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOnceTaskResultInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetOnceTaskResultInfoResponse() = default;
};
class GetPropertyScheduleConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  GetPropertyScheduleConfigRequest() {}

  explicit GetPropertyScheduleConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~GetPropertyScheduleConfigRequest() = default;
};
class GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<long> nextScheduleTime{};
  shared_ptr<string> scheduleTime{};
  shared_ptr<string> type{};

  GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig() {}

  explicit GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextScheduleTime) {
      res["NextScheduleTime"] = boost::any(*nextScheduleTime);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextScheduleTime") != m.end() && !m["NextScheduleTime"].empty()) {
      nextScheduleTime = make_shared<long>(boost::any_cast<long>(m["NextScheduleTime"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<string>(boost::any_cast<string>(m["ScheduleTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig() = default;
};
class GetPropertyScheduleConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig> propertyScheduleConfig{};
  shared_ptr<string> requestId{};

  GetPropertyScheduleConfigResponseBody() {}

  explicit GetPropertyScheduleConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (propertyScheduleConfig) {
      res["PropertyScheduleConfig"] = propertyScheduleConfig ? boost::any(propertyScheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PropertyScheduleConfig") != m.end() && !m["PropertyScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PropertyScheduleConfig"].type()) {
        GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PropertyScheduleConfig"]));
        propertyScheduleConfig = make_shared<GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPropertyScheduleConfigResponseBody() = default;
};
class GetPropertyScheduleConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPropertyScheduleConfigResponseBody> body{};

  GetPropertyScheduleConfigResponse() {}

  explicit GetPropertyScheduleConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPropertyScheduleConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPropertyScheduleConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetPropertyScheduleConfigResponse() = default;
};
class GetRulesCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalSystemClientRuleCount{};
  shared_ptr<long> totalUserDefineRuleCount{};

  GetRulesCountResponseBody() {}

  explicit GetRulesCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalSystemClientRuleCount) {
      res["TotalSystemClientRuleCount"] = boost::any(*totalSystemClientRuleCount);
    }
    if (totalUserDefineRuleCount) {
      res["TotalUserDefineRuleCount"] = boost::any(*totalUserDefineRuleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalSystemClientRuleCount") != m.end() && !m["TotalSystemClientRuleCount"].empty()) {
      totalSystemClientRuleCount = make_shared<long>(boost::any_cast<long>(m["TotalSystemClientRuleCount"]));
    }
    if (m.find("TotalUserDefineRuleCount") != m.end() && !m["TotalUserDefineRuleCount"].empty()) {
      totalUserDefineRuleCount = make_shared<long>(boost::any_cast<long>(m["TotalUserDefineRuleCount"]));
    }
  }


  virtual ~GetRulesCountResponseBody() = default;
};
class GetRulesCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRulesCountResponseBody> body{};

  GetRulesCountResponse() {}

  explicit GetRulesCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRulesCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRulesCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetRulesCountResponse() = default;
};
class GetSuspiciousStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupIdList{};
  shared_ptr<string> sourceIp{};

  GetSuspiciousStatisticsRequest() {}

  explicit GetSuspiciousStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupIdList) {
      res["GroupIdList"] = boost::any(*groupIdList);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupIdList") != m.end() && !m["GroupIdList"].empty()) {
      groupIdList = make_shared<string>(boost::any_cast<string>(m["GroupIdList"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~GetSuspiciousStatisticsRequest() = default;
};
class GetSuspiciousStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> remindCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> seriousCount{};
  shared_ptr<long> suspiciousCount{};
  shared_ptr<long> totalCount{};

  GetSuspiciousStatisticsResponseBody() {}

  explicit GetSuspiciousStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindCount) {
      res["RemindCount"] = boost::any(*remindCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (seriousCount) {
      res["SeriousCount"] = boost::any(*seriousCount);
    }
    if (suspiciousCount) {
      res["SuspiciousCount"] = boost::any(*suspiciousCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindCount") != m.end() && !m["RemindCount"].empty()) {
      remindCount = make_shared<long>(boost::any_cast<long>(m["RemindCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SeriousCount") != m.end() && !m["SeriousCount"].empty()) {
      seriousCount = make_shared<long>(boost::any_cast<long>(m["SeriousCount"]));
    }
    if (m.find("SuspiciousCount") != m.end() && !m["SuspiciousCount"].empty()) {
      suspiciousCount = make_shared<long>(boost::any_cast<long>(m["SuspiciousCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetSuspiciousStatisticsResponseBody() = default;
};
class GetSuspiciousStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSuspiciousStatisticsResponseBody> body{};

  GetSuspiciousStatisticsResponse() {}

  explicit GetSuspiciousStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSuspiciousStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSuspiciousStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetSuspiciousStatisticsResponse() = default;
};
class GetVulStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupIdList{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> typeList{};

  GetVulStatisticsRequest() {}

  explicit GetVulStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupIdList) {
      res["GroupIdList"] = boost::any(*groupIdList);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (typeList) {
      res["TypeList"] = boost::any(*typeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupIdList") != m.end() && !m["GroupIdList"].empty()) {
      groupIdList = make_shared<string>(boost::any_cast<string>(m["GroupIdList"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("TypeList") != m.end() && !m["TypeList"].empty()) {
      typeList = make_shared<string>(boost::any_cast<string>(m["TypeList"]));
    }
  }


  virtual ~GetVulStatisticsRequest() = default;
};
class GetVulStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> vulAsapSum{};
  shared_ptr<long> vulLaterSum{};
  shared_ptr<long> vulNntfSum{};

  GetVulStatisticsResponseBody() {}

  explicit GetVulStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vulAsapSum) {
      res["VulAsapSum"] = boost::any(*vulAsapSum);
    }
    if (vulLaterSum) {
      res["VulLaterSum"] = boost::any(*vulLaterSum);
    }
    if (vulNntfSum) {
      res["VulNntfSum"] = boost::any(*vulNntfSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VulAsapSum") != m.end() && !m["VulAsapSum"].empty()) {
      vulAsapSum = make_shared<long>(boost::any_cast<long>(m["VulAsapSum"]));
    }
    if (m.find("VulLaterSum") != m.end() && !m["VulLaterSum"].empty()) {
      vulLaterSum = make_shared<long>(boost::any_cast<long>(m["VulLaterSum"]));
    }
    if (m.find("VulNntfSum") != m.end() && !m["VulNntfSum"].empty()) {
      vulNntfSum = make_shared<long>(boost::any_cast<long>(m["VulNntfSum"]));
    }
  }


  virtual ~GetVulStatisticsResponseBody() = default;
};
class GetVulStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVulStatisticsResponseBody> body{};

  GetVulStatisticsResponse() {}

  explicit GetVulStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVulStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVulStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetVulStatisticsResponse() = default;
};
class GetVulWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<long> vulWhitelistId{};

  GetVulWhitelistRequest() {}

  explicit GetVulWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vulWhitelistId) {
      res["VulWhitelistId"] = boost::any(*vulWhitelistId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VulWhitelistId") != m.end() && !m["VulWhitelistId"].empty()) {
      vulWhitelistId = make_shared<long>(boost::any_cast<long>(m["VulWhitelistId"]));
    }
  }


  virtual ~GetVulWhitelistRequest() = default;
};
class GetVulWhitelistResponseBodyVulWhitelist : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> reason{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};
  shared_ptr<string> whitelist{};

  GetVulWhitelistResponseBodyVulWhitelist() {}

  explicit GetVulWhitelistResponseBodyVulWhitelist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (whitelist) {
      res["Whitelist"] = boost::any(*whitelist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Whitelist") != m.end() && !m["Whitelist"].empty()) {
      whitelist = make_shared<string>(boost::any_cast<string>(m["Whitelist"]));
    }
  }


  virtual ~GetVulWhitelistResponseBodyVulWhitelist() = default;
};
class GetVulWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetVulWhitelistResponseBodyVulWhitelist> vulWhitelist{};

  GetVulWhitelistResponseBody() {}

  explicit GetVulWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vulWhitelist) {
      res["VulWhitelist"] = vulWhitelist ? boost::any(vulWhitelist->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VulWhitelist") != m.end() && !m["VulWhitelist"].empty()) {
      if (typeid(map<string, boost::any>) == m["VulWhitelist"].type()) {
        GetVulWhitelistResponseBodyVulWhitelist model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VulWhitelist"]));
        vulWhitelist = make_shared<GetVulWhitelistResponseBodyVulWhitelist>(model1);
      }
    }
  }


  virtual ~GetVulWhitelistResponseBody() = default;
};
class GetVulWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVulWhitelistResponseBody> body{};

  GetVulWhitelistResponse() {}

  explicit GetVulWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVulWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVulWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~GetVulWhitelistResponse() = default;
};
class HandleSecurityEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> markBatch{};
  shared_ptr<string> markMissParam{};
  shared_ptr<string> operationCode{};
  shared_ptr<string> operationParams{};
  shared_ptr<vector<string>> securityEventIds{};
  shared_ptr<string> sourceIp{};

  HandleSecurityEventsRequest() {}

  explicit HandleSecurityEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (markBatch) {
      res["MarkBatch"] = boost::any(*markBatch);
    }
    if (markMissParam) {
      res["MarkMissParam"] = boost::any(*markMissParam);
    }
    if (operationCode) {
      res["OperationCode"] = boost::any(*operationCode);
    }
    if (operationParams) {
      res["OperationParams"] = boost::any(*operationParams);
    }
    if (securityEventIds) {
      res["SecurityEventIds"] = boost::any(*securityEventIds);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MarkBatch") != m.end() && !m["MarkBatch"].empty()) {
      markBatch = make_shared<string>(boost::any_cast<string>(m["MarkBatch"]));
    }
    if (m.find("MarkMissParam") != m.end() && !m["MarkMissParam"].empty()) {
      markMissParam = make_shared<string>(boost::any_cast<string>(m["MarkMissParam"]));
    }
    if (m.find("OperationCode") != m.end() && !m["OperationCode"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["OperationCode"]));
    }
    if (m.find("OperationParams") != m.end() && !m["OperationParams"].empty()) {
      operationParams = make_shared<string>(boost::any_cast<string>(m["OperationParams"]));
    }
    if (m.find("SecurityEventIds") != m.end() && !m["SecurityEventIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityEventIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityEventIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityEventIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~HandleSecurityEventsRequest() = default;
};
class HandleSecurityEventsResponseBodyHandleSecurityEventsResponse : public Darabonba::Model {
public:
  shared_ptr<long> taskId{};

  HandleSecurityEventsResponseBodyHandleSecurityEventsResponse() {}

  explicit HandleSecurityEventsResponseBodyHandleSecurityEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~HandleSecurityEventsResponseBodyHandleSecurityEventsResponse() = default;
};
class HandleSecurityEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<HandleSecurityEventsResponseBodyHandleSecurityEventsResponse> handleSecurityEventsResponse{};
  shared_ptr<string> requestId{};

  HandleSecurityEventsResponseBody() {}

  explicit HandleSecurityEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (handleSecurityEventsResponse) {
      res["HandleSecurityEventsResponse"] = handleSecurityEventsResponse ? boost::any(handleSecurityEventsResponse->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HandleSecurityEventsResponse") != m.end() && !m["HandleSecurityEventsResponse"].empty()) {
      if (typeid(map<string, boost::any>) == m["HandleSecurityEventsResponse"].type()) {
        HandleSecurityEventsResponseBodyHandleSecurityEventsResponse model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HandleSecurityEventsResponse"]));
        handleSecurityEventsResponse = make_shared<HandleSecurityEventsResponseBodyHandleSecurityEventsResponse>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~HandleSecurityEventsResponseBody() = default;
};
class HandleSecurityEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HandleSecurityEventsResponseBody> body{};

  HandleSecurityEventsResponse() {}

  explicit HandleSecurityEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HandleSecurityEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HandleSecurityEventsResponseBody>(model1);
      }
    }
  }


  virtual ~HandleSecurityEventsResponse() = default;
};
class HandleSimilarSecurityEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> markMissParam{};
  shared_ptr<string> operationCode{};
  shared_ptr<string> operationParams{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> taskId{};

  HandleSimilarSecurityEventsRequest() {}

  explicit HandleSimilarSecurityEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (markMissParam) {
      res["MarkMissParam"] = boost::any(*markMissParam);
    }
    if (operationCode) {
      res["OperationCode"] = boost::any(*operationCode);
    }
    if (operationParams) {
      res["OperationParams"] = boost::any(*operationParams);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MarkMissParam") != m.end() && !m["MarkMissParam"].empty()) {
      markMissParam = make_shared<string>(boost::any_cast<string>(m["MarkMissParam"]));
    }
    if (m.find("OperationCode") != m.end() && !m["OperationCode"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["OperationCode"]));
    }
    if (m.find("OperationParams") != m.end() && !m["OperationParams"].empty()) {
      operationParams = make_shared<string>(boost::any_cast<string>(m["OperationParams"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~HandleSimilarSecurityEventsRequest() = default;
};
class HandleSimilarSecurityEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  HandleSimilarSecurityEventsResponseBody() {}

  explicit HandleSimilarSecurityEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~HandleSimilarSecurityEventsResponseBody() = default;
};
class HandleSimilarSecurityEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HandleSimilarSecurityEventsResponseBody> body{};

  HandleSimilarSecurityEventsResponse() {}

  explicit HandleSimilarSecurityEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HandleSimilarSecurityEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HandleSimilarSecurityEventsResponseBody>(model1);
      }
    }
  }


  virtual ~HandleSimilarSecurityEventsResponse() = default;
};
class IgnoreCheckItemsRequestCheckAndRiskTypeList : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<string> riskType{};

  IgnoreCheckItemsRequestCheckAndRiskTypeList() {}

  explicit IgnoreCheckItemsRequestCheckAndRiskTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (riskType) {
      res["RiskType"] = boost::any(*riskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("RiskType") != m.end() && !m["RiskType"].empty()) {
      riskType = make_shared<string>(boost::any_cast<string>(m["RiskType"]));
    }
  }


  virtual ~IgnoreCheckItemsRequestCheckAndRiskTypeList() = default;
};
class IgnoreCheckItemsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<IgnoreCheckItemsRequestCheckAndRiskTypeList>> checkAndRiskTypeList{};
  shared_ptr<string> lang{};
  shared_ptr<string> reason{};
  shared_ptr<long> type{};
  shared_ptr<vector<string>> uuidList{};

  IgnoreCheckItemsRequest() {}

  explicit IgnoreCheckItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkAndRiskTypeList) {
      vector<boost::any> temp1;
      for(auto item1:*checkAndRiskTypeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CheckAndRiskTypeList"] = boost::any(temp1);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckAndRiskTypeList") != m.end() && !m["CheckAndRiskTypeList"].empty()) {
      if (typeid(vector<boost::any>) == m["CheckAndRiskTypeList"].type()) {
        vector<IgnoreCheckItemsRequestCheckAndRiskTypeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CheckAndRiskTypeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            IgnoreCheckItemsRequestCheckAndRiskTypeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkAndRiskTypeList = make_shared<vector<IgnoreCheckItemsRequestCheckAndRiskTypeList>>(expect1);
      }
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~IgnoreCheckItemsRequest() = default;
};
class IgnoreCheckItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  IgnoreCheckItemsResponseBody() {}

  explicit IgnoreCheckItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~IgnoreCheckItemsResponseBody() = default;
};
class IgnoreCheckItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IgnoreCheckItemsResponseBody> body{};

  IgnoreCheckItemsResponse() {}

  explicit IgnoreCheckItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IgnoreCheckItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IgnoreCheckItemsResponseBody>(model1);
      }
    }
  }


  virtual ~IgnoreCheckItemsResponse() = default;
};
class IgnoreHcCheckWarningsRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkIds{};
  shared_ptr<string> checkWarningIds{};
  shared_ptr<string> reason{};
  shared_ptr<string> riskId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> type{};

  IgnoreHcCheckWarningsRequest() {}

  explicit IgnoreHcCheckWarningsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkIds) {
      res["CheckIds"] = boost::any(*checkIds);
    }
    if (checkWarningIds) {
      res["CheckWarningIds"] = boost::any(*checkWarningIds);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckIds") != m.end() && !m["CheckIds"].empty()) {
      checkIds = make_shared<string>(boost::any_cast<string>(m["CheckIds"]));
    }
    if (m.find("CheckWarningIds") != m.end() && !m["CheckWarningIds"].empty()) {
      checkWarningIds = make_shared<string>(boost::any_cast<string>(m["CheckWarningIds"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<string>(boost::any_cast<string>(m["RiskId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~IgnoreHcCheckWarningsRequest() = default;
};
class IgnoreHcCheckWarningsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  IgnoreHcCheckWarningsResponseBody() {}

  explicit IgnoreHcCheckWarningsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~IgnoreHcCheckWarningsResponseBody() = default;
};
class IgnoreHcCheckWarningsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IgnoreHcCheckWarningsResponseBody> body{};

  IgnoreHcCheckWarningsResponse() {}

  explicit IgnoreHcCheckWarningsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IgnoreHcCheckWarningsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IgnoreHcCheckWarningsResponseBody>(model1);
      }
    }
  }


  virtual ~IgnoreHcCheckWarningsResponse() = default;
};
class InstallBackupClientRequest : public Darabonba::Model {
public:
  shared_ptr<string> policyVersion{};
  shared_ptr<string> uuid{};
  shared_ptr<vector<string>> uuidList{};

  InstallBackupClientRequest() {}

  explicit InstallBackupClientRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InstallBackupClientRequest() = default;
};
class InstallBackupClientResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  InstallBackupClientResponseBody() {}

  explicit InstallBackupClientResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InstallBackupClientResponseBody() = default;
};
class InstallBackupClientResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallBackupClientResponseBody> body{};

  InstallBackupClientResponse() {}

  explicit InstallBackupClientResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallBackupClientResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallBackupClientResponseBody>(model1);
      }
    }
  }


  virtual ~InstallBackupClientResponse() = default;
};
class InstallCloudMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentAccessKey{};
  shared_ptr<string> agentSecretKey{};
  shared_ptr<string> argusVersion{};
  shared_ptr<vector<string>> instanceIdList{};
  shared_ptr<vector<string>> uuidList{};

  InstallCloudMonitorRequest() {}

  explicit InstallCloudMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentAccessKey) {
      res["AgentAccessKey"] = boost::any(*agentAccessKey);
    }
    if (agentSecretKey) {
      res["AgentSecretKey"] = boost::any(*agentSecretKey);
    }
    if (argusVersion) {
      res["ArgusVersion"] = boost::any(*argusVersion);
    }
    if (instanceIdList) {
      res["InstanceIdList"] = boost::any(*instanceIdList);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentAccessKey") != m.end() && !m["AgentAccessKey"].empty()) {
      agentAccessKey = make_shared<string>(boost::any_cast<string>(m["AgentAccessKey"]));
    }
    if (m.find("AgentSecretKey") != m.end() && !m["AgentSecretKey"].empty()) {
      agentSecretKey = make_shared<string>(boost::any_cast<string>(m["AgentSecretKey"]));
    }
    if (m.find("ArgusVersion") != m.end() && !m["ArgusVersion"].empty()) {
      argusVersion = make_shared<string>(boost::any_cast<string>(m["ArgusVersion"]));
    }
    if (m.find("InstanceIdList") != m.end() && !m["InstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InstallCloudMonitorRequest() = default;
};
class InstallCloudMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InstallCloudMonitorResponseBody() {}

  explicit InstallCloudMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallCloudMonitorResponseBody() = default;
};
class InstallCloudMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallCloudMonitorResponseBody> body{};

  InstallCloudMonitorResponse() {}

  explicit InstallCloudMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallCloudMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallCloudMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~InstallCloudMonitorResponse() = default;
};
class InstallPmAgentRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};
  shared_ptr<string> uuids{};

  InstallPmAgentRequest() {}

  explicit InstallPmAgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~InstallPmAgentRequest() = default;
};
class InstallPmAgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  InstallPmAgentResponseBody() {}

  explicit InstallPmAgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InstallPmAgentResponseBody() = default;
};
class InstallPmAgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallPmAgentResponseBody> body{};

  InstallPmAgentResponse() {}

  explicit InstallPmAgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallPmAgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallPmAgentResponseBody>(model1);
      }
    }
  }


  virtual ~InstallPmAgentResponse() = default;
};
class InstallUniBackupAgentRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};

  InstallUniBackupAgentRequest() {}

  explicit InstallUniBackupAgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
  }


  virtual ~InstallUniBackupAgentRequest() = default;
};
class InstallUniBackupAgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  InstallUniBackupAgentResponseBody() {}

  explicit InstallUniBackupAgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InstallUniBackupAgentResponseBody() = default;
};
class InstallUniBackupAgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallUniBackupAgentResponseBody> body{};

  InstallUniBackupAgentResponse() {}

  explicit InstallUniBackupAgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallUniBackupAgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallUniBackupAgentResponseBody>(model1);
      }
    }
  }


  virtual ~InstallUniBackupAgentResponse() = default;
};
class JoinWebLockProcessWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> processPaths{};
  shared_ptr<string> uuids{};

  JoinWebLockProcessWhiteListRequest() {}

  explicit JoinWebLockProcessWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (processPaths) {
      res["ProcessPaths"] = boost::any(*processPaths);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProcessPaths") != m.end() && !m["ProcessPaths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProcessPaths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProcessPaths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processPaths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~JoinWebLockProcessWhiteListRequest() = default;
};
class JoinWebLockProcessWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  JoinWebLockProcessWhiteListResponseBody() {}

  explicit JoinWebLockProcessWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~JoinWebLockProcessWhiteListResponseBody() = default;
};
class JoinWebLockProcessWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinWebLockProcessWhiteListResponseBody> body{};

  JoinWebLockProcessWhiteListResponse() {}

  explicit JoinWebLockProcessWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinWebLockProcessWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinWebLockProcessWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~JoinWebLockProcessWhiteListResponse() = default;
};
class ListAvailableHoneypotRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};

  ListAvailableHoneypotRequest() {}

  explicit ListAvailableHoneypotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~ListAvailableHoneypotRequest() = default;
};
class ListAvailableHoneypotResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> honeypotImageDisplayName{};
  shared_ptr<string> honeypotImageId{};
  shared_ptr<string> honeypotImageName{};
  shared_ptr<string> honeypotImageType{};
  shared_ptr<string> honeypotImageVersion{};
  shared_ptr<string> multiports{};
  shared_ptr<string> proto{};
  shared_ptr<string> servicePort{};
  shared_ptr<string> template_{};

  ListAvailableHoneypotResponseBodyData() {}

  explicit ListAvailableHoneypotResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotImageDisplayName) {
      res["HoneypotImageDisplayName"] = boost::any(*honeypotImageDisplayName);
    }
    if (honeypotImageId) {
      res["HoneypotImageId"] = boost::any(*honeypotImageId);
    }
    if (honeypotImageName) {
      res["HoneypotImageName"] = boost::any(*honeypotImageName);
    }
    if (honeypotImageType) {
      res["HoneypotImageType"] = boost::any(*honeypotImageType);
    }
    if (honeypotImageVersion) {
      res["HoneypotImageVersion"] = boost::any(*honeypotImageVersion);
    }
    if (multiports) {
      res["Multiports"] = boost::any(*multiports);
    }
    if (proto) {
      res["Proto"] = boost::any(*proto);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    if (template_) {
      res["Template"] = boost::any(*template_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotImageDisplayName") != m.end() && !m["HoneypotImageDisplayName"].empty()) {
      honeypotImageDisplayName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageDisplayName"]));
    }
    if (m.find("HoneypotImageId") != m.end() && !m["HoneypotImageId"].empty()) {
      honeypotImageId = make_shared<string>(boost::any_cast<string>(m["HoneypotImageId"]));
    }
    if (m.find("HoneypotImageName") != m.end() && !m["HoneypotImageName"].empty()) {
      honeypotImageName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageName"]));
    }
    if (m.find("HoneypotImageType") != m.end() && !m["HoneypotImageType"].empty()) {
      honeypotImageType = make_shared<string>(boost::any_cast<string>(m["HoneypotImageType"]));
    }
    if (m.find("HoneypotImageVersion") != m.end() && !m["HoneypotImageVersion"].empty()) {
      honeypotImageVersion = make_shared<string>(boost::any_cast<string>(m["HoneypotImageVersion"]));
    }
    if (m.find("Multiports") != m.end() && !m["Multiports"].empty()) {
      multiports = make_shared<string>(boost::any_cast<string>(m["Multiports"]));
    }
    if (m.find("Proto") != m.end() && !m["Proto"].empty()) {
      proto = make_shared<string>(boost::any_cast<string>(m["Proto"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<string>(boost::any_cast<string>(m["ServicePort"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      template_ = make_shared<string>(boost::any_cast<string>(m["Template"]));
    }
  }


  virtual ~ListAvailableHoneypotResponseBodyData() = default;
};
class ListAvailableHoneypotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> count{};
  shared_ptr<vector<ListAvailableHoneypotResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAvailableHoneypotResponseBody() {}

  explicit ListAvailableHoneypotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAvailableHoneypotResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAvailableHoneypotResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAvailableHoneypotResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAvailableHoneypotResponseBody() = default;
};
class ListAvailableHoneypotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAvailableHoneypotResponseBody> body{};

  ListAvailableHoneypotResponse() {}

  explicit ListAvailableHoneypotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAvailableHoneypotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAvailableHoneypotResponseBody>(model1);
      }
    }
  }


  virtual ~ListAvailableHoneypotResponse() = default;
};
class ListCheckInstanceResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> instanceIdKey{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> instanceNameKey{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionIdKey{};
  shared_ptr<vector<string>> sortTypes{};
  shared_ptr<vector<string>> statuses{};

  ListCheckInstanceResultRequest() {}

  explicit ListCheckInstanceResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceIdKey) {
      res["InstanceIdKey"] = boost::any(*instanceIdKey);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (instanceNameKey) {
      res["InstanceNameKey"] = boost::any(*instanceNameKey);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionIdKey) {
      res["RegionIdKey"] = boost::any(*regionIdKey);
    }
    if (sortTypes) {
      res["SortTypes"] = boost::any(*sortTypes);
    }
    if (statuses) {
      res["Statuses"] = boost::any(*statuses);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("InstanceIdKey") != m.end() && !m["InstanceIdKey"].empty()) {
      instanceIdKey = make_shared<string>(boost::any_cast<string>(m["InstanceIdKey"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceNameKey") != m.end() && !m["InstanceNameKey"].empty()) {
      instanceNameKey = make_shared<string>(boost::any_cast<string>(m["InstanceNameKey"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionIdKey") != m.end() && !m["RegionIdKey"].empty()) {
      regionIdKey = make_shared<string>(boost::any_cast<string>(m["RegionIdKey"]));
    }
    if (m.find("SortTypes") != m.end() && !m["SortTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SortTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SortTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sortTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Statuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Statuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statuses = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListCheckInstanceResultRequest() = default;
};
class ListCheckInstanceResultResponseBodyBasicData : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  ListCheckInstanceResultResponseBodyBasicData() {}

  explicit ListCheckInstanceResultResponseBodyBasicData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListCheckInstanceResultResponseBodyBasicData() = default;
};
class ListCheckInstanceResultResponseBodyColumnsGrids : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> showName{};
  shared_ptr<string> type{};

  ListCheckInstanceResultResponseBodyColumnsGrids() {}

  explicit ListCheckInstanceResultResponseBodyColumnsGrids(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCheckInstanceResultResponseBodyColumnsGrids() = default;
};
class ListCheckInstanceResultResponseBodyColumns : public Darabonba::Model {
public:
  shared_ptr<vector<ListCheckInstanceResultResponseBodyColumnsGrids>> grids{};
  shared_ptr<string> key{};
  shared_ptr<bool> search{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> showName{};
  shared_ptr<string> type{};

  ListCheckInstanceResultResponseBodyColumns() {}

  explicit ListCheckInstanceResultResponseBodyColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grids) {
      vector<boost::any> temp1;
      for(auto item1:*grids){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Grids"] = boost::any(temp1);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (search) {
      res["Search"] = boost::any(*search);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Grids") != m.end() && !m["Grids"].empty()) {
      if (typeid(vector<boost::any>) == m["Grids"].type()) {
        vector<ListCheckInstanceResultResponseBodyColumnsGrids> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Grids"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckInstanceResultResponseBodyColumnsGrids model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        grids = make_shared<vector<ListCheckInstanceResultResponseBodyColumnsGrids>>(expect1);
      }
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Search") != m.end() && !m["Search"].empty()) {
      search = make_shared<bool>(boost::any_cast<bool>(m["Search"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCheckInstanceResultResponseBodyColumns() = default;
};
class ListCheckInstanceResultResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<string> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCheckInstanceResultResponseBodyPageInfo() {}

  explicit ListCheckInstanceResultResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCheckInstanceResultResponseBodyPageInfo() = default;
};
class ListCheckInstanceResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCheckInstanceResultResponseBodyBasicData>> basicData{};
  shared_ptr<vector<map<string, boost::any>>> checks{};
  shared_ptr<vector<ListCheckInstanceResultResponseBodyColumns>> columns{};
  shared_ptr<ListCheckInstanceResultResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListCheckInstanceResultResponseBody() {}

  explicit ListCheckInstanceResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basicData) {
      vector<boost::any> temp1;
      for(auto item1:*basicData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BasicData"] = boost::any(temp1);
    }
    if (checks) {
      res["Checks"] = boost::any(*checks);
    }
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasicData") != m.end() && !m["BasicData"].empty()) {
      if (typeid(vector<boost::any>) == m["BasicData"].type()) {
        vector<ListCheckInstanceResultResponseBodyBasicData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BasicData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckInstanceResultResponseBodyBasicData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        basicData = make_shared<vector<ListCheckInstanceResultResponseBodyBasicData>>(expect1);
      }
    }
    if (m.find("Checks") != m.end() && !m["Checks"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Checks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Checks"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      checks = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<ListCheckInstanceResultResponseBodyColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckInstanceResultResponseBodyColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<ListCheckInstanceResultResponseBodyColumns>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListCheckInstanceResultResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListCheckInstanceResultResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCheckInstanceResultResponseBody() = default;
};
class ListCheckInstanceResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCheckInstanceResultResponseBody> body{};

  ListCheckInstanceResultResponse() {}

  explicit ListCheckInstanceResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCheckInstanceResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCheckInstanceResultResponseBody>(model1);
      }
    }
  }


  virtual ~ListCheckInstanceResultResponse() = default;
};
class ListCheckItemWarningMachineRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> groupId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<string> riskType{};
  shared_ptr<long> status{};

  ListCheckItemWarningMachineRequest() {}

  explicit ListCheckItemWarningMachineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (riskType) {
      res["RiskType"] = boost::any(*riskType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RiskType") != m.end() && !m["RiskType"].empty()) {
      riskType = make_shared<string>(boost::any_cast<string>(m["RiskType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListCheckItemWarningMachineRequest() = default;
};
class ListCheckItemWarningMachineResponseBodyListFixList : public Darabonba::Model {
public:
  shared_ptr<long> riskId{};
  shared_ptr<string> riskName{};

  ListCheckItemWarningMachineResponseBodyListFixList() {}

  explicit ListCheckItemWarningMachineResponseBodyListFixList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
  }


  virtual ~ListCheckItemWarningMachineResponseBodyListFixList() = default;
};
class ListCheckItemWarningMachineResponseBodyListWarningRiskList : public Darabonba::Model {
public:
  shared_ptr<long> riskId{};
  shared_ptr<string> riskName{};

  ListCheckItemWarningMachineResponseBodyListWarningRiskList() {}

  explicit ListCheckItemWarningMachineResponseBodyListWarningRiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (riskId) {
      res["RiskId"] = boost::any(*riskId);
    }
    if (riskName) {
      res["RiskName"] = boost::any(*riskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RiskId") != m.end() && !m["RiskId"].empty()) {
      riskId = make_shared<long>(boost::any_cast<long>(m["RiskId"]));
    }
    if (m.find("RiskName") != m.end() && !m["RiskName"].empty()) {
      riskName = make_shared<string>(boost::any_cast<string>(m["RiskName"]));
    }
  }


  virtual ~ListCheckItemWarningMachineResponseBodyListWarningRiskList() = default;
};
class ListCheckItemWarningMachineResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> authVersion{};
  shared_ptr<bool> bind{};
  shared_ptr<vector<ListCheckItemWarningMachineResponseBodyListFixList>> fixList{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<bool> portOpen{};
  shared_ptr<string> prompt{};
  shared_ptr<string> regionId{};
  shared_ptr<long> status{};
  shared_ptr<string> uuid{};
  shared_ptr<vector<ListCheckItemWarningMachineResponseBodyListWarningRiskList>> warningRiskList{};

  ListCheckItemWarningMachineResponseBodyList() {}

  explicit ListCheckItemWarningMachineResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authVersion) {
      res["AuthVersion"] = boost::any(*authVersion);
    }
    if (bind) {
      res["Bind"] = boost::any(*bind);
    }
    if (fixList) {
      vector<boost::any> temp1;
      for(auto item1:*fixList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FixList"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (portOpen) {
      res["PortOpen"] = boost::any(*portOpen);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (warningRiskList) {
      vector<boost::any> temp1;
      for(auto item1:*warningRiskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WarningRiskList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthVersion") != m.end() && !m["AuthVersion"].empty()) {
      authVersion = make_shared<long>(boost::any_cast<long>(m["AuthVersion"]));
    }
    if (m.find("Bind") != m.end() && !m["Bind"].empty()) {
      bind = make_shared<bool>(boost::any_cast<bool>(m["Bind"]));
    }
    if (m.find("FixList") != m.end() && !m["FixList"].empty()) {
      if (typeid(vector<boost::any>) == m["FixList"].type()) {
        vector<ListCheckItemWarningMachineResponseBodyListFixList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FixList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckItemWarningMachineResponseBodyListFixList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fixList = make_shared<vector<ListCheckItemWarningMachineResponseBodyListFixList>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("PortOpen") != m.end() && !m["PortOpen"].empty()) {
      portOpen = make_shared<bool>(boost::any_cast<bool>(m["PortOpen"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("WarningRiskList") != m.end() && !m["WarningRiskList"].empty()) {
      if (typeid(vector<boost::any>) == m["WarningRiskList"].type()) {
        vector<ListCheckItemWarningMachineResponseBodyListWarningRiskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WarningRiskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckItemWarningMachineResponseBodyListWarningRiskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        warningRiskList = make_shared<vector<ListCheckItemWarningMachineResponseBodyListWarningRiskList>>(expect1);
      }
    }
  }


  virtual ~ListCheckItemWarningMachineResponseBodyList() = default;
};
class ListCheckItemWarningMachineResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCheckItemWarningMachineResponseBodyPageInfo() {}

  explicit ListCheckItemWarningMachineResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCheckItemWarningMachineResponseBodyPageInfo() = default;
};
class ListCheckItemWarningMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCheckItemWarningMachineResponseBodyList>> list{};
  shared_ptr<ListCheckItemWarningMachineResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListCheckItemWarningMachineResponseBody() {}

  explicit ListCheckItemWarningMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCheckItemWarningMachineResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckItemWarningMachineResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCheckItemWarningMachineResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListCheckItemWarningMachineResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListCheckItemWarningMachineResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCheckItemWarningMachineResponseBody() = default;
};
class ListCheckItemWarningMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCheckItemWarningMachineResponseBody> body{};

  ListCheckItemWarningMachineResponse() {}

  explicit ListCheckItemWarningMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCheckItemWarningMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCheckItemWarningMachineResponseBody>(model1);
      }
    }
  }


  virtual ~ListCheckItemWarningMachineResponse() = default;
};
class ListCheckItemWarningSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkItemFuzzy{};
  shared_ptr<string> checkLevel{};
  shared_ptr<string> checkType{};
  shared_ptr<long> checkWarningStatus{};
  shared_ptr<string> containerFieldName{};
  shared_ptr<string> containerFieldValue{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> groupId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> riskType{};

  ListCheckItemWarningSummaryRequest() {}

  explicit ListCheckItemWarningSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkItemFuzzy) {
      res["CheckItemFuzzy"] = boost::any(*checkItemFuzzy);
    }
    if (checkLevel) {
      res["CheckLevel"] = boost::any(*checkLevel);
    }
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (checkWarningStatus) {
      res["CheckWarningStatus"] = boost::any(*checkWarningStatus);
    }
    if (containerFieldName) {
      res["ContainerFieldName"] = boost::any(*containerFieldName);
    }
    if (containerFieldValue) {
      res["ContainerFieldValue"] = boost::any(*containerFieldValue);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (riskType) {
      res["RiskType"] = boost::any(*riskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckItemFuzzy") != m.end() && !m["CheckItemFuzzy"].empty()) {
      checkItemFuzzy = make_shared<string>(boost::any_cast<string>(m["CheckItemFuzzy"]));
    }
    if (m.find("CheckLevel") != m.end() && !m["CheckLevel"].empty()) {
      checkLevel = make_shared<string>(boost::any_cast<string>(m["CheckLevel"]));
    }
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<string>(boost::any_cast<string>(m["CheckType"]));
    }
    if (m.find("CheckWarningStatus") != m.end() && !m["CheckWarningStatus"].empty()) {
      checkWarningStatus = make_shared<long>(boost::any_cast<long>(m["CheckWarningStatus"]));
    }
    if (m.find("ContainerFieldName") != m.end() && !m["ContainerFieldName"].empty()) {
      containerFieldName = make_shared<string>(boost::any_cast<string>(m["ContainerFieldName"]));
    }
    if (m.find("ContainerFieldValue") != m.end() && !m["ContainerFieldValue"].empty()) {
      containerFieldValue = make_shared<string>(boost::any_cast<string>(m["ContainerFieldValue"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RiskType") != m.end() && !m["RiskType"].empty()) {
      riskType = make_shared<string>(boost::any_cast<string>(m["RiskType"]));
    }
  }


  virtual ~ListCheckItemWarningSummaryRequest() = default;
};
class ListCheckItemWarningSummaryResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> alias{};
  shared_ptr<long> checkId{};
  shared_ptr<string> checkItem{};
  shared_ptr<string> checkLevel{};
  shared_ptr<string> checkType{};
  shared_ptr<string> description{};
  shared_ptr<string> riskType{};
  shared_ptr<long> status{};
  shared_ptr<long> warningMachineCount{};

  ListCheckItemWarningSummaryResponseBodyList() {}

  explicit ListCheckItemWarningSummaryResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (checkItem) {
      res["CheckItem"] = boost::any(*checkItem);
    }
    if (checkLevel) {
      res["CheckLevel"] = boost::any(*checkLevel);
    }
    if (checkType) {
      res["CheckType"] = boost::any(*checkType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (riskType) {
      res["RiskType"] = boost::any(*riskType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (warningMachineCount) {
      res["WarningMachineCount"] = boost::any(*warningMachineCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("CheckItem") != m.end() && !m["CheckItem"].empty()) {
      checkItem = make_shared<string>(boost::any_cast<string>(m["CheckItem"]));
    }
    if (m.find("CheckLevel") != m.end() && !m["CheckLevel"].empty()) {
      checkLevel = make_shared<string>(boost::any_cast<string>(m["CheckLevel"]));
    }
    if (m.find("CheckType") != m.end() && !m["CheckType"].empty()) {
      checkType = make_shared<string>(boost::any_cast<string>(m["CheckType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RiskType") != m.end() && !m["RiskType"].empty()) {
      riskType = make_shared<string>(boost::any_cast<string>(m["RiskType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("WarningMachineCount") != m.end() && !m["WarningMachineCount"].empty()) {
      warningMachineCount = make_shared<long>(boost::any_cast<long>(m["WarningMachineCount"]));
    }
  }


  virtual ~ListCheckItemWarningSummaryResponseBodyList() = default;
};
class ListCheckItemWarningSummaryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCheckItemWarningSummaryResponseBodyPageInfo() {}

  explicit ListCheckItemWarningSummaryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCheckItemWarningSummaryResponseBodyPageInfo() = default;
};
class ListCheckItemWarningSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCheckItemWarningSummaryResponseBodyList>> list{};
  shared_ptr<ListCheckItemWarningSummaryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListCheckItemWarningSummaryResponseBody() {}

  explicit ListCheckItemWarningSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCheckItemWarningSummaryResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckItemWarningSummaryResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCheckItemWarningSummaryResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListCheckItemWarningSummaryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListCheckItemWarningSummaryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCheckItemWarningSummaryResponseBody() = default;
};
class ListCheckItemWarningSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCheckItemWarningSummaryResponseBody> body{};

  ListCheckItemWarningSummaryResponse() {}

  explicit ListCheckItemWarningSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCheckItemWarningSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCheckItemWarningSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~ListCheckItemWarningSummaryResponse() = default;
};
class ListCheckResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkKey{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<long>> requirementIds{};
  shared_ptr<vector<string>> riskLevels{};
  shared_ptr<vector<string>> sortTypes{};
  shared_ptr<vector<long>> standardIds{};
  shared_ptr<vector<string>> statuses{};
  shared_ptr<vector<string>> types{};
  shared_ptr<vector<string>> vendors{};

  ListCheckResultRequest() {}

  explicit ListCheckResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkKey) {
      res["CheckKey"] = boost::any(*checkKey);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requirementIds) {
      res["RequirementIds"] = boost::any(*requirementIds);
    }
    if (riskLevels) {
      res["RiskLevels"] = boost::any(*riskLevels);
    }
    if (sortTypes) {
      res["SortTypes"] = boost::any(*sortTypes);
    }
    if (standardIds) {
      res["StandardIds"] = boost::any(*standardIds);
    }
    if (statuses) {
      res["Statuses"] = boost::any(*statuses);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    if (vendors) {
      res["Vendors"] = boost::any(*vendors);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckKey") != m.end() && !m["CheckKey"].empty()) {
      checkKey = make_shared<string>(boost::any_cast<string>(m["CheckKey"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequirementIds") != m.end() && !m["RequirementIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RequirementIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequirementIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      requirementIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RiskLevels") != m.end() && !m["RiskLevels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RiskLevels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RiskLevels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      riskLevels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SortTypes") != m.end() && !m["SortTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SortTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SortTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sortTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StandardIds") != m.end() && !m["StandardIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StandardIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StandardIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      standardIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Statuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Statuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statuses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Vendors") != m.end() && !m["Vendors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Vendors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Vendors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vendors = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListCheckResultRequest() = default;
};
class ListCheckResultResponseBodyChecksCheckPolicies : public Darabonba::Model {
public:
  shared_ptr<long> requirementId{};
  shared_ptr<string> requirementShowName{};
  shared_ptr<long> sectionId{};
  shared_ptr<string> sectionShowName{};
  shared_ptr<long> standardId{};
  shared_ptr<string> standardShowName{};

  ListCheckResultResponseBodyChecksCheckPolicies() {}

  explicit ListCheckResultResponseBodyChecksCheckPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requirementId) {
      res["RequirementId"] = boost::any(*requirementId);
    }
    if (requirementShowName) {
      res["RequirementShowName"] = boost::any(*requirementShowName);
    }
    if (sectionId) {
      res["SectionId"] = boost::any(*sectionId);
    }
    if (sectionShowName) {
      res["SectionShowName"] = boost::any(*sectionShowName);
    }
    if (standardId) {
      res["StandardId"] = boost::any(*standardId);
    }
    if (standardShowName) {
      res["StandardShowName"] = boost::any(*standardShowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequirementId") != m.end() && !m["RequirementId"].empty()) {
      requirementId = make_shared<long>(boost::any_cast<long>(m["RequirementId"]));
    }
    if (m.find("RequirementShowName") != m.end() && !m["RequirementShowName"].empty()) {
      requirementShowName = make_shared<string>(boost::any_cast<string>(m["RequirementShowName"]));
    }
    if (m.find("SectionId") != m.end() && !m["SectionId"].empty()) {
      sectionId = make_shared<long>(boost::any_cast<long>(m["SectionId"]));
    }
    if (m.find("SectionShowName") != m.end() && !m["SectionShowName"].empty()) {
      sectionShowName = make_shared<string>(boost::any_cast<string>(m["SectionShowName"]));
    }
    if (m.find("StandardId") != m.end() && !m["StandardId"].empty()) {
      standardId = make_shared<long>(boost::any_cast<long>(m["StandardId"]));
    }
    if (m.find("StandardShowName") != m.end() && !m["StandardShowName"].empty()) {
      standardShowName = make_shared<string>(boost::any_cast<string>(m["StandardShowName"]));
    }
  }


  virtual ~ListCheckResultResponseBodyChecksCheckPolicies() = default;
};
class ListCheckResultResponseBodyChecks : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<vector<ListCheckResultResponseBodyChecksCheckPolicies>> checkPolicies{};
  shared_ptr<string> checkShowName{};
  shared_ptr<string> instanceSubType{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> lastCheckTime{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<bool> trialPermission{};
  shared_ptr<string> vendor{};
  shared_ptr<string> vendorShowName{};

  ListCheckResultResponseBodyChecks() {}

  explicit ListCheckResultResponseBodyChecks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (checkPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*checkPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CheckPolicies"] = boost::any(temp1);
    }
    if (checkShowName) {
      res["CheckShowName"] = boost::any(*checkShowName);
    }
    if (instanceSubType) {
      res["InstanceSubType"] = boost::any(*instanceSubType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (lastCheckTime) {
      res["LastCheckTime"] = boost::any(*lastCheckTime);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (trialPermission) {
      res["TrialPermission"] = boost::any(*trialPermission);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    if (vendorShowName) {
      res["VendorShowName"] = boost::any(*vendorShowName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("CheckPolicies") != m.end() && !m["CheckPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["CheckPolicies"].type()) {
        vector<ListCheckResultResponseBodyChecksCheckPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CheckPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckResultResponseBodyChecksCheckPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checkPolicies = make_shared<vector<ListCheckResultResponseBodyChecksCheckPolicies>>(expect1);
      }
    }
    if (m.find("CheckShowName") != m.end() && !m["CheckShowName"].empty()) {
      checkShowName = make_shared<string>(boost::any_cast<string>(m["CheckShowName"]));
    }
    if (m.find("InstanceSubType") != m.end() && !m["InstanceSubType"].empty()) {
      instanceSubType = make_shared<string>(boost::any_cast<string>(m["InstanceSubType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("LastCheckTime") != m.end() && !m["LastCheckTime"].empty()) {
      lastCheckTime = make_shared<long>(boost::any_cast<long>(m["LastCheckTime"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TrialPermission") != m.end() && !m["TrialPermission"].empty()) {
      trialPermission = make_shared<bool>(boost::any_cast<bool>(m["TrialPermission"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<string>(boost::any_cast<string>(m["Vendor"]));
    }
    if (m.find("VendorShowName") != m.end() && !m["VendorShowName"].empty()) {
      vendorShowName = make_shared<string>(boost::any_cast<string>(m["VendorShowName"]));
    }
  }


  virtual ~ListCheckResultResponseBodyChecks() = default;
};
class ListCheckResultResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCheckResultResponseBodyPageInfo() {}

  explicit ListCheckResultResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCheckResultResponseBodyPageInfo() = default;
};
class ListCheckResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCheckResultResponseBodyChecks>> checks{};
  shared_ptr<ListCheckResultResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListCheckResultResponseBody() {}

  explicit ListCheckResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checks) {
      vector<boost::any> temp1;
      for(auto item1:*checks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Checks"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checks") != m.end() && !m["Checks"].empty()) {
      if (typeid(vector<boost::any>) == m["Checks"].type()) {
        vector<ListCheckResultResponseBodyChecks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Checks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckResultResponseBodyChecks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        checks = make_shared<vector<ListCheckResultResponseBodyChecks>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListCheckResultResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListCheckResultResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCheckResultResponseBody() = default;
};
class ListCheckResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCheckResultResponseBody> body{};

  ListCheckResultResponse() {}

  explicit ListCheckResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCheckResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCheckResultResponseBody>(model1);
      }
    }
  }


  virtual ~ListCheckResultResponse() = default;
};
class ListCheckStandardRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<vector<string>> instanceSubTypes{};
  shared_ptr<vector<string>> instanceTypes{};
  shared_ptr<string> lang{};
  shared_ptr<vector<string>> vendors{};

  ListCheckStandardRequest() {}

  explicit ListCheckStandardRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (instanceSubTypes) {
      res["InstanceSubTypes"] = boost::any(*instanceSubTypes);
    }
    if (instanceTypes) {
      res["InstanceTypes"] = boost::any(*instanceTypes);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (vendors) {
      res["Vendors"] = boost::any(*vendors);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceSubTypes") != m.end() && !m["InstanceSubTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceSubTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceSubTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceSubTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Vendors") != m.end() && !m["Vendors"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Vendors"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Vendors"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vendors = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListCheckStandardRequest() = default;
};
class ListCheckStandardResponseBodyStandardsRequirements : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> riskCheckCount{};
  shared_ptr<string> showName{};

  ListCheckStandardResponseBodyStandardsRequirements() {}

  explicit ListCheckStandardResponseBodyStandardsRequirements(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (riskCheckCount) {
      res["RiskCheckCount"] = boost::any(*riskCheckCount);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RiskCheckCount") != m.end() && !m["RiskCheckCount"].empty()) {
      riskCheckCount = make_shared<long>(boost::any_cast<long>(m["RiskCheckCount"]));
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
  }


  virtual ~ListCheckStandardResponseBodyStandardsRequirements() = default;
};
class ListCheckStandardResponseBodyStandards : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<vector<ListCheckStandardResponseBodyStandardsRequirements>> requirements{};
  shared_ptr<string> showName{};
  shared_ptr<string> type{};

  ListCheckStandardResponseBodyStandards() {}

  explicit ListCheckStandardResponseBodyStandards(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requirements) {
      vector<boost::any> temp1;
      for(auto item1:*requirements){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Requirements"] = boost::any(temp1);
    }
    if (showName) {
      res["ShowName"] = boost::any(*showName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Requirements") != m.end() && !m["Requirements"].empty()) {
      if (typeid(vector<boost::any>) == m["Requirements"].type()) {
        vector<ListCheckStandardResponseBodyStandardsRequirements> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Requirements"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckStandardResponseBodyStandardsRequirements model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requirements = make_shared<vector<ListCheckStandardResponseBodyStandardsRequirements>>(expect1);
      }
    }
    if (m.find("ShowName") != m.end() && !m["ShowName"].empty()) {
      showName = make_shared<string>(boost::any_cast<string>(m["ShowName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCheckStandardResponseBodyStandards() = default;
};
class ListCheckStandardResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListCheckStandardResponseBodyStandards>> standards{};

  ListCheckStandardResponseBody() {}

  explicit ListCheckStandardResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (standards) {
      vector<boost::any> temp1;
      for(auto item1:*standards){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Standards"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Standards") != m.end() && !m["Standards"].empty()) {
      if (typeid(vector<boost::any>) == m["Standards"].type()) {
        vector<ListCheckStandardResponseBodyStandards> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Standards"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCheckStandardResponseBodyStandards model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        standards = make_shared<vector<ListCheckStandardResponseBodyStandards>>(expect1);
      }
    }
  }


  virtual ~ListCheckStandardResponseBody() = default;
};
class ListCheckStandardResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCheckStandardResponseBody> body{};

  ListCheckStandardResponse() {}

  explicit ListCheckStandardResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCheckStandardResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCheckStandardResponseBody>(model1);
      }
    }
  }


  virtual ~ListCheckStandardResponse() = default;
};
class ListClientUserDefineRuleTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> userDefineRuleTypes{};

  ListClientUserDefineRuleTypesResponseBody() {}

  explicit ListClientUserDefineRuleTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userDefineRuleTypes) {
      res["UserDefineRuleTypes"] = boost::any(*userDefineRuleTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserDefineRuleTypes") != m.end() && !m["UserDefineRuleTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserDefineRuleTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserDefineRuleTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userDefineRuleTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListClientUserDefineRuleTypesResponseBody() = default;
};
class ListClientUserDefineRuleTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClientUserDefineRuleTypesResponseBody> body{};

  ListClientUserDefineRuleTypesResponse() {}

  explicit ListClientUserDefineRuleTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClientUserDefineRuleTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClientUserDefineRuleTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClientUserDefineRuleTypesResponse() = default;
};
class ListClientUserDefineRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<long>> type{};

  ListClientUserDefineRulesRequest() {}

  explicit ListClientUserDefineRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Type"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Type"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      type = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListClientUserDefineRulesRequest() = default;
};
class ListClientUserDefineRulesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListClientUserDefineRulesResponseBodyPageInfo() {}

  explicit ListClientUserDefineRulesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClientUserDefineRulesResponseBodyPageInfo() = default;
};
class ListClientUserDefineRulesResponseBodyUserDefineRuleList : public Darabonba::Model {
public:
  shared_ptr<long> actionType{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> platform{};
  shared_ptr<string> switchId{};
  shared_ptr<long> type{};

  ListClientUserDefineRulesResponseBodyUserDefineRuleList() {}

  explicit ListClientUserDefineRulesResponseBodyUserDefineRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (switchId) {
      res["SwitchId"] = boost::any(*switchId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<long>(boost::any_cast<long>(m["ActionType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("SwitchId") != m.end() && !m["SwitchId"].empty()) {
      switchId = make_shared<string>(boost::any_cast<string>(m["SwitchId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ListClientUserDefineRulesResponseBodyUserDefineRuleList() = default;
};
class ListClientUserDefineRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListClientUserDefineRulesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListClientUserDefineRulesResponseBodyUserDefineRuleList>> userDefineRuleList{};

  ListClientUserDefineRulesResponseBody() {}

  explicit ListClientUserDefineRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userDefineRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*userDefineRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserDefineRuleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListClientUserDefineRulesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListClientUserDefineRulesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserDefineRuleList") != m.end() && !m["UserDefineRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserDefineRuleList"].type()) {
        vector<ListClientUserDefineRulesResponseBodyUserDefineRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserDefineRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClientUserDefineRulesResponseBodyUserDefineRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userDefineRuleList = make_shared<vector<ListClientUserDefineRulesResponseBodyUserDefineRuleList>>(expect1);
      }
    }
  }


  virtual ~ListClientUserDefineRulesResponseBody() = default;
};
class ListClientUserDefineRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClientUserDefineRulesResponseBody> body{};

  ListClientUserDefineRulesResponse() {}

  explicit ListClientUserDefineRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClientUserDefineRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClientUserDefineRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListClientUserDefineRulesResponse() = default;
};
class ListCloudAssetInstancesRequestCloudAssetTypes : public Darabonba::Model {
public:
  shared_ptr<long> assetSubType{};
  shared_ptr<long> assetType{};

  ListCloudAssetInstancesRequestCloudAssetTypes() {}

  explicit ListCloudAssetInstancesRequestCloudAssetTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetSubType) {
      res["AssetSubType"] = boost::any(*assetSubType);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetSubType") != m.end() && !m["AssetSubType"].empty()) {
      assetSubType = make_shared<long>(boost::any_cast<long>(m["AssetSubType"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<long>(boost::any_cast<long>(m["AssetType"]));
    }
  }


  virtual ~ListCloudAssetInstancesRequestCloudAssetTypes() = default;
};
class ListCloudAssetInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudAssetInstancesRequestCloudAssetTypes>> cloudAssetTypes{};
  shared_ptr<string> criteria{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> logicalExp{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  ListCloudAssetInstancesRequest() {}

  explicit ListCloudAssetInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudAssetTypes) {
      vector<boost::any> temp1;
      for(auto item1:*cloudAssetTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudAssetTypes"] = boost::any(temp1);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (logicalExp) {
      res["LogicalExp"] = boost::any(*logicalExp);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudAssetTypes") != m.end() && !m["CloudAssetTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudAssetTypes"].type()) {
        vector<ListCloudAssetInstancesRequestCloudAssetTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudAssetTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudAssetInstancesRequestCloudAssetTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudAssetTypes = make_shared<vector<ListCloudAssetInstancesRequestCloudAssetTypes>>(expect1);
      }
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("LogicalExp") != m.end() && !m["LogicalExp"].empty()) {
      logicalExp = make_shared<string>(boost::any_cast<string>(m["LogicalExp"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListCloudAssetInstancesRequest() = default;
};
class ListCloudAssetInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> alarmStatus{};
  shared_ptr<string> assetSubType{};
  shared_ptr<string> assetSubTypeName{};
  shared_ptr<long> assetType{};
  shared_ptr<string> assetTypeName{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> riskStatus{};
  shared_ptr<string> securityInfo{};
  shared_ptr<long> vendor{};

  ListCloudAssetInstancesResponseBodyInstances() {}

  explicit ListCloudAssetInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStatus) {
      res["AlarmStatus"] = boost::any(*alarmStatus);
    }
    if (assetSubType) {
      res["AssetSubType"] = boost::any(*assetSubType);
    }
    if (assetSubTypeName) {
      res["AssetSubTypeName"] = boost::any(*assetSubTypeName);
    }
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (assetTypeName) {
      res["AssetTypeName"] = boost::any(*assetTypeName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (riskStatus) {
      res["RiskStatus"] = boost::any(*riskStatus);
    }
    if (securityInfo) {
      res["SecurityInfo"] = boost::any(*securityInfo);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStatus") != m.end() && !m["AlarmStatus"].empty()) {
      alarmStatus = make_shared<string>(boost::any_cast<string>(m["AlarmStatus"]));
    }
    if (m.find("AssetSubType") != m.end() && !m["AssetSubType"].empty()) {
      assetSubType = make_shared<string>(boost::any_cast<string>(m["AssetSubType"]));
    }
    if (m.find("AssetSubTypeName") != m.end() && !m["AssetSubTypeName"].empty()) {
      assetSubTypeName = make_shared<string>(boost::any_cast<string>(m["AssetSubTypeName"]));
    }
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<long>(boost::any_cast<long>(m["AssetType"]));
    }
    if (m.find("AssetTypeName") != m.end() && !m["AssetTypeName"].empty()) {
      assetTypeName = make_shared<string>(boost::any_cast<string>(m["AssetTypeName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RiskStatus") != m.end() && !m["RiskStatus"].empty()) {
      riskStatus = make_shared<string>(boost::any_cast<string>(m["RiskStatus"]));
    }
    if (m.find("SecurityInfo") != m.end() && !m["SecurityInfo"].empty()) {
      securityInfo = make_shared<string>(boost::any_cast<string>(m["SecurityInfo"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<long>(boost::any_cast<long>(m["Vendor"]));
    }
  }


  virtual ~ListCloudAssetInstancesResponseBodyInstances() = default;
};
class ListCloudAssetInstancesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCloudAssetInstancesResponseBodyPageInfo() {}

  explicit ListCloudAssetInstancesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCloudAssetInstancesResponseBodyPageInfo() = default;
};
class ListCloudAssetInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCloudAssetInstancesResponseBodyInstances>> instances{};
  shared_ptr<ListCloudAssetInstancesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListCloudAssetInstancesResponseBody() {}

  explicit ListCloudAssetInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListCloudAssetInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCloudAssetInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListCloudAssetInstancesResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListCloudAssetInstancesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListCloudAssetInstancesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCloudAssetInstancesResponseBody() = default;
};
class ListCloudAssetInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCloudAssetInstancesResponseBody> body{};

  ListCloudAssetInstancesResponse() {}

  explicit ListCloudAssetInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCloudAssetInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCloudAssetInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCloudAssetInstancesResponse() = default;
};
class ListClusterCnnfStatusDetailRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> clusterIds{};

  ListClusterCnnfStatusDetailRequest() {}

  explicit ListClusterCnnfStatusDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListClusterCnnfStatusDetailRequest() = default;
};
class ListClusterCnnfStatusDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<bool> installed{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> invalidType{};
  shared_ptr<string> machineName{};
  shared_ptr<long> machineType{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> pluginVersion{};
  shared_ptr<string> status{};
  shared_ptr<string> uuid{};

  ListClusterCnnfStatusDetailResponseBodyData() {}

  explicit ListClusterCnnfStatusDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (installed) {
      res["Installed"] = boost::any(*installed);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (invalidType) {
      res["InvalidType"] = boost::any(*invalidType);
    }
    if (machineName) {
      res["MachineName"] = boost::any(*machineName);
    }
    if (machineType) {
      res["MachineType"] = boost::any(*machineType);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (pluginVersion) {
      res["PluginVersion"] = boost::any(*pluginVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Installed") != m.end() && !m["Installed"].empty()) {
      installed = make_shared<bool>(boost::any_cast<bool>(m["Installed"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("InvalidType") != m.end() && !m["InvalidType"].empty()) {
      invalidType = make_shared<string>(boost::any_cast<string>(m["InvalidType"]));
    }
    if (m.find("MachineName") != m.end() && !m["MachineName"].empty()) {
      machineName = make_shared<string>(boost::any_cast<string>(m["MachineName"]));
    }
    if (m.find("MachineType") != m.end() && !m["MachineType"].empty()) {
      machineType = make_shared<long>(boost::any_cast<long>(m["MachineType"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("PluginVersion") != m.end() && !m["PluginVersion"].empty()) {
      pluginVersion = make_shared<string>(boost::any_cast<string>(m["PluginVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ListClusterCnnfStatusDetailResponseBodyData() = default;
};
class ListClusterCnnfStatusDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterCnnfStatusDetailResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListClusterCnnfStatusDetailResponseBody() {}

  explicit ListClusterCnnfStatusDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListClusterCnnfStatusDetailResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterCnnfStatusDetailResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListClusterCnnfStatusDetailResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClusterCnnfStatusDetailResponseBody() = default;
};
class ListClusterCnnfStatusDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterCnnfStatusDetailResponseBody> body{};

  ListClusterCnnfStatusDetailResponse() {}

  explicit ListClusterCnnfStatusDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterCnnfStatusDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterCnnfStatusDetailResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterCnnfStatusDetailResponse() = default;
};
class ListClusterInterceptionConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> clusterCNNFStatus{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  ListClusterInterceptionConfigRequest() {}

  explicit ListClusterInterceptionConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterCNNFStatus) {
      res["ClusterCNNFStatus"] = boost::any(*clusterCNNFStatus);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterCNNFStatus") != m.end() && !m["ClusterCNNFStatus"].empty()) {
      clusterCNNFStatus = make_shared<long>(boost::any_cast<long>(m["ClusterCNNFStatus"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListClusterInterceptionConfigRequest() = default;
};
class ListClusterInterceptionConfigResponseBodyClusterConfigList : public Darabonba::Model {
public:
  shared_ptr<long> clusterCNNFStatus{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterType{};
  shared_ptr<long> interceptionSwitch{};
  shared_ptr<long> openRuleCount{};
  shared_ptr<bool> supportCNNF{};
  shared_ptr<long> totalRuleCount{};

  ListClusterInterceptionConfigResponseBodyClusterConfigList() {}

  explicit ListClusterInterceptionConfigResponseBodyClusterConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterCNNFStatus) {
      res["ClusterCNNFStatus"] = boost::any(*clusterCNNFStatus);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterType) {
      res["ClusterType"] = boost::any(*clusterType);
    }
    if (interceptionSwitch) {
      res["InterceptionSwitch"] = boost::any(*interceptionSwitch);
    }
    if (openRuleCount) {
      res["OpenRuleCount"] = boost::any(*openRuleCount);
    }
    if (supportCNNF) {
      res["SupportCNNF"] = boost::any(*supportCNNF);
    }
    if (totalRuleCount) {
      res["TotalRuleCount"] = boost::any(*totalRuleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterCNNFStatus") != m.end() && !m["ClusterCNNFStatus"].empty()) {
      clusterCNNFStatus = make_shared<long>(boost::any_cast<long>(m["ClusterCNNFStatus"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterType") != m.end() && !m["ClusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["ClusterType"]));
    }
    if (m.find("InterceptionSwitch") != m.end() && !m["InterceptionSwitch"].empty()) {
      interceptionSwitch = make_shared<long>(boost::any_cast<long>(m["InterceptionSwitch"]));
    }
    if (m.find("OpenRuleCount") != m.end() && !m["OpenRuleCount"].empty()) {
      openRuleCount = make_shared<long>(boost::any_cast<long>(m["OpenRuleCount"]));
    }
    if (m.find("SupportCNNF") != m.end() && !m["SupportCNNF"].empty()) {
      supportCNNF = make_shared<bool>(boost::any_cast<bool>(m["SupportCNNF"]));
    }
    if (m.find("TotalRuleCount") != m.end() && !m["TotalRuleCount"].empty()) {
      totalRuleCount = make_shared<long>(boost::any_cast<long>(m["TotalRuleCount"]));
    }
  }


  virtual ~ListClusterInterceptionConfigResponseBodyClusterConfigList() = default;
};
class ListClusterInterceptionConfigResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currrentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListClusterInterceptionConfigResponseBodyPageInfo() {}

  explicit ListClusterInterceptionConfigResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currrentPage) {
      res["CurrrentPage"] = boost::any(*currrentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrrentPage") != m.end() && !m["CurrrentPage"].empty()) {
      currrentPage = make_shared<long>(boost::any_cast<long>(m["CurrrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListClusterInterceptionConfigResponseBodyPageInfo() = default;
};
class ListClusterInterceptionConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListClusterInterceptionConfigResponseBodyClusterConfigList>> clusterConfigList{};
  shared_ptr<ListClusterInterceptionConfigResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListClusterInterceptionConfigResponseBody() {}

  explicit ListClusterInterceptionConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*clusterConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterConfigList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterConfigList") != m.end() && !m["ClusterConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterConfigList"].type()) {
        vector<ListClusterInterceptionConfigResponseBodyClusterConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClusterInterceptionConfigResponseBodyClusterConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterConfigList = make_shared<vector<ListClusterInterceptionConfigResponseBodyClusterConfigList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListClusterInterceptionConfigResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListClusterInterceptionConfigResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClusterInterceptionConfigResponseBody() = default;
};
class ListClusterInterceptionConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListClusterInterceptionConfigResponseBody> body{};

  ListClusterInterceptionConfigResponse() {}

  explicit ListClusterInterceptionConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClusterInterceptionConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClusterInterceptionConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ListClusterInterceptionConfigResponse() = default;
};
class ListHoneypotRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<string>> honeypotIds{};
  shared_ptr<string> honeypotName{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> pageSize{};

  ListHoneypotRequest() {}

  explicit ListHoneypotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (honeypotIds) {
      res["HoneypotIds"] = boost::any(*honeypotIds);
    }
    if (honeypotName) {
      res["HoneypotName"] = boost::any(*honeypotName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("HoneypotIds") != m.end() && !m["HoneypotIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["HoneypotIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HoneypotIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      honeypotIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HoneypotName") != m.end() && !m["HoneypotName"].empty()) {
      honeypotName = make_shared<string>(boost::any_cast<string>(m["HoneypotName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListHoneypotRequest() = default;
};
class ListHoneypotResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> controlNodeName{};
  shared_ptr<string> honeypotId{};
  shared_ptr<string> honeypotImageDisplayName{};
  shared_ptr<string> honeypotImageId{};
  shared_ptr<string> honeypotImageName{};
  shared_ptr<string> honeypotName{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> presetId{};
  shared_ptr<vector<string>> state{};

  ListHoneypotResponseBodyList() {}

  explicit ListHoneypotResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (controlNodeName) {
      res["ControlNodeName"] = boost::any(*controlNodeName);
    }
    if (honeypotId) {
      res["HoneypotId"] = boost::any(*honeypotId);
    }
    if (honeypotImageDisplayName) {
      res["HoneypotImageDisplayName"] = boost::any(*honeypotImageDisplayName);
    }
    if (honeypotImageId) {
      res["HoneypotImageId"] = boost::any(*honeypotImageId);
    }
    if (honeypotImageName) {
      res["HoneypotImageName"] = boost::any(*honeypotImageName);
    }
    if (honeypotName) {
      res["HoneypotName"] = boost::any(*honeypotName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (presetId) {
      res["PresetId"] = boost::any(*presetId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ControlNodeName") != m.end() && !m["ControlNodeName"].empty()) {
      controlNodeName = make_shared<string>(boost::any_cast<string>(m["ControlNodeName"]));
    }
    if (m.find("HoneypotId") != m.end() && !m["HoneypotId"].empty()) {
      honeypotId = make_shared<string>(boost::any_cast<string>(m["HoneypotId"]));
    }
    if (m.find("HoneypotImageDisplayName") != m.end() && !m["HoneypotImageDisplayName"].empty()) {
      honeypotImageDisplayName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageDisplayName"]));
    }
    if (m.find("HoneypotImageId") != m.end() && !m["HoneypotImageId"].empty()) {
      honeypotImageId = make_shared<string>(boost::any_cast<string>(m["HoneypotImageId"]));
    }
    if (m.find("HoneypotImageName") != m.end() && !m["HoneypotImageName"].empty()) {
      honeypotImageName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageName"]));
    }
    if (m.find("HoneypotName") != m.end() && !m["HoneypotName"].empty()) {
      honeypotName = make_shared<string>(boost::any_cast<string>(m["HoneypotName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PresetId") != m.end() && !m["PresetId"].empty()) {
      presetId = make_shared<string>(boost::any_cast<string>(m["PresetId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["State"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["State"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      state = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListHoneypotResponseBodyList() = default;
};
class ListHoneypotResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListHoneypotResponseBodyPageInfo() {}

  explicit ListHoneypotResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHoneypotResponseBodyPageInfo() = default;
};
class ListHoneypotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListHoneypotResponseBodyList>> list{};
  shared_ptr<string> message{};
  shared_ptr<ListHoneypotResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListHoneypotResponseBody() {}

  explicit ListHoneypotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListHoneypotResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHoneypotResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListHoneypotResponseBodyList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListHoneypotResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListHoneypotResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListHoneypotResponseBody() = default;
};
class ListHoneypotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHoneypotResponseBody> body{};

  ListHoneypotResponse() {}

  explicit ListHoneypotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHoneypotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHoneypotResponseBody>(model1);
      }
    }
  }


  virtual ~ListHoneypotResponse() = default;
};
class ListHoneypotAlarmEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> dealed{};
  shared_ptr<string> dstIp{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> riskLevelList{};
  shared_ptr<string> srcIp{};

  ListHoneypotAlarmEventsRequest() {}

  explicit ListHoneypotAlarmEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (dealed) {
      res["Dealed"] = boost::any(*dealed);
    }
    if (dstIp) {
      res["DstIp"] = boost::any(*dstIp);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (riskLevelList) {
      res["RiskLevelList"] = boost::any(*riskLevelList);
    }
    if (srcIp) {
      res["SrcIp"] = boost::any(*srcIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Dealed") != m.end() && !m["Dealed"].empty()) {
      dealed = make_shared<string>(boost::any_cast<string>(m["Dealed"]));
    }
    if (m.find("DstIp") != m.end() && !m["DstIp"].empty()) {
      dstIp = make_shared<string>(boost::any_cast<string>(m["DstIp"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RiskLevelList") != m.end() && !m["RiskLevelList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RiskLevelList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RiskLevelList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      riskLevelList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SrcIp") != m.end() && !m["SrcIp"].empty()) {
      srcIp = make_shared<string>(boost::any_cast<string>(m["SrcIp"]));
    }
  }


  virtual ~ListHoneypotAlarmEventsRequest() = default;
};
class ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList : public Darabonba::Model {
public:
  shared_ptr<string> fieldExtInfo{};
  shared_ptr<string> fieldKey{};
  shared_ptr<string> fieldType{};
  shared_ptr<string> fieldValue{};

  ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList() {}

  explicit ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldExtInfo) {
      res["FieldExtInfo"] = boost::any(*fieldExtInfo);
    }
    if (fieldKey) {
      res["FieldKey"] = boost::any(*fieldKey);
    }
    if (fieldType) {
      res["FieldType"] = boost::any(*fieldType);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldExtInfo") != m.end() && !m["FieldExtInfo"].empty()) {
      fieldExtInfo = make_shared<string>(boost::any_cast<string>(m["FieldExtInfo"]));
    }
    if (m.find("FieldKey") != m.end() && !m["FieldKey"].empty()) {
      fieldKey = make_shared<string>(boost::any_cast<string>(m["FieldKey"]));
    }
    if (m.find("FieldType") != m.end() && !m["FieldType"].empty()) {
      fieldType = make_shared<string>(boost::any_cast<string>(m["FieldType"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
  }


  virtual ~ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList() = default;
};
class ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents : public Darabonba::Model {
public:
  shared_ptr<long> alarmEventId{};
  shared_ptr<string> alarmEventName{};
  shared_ptr<string> alarmEventType{};
  shared_ptr<string> alarmUniqueInfo{};
  shared_ptr<long> eventCount{};
  shared_ptr<long> firstTime{};
  shared_ptr<long> lastTime{};
  shared_ptr<vector<ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList>> mergeFieldList{};
  shared_ptr<long> operateStatus{};
  shared_ptr<string> riskLevel{};

  ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents() {}

  explicit ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmEventId) {
      res["AlarmEventId"] = boost::any(*alarmEventId);
    }
    if (alarmEventName) {
      res["AlarmEventName"] = boost::any(*alarmEventName);
    }
    if (alarmEventType) {
      res["AlarmEventType"] = boost::any(*alarmEventType);
    }
    if (alarmUniqueInfo) {
      res["AlarmUniqueInfo"] = boost::any(*alarmUniqueInfo);
    }
    if (eventCount) {
      res["EventCount"] = boost::any(*eventCount);
    }
    if (firstTime) {
      res["FirstTime"] = boost::any(*firstTime);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (mergeFieldList) {
      vector<boost::any> temp1;
      for(auto item1:*mergeFieldList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MergeFieldList"] = boost::any(temp1);
    }
    if (operateStatus) {
      res["OperateStatus"] = boost::any(*operateStatus);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmEventId") != m.end() && !m["AlarmEventId"].empty()) {
      alarmEventId = make_shared<long>(boost::any_cast<long>(m["AlarmEventId"]));
    }
    if (m.find("AlarmEventName") != m.end() && !m["AlarmEventName"].empty()) {
      alarmEventName = make_shared<string>(boost::any_cast<string>(m["AlarmEventName"]));
    }
    if (m.find("AlarmEventType") != m.end() && !m["AlarmEventType"].empty()) {
      alarmEventType = make_shared<string>(boost::any_cast<string>(m["AlarmEventType"]));
    }
    if (m.find("AlarmUniqueInfo") != m.end() && !m["AlarmUniqueInfo"].empty()) {
      alarmUniqueInfo = make_shared<string>(boost::any_cast<string>(m["AlarmUniqueInfo"]));
    }
    if (m.find("EventCount") != m.end() && !m["EventCount"].empty()) {
      eventCount = make_shared<long>(boost::any_cast<long>(m["EventCount"]));
    }
    if (m.find("FirstTime") != m.end() && !m["FirstTime"].empty()) {
      firstTime = make_shared<long>(boost::any_cast<long>(m["FirstTime"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
    if (m.find("MergeFieldList") != m.end() && !m["MergeFieldList"].empty()) {
      if (typeid(vector<boost::any>) == m["MergeFieldList"].type()) {
        vector<ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MergeFieldList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mergeFieldList = make_shared<vector<ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList>>(expect1);
      }
    }
    if (m.find("OperateStatus") != m.end() && !m["OperateStatus"].empty()) {
      operateStatus = make_shared<long>(boost::any_cast<long>(m["OperateStatus"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
  }


  virtual ~ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents() = default;
};
class ListHoneypotAlarmEventsResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListHoneypotAlarmEventsResponseBodyPageInfo() {}

  explicit ListHoneypotAlarmEventsResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHoneypotAlarmEventsResponseBodyPageInfo() = default;
};
class ListHoneypotAlarmEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents>> honeypotAlarmEvents{};
  shared_ptr<ListHoneypotAlarmEventsResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListHoneypotAlarmEventsResponseBody() {}

  explicit ListHoneypotAlarmEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotAlarmEvents) {
      vector<boost::any> temp1;
      for(auto item1:*honeypotAlarmEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HoneypotAlarmEvents"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotAlarmEvents") != m.end() && !m["HoneypotAlarmEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["HoneypotAlarmEvents"].type()) {
        vector<ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HoneypotAlarmEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        honeypotAlarmEvents = make_shared<vector<ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListHoneypotAlarmEventsResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListHoneypotAlarmEventsResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListHoneypotAlarmEventsResponseBody() = default;
};
class ListHoneypotAlarmEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHoneypotAlarmEventsResponseBody> body{};

  ListHoneypotAlarmEventsResponse() {}

  explicit ListHoneypotAlarmEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHoneypotAlarmEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHoneypotAlarmEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListHoneypotAlarmEventsResponse() = default;
};
class ListHoneypotNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> pageSize{};

  ListHoneypotNodeRequest() {}

  explicit ListHoneypotNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListHoneypotNodeRequest() = default;
};
class ListHoneypotNodeResponseBodyHoneypotNodeList : public Darabonba::Model {
public:
  shared_ptr<bool> allowHoneypotAccessInternet{};
  shared_ptr<string> createTime{};
  shared_ptr<bool> defaultNode{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<long> honeypotTotalCount{};
  shared_ptr<long> honeypotUsedCount{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeIp{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> probeTotalCount{};
  shared_ptr<long> probeUsedCount{};
  shared_ptr<vector<string>> securityGroupProbeIpList{};
  shared_ptr<long> totalStatus{};
  shared_ptr<bool> upgradeAvailable{};

  ListHoneypotNodeResponseBodyHoneypotNodeList() {}

  explicit ListHoneypotNodeResponseBodyHoneypotNodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowHoneypotAccessInternet) {
      res["AllowHoneypotAccessInternet"] = boost::any(*allowHoneypotAccessInternet);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (defaultNode) {
      res["DefaultNode"] = boost::any(*defaultNode);
    }
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (honeypotTotalCount) {
      res["HoneypotTotalCount"] = boost::any(*honeypotTotalCount);
    }
    if (honeypotUsedCount) {
      res["HoneypotUsedCount"] = boost::any(*honeypotUsedCount);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (probeTotalCount) {
      res["ProbeTotalCount"] = boost::any(*probeTotalCount);
    }
    if (probeUsedCount) {
      res["ProbeUsedCount"] = boost::any(*probeUsedCount);
    }
    if (securityGroupProbeIpList) {
      res["SecurityGroupProbeIpList"] = boost::any(*securityGroupProbeIpList);
    }
    if (totalStatus) {
      res["TotalStatus"] = boost::any(*totalStatus);
    }
    if (upgradeAvailable) {
      res["UpgradeAvailable"] = boost::any(*upgradeAvailable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowHoneypotAccessInternet") != m.end() && !m["AllowHoneypotAccessInternet"].empty()) {
      allowHoneypotAccessInternet = make_shared<bool>(boost::any_cast<bool>(m["AllowHoneypotAccessInternet"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DefaultNode") != m.end() && !m["DefaultNode"].empty()) {
      defaultNode = make_shared<bool>(boost::any_cast<bool>(m["DefaultNode"]));
    }
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("HoneypotTotalCount") != m.end() && !m["HoneypotTotalCount"].empty()) {
      honeypotTotalCount = make_shared<long>(boost::any_cast<long>(m["HoneypotTotalCount"]));
    }
    if (m.find("HoneypotUsedCount") != m.end() && !m["HoneypotUsedCount"].empty()) {
      honeypotUsedCount = make_shared<long>(boost::any_cast<long>(m["HoneypotUsedCount"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ProbeTotalCount") != m.end() && !m["ProbeTotalCount"].empty()) {
      probeTotalCount = make_shared<long>(boost::any_cast<long>(m["ProbeTotalCount"]));
    }
    if (m.find("ProbeUsedCount") != m.end() && !m["ProbeUsedCount"].empty()) {
      probeUsedCount = make_shared<long>(boost::any_cast<long>(m["ProbeUsedCount"]));
    }
    if (m.find("SecurityGroupProbeIpList") != m.end() && !m["SecurityGroupProbeIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupProbeIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupProbeIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupProbeIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalStatus") != m.end() && !m["TotalStatus"].empty()) {
      totalStatus = make_shared<long>(boost::any_cast<long>(m["TotalStatus"]));
    }
    if (m.find("UpgradeAvailable") != m.end() && !m["UpgradeAvailable"].empty()) {
      upgradeAvailable = make_shared<bool>(boost::any_cast<bool>(m["UpgradeAvailable"]));
    }
  }


  virtual ~ListHoneypotNodeResponseBodyHoneypotNodeList() = default;
};
class ListHoneypotNodeResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListHoneypotNodeResponseBodyPageInfo() {}

  explicit ListHoneypotNodeResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHoneypotNodeResponseBodyPageInfo() = default;
};
class ListHoneypotNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListHoneypotNodeResponseBodyHoneypotNodeList>> honeypotNodeList{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListHoneypotNodeResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListHoneypotNodeResponseBody() {}

  explicit ListHoneypotNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (honeypotNodeList) {
      vector<boost::any> temp1;
      for(auto item1:*honeypotNodeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HoneypotNodeList"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HoneypotNodeList") != m.end() && !m["HoneypotNodeList"].empty()) {
      if (typeid(vector<boost::any>) == m["HoneypotNodeList"].type()) {
        vector<ListHoneypotNodeResponseBodyHoneypotNodeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HoneypotNodeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHoneypotNodeResponseBodyHoneypotNodeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        honeypotNodeList = make_shared<vector<ListHoneypotNodeResponseBodyHoneypotNodeList>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListHoneypotNodeResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListHoneypotNodeResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListHoneypotNodeResponseBody() = default;
};
class ListHoneypotNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHoneypotNodeResponseBody> body{};

  ListHoneypotNodeResponse() {}

  explicit ListHoneypotNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHoneypotNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHoneypotNodeResponseBody>(model1);
      }
    }
  }


  virtual ~ListHoneypotNodeResponse() = default;
};
class ListHoneypotPresetRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> honeypotImageName{};
  shared_ptr<string> lang{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> presetName{};

  ListHoneypotPresetRequest() {}

  explicit ListHoneypotPresetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (honeypotImageName) {
      res["HoneypotImageName"] = boost::any(*honeypotImageName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (presetName) {
      res["PresetName"] = boost::any(*presetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("HoneypotImageName") != m.end() && !m["HoneypotImageName"].empty()) {
      honeypotImageName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PresetName") != m.end() && !m["PresetName"].empty()) {
      presetName = make_shared<string>(boost::any_cast<string>(m["PresetName"]));
    }
  }


  virtual ~ListHoneypotPresetRequest() = default;
};
class ListHoneypotPresetResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> controlNodeName{};
  shared_ptr<string> honeypotImageDisplayName{};
  shared_ptr<string> honeypotImageName{};
  shared_ptr<string> honeypotPresetId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> presetName{};
  shared_ptr<string> presetType{};

  ListHoneypotPresetResponseBodyList() {}

  explicit ListHoneypotPresetResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (controlNodeName) {
      res["ControlNodeName"] = boost::any(*controlNodeName);
    }
    if (honeypotImageDisplayName) {
      res["HoneypotImageDisplayName"] = boost::any(*honeypotImageDisplayName);
    }
    if (honeypotImageName) {
      res["HoneypotImageName"] = boost::any(*honeypotImageName);
    }
    if (honeypotPresetId) {
      res["HoneypotPresetId"] = boost::any(*honeypotPresetId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (presetName) {
      res["PresetName"] = boost::any(*presetName);
    }
    if (presetType) {
      res["PresetType"] = boost::any(*presetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ControlNodeName") != m.end() && !m["ControlNodeName"].empty()) {
      controlNodeName = make_shared<string>(boost::any_cast<string>(m["ControlNodeName"]));
    }
    if (m.find("HoneypotImageDisplayName") != m.end() && !m["HoneypotImageDisplayName"].empty()) {
      honeypotImageDisplayName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageDisplayName"]));
    }
    if (m.find("HoneypotImageName") != m.end() && !m["HoneypotImageName"].empty()) {
      honeypotImageName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageName"]));
    }
    if (m.find("HoneypotPresetId") != m.end() && !m["HoneypotPresetId"].empty()) {
      honeypotPresetId = make_shared<string>(boost::any_cast<string>(m["HoneypotPresetId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PresetName") != m.end() && !m["PresetName"].empty()) {
      presetName = make_shared<string>(boost::any_cast<string>(m["PresetName"]));
    }
    if (m.find("PresetType") != m.end() && !m["PresetType"].empty()) {
      presetType = make_shared<string>(boost::any_cast<string>(m["PresetType"]));
    }
  }


  virtual ~ListHoneypotPresetResponseBodyList() = default;
};
class ListHoneypotPresetResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListHoneypotPresetResponseBodyPageInfo() {}

  explicit ListHoneypotPresetResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHoneypotPresetResponseBodyPageInfo() = default;
};
class ListHoneypotPresetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListHoneypotPresetResponseBodyList>> list{};
  shared_ptr<string> message{};
  shared_ptr<ListHoneypotPresetResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListHoneypotPresetResponseBody() {}

  explicit ListHoneypotPresetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListHoneypotPresetResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHoneypotPresetResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListHoneypotPresetResponseBodyList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListHoneypotPresetResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListHoneypotPresetResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListHoneypotPresetResponseBody() = default;
};
class ListHoneypotPresetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHoneypotPresetResponseBody> body{};

  ListHoneypotPresetResponse() {}

  explicit ListHoneypotPresetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHoneypotPresetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHoneypotPresetResponseBody>(model1);
      }
    }
  }


  virtual ~ListHoneypotPresetResponse() = default;
};
class ListHoneypotProbeRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> displayName{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> probeStatus{};
  shared_ptr<string> probeType{};

  ListHoneypotProbeRequest() {}

  explicit ListHoneypotProbeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (probeStatus) {
      res["ProbeStatus"] = boost::any(*probeStatus);
    }
    if (probeType) {
      res["ProbeType"] = boost::any(*probeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProbeStatus") != m.end() && !m["ProbeStatus"].empty()) {
      probeStatus = make_shared<string>(boost::any_cast<string>(m["ProbeStatus"]));
    }
    if (m.find("ProbeType") != m.end() && !m["ProbeType"].empty()) {
      probeType = make_shared<string>(boost::any_cast<string>(m["ProbeType"]));
    }
  }


  virtual ~ListHoneypotProbeRequest() = default;
};
class ListHoneypotProbeResponseBodyListControlNode : public Darabonba::Model {
public:
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};

  ListHoneypotProbeResponseBodyListControlNode() {}

  explicit ListHoneypotProbeResponseBodyListControlNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsInstanceId) {
      res["EcsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EcsInstanceId") != m.end() && !m["EcsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["EcsInstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~ListHoneypotProbeResponseBodyListControlNode() = default;
};
class ListHoneypotProbeResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<ListHoneypotProbeResponseBodyListControlNode> controlNode{};
  shared_ptr<long> deployTime{};
  shared_ptr<string> displayName{};
  shared_ptr<string> hostIp{};
  shared_ptr<string> osType{};
  shared_ptr<string> probeId{};
  shared_ptr<string> probeType{};
  shared_ptr<string> probeVersion{};
  shared_ptr<string> status{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vpcId{};

  ListHoneypotProbeResponseBodyList() {}

  explicit ListHoneypotProbeResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (controlNode) {
      res["ControlNode"] = controlNode ? boost::any(controlNode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (hostIp) {
      res["HostIp"] = boost::any(*hostIp);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (probeId) {
      res["ProbeId"] = boost::any(*probeId);
    }
    if (probeType) {
      res["ProbeType"] = boost::any(*probeType);
    }
    if (probeVersion) {
      res["ProbeVersion"] = boost::any(*probeVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ControlNode") != m.end() && !m["ControlNode"].empty()) {
      if (typeid(map<string, boost::any>) == m["ControlNode"].type()) {
        ListHoneypotProbeResponseBodyListControlNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ControlNode"]));
        controlNode = make_shared<ListHoneypotProbeResponseBodyListControlNode>(model1);
      }
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<long>(boost::any_cast<long>(m["DeployTime"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("HostIp") != m.end() && !m["HostIp"].empty()) {
      hostIp = make_shared<string>(boost::any_cast<string>(m["HostIp"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("ProbeId") != m.end() && !m["ProbeId"].empty()) {
      probeId = make_shared<string>(boost::any_cast<string>(m["ProbeId"]));
    }
    if (m.find("ProbeType") != m.end() && !m["ProbeType"].empty()) {
      probeType = make_shared<string>(boost::any_cast<string>(m["ProbeType"]));
    }
    if (m.find("ProbeVersion") != m.end() && !m["ProbeVersion"].empty()) {
      probeVersion = make_shared<string>(boost::any_cast<string>(m["ProbeVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListHoneypotProbeResponseBodyList() = default;
};
class ListHoneypotProbeResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListHoneypotProbeResponseBodyPageInfo() {}

  explicit ListHoneypotProbeResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHoneypotProbeResponseBodyPageInfo() = default;
};
class ListHoneypotProbeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListHoneypotProbeResponseBodyList>> list{};
  shared_ptr<string> message{};
  shared_ptr<ListHoneypotProbeResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListHoneypotProbeResponseBody() {}

  explicit ListHoneypotProbeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListHoneypotProbeResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHoneypotProbeResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListHoneypotProbeResponseBodyList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListHoneypotProbeResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListHoneypotProbeResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListHoneypotProbeResponseBody() = default;
};
class ListHoneypotProbeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHoneypotProbeResponseBody> body{};

  ListHoneypotProbeResponse() {}

  explicit ListHoneypotProbeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHoneypotProbeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHoneypotProbeResponseBody>(model1);
      }
    }
  }


  virtual ~ListHoneypotProbeResponse() = default;
};
class ListImageRegistryRegionResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};

  ListImageRegistryRegionResponseBodyRegions() {}

  explicit ListImageRegistryRegionResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
  }


  virtual ~ListImageRegistryRegionResponseBodyRegions() = default;
};
class ListImageRegistryRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListImageRegistryRegionResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  ListImageRegistryRegionResponseBody() {}

  explicit ListImageRegistryRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<ListImageRegistryRegionResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListImageRegistryRegionResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<ListImageRegistryRegionResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListImageRegistryRegionResponseBody() = default;
};
class ListImageRegistryRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListImageRegistryRegionResponseBody> body{};

  ListImageRegistryRegionResponse() {}

  explicit ListImageRegistryRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListImageRegistryRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListImageRegistryRegionResponseBody>(model1);
      }
    }
  }


  virtual ~ListImageRegistryRegionResponse() = default;
};
class ListImageRiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> imageName{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageSize{};

  ListImageRiskRequest() {}

  explicit ListImageRiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (imageName) {
      res["ImageName"] = boost::any(*imageName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ImageName") != m.end() && !m["ImageName"].empty()) {
      imageName = make_shared<string>(boost::any_cast<string>(m["ImageName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListImageRiskRequest() = default;
};
class ListImageRiskResponseBodyImageRiskListEndPointList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> type{};

  ListImageRiskResponseBodyImageRiskListEndPointList() {}

  explicit ListImageRiskResponseBodyImageRiskListEndPointList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListImageRiskResponseBodyImageRiskListEndPointList() = default;
};
class ListImageRiskResponseBodyImageRiskList : public Darabonba::Model {
public:
  shared_ptr<string> digest{};
  shared_ptr<vector<ListImageRiskResponseBodyImageRiskListEndPointList>> endPointList{};
  shared_ptr<string> endpoints{};
  shared_ptr<string> image{};
  shared_ptr<string> imageAccessType{};
  shared_ptr<string> imageId{};
  shared_ptr<string> internetURLs{};
  shared_ptr<string> regionId{};
  shared_ptr<string> registryType{};
  shared_ptr<string> repoId{};
  shared_ptr<string> repoName{};
  shared_ptr<string> repoNamespace{};
  shared_ptr<string> repoType{};
  shared_ptr<string> statistics{};
  shared_ptr<string> tag{};
  shared_ptr<long> tagImmutable{};
  shared_ptr<string> uuid{};
  shared_ptr<string> vpcURLs{};

  ListImageRiskResponseBodyImageRiskList() {}

  explicit ListImageRiskResponseBodyImageRiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (digest) {
      res["Digest"] = boost::any(*digest);
    }
    if (endPointList) {
      vector<boost::any> temp1;
      for(auto item1:*endPointList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndPointList"] = boost::any(temp1);
    }
    if (endpoints) {
      res["Endpoints"] = boost::any(*endpoints);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (imageAccessType) {
      res["ImageAccessType"] = boost::any(*imageAccessType);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (internetURLs) {
      res["InternetURLs"] = boost::any(*internetURLs);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (repoId) {
      res["RepoId"] = boost::any(*repoId);
    }
    if (repoName) {
      res["RepoName"] = boost::any(*repoName);
    }
    if (repoNamespace) {
      res["RepoNamespace"] = boost::any(*repoNamespace);
    }
    if (repoType) {
      res["RepoType"] = boost::any(*repoType);
    }
    if (statistics) {
      res["Statistics"] = boost::any(*statistics);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tagImmutable) {
      res["TagImmutable"] = boost::any(*tagImmutable);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vpcURLs) {
      res["VpcURLs"] = boost::any(*vpcURLs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Digest") != m.end() && !m["Digest"].empty()) {
      digest = make_shared<string>(boost::any_cast<string>(m["Digest"]));
    }
    if (m.find("EndPointList") != m.end() && !m["EndPointList"].empty()) {
      if (typeid(vector<boost::any>) == m["EndPointList"].type()) {
        vector<ListImageRiskResponseBodyImageRiskListEndPointList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndPointList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListImageRiskResponseBodyImageRiskListEndPointList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endPointList = make_shared<vector<ListImageRiskResponseBodyImageRiskListEndPointList>>(expect1);
      }
    }
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      endpoints = make_shared<string>(boost::any_cast<string>(m["Endpoints"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("ImageAccessType") != m.end() && !m["ImageAccessType"].empty()) {
      imageAccessType = make_shared<string>(boost::any_cast<string>(m["ImageAccessType"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("InternetURLs") != m.end() && !m["InternetURLs"].empty()) {
      internetURLs = make_shared<string>(boost::any_cast<string>(m["InternetURLs"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("RepoId") != m.end() && !m["RepoId"].empty()) {
      repoId = make_shared<string>(boost::any_cast<string>(m["RepoId"]));
    }
    if (m.find("RepoName") != m.end() && !m["RepoName"].empty()) {
      repoName = make_shared<string>(boost::any_cast<string>(m["RepoName"]));
    }
    if (m.find("RepoNamespace") != m.end() && !m["RepoNamespace"].empty()) {
      repoNamespace = make_shared<string>(boost::any_cast<string>(m["RepoNamespace"]));
    }
    if (m.find("RepoType") != m.end() && !m["RepoType"].empty()) {
      repoType = make_shared<string>(boost::any_cast<string>(m["RepoType"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      statistics = make_shared<string>(boost::any_cast<string>(m["Statistics"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TagImmutable") != m.end() && !m["TagImmutable"].empty()) {
      tagImmutable = make_shared<long>(boost::any_cast<long>(m["TagImmutable"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("VpcURLs") != m.end() && !m["VpcURLs"].empty()) {
      vpcURLs = make_shared<string>(boost::any_cast<string>(m["VpcURLs"]));
    }
  }


  virtual ~ListImageRiskResponseBodyImageRiskList() = default;
};
class ListImageRiskResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListImageRiskResponseBodyPageInfo() {}

  explicit ListImageRiskResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListImageRiskResponseBodyPageInfo() = default;
};
class ListImageRiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListImageRiskResponseBodyImageRiskList>> imageRiskList{};
  shared_ptr<ListImageRiskResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListImageRiskResponseBody() {}

  explicit ListImageRiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageRiskList) {
      vector<boost::any> temp1;
      for(auto item1:*imageRiskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageRiskList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageRiskList") != m.end() && !m["ImageRiskList"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageRiskList"].type()) {
        vector<ListImageRiskResponseBodyImageRiskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageRiskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListImageRiskResponseBodyImageRiskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageRiskList = make_shared<vector<ListImageRiskResponseBodyImageRiskList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListImageRiskResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListImageRiskResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListImageRiskResponseBody() = default;
};
class ListImageRiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListImageRiskResponseBody> body{};

  ListImageRiskResponse() {}

  explicit ListImageRiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListImageRiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListImageRiskResponseBody>(model1);
      }
    }
  }


  virtual ~ListImageRiskResponse() = default;
};
class ListInstanceCatalogRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<long>> requirementIds{};
  shared_ptr<vector<long>> standardIds{};
  shared_ptr<vector<string>> types{};

  ListInstanceCatalogRequest() {}

  explicit ListInstanceCatalogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requirementIds) {
      res["RequirementIds"] = boost::any(*requirementIds);
    }
    if (standardIds) {
      res["StandardIds"] = boost::any(*standardIds);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequirementIds") != m.end() && !m["RequirementIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RequirementIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RequirementIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      requirementIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("StandardIds") != m.end() && !m["StandardIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["StandardIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StandardIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      standardIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListInstanceCatalogRequest() = default;
};
class ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes() {}

  explicit ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes() = default;
};
class ListInstanceCatalogResponseBodyVendorsInstanceTypes : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes>> instanceSubTypes{};
  shared_ptr<string> name{};

  ListInstanceCatalogResponseBodyVendorsInstanceTypes() {}

  explicit ListInstanceCatalogResponseBodyVendorsInstanceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSubTypes) {
      vector<boost::any> temp1;
      for(auto item1:*instanceSubTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceSubTypes"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSubTypes") != m.end() && !m["InstanceSubTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceSubTypes"].type()) {
        vector<ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceSubTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceSubTypes = make_shared<vector<ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListInstanceCatalogResponseBodyVendorsInstanceTypes() = default;
};
class ListInstanceCatalogResponseBodyVendors : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstanceCatalogResponseBodyVendorsInstanceTypes>> instanceTypes{};
  shared_ptr<string> name{};

  ListInstanceCatalogResponseBodyVendors() {}

  explicit ListInstanceCatalogResponseBodyVendors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTypes) {
      vector<boost::any> temp1;
      for(auto item1:*instanceTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceTypes"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTypes") != m.end() && !m["InstanceTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceTypes"].type()) {
        vector<ListInstanceCatalogResponseBodyVendorsInstanceTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceCatalogResponseBodyVendorsInstanceTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceTypes = make_shared<vector<ListInstanceCatalogResponseBodyVendorsInstanceTypes>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListInstanceCatalogResponseBodyVendors() = default;
};
class ListInstanceCatalogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListInstanceCatalogResponseBodyVendors>> vendors{};

  ListInstanceCatalogResponseBody() {}

  explicit ListInstanceCatalogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vendors) {
      vector<boost::any> temp1;
      for(auto item1:*vendors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Vendors"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Vendors") != m.end() && !m["Vendors"].empty()) {
      if (typeid(vector<boost::any>) == m["Vendors"].type()) {
        vector<ListInstanceCatalogResponseBodyVendors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Vendors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceCatalogResponseBodyVendors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vendors = make_shared<vector<ListInstanceCatalogResponseBodyVendors>>(expect1);
      }
    }
  }


  virtual ~ListInstanceCatalogResponseBody() = default;
};
class ListInstanceCatalogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstanceCatalogResponseBody> body{};

  ListInstanceCatalogResponse() {}

  explicit ListInstanceCatalogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceCatalogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceCatalogResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceCatalogResponse() = default;
};
class ListInterceptionHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> endTime{};
  shared_ptr<string> historyName{};
  shared_ptr<vector<long>> interceptionTypes{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListInterceptionHistoryRequest() {}

  explicit ListInterceptionHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (historyName) {
      res["HistoryName"] = boost::any(*historyName);
    }
    if (interceptionTypes) {
      res["InterceptionTypes"] = boost::any(*interceptionTypes);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("HistoryName") != m.end() && !m["HistoryName"].empty()) {
      historyName = make_shared<string>(boost::any_cast<string>(m["HistoryName"]));
    }
    if (m.find("InterceptionTypes") != m.end() && !m["InterceptionTypes"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["InterceptionTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InterceptionTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      interceptionTypes = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListInterceptionHistoryRequest() = default;
};
class ListInterceptionHistoryResponseBodyInterceptionHistoryList : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> dstAppName{};
  shared_ptr<string> dstNamespace{};
  shared_ptr<long> dstPort{};
  shared_ptr<string> dstRuleTargetName{};
  shared_ptr<long> firstTime{};
  shared_ptr<long> id{};
  shared_ptr<long> interceptionName{};
  shared_ptr<long> interceptionType{};
  shared_ptr<long> lastTime{};
  shared_ptr<string> realDstAppName{};
  shared_ptr<string> realDstImageName{};
  shared_ptr<string> realDstNamespace{};
  shared_ptr<string> realDstPodName{};
  shared_ptr<long> realInterceptionType{};
  shared_ptr<string> realSrcAppName{};
  shared_ptr<string> realSrcImageName{};
  shared_ptr<string> realSrcNamespace{};
  shared_ptr<string> realSrcPodName{};
  shared_ptr<long> riskLevel{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> srcAppName{};
  shared_ptr<string> srcNamespace{};
  shared_ptr<string> srcRuleTargetName{};
  shared_ptr<long> status{};
  shared_ptr<long> tryCount{};

  ListInterceptionHistoryResponseBodyInterceptionHistoryList() {}

  explicit ListInterceptionHistoryResponseBodyInterceptionHistoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (dstAppName) {
      res["DstAppName"] = boost::any(*dstAppName);
    }
    if (dstNamespace) {
      res["DstNamespace"] = boost::any(*dstNamespace);
    }
    if (dstPort) {
      res["DstPort"] = boost::any(*dstPort);
    }
    if (dstRuleTargetName) {
      res["DstRuleTargetName"] = boost::any(*dstRuleTargetName);
    }
    if (firstTime) {
      res["FirstTime"] = boost::any(*firstTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (interceptionName) {
      res["InterceptionName"] = boost::any(*interceptionName);
    }
    if (interceptionType) {
      res["InterceptionType"] = boost::any(*interceptionType);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (realDstAppName) {
      res["RealDstAppName"] = boost::any(*realDstAppName);
    }
    if (realDstImageName) {
      res["RealDstImageName"] = boost::any(*realDstImageName);
    }
    if (realDstNamespace) {
      res["RealDstNamespace"] = boost::any(*realDstNamespace);
    }
    if (realDstPodName) {
      res["RealDstPodName"] = boost::any(*realDstPodName);
    }
    if (realInterceptionType) {
      res["RealInterceptionType"] = boost::any(*realInterceptionType);
    }
    if (realSrcAppName) {
      res["RealSrcAppName"] = boost::any(*realSrcAppName);
    }
    if (realSrcImageName) {
      res["RealSrcImageName"] = boost::any(*realSrcImageName);
    }
    if (realSrcNamespace) {
      res["RealSrcNamespace"] = boost::any(*realSrcNamespace);
    }
    if (realSrcPodName) {
      res["RealSrcPodName"] = boost::any(*realSrcPodName);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (srcAppName) {
      res["SrcAppName"] = boost::any(*srcAppName);
    }
    if (srcNamespace) {
      res["SrcNamespace"] = boost::any(*srcNamespace);
    }
    if (srcRuleTargetName) {
      res["SrcRuleTargetName"] = boost::any(*srcRuleTargetName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tryCount) {
      res["TryCount"] = boost::any(*tryCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("DstAppName") != m.end() && !m["DstAppName"].empty()) {
      dstAppName = make_shared<string>(boost::any_cast<string>(m["DstAppName"]));
    }
    if (m.find("DstNamespace") != m.end() && !m["DstNamespace"].empty()) {
      dstNamespace = make_shared<string>(boost::any_cast<string>(m["DstNamespace"]));
    }
    if (m.find("DstPort") != m.end() && !m["DstPort"].empty()) {
      dstPort = make_shared<long>(boost::any_cast<long>(m["DstPort"]));
    }
    if (m.find("DstRuleTargetName") != m.end() && !m["DstRuleTargetName"].empty()) {
      dstRuleTargetName = make_shared<string>(boost::any_cast<string>(m["DstRuleTargetName"]));
    }
    if (m.find("FirstTime") != m.end() && !m["FirstTime"].empty()) {
      firstTime = make_shared<long>(boost::any_cast<long>(m["FirstTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InterceptionName") != m.end() && !m["InterceptionName"].empty()) {
      interceptionName = make_shared<long>(boost::any_cast<long>(m["InterceptionName"]));
    }
    if (m.find("InterceptionType") != m.end() && !m["InterceptionType"].empty()) {
      interceptionType = make_shared<long>(boost::any_cast<long>(m["InterceptionType"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
    if (m.find("RealDstAppName") != m.end() && !m["RealDstAppName"].empty()) {
      realDstAppName = make_shared<string>(boost::any_cast<string>(m["RealDstAppName"]));
    }
    if (m.find("RealDstImageName") != m.end() && !m["RealDstImageName"].empty()) {
      realDstImageName = make_shared<string>(boost::any_cast<string>(m["RealDstImageName"]));
    }
    if (m.find("RealDstNamespace") != m.end() && !m["RealDstNamespace"].empty()) {
      realDstNamespace = make_shared<string>(boost::any_cast<string>(m["RealDstNamespace"]));
    }
    if (m.find("RealDstPodName") != m.end() && !m["RealDstPodName"].empty()) {
      realDstPodName = make_shared<string>(boost::any_cast<string>(m["RealDstPodName"]));
    }
    if (m.find("RealInterceptionType") != m.end() && !m["RealInterceptionType"].empty()) {
      realInterceptionType = make_shared<long>(boost::any_cast<long>(m["RealInterceptionType"]));
    }
    if (m.find("RealSrcAppName") != m.end() && !m["RealSrcAppName"].empty()) {
      realSrcAppName = make_shared<string>(boost::any_cast<string>(m["RealSrcAppName"]));
    }
    if (m.find("RealSrcImageName") != m.end() && !m["RealSrcImageName"].empty()) {
      realSrcImageName = make_shared<string>(boost::any_cast<string>(m["RealSrcImageName"]));
    }
    if (m.find("RealSrcNamespace") != m.end() && !m["RealSrcNamespace"].empty()) {
      realSrcNamespace = make_shared<string>(boost::any_cast<string>(m["RealSrcNamespace"]));
    }
    if (m.find("RealSrcPodName") != m.end() && !m["RealSrcPodName"].empty()) {
      realSrcPodName = make_shared<string>(boost::any_cast<string>(m["RealSrcPodName"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SrcAppName") != m.end() && !m["SrcAppName"].empty()) {
      srcAppName = make_shared<string>(boost::any_cast<string>(m["SrcAppName"]));
    }
    if (m.find("SrcNamespace") != m.end() && !m["SrcNamespace"].empty()) {
      srcNamespace = make_shared<string>(boost::any_cast<string>(m["SrcNamespace"]));
    }
    if (m.find("SrcRuleTargetName") != m.end() && !m["SrcRuleTargetName"].empty()) {
      srcRuleTargetName = make_shared<string>(boost::any_cast<string>(m["SrcRuleTargetName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TryCount") != m.end() && !m["TryCount"].empty()) {
      tryCount = make_shared<long>(boost::any_cast<long>(m["TryCount"]));
    }
  }


  virtual ~ListInterceptionHistoryResponseBodyInterceptionHistoryList() = default;
};
class ListInterceptionHistoryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListInterceptionHistoryResponseBodyPageInfo() {}

  explicit ListInterceptionHistoryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInterceptionHistoryResponseBodyPageInfo() = default;
};
class ListInterceptionHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListInterceptionHistoryResponseBodyInterceptionHistoryList>> interceptionHistoryList{};
  shared_ptr<ListInterceptionHistoryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListInterceptionHistoryResponseBody() {}

  explicit ListInterceptionHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interceptionHistoryList) {
      vector<boost::any> temp1;
      for(auto item1:*interceptionHistoryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InterceptionHistoryList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InterceptionHistoryList") != m.end() && !m["InterceptionHistoryList"].empty()) {
      if (typeid(vector<boost::any>) == m["InterceptionHistoryList"].type()) {
        vector<ListInterceptionHistoryResponseBodyInterceptionHistoryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InterceptionHistoryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInterceptionHistoryResponseBodyInterceptionHistoryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        interceptionHistoryList = make_shared<vector<ListInterceptionHistoryResponseBodyInterceptionHistoryList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListInterceptionHistoryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListInterceptionHistoryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInterceptionHistoryResponseBody() = default;
};
class ListInterceptionHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInterceptionHistoryResponseBody> body{};

  ListInterceptionHistoryResponse() {}

  explicit ListInterceptionHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInterceptionHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInterceptionHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~ListInterceptionHistoryResponse() = default;
};
class ListInterceptionRulePageRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> criteria{};
  shared_ptr<string> criteriaType{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};

  ListInterceptionRulePageRequest() {}

  explicit ListInterceptionRulePageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (criteriaType) {
      res["CriteriaType"] = boost::any(*criteriaType);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("CriteriaType") != m.end() && !m["CriteriaType"].empty()) {
      criteriaType = make_shared<string>(boost::any_cast<string>(m["CriteriaType"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListInterceptionRulePageRequest() = default;
};
class ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<vector<string>> imageList{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<string>> ports{};
  shared_ptr<string> ruleType{};
  shared_ptr<vector<string>> tagList{};
  shared_ptr<long> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};

  ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget() {}

  explicit ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (imageList) {
      res["ImageList"] = boost::any(*imageList);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (ports) {
      res["Ports"] = boost::any(*ports);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ImageList") != m.end() && !m["ImageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ports"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ports = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<long>(boost::any_cast<long>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget() = default;
};
class ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<vector<string>> imageList{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> ruleType{};
  shared_ptr<vector<string>> tagList{};
  shared_ptr<long> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};

  ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget() {}

  explicit ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (imageList) {
      res["ImageList"] = boost::any(*imageList);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ImageList") != m.end() && !m["ImageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<long>(boost::any_cast<long>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget() = default;
};
class ListInterceptionRulePageResponseBodyInterceptionRuleList : public Darabonba::Model {
public:
  shared_ptr<ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget> dstTarget{};
  shared_ptr<long> interceptType{};
  shared_ptr<long> orderIndex{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleSwitch{};
  shared_ptr<string> ruleType{};
  shared_ptr<ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget> srcTarget{};

  ListInterceptionRulePageResponseBodyInterceptionRuleList() {}

  explicit ListInterceptionRulePageResponseBodyInterceptionRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dstTarget) {
      res["DstTarget"] = dstTarget ? boost::any(dstTarget->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interceptType) {
      res["InterceptType"] = boost::any(*interceptType);
    }
    if (orderIndex) {
      res["OrderIndex"] = boost::any(*orderIndex);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleSwitch) {
      res["RuleSwitch"] = boost::any(*ruleSwitch);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (srcTarget) {
      res["SrcTarget"] = srcTarget ? boost::any(srcTarget->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DstTarget") != m.end() && !m["DstTarget"].empty()) {
      if (typeid(map<string, boost::any>) == m["DstTarget"].type()) {
        ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DstTarget"]));
        dstTarget = make_shared<ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget>(model1);
      }
    }
    if (m.find("InterceptType") != m.end() && !m["InterceptType"].empty()) {
      interceptType = make_shared<long>(boost::any_cast<long>(m["InterceptType"]));
    }
    if (m.find("OrderIndex") != m.end() && !m["OrderIndex"].empty()) {
      orderIndex = make_shared<long>(boost::any_cast<long>(m["OrderIndex"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleSwitch") != m.end() && !m["RuleSwitch"].empty()) {
      ruleSwitch = make_shared<long>(boost::any_cast<long>(m["RuleSwitch"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("SrcTarget") != m.end() && !m["SrcTarget"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcTarget"].type()) {
        ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcTarget"]));
        srcTarget = make_shared<ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget>(model1);
      }
    }
  }


  virtual ~ListInterceptionRulePageResponseBodyInterceptionRuleList() = default;
};
class ListInterceptionRulePageResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListInterceptionRulePageResponseBodyPageInfo() {}

  explicit ListInterceptionRulePageResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInterceptionRulePageResponseBodyPageInfo() = default;
};
class ListInterceptionRulePageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListInterceptionRulePageResponseBodyInterceptionRuleList>> interceptionRuleList{};
  shared_ptr<ListInterceptionRulePageResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListInterceptionRulePageResponseBody() {}

  explicit ListInterceptionRulePageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interceptionRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*interceptionRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InterceptionRuleList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InterceptionRuleList") != m.end() && !m["InterceptionRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["InterceptionRuleList"].type()) {
        vector<ListInterceptionRulePageResponseBodyInterceptionRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InterceptionRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInterceptionRulePageResponseBodyInterceptionRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        interceptionRuleList = make_shared<vector<ListInterceptionRulePageResponseBodyInterceptionRuleList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListInterceptionRulePageResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListInterceptionRulePageResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInterceptionRulePageResponseBody() = default;
};
class ListInterceptionRulePageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInterceptionRulePageResponseBody> body{};

  ListInterceptionRulePageResponse() {}

  explicit ListInterceptionRulePageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInterceptionRulePageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInterceptionRulePageResponseBody>(model1);
      }
    }
  }


  virtual ~ListInterceptionRulePageResponse() = default;
};
class ListInterceptionTargetPageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> currentPage{};
  shared_ptr<vector<string>> imageList{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> tagList{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};

  ListInterceptionTargetPageRequest() {}

  explicit ListInterceptionTargetPageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (imageList) {
      res["ImageList"] = boost::any(*imageList);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("ImageList") != m.end() && !m["ImageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~ListInterceptionTargetPageRequest() = default;
};
class ListInterceptionTargetPageResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListInterceptionTargetPageResponseBodyPageInfo() {}

  explicit ListInterceptionTargetPageResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInterceptionTargetPageResponseBodyPageInfo() = default;
};
class ListInterceptionTargetPageResponseBodyRuleTargetList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<vector<string>> imageList{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> ruleType{};
  shared_ptr<vector<string>> tagList{};
  shared_ptr<long> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};

  ListInterceptionTargetPageResponseBodyRuleTargetList() {}

  explicit ListInterceptionTargetPageResponseBodyRuleTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (imageList) {
      res["ImageList"] = boost::any(*imageList);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ImageList") != m.end() && !m["ImageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<long>(boost::any_cast<long>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~ListInterceptionTargetPageResponseBodyRuleTargetList() = default;
};
class ListInterceptionTargetPageResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListInterceptionTargetPageResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListInterceptionTargetPageResponseBodyRuleTargetList>> ruleTargetList{};

  ListInterceptionTargetPageResponseBody() {}

  explicit ListInterceptionTargetPageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleTargetList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleTargetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleTargetList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListInterceptionTargetPageResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListInterceptionTargetPageResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleTargetList") != m.end() && !m["RuleTargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleTargetList"].type()) {
        vector<ListInterceptionTargetPageResponseBodyRuleTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleTargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInterceptionTargetPageResponseBodyRuleTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleTargetList = make_shared<vector<ListInterceptionTargetPageResponseBodyRuleTargetList>>(expect1);
      }
    }
  }


  virtual ~ListInterceptionTargetPageResponseBody() = default;
};
class ListInterceptionTargetPageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInterceptionTargetPageResponseBody> body{};

  ListInterceptionTargetPageResponse() {}

  explicit ListInterceptionTargetPageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInterceptionTargetPageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInterceptionTargetPageResponseBody>(model1);
      }
    }
  }


  virtual ~ListInterceptionTargetPageResponse() = default;
};
class ListPluginForUuidRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> types{};
  shared_ptr<string> uuid{};

  ListPluginForUuidRequest() {}

  explicit ListPluginForUuidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (types) {
      res["Types"] = boost::any(*types);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ListPluginForUuidRequest() = default;
};
class ListPluginForUuidShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> typesShrink{};
  shared_ptr<string> uuid{};

  ListPluginForUuidShrinkRequest() {}

  explicit ListPluginForUuidShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (typesShrink) {
      res["Types"] = boost::any(*typesShrink);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      typesShrink = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ListPluginForUuidShrinkRequest() = default;
};
class ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList : public Darabonba::Model {
public:
  shared_ptr<bool> config{};
  shared_ptr<string> msg{};
  shared_ptr<bool> overallConfig{};
  shared_ptr<string> type{};

  ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList() {}

  explicit ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (overallConfig) {
      res["OverallConfig"] = boost::any(*overallConfig);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<bool>(boost::any_cast<bool>(m["Config"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("OverallConfig") != m.end() && !m["OverallConfig"].empty()) {
      overallConfig = make_shared<bool>(boost::any_cast<bool>(m["OverallConfig"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList() = default;
};
class ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList : public Darabonba::Model {
public:
  shared_ptr<vector<ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList>> aegisSuspiciousConfigList{};
  shared_ptr<string> pluginInstallCode{};
  shared_ptr<string> pluginName{};
  shared_ptr<bool> pluginOnlineInstalled{};
  shared_ptr<bool> pluginOnlineStatus{};
  shared_ptr<string> pluginVersion{};

  ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList() {}

  explicit ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aegisSuspiciousConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*aegisSuspiciousConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AegisSuspiciousConfigList"] = boost::any(temp1);
    }
    if (pluginInstallCode) {
      res["PluginInstallCode"] = boost::any(*pluginInstallCode);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (pluginOnlineInstalled) {
      res["PluginOnlineInstalled"] = boost::any(*pluginOnlineInstalled);
    }
    if (pluginOnlineStatus) {
      res["PluginOnlineStatus"] = boost::any(*pluginOnlineStatus);
    }
    if (pluginVersion) {
      res["PluginVersion"] = boost::any(*pluginVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AegisSuspiciousConfigList") != m.end() && !m["AegisSuspiciousConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["AegisSuspiciousConfigList"].type()) {
        vector<ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AegisSuspiciousConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aegisSuspiciousConfigList = make_shared<vector<ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList>>(expect1);
      }
    }
    if (m.find("PluginInstallCode") != m.end() && !m["PluginInstallCode"].empty()) {
      pluginInstallCode = make_shared<string>(boost::any_cast<string>(m["PluginInstallCode"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("PluginOnlineInstalled") != m.end() && !m["PluginOnlineInstalled"].empty()) {
      pluginOnlineInstalled = make_shared<bool>(boost::any_cast<bool>(m["PluginOnlineInstalled"]));
    }
    if (m.find("PluginOnlineStatus") != m.end() && !m["PluginOnlineStatus"].empty()) {
      pluginOnlineStatus = make_shared<bool>(boost::any_cast<bool>(m["PluginOnlineStatus"]));
    }
    if (m.find("PluginVersion") != m.end() && !m["PluginVersion"].empty()) {
      pluginVersion = make_shared<string>(boost::any_cast<string>(m["PluginVersion"]));
    }
  }


  virtual ~ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList() = default;
};
class ListPluginForUuidResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList>> aegisUuidTargetPluginConfigList{};
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPluginForUuidResponseBody() {}

  explicit ListPluginForUuidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aegisUuidTargetPluginConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*aegisUuidTargetPluginConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AegisUuidTargetPluginConfigList"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AegisUuidTargetPluginConfigList") != m.end() && !m["AegisUuidTargetPluginConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["AegisUuidTargetPluginConfigList"].type()) {
        vector<ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AegisUuidTargetPluginConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aegisUuidTargetPluginConfigList = make_shared<vector<ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPluginForUuidResponseBody() = default;
};
class ListPluginForUuidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPluginForUuidResponseBody> body{};

  ListPluginForUuidResponse() {}

  explicit ListPluginForUuidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPluginForUuidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPluginForUuidResponseBody>(model1);
      }
    }
  }


  virtual ~ListPluginForUuidResponse() = default;
};
class ListPodRiskRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> podName{};

  ListPodRiskRequest() {}

  explicit ListPodRiskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (podName) {
      res["PodName"] = boost::any(*podName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PodName") != m.end() && !m["PodName"].empty()) {
      podName = make_shared<string>(boost::any_cast<string>(m["PodName"]));
    }
  }


  virtual ~ListPodRiskRequest() = default;
};
class ListPodRiskResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListPodRiskResponseBodyPageInfo() {}

  explicit ListPodRiskResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPodRiskResponseBodyPageInfo() = default;
};
class ListPodRiskResponseBodyPodRiskList : public Darabonba::Model {
public:
  shared_ptr<long> alarmCount{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterName{};
  shared_ptr<long> createTime{};
  shared_ptr<long> hcCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> pod{};
  shared_ptr<string> podIp{};
  shared_ptr<long> vulCount{};

  ListPodRiskResponseBodyPodRiskList() {}

  explicit ListPodRiskResponseBodyPodRiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmCount) {
      res["AlarmCount"] = boost::any(*alarmCount);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hcCount) {
      res["HcCount"] = boost::any(*hcCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (pod) {
      res["Pod"] = boost::any(*pod);
    }
    if (podIp) {
      res["PodIp"] = boost::any(*podIp);
    }
    if (vulCount) {
      res["VulCount"] = boost::any(*vulCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmCount") != m.end() && !m["AlarmCount"].empty()) {
      alarmCount = make_shared<long>(boost::any_cast<long>(m["AlarmCount"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("HcCount") != m.end() && !m["HcCount"].empty()) {
      hcCount = make_shared<long>(boost::any_cast<long>(m["HcCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Pod") != m.end() && !m["Pod"].empty()) {
      pod = make_shared<string>(boost::any_cast<string>(m["Pod"]));
    }
    if (m.find("PodIp") != m.end() && !m["PodIp"].empty()) {
      podIp = make_shared<string>(boost::any_cast<string>(m["PodIp"]));
    }
    if (m.find("VulCount") != m.end() && !m["VulCount"].empty()) {
      vulCount = make_shared<long>(boost::any_cast<long>(m["VulCount"]));
    }
  }


  virtual ~ListPodRiskResponseBodyPodRiskList() = default;
};
class ListPodRiskResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListPodRiskResponseBodyPageInfo> pageInfo{};
  shared_ptr<vector<ListPodRiskResponseBodyPodRiskList>> podRiskList{};
  shared_ptr<string> requestId{};

  ListPodRiskResponseBody() {}

  explicit ListPodRiskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (podRiskList) {
      vector<boost::any> temp1;
      for(auto item1:*podRiskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PodRiskList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListPodRiskResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListPodRiskResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("PodRiskList") != m.end() && !m["PodRiskList"].empty()) {
      if (typeid(vector<boost::any>) == m["PodRiskList"].type()) {
        vector<ListPodRiskResponseBodyPodRiskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PodRiskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPodRiskResponseBodyPodRiskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        podRiskList = make_shared<vector<ListPodRiskResponseBodyPodRiskList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPodRiskResponseBody() = default;
};
class ListPodRiskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPodRiskResponseBody> body{};

  ListPodRiskResponse() {}

  explicit ListPodRiskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPodRiskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPodRiskResponseBody>(model1);
      }
    }
  }


  virtual ~ListPodRiskResponse() = default;
};
class ListPrivateRegistryListRequest : public Darabonba::Model {
public:
  shared_ptr<string> registryType{};

  ListPrivateRegistryListRequest() {}

  explicit ListPrivateRegistryListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
  }


  virtual ~ListPrivateRegistryListRequest() = default;
};
class ListPrivateRegistryListResponseBodyImageRegistryInfos : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> domainName{};
  shared_ptr<long> id{};
  shared_ptr<string> jenkinsEnv{};
  shared_ptr<long> netType{};
  shared_ptr<string> password{};
  shared_ptr<long> persistenceDay{};
  shared_ptr<long> protocolType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> registryHostIp{};
  shared_ptr<string> registryName{};
  shared_ptr<string> registryType{};
  shared_ptr<string> registryVersion{};
  shared_ptr<string> token{};
  shared_ptr<long> transPerHour{};
  shared_ptr<string> userName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> whiteList{};

  ListPrivateRegistryListResponseBodyImageRegistryInfos() {}

  explicit ListPrivateRegistryListResponseBodyImageRegistryInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (jenkinsEnv) {
      res["JenkinsEnv"] = boost::any(*jenkinsEnv);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (persistenceDay) {
      res["PersistenceDay"] = boost::any(*persistenceDay);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (registryHostIp) {
      res["RegistryHostIp"] = boost::any(*registryHostIp);
    }
    if (registryName) {
      res["RegistryName"] = boost::any(*registryName);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (registryVersion) {
      res["RegistryVersion"] = boost::any(*registryVersion);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (transPerHour) {
      res["TransPerHour"] = boost::any(*transPerHour);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("JenkinsEnv") != m.end() && !m["JenkinsEnv"].empty()) {
      jenkinsEnv = make_shared<string>(boost::any_cast<string>(m["JenkinsEnv"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<long>(boost::any_cast<long>(m["NetType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PersistenceDay") != m.end() && !m["PersistenceDay"].empty()) {
      persistenceDay = make_shared<long>(boost::any_cast<long>(m["PersistenceDay"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<long>(boost::any_cast<long>(m["ProtocolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegistryHostIp") != m.end() && !m["RegistryHostIp"].empty()) {
      registryHostIp = make_shared<string>(boost::any_cast<string>(m["RegistryHostIp"]));
    }
    if (m.find("RegistryName") != m.end() && !m["RegistryName"].empty()) {
      registryName = make_shared<string>(boost::any_cast<string>(m["RegistryName"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("RegistryVersion") != m.end() && !m["RegistryVersion"].empty()) {
      registryVersion = make_shared<string>(boost::any_cast<string>(m["RegistryVersion"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("TransPerHour") != m.end() && !m["TransPerHour"].empty()) {
      transPerHour = make_shared<long>(boost::any_cast<long>(m["TransPerHour"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~ListPrivateRegistryListResponseBodyImageRegistryInfos() = default;
};
class ListPrivateRegistryListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPrivateRegistryListResponseBodyImageRegistryInfos>> imageRegistryInfos{};
  shared_ptr<string> requestId{};

  ListPrivateRegistryListResponseBody() {}

  explicit ListPrivateRegistryListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageRegistryInfos) {
      vector<boost::any> temp1;
      for(auto item1:*imageRegistryInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageRegistryInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageRegistryInfos") != m.end() && !m["ImageRegistryInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageRegistryInfos"].type()) {
        vector<ListPrivateRegistryListResponseBodyImageRegistryInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageRegistryInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrivateRegistryListResponseBodyImageRegistryInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageRegistryInfos = make_shared<vector<ListPrivateRegistryListResponseBodyImageRegistryInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrivateRegistryListResponseBody() = default;
};
class ListPrivateRegistryListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrivateRegistryListResponseBody> body{};

  ListPrivateRegistryListResponse() {}

  explicit ListPrivateRegistryListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrivateRegistryListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrivateRegistryListResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrivateRegistryListResponse() = default;
};
class ListPrivateRegistryTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  ListPrivateRegistryTypeRequest() {}

  explicit ListPrivateRegistryTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~ListPrivateRegistryTypeRequest() = default;
};
class ListPrivateRegistryTypeResponseBodyRegistryTypeInfos : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> registryType{};

  ListPrivateRegistryTypeResponseBodyRegistryTypeInfos() {}

  explicit ListPrivateRegistryTypeResponseBodyRegistryTypeInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
  }


  virtual ~ListPrivateRegistryTypeResponseBodyRegistryTypeInfos() = default;
};
class ListPrivateRegistryTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPrivateRegistryTypeResponseBodyRegistryTypeInfos>> registryTypeInfos{};
  shared_ptr<string> requestId{};

  ListPrivateRegistryTypeResponseBody() {}

  explicit ListPrivateRegistryTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (registryTypeInfos) {
      vector<boost::any> temp1;
      for(auto item1:*registryTypeInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistryTypeInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegistryTypeInfos") != m.end() && !m["RegistryTypeInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistryTypeInfos"].type()) {
        vector<ListPrivateRegistryTypeResponseBodyRegistryTypeInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistryTypeInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrivateRegistryTypeResponseBodyRegistryTypeInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registryTypeInfos = make_shared<vector<ListPrivateRegistryTypeResponseBodyRegistryTypeInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrivateRegistryTypeResponseBody() = default;
};
class ListPrivateRegistryTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrivateRegistryTypeResponseBody> body{};

  ListPrivateRegistryTypeResponse() {}

  explicit ListPrivateRegistryTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrivateRegistryTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrivateRegistryTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrivateRegistryTypeResponse() = default;
};
class ListRuleTargetAllRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};

  ListRuleTargetAllRequest() {}

  explicit ListRuleTargetAllRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~ListRuleTargetAllRequest() = default;
};
class ListRuleTargetAllResponseBodyRuleTargetList : public Darabonba::Model {
public:
  shared_ptr<long> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};

  ListRuleTargetAllResponseBodyRuleTargetList() {}

  explicit ListRuleTargetAllResponseBodyRuleTargetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<long>(boost::any_cast<long>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~ListRuleTargetAllResponseBodyRuleTargetList() = default;
};
class ListRuleTargetAllResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListRuleTargetAllResponseBodyRuleTargetList>> ruleTargetList{};

  ListRuleTargetAllResponseBody() {}

  explicit ListRuleTargetAllResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleTargetList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleTargetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleTargetList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleTargetList") != m.end() && !m["RuleTargetList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleTargetList"].type()) {
        vector<ListRuleTargetAllResponseBodyRuleTargetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleTargetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRuleTargetAllResponseBodyRuleTargetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleTargetList = make_shared<vector<ListRuleTargetAllResponseBodyRuleTargetList>>(expect1);
      }
    }
  }


  virtual ~ListRuleTargetAllResponseBody() = default;
};
class ListRuleTargetAllResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRuleTargetAllResponseBody> body{};

  ListRuleTargetAllResponse() {}

  explicit ListRuleTargetAllResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRuleTargetAllResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRuleTargetAllResponseBody>(model1);
      }
    }
  }


  virtual ~ListRuleTargetAllResponse() = default;
};
class ListSystemAggregationRulesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> aggregationIds{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleName{};
  shared_ptr<vector<long>> ruleTypes{};
  shared_ptr<long> systemType{};

  ListSystemAggregationRulesRequest() {}

  explicit ListSystemAggregationRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregationIds) {
      res["AggregationIds"] = boost::any(*aggregationIds);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTypes) {
      res["RuleTypes"] = boost::any(*ruleTypes);
    }
    if (systemType) {
      res["SystemType"] = boost::any(*systemType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregationIds") != m.end() && !m["AggregationIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AggregationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AggregationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      aggregationIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTypes") != m.end() && !m["RuleTypes"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RuleTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ruleTypes = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SystemType") != m.end() && !m["SystemType"].empty()) {
      systemType = make_shared<long>(boost::any_cast<long>(m["SystemType"]));
    }
  }


  virtual ~ListSystemAggregationRulesRequest() = default;
};
class ListSystemAggregationRulesResponseBodyAggregationList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> ruleCount{};

  ListSystemAggregationRulesResponseBodyAggregationList() {}

  explicit ListSystemAggregationRulesResponseBodyAggregationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ruleCount) {
      res["RuleCount"] = boost::any(*ruleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RuleCount") != m.end() && !m["RuleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["RuleCount"]));
    }
  }


  virtual ~ListSystemAggregationRulesResponseBodyAggregationList() = default;
};
class ListSystemAggregationRulesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSystemAggregationRulesResponseBodyPageInfo() {}

  explicit ListSystemAggregationRulesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSystemAggregationRulesResponseBodyPageInfo() = default;
};
class ListSystemAggregationRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListSystemAggregationRulesResponseBodyAggregationList>> aggregationList{};
  shared_ptr<ListSystemAggregationRulesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListSystemAggregationRulesResponseBody() {}

  explicit ListSystemAggregationRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregationList) {
      vector<boost::any> temp1;
      for(auto item1:*aggregationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AggregationList"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregationList") != m.end() && !m["AggregationList"].empty()) {
      if (typeid(vector<boost::any>) == m["AggregationList"].type()) {
        vector<ListSystemAggregationRulesResponseBodyAggregationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AggregationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSystemAggregationRulesResponseBodyAggregationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregationList = make_shared<vector<ListSystemAggregationRulesResponseBodyAggregationList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListSystemAggregationRulesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListSystemAggregationRulesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSystemAggregationRulesResponseBody() = default;
};
class ListSystemAggregationRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSystemAggregationRulesResponseBody> body{};

  ListSystemAggregationRulesResponse() {}

  explicit ListSystemAggregationRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSystemAggregationRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSystemAggregationRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSystemAggregationRulesResponse() = default;
};
class ListSystemClientRuleTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> ruleTypes{};

  ListSystemClientRuleTypesResponseBody() {}

  explicit ListSystemClientRuleTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleTypes) {
      res["RuleTypes"] = boost::any(*ruleTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleTypes") != m.end() && !m["RuleTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListSystemClientRuleTypesResponseBody() = default;
};
class ListSystemClientRuleTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSystemClientRuleTypesResponseBody> body{};

  ListSystemClientRuleTypesResponse() {}

  explicit ListSystemClientRuleTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSystemClientRuleTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSystemClientRuleTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSystemClientRuleTypesResponse() = default;
};
class ListSystemClientRulesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> aggregationIds{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> isContainer{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleName{};
  shared_ptr<vector<long>> ruleTypes{};
  shared_ptr<long> systemType{};

  ListSystemClientRulesRequest() {}

  explicit ListSystemClientRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregationIds) {
      res["AggregationIds"] = boost::any(*aggregationIds);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (isContainer) {
      res["IsContainer"] = boost::any(*isContainer);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleTypes) {
      res["RuleTypes"] = boost::any(*ruleTypes);
    }
    if (systemType) {
      res["SystemType"] = boost::any(*systemType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregationIds") != m.end() && !m["AggregationIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AggregationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AggregationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      aggregationIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("IsContainer") != m.end() && !m["IsContainer"].empty()) {
      isContainer = make_shared<long>(boost::any_cast<long>(m["IsContainer"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleTypes") != m.end() && !m["RuleTypes"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RuleTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ruleTypes = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SystemType") != m.end() && !m["SystemType"].empty()) {
      systemType = make_shared<long>(boost::any_cast<long>(m["SystemType"]));
    }
  }


  virtual ~ListSystemClientRulesRequest() = default;
};
class ListSystemClientRulesResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSystemClientRulesResponseBodyPageInfo() {}

  explicit ListSystemClientRulesResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSystemClientRulesResponseBodyPageInfo() = default;
};
class ListSystemClientRulesResponseBodyRuleListPolicies : public Darabonba::Model {
public:
  shared_ptr<string> policyKey{};
  shared_ptr<string> policyName{};

  ListSystemClientRulesResponseBodyRuleListPolicies() {}

  explicit ListSystemClientRulesResponseBodyRuleListPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyKey) {
      res["PolicyKey"] = boost::any(*policyKey);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyKey") != m.end() && !m["PolicyKey"].empty()) {
      policyKey = make_shared<string>(boost::any_cast<string>(m["PolicyKey"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
  }


  virtual ~ListSystemClientRulesResponseBodyRuleListPolicies() = default;
};
class ListSystemClientRulesResponseBodyRuleList : public Darabonba::Model {
public:
  shared_ptr<string> aggregationName{};
  shared_ptr<string> description{};
  shared_ptr<string> platform{};
  shared_ptr<vector<ListSystemClientRulesResponseBodyRuleListPolicies>> policies{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleType{};
  shared_ptr<long> status{};
  shared_ptr<string> switchId{};

  ListSystemClientRulesResponseBodyRuleList() {}

  explicit ListSystemClientRulesResponseBodyRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregationName) {
      res["AggregationName"] = boost::any(*aggregationName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (switchId) {
      res["SwitchId"] = boost::any(*switchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregationName") != m.end() && !m["AggregationName"].empty()) {
      aggregationName = make_shared<string>(boost::any_cast<string>(m["AggregationName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<ListSystemClientRulesResponseBodyRuleListPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSystemClientRulesResponseBodyRuleListPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<ListSystemClientRulesResponseBodyRuleListPolicies>>(expect1);
      }
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SwitchId") != m.end() && !m["SwitchId"].empty()) {
      switchId = make_shared<string>(boost::any_cast<string>(m["SwitchId"]));
    }
  }


  virtual ~ListSystemClientRulesResponseBodyRuleList() = default;
};
class ListSystemClientRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSystemClientRulesResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSystemClientRulesResponseBodyRuleList>> ruleList{};

  ListSystemClientRulesResponseBody() {}

  explicit ListSystemClientRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListSystemClientRulesResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListSystemClientRulesResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleList") != m.end() && !m["RuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleList"].type()) {
        vector<ListSystemClientRulesResponseBodyRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSystemClientRulesResponseBodyRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleList = make_shared<vector<ListSystemClientRulesResponseBodyRuleList>>(expect1);
      }
    }
  }


  virtual ~ListSystemClientRulesResponseBody() = default;
};
class ListSystemClientRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSystemClientRulesResponseBody> body{};

  ListSystemClientRulesResponse() {}

  explicit ListSystemClientRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSystemClientRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSystemClientRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSystemClientRulesResponse() = default;
};
class ListSystemRuleAggregationTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  ListSystemRuleAggregationTypesRequest() {}

  explicit ListSystemRuleAggregationTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~ListSystemRuleAggregationTypesRequest() = default;
};
class ListSystemRuleAggregationTypesResponseBodyAggregationTypeList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListSystemRuleAggregationTypesResponseBodyAggregationTypeList() {}

  explicit ListSystemRuleAggregationTypesResponseBodyAggregationTypeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListSystemRuleAggregationTypesResponseBodyAggregationTypeList() = default;
};
class ListSystemRuleAggregationTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListSystemRuleAggregationTypesResponseBodyAggregationTypeList>> aggregationTypeList{};
  shared_ptr<string> requestId{};

  ListSystemRuleAggregationTypesResponseBody() {}

  explicit ListSystemRuleAggregationTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregationTypeList) {
      vector<boost::any> temp1;
      for(auto item1:*aggregationTypeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AggregationTypeList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregationTypeList") != m.end() && !m["AggregationTypeList"].empty()) {
      if (typeid(vector<boost::any>) == m["AggregationTypeList"].type()) {
        vector<ListSystemRuleAggregationTypesResponseBodyAggregationTypeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AggregationTypeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSystemRuleAggregationTypesResponseBodyAggregationTypeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregationTypeList = make_shared<vector<ListSystemRuleAggregationTypesResponseBodyAggregationTypeList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSystemRuleAggregationTypesResponseBody() = default;
};
class ListSystemRuleAggregationTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSystemRuleAggregationTypesResponseBody> body{};

  ListSystemRuleAggregationTypesResponse() {}

  explicit ListSystemRuleAggregationTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSystemRuleAggregationTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSystemRuleAggregationTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSystemRuleAggregationTypesResponse() = default;
};
class ListUninstallAegisMachinesRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> os{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionIdStr{};
  shared_ptr<string> regionNo{};
  shared_ptr<string> remark{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> vendor{};

  ListUninstallAegisMachinesRequest() {}

  explicit ListUninstallAegisMachinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionIdStr) {
      res["RegionIdStr"] = boost::any(*regionIdStr);
    }
    if (regionNo) {
      res["RegionNo"] = boost::any(*regionNo);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionIdStr") != m.end() && !m["RegionIdStr"].empty()) {
      regionIdStr = make_shared<string>(boost::any_cast<string>(m["RegionIdStr"]));
    }
    if (m.find("RegionNo") != m.end() && !m["RegionNo"].empty()) {
      regionNo = make_shared<string>(boost::any_cast<string>(m["RegionNo"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<long>(boost::any_cast<long>(m["Vendor"]));
    }
  }


  virtual ~ListUninstallAegisMachinesRequest() = default;
};
class ListUninstallAegisMachinesResponseBodyMachineList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> machineRegion{};
  shared_ptr<string> os{};
  shared_ptr<string> regionId{};
  shared_ptr<string> uuid{};
  shared_ptr<long> vendor{};
  shared_ptr<string> vendorName{};

  ListUninstallAegisMachinesResponseBodyMachineList() {}

  explicit ListUninstallAegisMachinesResponseBodyMachineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (machineRegion) {
      res["MachineRegion"] = boost::any(*machineRegion);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (vendor) {
      res["Vendor"] = boost::any(*vendor);
    }
    if (vendorName) {
      res["VendorName"] = boost::any(*vendorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("MachineRegion") != m.end() && !m["MachineRegion"].empty()) {
      machineRegion = make_shared<string>(boost::any_cast<string>(m["MachineRegion"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Vendor") != m.end() && !m["Vendor"].empty()) {
      vendor = make_shared<long>(boost::any_cast<long>(m["Vendor"]));
    }
    if (m.find("VendorName") != m.end() && !m["VendorName"].empty()) {
      vendorName = make_shared<string>(boost::any_cast<string>(m["VendorName"]));
    }
  }


  virtual ~ListUninstallAegisMachinesResponseBodyMachineList() = default;
};
class ListUninstallAegisMachinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<vector<ListUninstallAegisMachinesResponseBodyMachineList>> machineList{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListUninstallAegisMachinesResponseBody() {}

  explicit ListUninstallAegisMachinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (machineList) {
      vector<boost::any> temp1;
      for(auto item1:*machineList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MachineList"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("MachineList") != m.end() && !m["MachineList"].empty()) {
      if (typeid(vector<boost::any>) == m["MachineList"].type()) {
        vector<ListUninstallAegisMachinesResponseBodyMachineList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MachineList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUninstallAegisMachinesResponseBodyMachineList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machineList = make_shared<vector<ListUninstallAegisMachinesResponseBodyMachineList>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUninstallAegisMachinesResponseBody() = default;
};
class ListUninstallAegisMachinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUninstallAegisMachinesResponseBody> body{};

  ListUninstallAegisMachinesResponse() {}

  explicit ListUninstallAegisMachinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUninstallAegisMachinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUninstallAegisMachinesResponseBody>(model1);
      }
    }
  }


  virtual ~ListUninstallAegisMachinesResponse() = default;
};
class ListUuidsByWebPathRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> type{};
  shared_ptr<string> webPath{};

  ListUuidsByWebPathRequest() {}

  explicit ListUuidsByWebPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (webPath) {
      res["WebPath"] = boost::any(*webPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WebPath") != m.end() && !m["WebPath"].empty()) {
      webPath = make_shared<string>(boost::any_cast<string>(m["WebPath"]));
    }
  }


  virtual ~ListUuidsByWebPathRequest() = default;
};
class ListUuidsByWebPathResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<string> machineName{};
  shared_ptr<string> uuid{};

  ListUuidsByWebPathResponseBodyList() {}

  explicit ListUuidsByWebPathResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (machineName) {
      res["MachineName"] = boost::any(*machineName);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("MachineName") != m.end() && !m["MachineName"].empty()) {
      machineName = make_shared<string>(boost::any_cast<string>(m["MachineName"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ListUuidsByWebPathResponseBodyList() = default;
};
class ListUuidsByWebPathResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUuidsByWebPathResponseBodyPageInfo() {}

  explicit ListUuidsByWebPathResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUuidsByWebPathResponseBodyPageInfo() = default;
};
class ListUuidsByWebPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListUuidsByWebPathResponseBodyList>> list{};
  shared_ptr<ListUuidsByWebPathResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  ListUuidsByWebPathResponseBody() {}

  explicit ListUuidsByWebPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListUuidsByWebPathResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUuidsByWebPathResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListUuidsByWebPathResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListUuidsByWebPathResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListUuidsByWebPathResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUuidsByWebPathResponseBody() = default;
};
class ListUuidsByWebPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUuidsByWebPathResponseBody> body{};

  ListUuidsByWebPathResponse() {}

  explicit ListUuidsByWebPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUuidsByWebPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUuidsByWebPathResponseBody>(model1);
      }
    }
  }


  virtual ~ListUuidsByWebPathResponse() = default;
};
class ListVulAutoRepairConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> type{};

  ListVulAutoRepairConfigRequest() {}

  explicit ListVulAutoRepairConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListVulAutoRepairConfigRequest() = default;
};
class ListVulAutoRepairConfigResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListVulAutoRepairConfigResponseBodyPageInfo() {}

  explicit ListVulAutoRepairConfigResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListVulAutoRepairConfigResponseBodyPageInfo() = default;
};
class ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList : public Darabonba::Model {
public:
  shared_ptr<string> aliasName{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> reason{};
  shared_ptr<string> type{};

  ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList() {}

  explicit ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliasName) {
      res["AliasName"] = boost::any(*aliasName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliasName") != m.end() && !m["AliasName"].empty()) {
      aliasName = make_shared<string>(boost::any_cast<string>(m["AliasName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList() = default;
};
class ListVulAutoRepairConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListVulAutoRepairConfigResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList>> vulAutoRepairConfigList{};

  ListVulAutoRepairConfigResponseBody() {}

  explicit ListVulAutoRepairConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (vulAutoRepairConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*vulAutoRepairConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VulAutoRepairConfigList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        ListVulAutoRepairConfigResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<ListVulAutoRepairConfigResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("VulAutoRepairConfigList") != m.end() && !m["VulAutoRepairConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["VulAutoRepairConfigList"].type()) {
        vector<ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VulAutoRepairConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulAutoRepairConfigList = make_shared<vector<ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList>>(expect1);
      }
    }
  }


  virtual ~ListVulAutoRepairConfigResponseBody() = default;
};
class ListVulAutoRepairConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVulAutoRepairConfigResponseBody> body{};

  ListVulAutoRepairConfigResponse() {}

  explicit ListVulAutoRepairConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVulAutoRepairConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVulAutoRepairConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ListVulAutoRepairConfigResponse() = default;
};
class ModifyAccessKeyLeakDealRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<vector<long>> idList{};
  shared_ptr<string> remark{};
  shared_ptr<string> type{};

  ModifyAccessKeyLeakDealRequest() {}

  explicit ModifyAccessKeyLeakDealRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (idList) {
      res["IdList"] = boost::any(*idList);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IdList") != m.end() && !m["IdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["IdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      idList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyAccessKeyLeakDealRequest() = default;
};
class ModifyAccessKeyLeakDealResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAccessKeyLeakDealResponseBody() {}

  explicit ModifyAccessKeyLeakDealResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAccessKeyLeakDealResponseBody() = default;
};
class ModifyAccessKeyLeakDealResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAccessKeyLeakDealResponseBody> body{};

  ModifyAccessKeyLeakDealResponse() {}

  explicit ModifyAccessKeyLeakDealResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAccessKeyLeakDealResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAccessKeyLeakDealResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAccessKeyLeakDealResponse() = default;
};
class ModifyAntiBruteForceRuleRequest : public Darabonba::Model {
public:
  shared_ptr<bool> defaultRule{};
  shared_ptr<long> failCount{};
  shared_ptr<long> forbiddenTime{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> span{};
  shared_ptr<vector<string>> uuidList{};

  ModifyAntiBruteForceRuleRequest() {}

  explicit ModifyAntiBruteForceRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultRule) {
      res["DefaultRule"] = boost::any(*defaultRule);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (forbiddenTime) {
      res["ForbiddenTime"] = boost::any(*forbiddenTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (span) {
      res["Span"] = boost::any(*span);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultRule") != m.end() && !m["DefaultRule"].empty()) {
      defaultRule = make_shared<bool>(boost::any_cast<bool>(m["DefaultRule"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("ForbiddenTime") != m.end() && !m["ForbiddenTime"].empty()) {
      forbiddenTime = make_shared<long>(boost::any_cast<long>(m["ForbiddenTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Span") != m.end() && !m["Span"].empty()) {
      span = make_shared<long>(boost::any_cast<long>(m["Span"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyAntiBruteForceRuleRequest() = default;
};
class ModifyAntiBruteForceRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAntiBruteForceRuleResponseBody() {}

  explicit ModifyAntiBruteForceRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAntiBruteForceRuleResponseBody() = default;
};
class ModifyAntiBruteForceRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAntiBruteForceRuleResponseBody> body{};

  ModifyAntiBruteForceRuleResponse() {}

  explicit ModifyAntiBruteForceRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAntiBruteForceRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAntiBruteForceRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAntiBruteForceRuleResponse() = default;
};
class ModifyAppVulScanCycleRequest : public Darabonba::Model {
public:
  shared_ptr<string> cycle{};

  ModifyAppVulScanCycleRequest() {}

  explicit ModifyAppVulScanCycleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycle) {
      res["Cycle"] = boost::any(*cycle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cycle") != m.end() && !m["Cycle"].empty()) {
      cycle = make_shared<string>(boost::any_cast<string>(m["Cycle"]));
    }
  }


  virtual ~ModifyAppVulScanCycleRequest() = default;
};
class ModifyAppVulScanCycleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAppVulScanCycleResponseBody() {}

  explicit ModifyAppVulScanCycleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAppVulScanCycleResponseBody() = default;
};
class ModifyAppVulScanCycleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAppVulScanCycleResponseBody> body{};

  ModifyAppVulScanCycleResponse() {}

  explicit ModifyAppVulScanCycleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAppVulScanCycleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAppVulScanCycleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAppVulScanCycleResponse() = default;
};
class ModifyAssetGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuids{};

  ModifyAssetGroupRequest() {}

  explicit ModifyAssetGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~ModifyAssetGroupRequest() = default;
};
class ModifyAssetGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAssetGroupResponseBody() {}

  explicit ModifyAssetGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAssetGroupResponseBody() = default;
};
class ModifyAssetGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAssetGroupResponseBody> body{};

  ModifyAssetGroupResponse() {}

  explicit ModifyAssetGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAssetGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAssetGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAssetGroupResponse() = default;
};
class ModifyAssetImportantRequest : public Darabonba::Model {
public:
  shared_ptr<long> importantCode{};
  shared_ptr<string> uuidList{};

  ModifyAssetImportantRequest() {}

  explicit ModifyAssetImportantRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (importantCode) {
      res["ImportantCode"] = boost::any(*importantCode);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImportantCode") != m.end() && !m["ImportantCode"].empty()) {
      importantCode = make_shared<long>(boost::any_cast<long>(m["ImportantCode"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      uuidList = make_shared<string>(boost::any_cast<string>(m["UuidList"]));
    }
  }


  virtual ~ModifyAssetImportantRequest() = default;
};
class ModifyAssetImportantResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errCode{};
  shared_ptr<string> errMessage{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyAssetImportantResponseBody() {}

  explicit ModifyAssetImportantResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errCode) {
      res["ErrCode"] = boost::any(*errCode);
    }
    if (errMessage) {
      res["ErrMessage"] = boost::any(*errMessage);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrCode") != m.end() && !m["ErrCode"].empty()) {
      errCode = make_shared<string>(boost::any_cast<string>(m["ErrCode"]));
    }
    if (m.find("ErrMessage") != m.end() && !m["ErrMessage"].empty()) {
      errMessage = make_shared<string>(boost::any_cast<string>(m["ErrMessage"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyAssetImportantResponseBody() = default;
};
class ModifyAssetImportantResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAssetImportantResponseBody> body{};

  ModifyAssetImportantResponse() {}

  explicit ModifyAssetImportantResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAssetImportantResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAssetImportantResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAssetImportantResponse() = default;
};
class ModifyAutoDelConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> days{};

  ModifyAutoDelConfigRequest() {}

  explicit ModifyAutoDelConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (days) {
      res["Days"] = boost::any(*days);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      days = make_shared<long>(boost::any_cast<long>(m["Days"]));
    }
  }


  virtual ~ModifyAutoDelConfigRequest() = default;
};
class ModifyAutoDelConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAutoDelConfigResponseBody() {}

  explicit ModifyAutoDelConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAutoDelConfigResponseBody() = default;
};
class ModifyAutoDelConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAutoDelConfigResponseBody> body{};

  ModifyAutoDelConfigResponse() {}

  explicit ModifyAutoDelConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAutoDelConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAutoDelConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAutoDelConfigResponse() = default;
};
class ModifyBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> policy{};
  shared_ptr<string> policyRegionId{};
  shared_ptr<string> policyVersion{};
  shared_ptr<vector<string>> uuidList{};

  ModifyBackupPolicyRequest() {}

  explicit ModifyBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (policyRegionId) {
      res["PolicyRegionId"] = boost::any(*policyRegionId);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Policy"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      policy = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("PolicyRegionId") != m.end() && !m["PolicyRegionId"].empty()) {
      policyRegionId = make_shared<string>(boost::any_cast<string>(m["PolicyRegionId"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyBackupPolicyRequest() = default;
};
class ModifyBackupPolicyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> policyShrink{};
  shared_ptr<string> policyRegionId{};
  shared_ptr<string> policyVersion{};
  shared_ptr<vector<string>> uuidList{};

  ModifyBackupPolicyShrinkRequest() {}

  explicit ModifyBackupPolicyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policyShrink) {
      res["Policy"] = boost::any(*policyShrink);
    }
    if (policyRegionId) {
      res["PolicyRegionId"] = boost::any(*policyRegionId);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policyShrink = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("PolicyRegionId") != m.end() && !m["PolicyRegionId"].empty()) {
      policyRegionId = make_shared<string>(boost::any_cast<string>(m["PolicyRegionId"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyBackupPolicyShrinkRequest() = default;
};
class ModifyBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBackupPolicyResponseBody() {}

  explicit ModifyBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBackupPolicyResponseBody() = default;
};
class ModifyBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBackupPolicyResponseBody> body{};

  ModifyBackupPolicyResponse() {}

  explicit ModifyBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBackupPolicyResponse() = default;
};
class ModifyBackupPolicyStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> policyVersion{};
  shared_ptr<string> status{};

  ModifyBackupPolicyStatusRequest() {}

  explicit ModifyBackupPolicyStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyBackupPolicyStatusRequest() = default;
};
class ModifyBackupPolicyStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBackupPolicyStatusResponseBody() {}

  explicit ModifyBackupPolicyStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBackupPolicyStatusResponseBody() = default;
};
class ModifyBackupPolicyStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBackupPolicyStatusResponseBody> body{};

  ModifyBackupPolicyStatusResponse() {}

  explicit ModifyBackupPolicyStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBackupPolicyStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBackupPolicyStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBackupPolicyStatusResponse() = default;
};
class ModifyClearLogstoreStorageRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> lang{};
  shared_ptr<string> userLogStore{};
  shared_ptr<string> userProject{};

  ModifyClearLogstoreStorageRequest() {}

  explicit ModifyClearLogstoreStorageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (userLogStore) {
      res["UserLogStore"] = boost::any(*userLogStore);
    }
    if (userProject) {
      res["UserProject"] = boost::any(*userProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("UserLogStore") != m.end() && !m["UserLogStore"].empty()) {
      userLogStore = make_shared<string>(boost::any_cast<string>(m["UserLogStore"]));
    }
    if (m.find("UserProject") != m.end() && !m["UserProject"].empty()) {
      userProject = make_shared<string>(boost::any_cast<string>(m["UserProject"]));
    }
  }


  virtual ~ModifyClearLogstoreStorageRequest() = default;
};
class ModifyClearLogstoreStorageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyClearLogstoreStorageResponseBody() {}

  explicit ModifyClearLogstoreStorageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClearLogstoreStorageResponseBody() = default;
};
class ModifyClearLogstoreStorageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyClearLogstoreStorageResponseBody> body{};

  ModifyClearLogstoreStorageResponse() {}

  explicit ModifyClearLogstoreStorageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClearLogstoreStorageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClearLogstoreStorageResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClearLogstoreStorageResponse() = default;
};
class ModifyClientConfSetupRequest : public Darabonba::Model {
public:
  shared_ptr<string> strategyConfig{};
  shared_ptr<string> strategyTag{};
  shared_ptr<string> strategyTagValue{};

  ModifyClientConfSetupRequest() {}

  explicit ModifyClientConfSetupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (strategyConfig) {
      res["StrategyConfig"] = boost::any(*strategyConfig);
    }
    if (strategyTag) {
      res["StrategyTag"] = boost::any(*strategyTag);
    }
    if (strategyTagValue) {
      res["StrategyTagValue"] = boost::any(*strategyTagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StrategyConfig") != m.end() && !m["StrategyConfig"].empty()) {
      strategyConfig = make_shared<string>(boost::any_cast<string>(m["StrategyConfig"]));
    }
    if (m.find("StrategyTag") != m.end() && !m["StrategyTag"].empty()) {
      strategyTag = make_shared<string>(boost::any_cast<string>(m["StrategyTag"]));
    }
    if (m.find("StrategyTagValue") != m.end() && !m["StrategyTagValue"].empty()) {
      strategyTagValue = make_shared<string>(boost::any_cast<string>(m["StrategyTagValue"]));
    }
  }


  virtual ~ModifyClientConfSetupRequest() = default;
};
class ModifyClientConfSetupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyClientConfSetupResponseBody() {}

  explicit ModifyClientConfSetupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClientConfSetupResponseBody() = default;
};
class ModifyClientConfSetupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyClientConfSetupResponseBody> body{};

  ModifyClientConfSetupResponse() {}

  explicit ModifyClientConfSetupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClientConfSetupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClientConfSetupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClientConfSetupResponse() = default;
};
class ModifyClientConfStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> tag{};
  shared_ptr<string> tagExt{};
  shared_ptr<string> tagValue{};
  shared_ptr<string> uuid{};
  shared_ptr<vector<string>> uuids{};

  ModifyClientConfStrategyRequest() {}

  explicit ModifyClientConfStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tagExt) {
      res["TagExt"] = boost::any(*tagExt);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TagExt") != m.end() && !m["TagExt"].empty()) {
      tagExt = make_shared<string>(boost::any_cast<string>(m["TagExt"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Uuids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Uuids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuids = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyClientConfStrategyRequest() = default;
};
class ModifyClientConfStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyClientConfStrategyResponseBody() {}

  explicit ModifyClientConfStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClientConfStrategyResponseBody() = default;
};
class ModifyClientConfStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyClientConfStrategyResponseBody> body{};

  ModifyClientConfStrategyResponse() {}

  explicit ModifyClientConfStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClientConfStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClientConfStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClientConfStrategyResponse() = default;
};
class ModifyClientUserDefineRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> actionType{};
  shared_ptr<string> cmdline{};
  shared_ptr<string> filePath{};
  shared_ptr<string> IP{};
  shared_ptr<long> id{};
  shared_ptr<string> md5List{};
  shared_ptr<string> name{};
  shared_ptr<string> newFilePath{};
  shared_ptr<string> parentCmdline{};
  shared_ptr<string> parentProcPath{};
  shared_ptr<string> platform{};
  shared_ptr<long> port{};
  shared_ptr<string> portStr{};
  shared_ptr<string> procPath{};
  shared_ptr<string> registryContent{};
  shared_ptr<string> registryKey{};
  shared_ptr<long> type{};

  ModifyClientUserDefineRuleRequest() {}

  explicit ModifyClientUserDefineRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["ActionType"] = boost::any(*actionType);
    }
    if (cmdline) {
      res["Cmdline"] = boost::any(*cmdline);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (md5List) {
      res["Md5List"] = boost::any(*md5List);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newFilePath) {
      res["NewFilePath"] = boost::any(*newFilePath);
    }
    if (parentCmdline) {
      res["ParentCmdline"] = boost::any(*parentCmdline);
    }
    if (parentProcPath) {
      res["ParentProcPath"] = boost::any(*parentProcPath);
    }
    if (platform) {
      res["Platform"] = boost::any(*platform);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (portStr) {
      res["PortStr"] = boost::any(*portStr);
    }
    if (procPath) {
      res["ProcPath"] = boost::any(*procPath);
    }
    if (registryContent) {
      res["RegistryContent"] = boost::any(*registryContent);
    }
    if (registryKey) {
      res["RegistryKey"] = boost::any(*registryKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionType") != m.end() && !m["ActionType"].empty()) {
      actionType = make_shared<long>(boost::any_cast<long>(m["ActionType"]));
    }
    if (m.find("Cmdline") != m.end() && !m["Cmdline"].empty()) {
      cmdline = make_shared<string>(boost::any_cast<string>(m["Cmdline"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Md5List") != m.end() && !m["Md5List"].empty()) {
      md5List = make_shared<string>(boost::any_cast<string>(m["Md5List"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewFilePath") != m.end() && !m["NewFilePath"].empty()) {
      newFilePath = make_shared<string>(boost::any_cast<string>(m["NewFilePath"]));
    }
    if (m.find("ParentCmdline") != m.end() && !m["ParentCmdline"].empty()) {
      parentCmdline = make_shared<string>(boost::any_cast<string>(m["ParentCmdline"]));
    }
    if (m.find("ParentProcPath") != m.end() && !m["ParentProcPath"].empty()) {
      parentProcPath = make_shared<string>(boost::any_cast<string>(m["ParentProcPath"]));
    }
    if (m.find("Platform") != m.end() && !m["Platform"].empty()) {
      platform = make_shared<string>(boost::any_cast<string>(m["Platform"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("PortStr") != m.end() && !m["PortStr"].empty()) {
      portStr = make_shared<string>(boost::any_cast<string>(m["PortStr"]));
    }
    if (m.find("ProcPath") != m.end() && !m["ProcPath"].empty()) {
      procPath = make_shared<string>(boost::any_cast<string>(m["ProcPath"]));
    }
    if (m.find("RegistryContent") != m.end() && !m["RegistryContent"].empty()) {
      registryContent = make_shared<string>(boost::any_cast<string>(m["RegistryContent"]));
    }
    if (m.find("RegistryKey") != m.end() && !m["RegistryKey"].empty()) {
      registryKey = make_shared<string>(boost::any_cast<string>(m["RegistryKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ModifyClientUserDefineRuleRequest() = default;
};
class ModifyClientUserDefineRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyClientUserDefineRuleResponseBody() {}

  explicit ModifyClientUserDefineRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClientUserDefineRuleResponseBody() = default;
};
class ModifyClientUserDefineRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyClientUserDefineRuleResponseBody> body{};

  ModifyClientUserDefineRuleResponse() {}

  explicit ModifyClientUserDefineRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClientUserDefineRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClientUserDefineRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClientUserDefineRuleResponse() = default;
};
class ModifyClusterCnnfStatusUserConfirmRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> clusterIds{};
  shared_ptr<bool> userConfirm{};

  ModifyClusterCnnfStatusUserConfirmRequest() {}

  explicit ModifyClusterCnnfStatusUserConfirmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    if (userConfirm) {
      res["UserConfirm"] = boost::any(*userConfirm);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ClusterIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ClusterIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clusterIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserConfirm") != m.end() && !m["UserConfirm"].empty()) {
      userConfirm = make_shared<bool>(boost::any_cast<bool>(m["UserConfirm"]));
    }
  }


  virtual ~ModifyClusterCnnfStatusUserConfirmRequest() = default;
};
class ModifyClusterCnnfStatusUserConfirmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyClusterCnnfStatusUserConfirmResponseBody() {}

  explicit ModifyClusterCnnfStatusUserConfirmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClusterCnnfStatusUserConfirmResponseBody() = default;
};
class ModifyClusterCnnfStatusUserConfirmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyClusterCnnfStatusUserConfirmResponseBody> body{};

  ModifyClusterCnnfStatusUserConfirmResponse() {}

  explicit ModifyClusterCnnfStatusUserConfirmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClusterCnnfStatusUserConfirmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClusterCnnfStatusUserConfirmResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClusterCnnfStatusUserConfirmResponse() = default;
};
class ModifyConcernNecessityRequest : public Darabonba::Model {
public:
  shared_ptr<string> concernNecessity{};

  ModifyConcernNecessityRequest() {}

  explicit ModifyConcernNecessityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concernNecessity) {
      res["ConcernNecessity"] = boost::any(*concernNecessity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcernNecessity") != m.end() && !m["ConcernNecessity"].empty()) {
      concernNecessity = make_shared<string>(boost::any_cast<string>(m["ConcernNecessity"]));
    }
  }


  virtual ~ModifyConcernNecessityRequest() = default;
};
class ModifyConcernNecessityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyConcernNecessityResponseBody() {}

  explicit ModifyConcernNecessityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyConcernNecessityResponseBody() = default;
};
class ModifyConcernNecessityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyConcernNecessityResponseBody> body{};

  ModifyConcernNecessityResponse() {}

  explicit ModifyConcernNecessityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyConcernNecessityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyConcernNecessityResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyConcernNecessityResponse() = default;
};
class ModifyCreateVulWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> reason{};
  shared_ptr<string> targetInfo{};
  shared_ptr<string> whitelist{};

  ModifyCreateVulWhitelistRequest() {}

  explicit ModifyCreateVulWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (targetInfo) {
      res["TargetInfo"] = boost::any(*targetInfo);
    }
    if (whitelist) {
      res["Whitelist"] = boost::any(*whitelist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("TargetInfo") != m.end() && !m["TargetInfo"].empty()) {
      targetInfo = make_shared<string>(boost::any_cast<string>(m["TargetInfo"]));
    }
    if (m.find("Whitelist") != m.end() && !m["Whitelist"].empty()) {
      whitelist = make_shared<string>(boost::any_cast<string>(m["Whitelist"]));
    }
  }


  virtual ~ModifyCreateVulWhitelistRequest() = default;
};
class ModifyCreateVulWhitelistResponseBodyVulWhitelistList : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  ModifyCreateVulWhitelistResponseBodyVulWhitelistList() {}

  explicit ModifyCreateVulWhitelistResponseBodyVulWhitelistList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ModifyCreateVulWhitelistResponseBodyVulWhitelistList() = default;
};
class ModifyCreateVulWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ModifyCreateVulWhitelistResponseBodyVulWhitelistList>> vulWhitelistList{};

  ModifyCreateVulWhitelistResponseBody() {}

  explicit ModifyCreateVulWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vulWhitelistList) {
      vector<boost::any> temp1;
      for(auto item1:*vulWhitelistList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VulWhitelistList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VulWhitelistList") != m.end() && !m["VulWhitelistList"].empty()) {
      if (typeid(vector<boost::any>) == m["VulWhitelistList"].type()) {
        vector<ModifyCreateVulWhitelistResponseBodyVulWhitelistList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VulWhitelistList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCreateVulWhitelistResponseBodyVulWhitelistList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vulWhitelistList = make_shared<vector<ModifyCreateVulWhitelistResponseBodyVulWhitelistList>>(expect1);
      }
    }
  }


  virtual ~ModifyCreateVulWhitelistResponseBody() = default;
};
class ModifyCreateVulWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCreateVulWhitelistResponseBody> body{};

  ModifyCreateVulWhitelistResponse() {}

  explicit ModifyCreateVulWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCreateVulWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCreateVulWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCreateVulWhitelistResponse() = default;
};
class ModifyCustomBlockRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> blockIp{};
  shared_ptr<string> bound{};
  shared_ptr<long> expireTime{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> uuids{};

  ModifyCustomBlockRecordRequest() {}

  explicit ModifyCustomBlockRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockIp) {
      res["BlockIp"] = boost::any(*blockIp);
    }
    if (bound) {
      res["Bound"] = boost::any(*bound);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockIp") != m.end() && !m["BlockIp"].empty()) {
      blockIp = make_shared<string>(boost::any_cast<string>(m["BlockIp"]));
    }
    if (m.find("Bound") != m.end() && !m["Bound"].empty()) {
      bound = make_shared<string>(boost::any_cast<string>(m["Bound"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~ModifyCustomBlockRecordRequest() = default;
};
class ModifyCustomBlockRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCustomBlockRecordResponseBody() {}

  explicit ModifyCustomBlockRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCustomBlockRecordResponseBody() = default;
};
class ModifyCustomBlockRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCustomBlockRecordResponseBody> body{};

  ModifyCustomBlockRecordResponse() {}

  explicit ModifyCustomBlockRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCustomBlockRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCustomBlockRecordResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCustomBlockRecordResponse() = default;
};
class ModifyCycleTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<long> enable{};
  shared_ptr<long> firstDateStr{};
  shared_ptr<long> intervalPeriod{};
  shared_ptr<string> param{};
  shared_ptr<string> periodUnit{};
  shared_ptr<long> targetEndTime{};
  shared_ptr<long> targetStartTime{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskType{};

  ModifyCycleTaskRequest() {}

  explicit ModifyCycleTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (firstDateStr) {
      res["FirstDateStr"] = boost::any(*firstDateStr);
    }
    if (intervalPeriod) {
      res["IntervalPeriod"] = boost::any(*intervalPeriod);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (targetEndTime) {
      res["TargetEndTime"] = boost::any(*targetEndTime);
    }
    if (targetStartTime) {
      res["TargetStartTime"] = boost::any(*targetStartTime);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<long>(boost::any_cast<long>(m["Enable"]));
    }
    if (m.find("FirstDateStr") != m.end() && !m["FirstDateStr"].empty()) {
      firstDateStr = make_shared<long>(boost::any_cast<long>(m["FirstDateStr"]));
    }
    if (m.find("IntervalPeriod") != m.end() && !m["IntervalPeriod"].empty()) {
      intervalPeriod = make_shared<long>(boost::any_cast<long>(m["IntervalPeriod"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("TargetEndTime") != m.end() && !m["TargetEndTime"].empty()) {
      targetEndTime = make_shared<long>(boost::any_cast<long>(m["TargetEndTime"]));
    }
    if (m.find("TargetStartTime") != m.end() && !m["TargetStartTime"].empty()) {
      targetStartTime = make_shared<long>(boost::any_cast<long>(m["TargetStartTime"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~ModifyCycleTaskRequest() = default;
};
class ModifyCycleTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCycleTaskResponseBody() {}

  explicit ModifyCycleTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCycleTaskResponseBody() = default;
};
class ModifyCycleTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCycleTaskResponseBody> body{};

  ModifyCycleTaskResponse() {}

  explicit ModifyCycleTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCycleTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCycleTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCycleTaskResponse() = default;
};
class ModifyEmgVulSubmitRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> name{};
  shared_ptr<string> userAgreement{};

  ModifyEmgVulSubmitRequest() {}

  explicit ModifyEmgVulSubmitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userAgreement) {
      res["UserAgreement"] = boost::any(*userAgreement);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserAgreement") != m.end() && !m["UserAgreement"].empty()) {
      userAgreement = make_shared<string>(boost::any_cast<string>(m["UserAgreement"]));
    }
  }


  virtual ~ModifyEmgVulSubmitRequest() = default;
};
class ModifyEmgVulSubmitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyEmgVulSubmitResponseBody() {}

  explicit ModifyEmgVulSubmitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyEmgVulSubmitResponseBody() = default;
};
class ModifyEmgVulSubmitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyEmgVulSubmitResponseBody> body{};

  ModifyEmgVulSubmitResponse() {}

  explicit ModifyEmgVulSubmitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyEmgVulSubmitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyEmgVulSubmitResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyEmgVulSubmitResponse() = default;
};
class ModifyGroupPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ModifyGroupPropertyRequest() {}

  explicit ModifyGroupPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ModifyGroupPropertyRequest() = default;
};
class ModifyGroupPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyGroupPropertyResponseBody() {}

  explicit ModifyGroupPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyGroupPropertyResponseBody() = default;
};
class ModifyGroupPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyGroupPropertyResponseBody> body{};

  ModifyGroupPropertyResponse() {}

  explicit ModifyGroupPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyGroupPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyGroupPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyGroupPropertyResponse() = default;
};
class ModifyInstanceAntiBruteForceRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> newRuleId{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuid{};

  ModifyInstanceAntiBruteForceRuleRequest() {}

  explicit ModifyInstanceAntiBruteForceRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newRuleId) {
      res["NewRuleId"] = boost::any(*newRuleId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewRuleId") != m.end() && !m["NewRuleId"].empty()) {
      newRuleId = make_shared<long>(boost::any_cast<long>(m["NewRuleId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyInstanceAntiBruteForceRuleRequest() = default;
};
class ModifyInstanceAntiBruteForceRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAntiBruteForceRuleResponseBody() {}

  explicit ModifyInstanceAntiBruteForceRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAntiBruteForceRuleResponseBody() = default;
};
class ModifyInstanceAntiBruteForceRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceAntiBruteForceRuleResponseBody> body{};

  ModifyInstanceAntiBruteForceRuleResponse() {}

  explicit ModifyInstanceAntiBruteForceRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAntiBruteForceRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAntiBruteForceRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAntiBruteForceRuleResponse() = default;
};
class ModifyInterceptionRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<map<string, boost::any>> dstTarget{};
  shared_ptr<long> interceptType{};
  shared_ptr<long> orderIndex{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleSwitch{};
  shared_ptr<map<string, boost::any>> srcTarget{};

  ModifyInterceptionRuleRequest() {}

  explicit ModifyInterceptionRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dstTarget) {
      res["DstTarget"] = boost::any(*dstTarget);
    }
    if (interceptType) {
      res["InterceptType"] = boost::any(*interceptType);
    }
    if (orderIndex) {
      res["OrderIndex"] = boost::any(*orderIndex);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleSwitch) {
      res["RuleSwitch"] = boost::any(*ruleSwitch);
    }
    if (srcTarget) {
      res["SrcTarget"] = boost::any(*srcTarget);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DstTarget") != m.end() && !m["DstTarget"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["DstTarget"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      dstTarget = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("InterceptType") != m.end() && !m["InterceptType"].empty()) {
      interceptType = make_shared<long>(boost::any_cast<long>(m["InterceptType"]));
    }
    if (m.find("OrderIndex") != m.end() && !m["OrderIndex"].empty()) {
      orderIndex = make_shared<long>(boost::any_cast<long>(m["OrderIndex"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleSwitch") != m.end() && !m["RuleSwitch"].empty()) {
      ruleSwitch = make_shared<long>(boost::any_cast<long>(m["RuleSwitch"]));
    }
    if (m.find("SrcTarget") != m.end() && !m["SrcTarget"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SrcTarget"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      srcTarget = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ModifyInterceptionRuleRequest() = default;
};
class ModifyInterceptionRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dstTargetShrink{};
  shared_ptr<long> interceptType{};
  shared_ptr<long> orderIndex{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> ruleSwitch{};
  shared_ptr<string> srcTargetShrink{};

  ModifyInterceptionRuleShrinkRequest() {}

  explicit ModifyInterceptionRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dstTargetShrink) {
      res["DstTarget"] = boost::any(*dstTargetShrink);
    }
    if (interceptType) {
      res["InterceptType"] = boost::any(*interceptType);
    }
    if (orderIndex) {
      res["OrderIndex"] = boost::any(*orderIndex);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleSwitch) {
      res["RuleSwitch"] = boost::any(*ruleSwitch);
    }
    if (srcTargetShrink) {
      res["SrcTarget"] = boost::any(*srcTargetShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DstTarget") != m.end() && !m["DstTarget"].empty()) {
      dstTargetShrink = make_shared<string>(boost::any_cast<string>(m["DstTarget"]));
    }
    if (m.find("InterceptType") != m.end() && !m["InterceptType"].empty()) {
      interceptType = make_shared<long>(boost::any_cast<long>(m["InterceptType"]));
    }
    if (m.find("OrderIndex") != m.end() && !m["OrderIndex"].empty()) {
      orderIndex = make_shared<long>(boost::any_cast<long>(m["OrderIndex"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleSwitch") != m.end() && !m["RuleSwitch"].empty()) {
      ruleSwitch = make_shared<long>(boost::any_cast<long>(m["RuleSwitch"]));
    }
    if (m.find("SrcTarget") != m.end() && !m["SrcTarget"].empty()) {
      srcTargetShrink = make_shared<string>(boost::any_cast<string>(m["SrcTarget"]));
    }
  }


  virtual ~ModifyInterceptionRuleShrinkRequest() = default;
};
class ModifyInterceptionRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInterceptionRuleResponseBody() {}

  explicit ModifyInterceptionRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInterceptionRuleResponseBody() = default;
};
class ModifyInterceptionRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInterceptionRuleResponseBody> body{};

  ModifyInterceptionRuleResponse() {}

  explicit ModifyInterceptionRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInterceptionRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInterceptionRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInterceptionRuleResponse() = default;
};
class ModifyInterceptionRuleSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> ruleIds{};
  shared_ptr<long> ruleSwitch{};

  ModifyInterceptionRuleSwitchRequest() {}

  explicit ModifyInterceptionRuleSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    if (ruleSwitch) {
      res["RuleSwitch"] = boost::any(*ruleSwitch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      ruleIds = make_shared<string>(boost::any_cast<string>(m["RuleIds"]));
    }
    if (m.find("RuleSwitch") != m.end() && !m["RuleSwitch"].empty()) {
      ruleSwitch = make_shared<long>(boost::any_cast<long>(m["RuleSwitch"]));
    }
  }


  virtual ~ModifyInterceptionRuleSwitchRequest() = default;
};
class ModifyInterceptionRuleSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInterceptionRuleSwitchResponseBody() {}

  explicit ModifyInterceptionRuleSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInterceptionRuleSwitchResponseBody() = default;
};
class ModifyInterceptionRuleSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInterceptionRuleSwitchResponseBody> body{};

  ModifyInterceptionRuleSwitchResponse() {}

  explicit ModifyInterceptionRuleSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInterceptionRuleSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInterceptionRuleSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInterceptionRuleSwitchResponse() = default;
};
class ModifyInterceptionTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<vector<string>> imageList{};
  shared_ptr<string> namespace_{};
  shared_ptr<vector<string>> tagList{};
  shared_ptr<long> targetId{};
  shared_ptr<string> targetName{};
  shared_ptr<string> targetType{};

  ModifyInterceptionTargetRequest() {}

  explicit ModifyInterceptionTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (imageList) {
      res["ImageList"] = boost::any(*imageList);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetName) {
      res["TargetName"] = boost::any(*targetName);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("ImageList") != m.end() && !m["ImageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<long>(boost::any_cast<long>(m["TargetId"]));
    }
    if (m.find("TargetName") != m.end() && !m["TargetName"].empty()) {
      targetName = make_shared<string>(boost::any_cast<string>(m["TargetName"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~ModifyInterceptionTargetRequest() = default;
};
class ModifyInterceptionTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ModifyInterceptionTargetResponseBody() {}

  explicit ModifyInterceptionTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ModifyInterceptionTargetResponseBody() = default;
};
class ModifyInterceptionTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInterceptionTargetResponseBody> body{};

  ModifyInterceptionTargetResponse() {}

  explicit ModifyInterceptionTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInterceptionTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInterceptionTargetResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInterceptionTargetResponse() = default;
};
class ModifyLogMetaStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> logStore{};
  shared_ptr<string> project{};
  shared_ptr<string> status{};

  ModifyLogMetaStatusRequest() {}

  explicit ModifyLogMetaStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyLogMetaStatusRequest() = default;
};
class ModifyLogMetaStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLogMetaStatusResponseBody() {}

  explicit ModifyLogMetaStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLogMetaStatusResponseBody() = default;
};
class ModifyLogMetaStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLogMetaStatusResponseBody> body{};

  ModifyLogMetaStatusResponse() {}

  explicit ModifyLogMetaStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLogMetaStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLogMetaStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLogMetaStatusResponse() = default;
};
class ModifyLoginBaseConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  ModifyLoginBaseConfigRequest() {}

  explicit ModifyLoginBaseConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyLoginBaseConfigRequest() = default;
};
class ModifyLoginBaseConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyLoginBaseConfigResponseBody() {}

  explicit ModifyLoginBaseConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyLoginBaseConfigResponseBody() = default;
};
class ModifyLoginBaseConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLoginBaseConfigResponseBody> body{};

  ModifyLoginBaseConfigResponse() {}

  explicit ModifyLoginBaseConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLoginBaseConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLoginBaseConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLoginBaseConfigResponse() = default;
};
class ModifyLoginSwitchConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<long> status{};

  ModifyLoginSwitchConfigRequest() {}

  explicit ModifyLoginSwitchConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ModifyLoginSwitchConfigRequest() = default;
};
class ModifyLoginSwitchConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLoginSwitchConfigResponseBody() {}

  explicit ModifyLoginSwitchConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLoginSwitchConfigResponseBody() = default;
};
class ModifyLoginSwitchConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLoginSwitchConfigResponseBody> body{};

  ModifyLoginSwitchConfigResponse() {}

  explicit ModifyLoginSwitchConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLoginSwitchConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLoginSwitchConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLoginSwitchConfigResponse() = default;
};
class ModifyNoticeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> project{};
  shared_ptr<long> route{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> timeLimit{};

  ModifyNoticeConfigRequest() {}

  explicit ModifyNoticeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (route) {
      res["Route"] = boost::any(*route);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (timeLimit) {
      res["TimeLimit"] = boost::any(*timeLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Route") != m.end() && !m["Route"].empty()) {
      route = make_shared<long>(boost::any_cast<long>(m["Route"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("TimeLimit") != m.end() && !m["TimeLimit"].empty()) {
      timeLimit = make_shared<long>(boost::any_cast<long>(m["TimeLimit"]));
    }
  }


  virtual ~ModifyNoticeConfigRequest() = default;
};
class ModifyNoticeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyNoticeConfigResponseBody() {}

  explicit ModifyNoticeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyNoticeConfigResponseBody() = default;
};
class ModifyNoticeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyNoticeConfigResponseBody> body{};

  ModifyNoticeConfigResponse() {}

  explicit ModifyNoticeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyNoticeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyNoticeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyNoticeConfigResponse() = default;
};
class ModifyOpenLogShipperRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};

  ModifyOpenLogShipperRequest() {}

  explicit ModifyOpenLogShipperRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
  }


  virtual ~ModifyOpenLogShipperRequest() = default;
};
class ModifyOpenLogShipperResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyOpenLogShipperResponseBody() {}

  explicit ModifyOpenLogShipperResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyOpenLogShipperResponseBody() = default;
};
class ModifyOpenLogShipperResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyOpenLogShipperResponseBody> body{};

  ModifyOpenLogShipperResponse() {}

  explicit ModifyOpenLogShipperResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOpenLogShipperResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOpenLogShipperResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOpenLogShipperResponse() = default;
};
class ModifyOperateVulRequest : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> operateType{};
  shared_ptr<string> reason{};
  shared_ptr<string> type{};

  ModifyOperateVulRequest() {}

  explicit ModifyOperateVulRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyOperateVulRequest() = default;
};
class ModifyOperateVulResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyOperateVulResponseBody() {}

  explicit ModifyOperateVulResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyOperateVulResponseBody() = default;
};
class ModifyOperateVulResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyOperateVulResponseBody> body{};

  ModifyOperateVulResponse() {}

  explicit ModifyOperateVulResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyOperateVulResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyOperateVulResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyOperateVulResponse() = default;
};
class ModifyPropertyScheduleConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> scheduleTime{};
  shared_ptr<string> type{};

  ModifyPropertyScheduleConfigRequest() {}

  explicit ModifyPropertyScheduleConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<string>(boost::any_cast<string>(m["ScheduleTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyPropertyScheduleConfigRequest() = default;
};
class ModifyPropertyScheduleConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> modifyResult{};
  shared_ptr<string> requestId{};

  ModifyPropertyScheduleConfigResponseBody() {}

  explicit ModifyPropertyScheduleConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifyResult) {
      res["ModifyResult"] = boost::any(*modifyResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModifyResult") != m.end() && !m["ModifyResult"].empty()) {
      modifyResult = make_shared<bool>(boost::any_cast<bool>(m["ModifyResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPropertyScheduleConfigResponseBody() = default;
};
class ModifyPropertyScheduleConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPropertyScheduleConfigResponseBody> body{};

  ModifyPropertyScheduleConfigResponse() {}

  explicit ModifyPropertyScheduleConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPropertyScheduleConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPropertyScheduleConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPropertyScheduleConfigResponse() = default;
};
class ModifyPushAllTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};
  shared_ptr<string> tasks{};
  shared_ptr<string> uuids{};

  ModifyPushAllTaskRequest() {}

  explicit ModifyPushAllTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (tasks) {
      res["Tasks"] = boost::any(*tasks);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      tasks = make_shared<string>(boost::any_cast<string>(m["Tasks"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~ModifyPushAllTaskRequest() = default;
};
class ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> ip{};
  shared_ptr<string> message{};
  shared_ptr<bool> online{};
  shared_ptr<string> osVersion{};
  shared_ptr<string> region{};
  shared_ptr<bool> success{};
  shared_ptr<string> uuid{};

  ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList() {}

  explicit ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (osVersion) {
      res["OsVersion"] = boost::any(*osVersion);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      osVersion = make_shared<string>(boost::any_cast<string>(m["OsVersion"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList() = default;
};
class ModifyPushAllTaskResponseBodyPushTaskRsp : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList>> pushTaskResultList{};

  ModifyPushAllTaskResponseBodyPushTaskRsp() {}

  explicit ModifyPushAllTaskResponseBodyPushTaskRsp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushTaskResultList) {
      vector<boost::any> temp1;
      for(auto item1:*pushTaskResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PushTaskResultList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushTaskResultList") != m.end() && !m["PushTaskResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["PushTaskResultList"].type()) {
        vector<ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PushTaskResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pushTaskResultList = make_shared<vector<ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList>>(expect1);
      }
    }
  }


  virtual ~ModifyPushAllTaskResponseBodyPushTaskRsp() = default;
};
class ModifyPushAllTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyPushAllTaskResponseBodyPushTaskRsp> pushTaskRsp{};
  shared_ptr<string> requestId{};

  ModifyPushAllTaskResponseBody() {}

  explicit ModifyPushAllTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pushTaskRsp) {
      res["PushTaskRsp"] = pushTaskRsp ? boost::any(pushTaskRsp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PushTaskRsp") != m.end() && !m["PushTaskRsp"].empty()) {
      if (typeid(map<string, boost::any>) == m["PushTaskRsp"].type()) {
        ModifyPushAllTaskResponseBodyPushTaskRsp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PushTaskRsp"]));
        pushTaskRsp = make_shared<ModifyPushAllTaskResponseBodyPushTaskRsp>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPushAllTaskResponseBody() = default;
};
class ModifyPushAllTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPushAllTaskResponseBody> body{};

  ModifyPushAllTaskResponse() {}

  explicit ModifyPushAllTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPushAllTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPushAllTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPushAllTaskResponse() = default;
};
class ModifyRiskCheckStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> itemId{};
  shared_ptr<string> lang{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};

  ModifyRiskCheckStatusRequest() {}

  explicit ModifyRiskCheckStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<long>(boost::any_cast<long>(m["ItemId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~ModifyRiskCheckStatusRequest() = default;
};
class ModifyRiskCheckStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRiskCheckStatusResponseBody() {}

  explicit ModifyRiskCheckStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRiskCheckStatusResponseBody() = default;
};
class ModifyRiskCheckStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRiskCheckStatusResponseBody> body{};

  ModifyRiskCheckStatusResponse() {}

  explicit ModifyRiskCheckStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRiskCheckStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRiskCheckStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRiskCheckStatusResponse() = default;
};
class ModifyRiskSingleResultStatusRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ids{};
  shared_ptr<string> lang{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};

  ModifyRiskSingleResultStatusRequest() {}

  explicit ModifyRiskSingleResultStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~ModifyRiskSingleResultStatusRequest() = default;
};
class ModifyRiskSingleResultStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRiskSingleResultStatusResponseBody() {}

  explicit ModifyRiskSingleResultStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRiskSingleResultStatusResponseBody() = default;
};
class ModifyRiskSingleResultStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyRiskSingleResultStatusResponseBody> body{};

  ModifyRiskSingleResultStatusResponse() {}

  explicit ModifyRiskSingleResultStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRiskSingleResultStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRiskSingleResultStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRiskSingleResultStatusResponse() = default;
};
class ModifySecurityCheckScheduleConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> daysOfWeek{};
  shared_ptr<long> endTime{};
  shared_ptr<string> lang{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<long> startTime{};

  ModifySecurityCheckScheduleConfigRequest() {}

  explicit ModifySecurityCheckScheduleConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (daysOfWeek) {
      res["DaysOfWeek"] = boost::any(*daysOfWeek);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DaysOfWeek") != m.end() && !m["DaysOfWeek"].empty()) {
      daysOfWeek = make_shared<string>(boost::any_cast<string>(m["DaysOfWeek"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ModifySecurityCheckScheduleConfigRequest() = default;
};
class ModifySecurityCheckScheduleConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySecurityCheckScheduleConfigResponseBody() {}

  explicit ModifySecurityCheckScheduleConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySecurityCheckScheduleConfigResponseBody() = default;
};
class ModifySecurityCheckScheduleConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySecurityCheckScheduleConfigResponseBody> body{};

  ModifySecurityCheckScheduleConfigResponse() {}

  explicit ModifySecurityCheckScheduleConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityCheckScheduleConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityCheckScheduleConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityCheckScheduleConfigResponse() = default;
};
class ModifySecurityEventMarkMissIndividuallyRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteMarkMissParam{};
  shared_ptr<string> from{};
  shared_ptr<string> insertMarkMissParam{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};

  ModifySecurityEventMarkMissIndividuallyRequest() {}

  explicit ModifySecurityEventMarkMissIndividuallyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteMarkMissParam) {
      res["DeleteMarkMissParam"] = boost::any(*deleteMarkMissParam);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (insertMarkMissParam) {
      res["InsertMarkMissParam"] = boost::any(*insertMarkMissParam);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteMarkMissParam") != m.end() && !m["DeleteMarkMissParam"].empty()) {
      deleteMarkMissParam = make_shared<string>(boost::any_cast<string>(m["DeleteMarkMissParam"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("InsertMarkMissParam") != m.end() && !m["InsertMarkMissParam"].empty()) {
      insertMarkMissParam = make_shared<string>(boost::any_cast<string>(m["InsertMarkMissParam"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~ModifySecurityEventMarkMissIndividuallyRequest() = default;
};
class ModifySecurityEventMarkMissIndividuallyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> timeCost{};

  ModifySecurityEventMarkMissIndividuallyResponseBody() {}

  explicit ModifySecurityEventMarkMissIndividuallyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<long>(boost::any_cast<long>(m["TimeCost"]));
    }
  }


  virtual ~ModifySecurityEventMarkMissIndividuallyResponseBody() = default;
};
class ModifySecurityEventMarkMissIndividuallyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySecurityEventMarkMissIndividuallyResponseBody> body{};

  ModifySecurityEventMarkMissIndividuallyResponse() {}

  explicit ModifySecurityEventMarkMissIndividuallyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityEventMarkMissIndividuallyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityEventMarkMissIndividuallyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityEventMarkMissIndividuallyResponse() = default;
};
class ModifyStartVulScanRequest : public Darabonba::Model {
public:
  shared_ptr<string> types{};
  shared_ptr<string> uuids{};

  ModifyStartVulScanRequest() {}

  explicit ModifyStartVulScanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (types) {
      res["Types"] = boost::any(*types);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      types = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~ModifyStartVulScanRequest() = default;
};
class ModifyStartVulScanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyStartVulScanResponseBody() {}

  explicit ModifyStartVulScanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyStartVulScanResponseBody() = default;
};
class ModifyStartVulScanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyStartVulScanResponseBody> body{};

  ModifyStartVulScanResponse() {}

  explicit ModifyStartVulScanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStartVulScanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStartVulScanResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStartVulScanResponse() = default;
};
class ModifyStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> customType{};
  shared_ptr<string> cycleDays{};
  shared_ptr<string> cycleStartTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> riskCustomParams{};
  shared_ptr<string> riskSubTypeName{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> startTime{};
  shared_ptr<string> targetType{};

  ModifyStrategyRequest() {}

  explicit ModifyStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customType) {
      res["CustomType"] = boost::any(*customType);
    }
    if (cycleDays) {
      res["CycleDays"] = boost::any(*cycleDays);
    }
    if (cycleStartTime) {
      res["CycleStartTime"] = boost::any(*cycleStartTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (riskCustomParams) {
      res["RiskCustomParams"] = boost::any(*riskCustomParams);
    }
    if (riskSubTypeName) {
      res["RiskSubTypeName"] = boost::any(*riskSubTypeName);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomType") != m.end() && !m["CustomType"].empty()) {
      customType = make_shared<string>(boost::any_cast<string>(m["CustomType"]));
    }
    if (m.find("CycleDays") != m.end() && !m["CycleDays"].empty()) {
      cycleDays = make_shared<string>(boost::any_cast<string>(m["CycleDays"]));
    }
    if (m.find("CycleStartTime") != m.end() && !m["CycleStartTime"].empty()) {
      cycleStartTime = make_shared<string>(boost::any_cast<string>(m["CycleStartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RiskCustomParams") != m.end() && !m["RiskCustomParams"].empty()) {
      riskCustomParams = make_shared<string>(boost::any_cast<string>(m["RiskCustomParams"]));
    }
    if (m.find("RiskSubTypeName") != m.end() && !m["RiskSubTypeName"].empty()) {
      riskSubTypeName = make_shared<string>(boost::any_cast<string>(m["RiskSubTypeName"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~ModifyStrategyRequest() = default;
};
class ModifyStrategyResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> strategyId{};

  ModifyStrategyResponseBodyResult() {}

  explicit ModifyStrategyResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
  }


  virtual ~ModifyStrategyResponseBodyResult() = default;
};
class ModifyStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<ModifyStrategyResponseBodyResult> result{};
  shared_ptr<bool> success{};

  ModifyStrategyResponseBody() {}

  explicit ModifyStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ModifyStrategyResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ModifyStrategyResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyStrategyResponseBody() = default;
};
class ModifyStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyStrategyResponseBody> body{};

  ModifyStrategyResponse() {}

  explicit ModifyStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStrategyResponse() = default;
};
class ModifyStrategyTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  ModifyStrategyTargetRequest() {}

  explicit ModifyStrategyTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyStrategyTargetRequest() = default;
};
class ModifyStrategyTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyStrategyTargetResponseBody() {}

  explicit ModifyStrategyTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyStrategyTargetResponseBody() = default;
};
class ModifyStrategyTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyStrategyTargetResponseBody> body{};

  ModifyStrategyTargetResponse() {}

  explicit ModifyStrategyTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyStrategyTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyStrategyTargetResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyStrategyTargetResponse() = default;
};
class ModifyTagWithUuidRequest : public Darabonba::Model {
public:
  shared_ptr<string> machineTypes{};
  shared_ptr<string> tagId{};
  shared_ptr<string> tagList{};
  shared_ptr<string> uuidList{};

  ModifyTagWithUuidRequest() {}

  explicit ModifyTagWithUuidRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (machineTypes) {
      res["MachineTypes"] = boost::any(*machineTypes);
    }
    if (tagId) {
      res["TagId"] = boost::any(*tagId);
    }
    if (tagList) {
      res["TagList"] = boost::any(*tagList);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MachineTypes") != m.end() && !m["MachineTypes"].empty()) {
      machineTypes = make_shared<string>(boost::any_cast<string>(m["MachineTypes"]));
    }
    if (m.find("TagId") != m.end() && !m["TagId"].empty()) {
      tagId = make_shared<string>(boost::any_cast<string>(m["TagId"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      tagList = make_shared<string>(boost::any_cast<string>(m["TagList"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      uuidList = make_shared<string>(boost::any_cast<string>(m["UuidList"]));
    }
  }


  virtual ~ModifyTagWithUuidRequest() = default;
};
class ModifyTagWithUuidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyTagWithUuidResponseBody() {}

  explicit ModifyTagWithUuidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTagWithUuidResponseBody() = default;
};
class ModifyTagWithUuidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTagWithUuidResponseBody> body{};

  ModifyTagWithUuidResponse() {}

  explicit ModifyTagWithUuidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTagWithUuidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTagWithUuidResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTagWithUuidResponse() = default;
};
class ModifyUniBackupPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> accountPassword{};
  shared_ptr<map<string, boost::any>> fullPlan{};
  shared_ptr<map<string, boost::any>> incPlan{};
  shared_ptr<long> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyStatus{};
  shared_ptr<long> retention{};
  shared_ptr<long> speedLimiter{};

  ModifyUniBackupPolicyRequest() {}

  explicit ModifyUniBackupPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountPassword) {
      res["AccountPassword"] = boost::any(*accountPassword);
    }
    if (fullPlan) {
      res["FullPlan"] = boost::any(*fullPlan);
    }
    if (incPlan) {
      res["IncPlan"] = boost::any(*incPlan);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (policyStatus) {
      res["PolicyStatus"] = boost::any(*policyStatus);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (speedLimiter) {
      res["SpeedLimiter"] = boost::any(*speedLimiter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountPassword") != m.end() && !m["AccountPassword"].empty()) {
      accountPassword = make_shared<string>(boost::any_cast<string>(m["AccountPassword"]));
    }
    if (m.find("FullPlan") != m.end() && !m["FullPlan"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FullPlan"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      fullPlan = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IncPlan") != m.end() && !m["IncPlan"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["IncPlan"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      incPlan = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("PolicyStatus") != m.end() && !m["PolicyStatus"].empty()) {
      policyStatus = make_shared<string>(boost::any_cast<string>(m["PolicyStatus"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("SpeedLimiter") != m.end() && !m["SpeedLimiter"].empty()) {
      speedLimiter = make_shared<long>(boost::any_cast<long>(m["SpeedLimiter"]));
    }
  }


  virtual ~ModifyUniBackupPolicyRequest() = default;
};
class ModifyUniBackupPolicyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> accountPassword{};
  shared_ptr<string> fullPlanShrink{};
  shared_ptr<string> incPlanShrink{};
  shared_ptr<long> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyStatus{};
  shared_ptr<long> retention{};
  shared_ptr<long> speedLimiter{};

  ModifyUniBackupPolicyShrinkRequest() {}

  explicit ModifyUniBackupPolicyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountPassword) {
      res["AccountPassword"] = boost::any(*accountPassword);
    }
    if (fullPlanShrink) {
      res["FullPlan"] = boost::any(*fullPlanShrink);
    }
    if (incPlanShrink) {
      res["IncPlan"] = boost::any(*incPlanShrink);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (policyStatus) {
      res["PolicyStatus"] = boost::any(*policyStatus);
    }
    if (retention) {
      res["Retention"] = boost::any(*retention);
    }
    if (speedLimiter) {
      res["SpeedLimiter"] = boost::any(*speedLimiter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountPassword") != m.end() && !m["AccountPassword"].empty()) {
      accountPassword = make_shared<string>(boost::any_cast<string>(m["AccountPassword"]));
    }
    if (m.find("FullPlan") != m.end() && !m["FullPlan"].empty()) {
      fullPlanShrink = make_shared<string>(boost::any_cast<string>(m["FullPlan"]));
    }
    if (m.find("IncPlan") != m.end() && !m["IncPlan"].empty()) {
      incPlanShrink = make_shared<string>(boost::any_cast<string>(m["IncPlan"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("PolicyStatus") != m.end() && !m["PolicyStatus"].empty()) {
      policyStatus = make_shared<string>(boost::any_cast<string>(m["PolicyStatus"]));
    }
    if (m.find("Retention") != m.end() && !m["Retention"].empty()) {
      retention = make_shared<long>(boost::any_cast<long>(m["Retention"]));
    }
    if (m.find("SpeedLimiter") != m.end() && !m["SpeedLimiter"].empty()) {
      speedLimiter = make_shared<long>(boost::any_cast<long>(m["SpeedLimiter"]));
    }
  }


  virtual ~ModifyUniBackupPolicyShrinkRequest() = default;
};
class ModifyUniBackupPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyUniBackupPolicyResponseBody() {}

  explicit ModifyUniBackupPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUniBackupPolicyResponseBody() = default;
};
class ModifyUniBackupPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyUniBackupPolicyResponseBody> body{};

  ModifyUniBackupPolicyResponse() {}

  explicit ModifyUniBackupPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUniBackupPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUniBackupPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUniBackupPolicyResponse() = default;
};
class ModifyVpcHoneyPotRequest : public Darabonba::Model {
public:
  shared_ptr<string> honeyPotAction{};
  shared_ptr<string> vpcId{};

  ModifyVpcHoneyPotRequest() {}

  explicit ModifyVpcHoneyPotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeyPotAction) {
      res["HoneyPotAction"] = boost::any(*honeyPotAction);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneyPotAction") != m.end() && !m["HoneyPotAction"].empty()) {
      honeyPotAction = make_shared<string>(boost::any_cast<string>(m["HoneyPotAction"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ModifyVpcHoneyPotRequest() = default;
};
class ModifyVpcHoneyPotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVpcHoneyPotResponseBody() {}

  explicit ModifyVpcHoneyPotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVpcHoneyPotResponseBody() = default;
};
class ModifyVpcHoneyPotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpcHoneyPotResponseBody> body{};

  ModifyVpcHoneyPotResponse() {}

  explicit ModifyVpcHoneyPotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpcHoneyPotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpcHoneyPotResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpcHoneyPotResponse() = default;
};
class ModifyVulConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> type{};

  ModifyVulConfigRequest() {}

  explicit ModifyVulConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyVulConfigRequest() = default;
};
class ModifyVulConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVulConfigResponseBody() {}

  explicit ModifyVulConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVulConfigResponseBody() = default;
};
class ModifyVulConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVulConfigResponseBody> body{};

  ModifyVulConfigResponse() {}

  explicit ModifyVulConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVulConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVulConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVulConfigResponse() = default;
};
class ModifyVulTargetRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> target{};

  ModifyVulTargetRequest() {}

  explicit ModifyVulTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~ModifyVulTargetRequest() = default;
};
class ModifyVulTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVulTargetResponseBody() {}

  explicit ModifyVulTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVulTargetResponseBody() = default;
};
class ModifyVulTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVulTargetResponseBody> body{};

  ModifyVulTargetResponse() {}

  explicit ModifyVulTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVulTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVulTargetResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVulTargetResponse() = default;
};
class ModifyVulTargetConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};
  shared_ptr<string> uuid{};

  ModifyVulTargetConfigRequest() {}

  explicit ModifyVulTargetConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyVulTargetConfigRequest() = default;
};
class ModifyVulTargetConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVulTargetConfigResponseBody() {}

  explicit ModifyVulTargetConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVulTargetConfigResponseBody() = default;
};
class ModifyVulTargetConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVulTargetConfigResponseBody> body{};

  ModifyVulTargetConfigResponse() {}

  explicit ModifyVulTargetConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVulTargetConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVulTargetConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVulTargetConfigResponse() = default;
};
class ModifyVulWhitelistTargetRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> reason{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> targetInfo{};

  ModifyVulWhitelistTargetRequest() {}

  explicit ModifyVulWhitelistTargetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (targetInfo) {
      res["TargetInfo"] = boost::any(*targetInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("TargetInfo") != m.end() && !m["TargetInfo"].empty()) {
      targetInfo = make_shared<string>(boost::any_cast<string>(m["TargetInfo"]));
    }
  }


  virtual ~ModifyVulWhitelistTargetRequest() = default;
};
class ModifyVulWhitelistTargetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyVulWhitelistTargetResponseBody() {}

  explicit ModifyVulWhitelistTargetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVulWhitelistTargetResponseBody() = default;
};
class ModifyVulWhitelistTargetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVulWhitelistTargetResponseBody> body{};

  ModifyVulWhitelistTargetResponse() {}

  explicit ModifyVulWhitelistTargetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVulWhitelistTargetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVulWhitelistTargetResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVulWhitelistTargetResponse() = default;
};
class ModifyWebLockCreateConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenceMode{};
  shared_ptr<string> dir{};
  shared_ptr<string> exclusiveDir{};
  shared_ptr<string> exclusiveFile{};
  shared_ptr<string> exclusiveFileType{};
  shared_ptr<string> inclusiveFile{};
  shared_ptr<string> inclusiveFileType{};
  shared_ptr<string> lang{};
  shared_ptr<string> localBackupDir{};
  shared_ptr<string> mode{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuid{};

  ModifyWebLockCreateConfigRequest() {}

  explicit ModifyWebLockCreateConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenceMode) {
      res["DefenceMode"] = boost::any(*defenceMode);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (exclusiveDir) {
      res["ExclusiveDir"] = boost::any(*exclusiveDir);
    }
    if (exclusiveFile) {
      res["ExclusiveFile"] = boost::any(*exclusiveFile);
    }
    if (exclusiveFileType) {
      res["ExclusiveFileType"] = boost::any(*exclusiveFileType);
    }
    if (inclusiveFile) {
      res["InclusiveFile"] = boost::any(*inclusiveFile);
    }
    if (inclusiveFileType) {
      res["InclusiveFileType"] = boost::any(*inclusiveFileType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (localBackupDir) {
      res["LocalBackupDir"] = boost::any(*localBackupDir);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenceMode") != m.end() && !m["DefenceMode"].empty()) {
      defenceMode = make_shared<string>(boost::any_cast<string>(m["DefenceMode"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("ExclusiveDir") != m.end() && !m["ExclusiveDir"].empty()) {
      exclusiveDir = make_shared<string>(boost::any_cast<string>(m["ExclusiveDir"]));
    }
    if (m.find("ExclusiveFile") != m.end() && !m["ExclusiveFile"].empty()) {
      exclusiveFile = make_shared<string>(boost::any_cast<string>(m["ExclusiveFile"]));
    }
    if (m.find("ExclusiveFileType") != m.end() && !m["ExclusiveFileType"].empty()) {
      exclusiveFileType = make_shared<string>(boost::any_cast<string>(m["ExclusiveFileType"]));
    }
    if (m.find("InclusiveFile") != m.end() && !m["InclusiveFile"].empty()) {
      inclusiveFile = make_shared<string>(boost::any_cast<string>(m["InclusiveFile"]));
    }
    if (m.find("InclusiveFileType") != m.end() && !m["InclusiveFileType"].empty()) {
      inclusiveFileType = make_shared<string>(boost::any_cast<string>(m["InclusiveFileType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("LocalBackupDir") != m.end() && !m["LocalBackupDir"].empty()) {
      localBackupDir = make_shared<string>(boost::any_cast<string>(m["LocalBackupDir"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyWebLockCreateConfigRequest() = default;
};
class ModifyWebLockCreateConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockCreateConfigResponseBody() {}

  explicit ModifyWebLockCreateConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockCreateConfigResponseBody() = default;
};
class ModifyWebLockCreateConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebLockCreateConfigResponseBody> body{};

  ModifyWebLockCreateConfigResponse() {}

  explicit ModifyWebLockCreateConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockCreateConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockCreateConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockCreateConfigResponse() = default;
};
class ModifyWebLockDeleteConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuid{};

  ModifyWebLockDeleteConfigRequest() {}

  explicit ModifyWebLockDeleteConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyWebLockDeleteConfigRequest() = default;
};
class ModifyWebLockDeleteConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockDeleteConfigResponseBody() {}

  explicit ModifyWebLockDeleteConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockDeleteConfigResponseBody() = default;
};
class ModifyWebLockDeleteConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebLockDeleteConfigResponseBody> body{};

  ModifyWebLockDeleteConfigResponse() {}

  explicit ModifyWebLockDeleteConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockDeleteConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockDeleteConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockDeleteConfigResponse() = default;
};
class ModifyWebLockProcessStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> dealAll{};
  shared_ptr<string> operateInfo{};
  shared_ptr<vector<string>> processPath{};
  shared_ptr<long> status{};
  shared_ptr<string> uuid{};

  ModifyWebLockProcessStatusRequest() {}

  explicit ModifyWebLockProcessStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dealAll) {
      res["DealAll"] = boost::any(*dealAll);
    }
    if (operateInfo) {
      res["OperateInfo"] = boost::any(*operateInfo);
    }
    if (processPath) {
      res["ProcessPath"] = boost::any(*processPath);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DealAll") != m.end() && !m["DealAll"].empty()) {
      dealAll = make_shared<long>(boost::any_cast<long>(m["DealAll"]));
    }
    if (m.find("OperateInfo") != m.end() && !m["OperateInfo"].empty()) {
      operateInfo = make_shared<string>(boost::any_cast<string>(m["OperateInfo"]));
    }
    if (m.find("ProcessPath") != m.end() && !m["ProcessPath"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProcessPath"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProcessPath"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processPath = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyWebLockProcessStatusRequest() = default;
};
class ModifyWebLockProcessStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockProcessStatusResponseBody() {}

  explicit ModifyWebLockProcessStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockProcessStatusResponseBody() = default;
};
class ModifyWebLockProcessStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebLockProcessStatusResponseBody> body{};

  ModifyWebLockProcessStatusResponse() {}

  explicit ModifyWebLockProcessStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockProcessStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockProcessStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockProcessStatusResponse() = default;
};
class ModifyWebLockStartRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenceMode{};
  shared_ptr<string> dir{};
  shared_ptr<string> exclusiveDir{};
  shared_ptr<string> exclusiveFile{};
  shared_ptr<string> exclusiveFileType{};
  shared_ptr<string> inclusiveFileType{};
  shared_ptr<string> localBackupDir{};
  shared_ptr<string> mode{};
  shared_ptr<string> uuid{};

  ModifyWebLockStartRequest() {}

  explicit ModifyWebLockStartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenceMode) {
      res["DefenceMode"] = boost::any(*defenceMode);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (exclusiveDir) {
      res["ExclusiveDir"] = boost::any(*exclusiveDir);
    }
    if (exclusiveFile) {
      res["ExclusiveFile"] = boost::any(*exclusiveFile);
    }
    if (exclusiveFileType) {
      res["ExclusiveFileType"] = boost::any(*exclusiveFileType);
    }
    if (inclusiveFileType) {
      res["InclusiveFileType"] = boost::any(*inclusiveFileType);
    }
    if (localBackupDir) {
      res["LocalBackupDir"] = boost::any(*localBackupDir);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenceMode") != m.end() && !m["DefenceMode"].empty()) {
      defenceMode = make_shared<string>(boost::any_cast<string>(m["DefenceMode"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("ExclusiveDir") != m.end() && !m["ExclusiveDir"].empty()) {
      exclusiveDir = make_shared<string>(boost::any_cast<string>(m["ExclusiveDir"]));
    }
    if (m.find("ExclusiveFile") != m.end() && !m["ExclusiveFile"].empty()) {
      exclusiveFile = make_shared<string>(boost::any_cast<string>(m["ExclusiveFile"]));
    }
    if (m.find("ExclusiveFileType") != m.end() && !m["ExclusiveFileType"].empty()) {
      exclusiveFileType = make_shared<string>(boost::any_cast<string>(m["ExclusiveFileType"]));
    }
    if (m.find("InclusiveFileType") != m.end() && !m["InclusiveFileType"].empty()) {
      inclusiveFileType = make_shared<string>(boost::any_cast<string>(m["InclusiveFileType"]));
    }
    if (m.find("LocalBackupDir") != m.end() && !m["LocalBackupDir"].empty()) {
      localBackupDir = make_shared<string>(boost::any_cast<string>(m["LocalBackupDir"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyWebLockStartRequest() = default;
};
class ModifyWebLockStartResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockStartResponseBody() {}

  explicit ModifyWebLockStartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockStartResponseBody() = default;
};
class ModifyWebLockStartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebLockStartResponseBody> body{};

  ModifyWebLockStartResponse() {}

  explicit ModifyWebLockStartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockStartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockStartResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockStartResponse() = default;
};
class ModifyWebLockStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> status{};
  shared_ptr<string> uuid{};

  ModifyWebLockStatusRequest() {}

  explicit ModifyWebLockStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyWebLockStatusRequest() = default;
};
class ModifyWebLockStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockStatusResponseBody() {}

  explicit ModifyWebLockStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockStatusResponseBody() = default;
};
class ModifyWebLockStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebLockStatusResponseBody> body{};

  ModifyWebLockStatusResponse() {}

  explicit ModifyWebLockStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockStatusResponse() = default;
};
class ModifyWebLockUnbindRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};

  ModifyWebLockUnbindRequest() {}

  explicit ModifyWebLockUnbindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyWebLockUnbindRequest() = default;
};
class ModifyWebLockUnbindResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockUnbindResponseBody() {}

  explicit ModifyWebLockUnbindResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockUnbindResponseBody() = default;
};
class ModifyWebLockUnbindResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebLockUnbindResponseBody> body{};

  ModifyWebLockUnbindResponse() {}

  explicit ModifyWebLockUnbindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockUnbindResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockUnbindResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockUnbindResponse() = default;
};
class ModifyWebLockUpdateConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenceMode{};
  shared_ptr<string> dir{};
  shared_ptr<string> exclusiveDir{};
  shared_ptr<string> exclusiveFile{};
  shared_ptr<string> exclusiveFileType{};
  shared_ptr<long> id{};
  shared_ptr<string> inclusiveFile{};
  shared_ptr<string> inclusiveFileType{};
  shared_ptr<string> lang{};
  shared_ptr<string> localBackupDir{};
  shared_ptr<string> mode{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuid{};

  ModifyWebLockUpdateConfigRequest() {}

  explicit ModifyWebLockUpdateConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenceMode) {
      res["DefenceMode"] = boost::any(*defenceMode);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (exclusiveDir) {
      res["ExclusiveDir"] = boost::any(*exclusiveDir);
    }
    if (exclusiveFile) {
      res["ExclusiveFile"] = boost::any(*exclusiveFile);
    }
    if (exclusiveFileType) {
      res["ExclusiveFileType"] = boost::any(*exclusiveFileType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inclusiveFile) {
      res["InclusiveFile"] = boost::any(*inclusiveFile);
    }
    if (inclusiveFileType) {
      res["InclusiveFileType"] = boost::any(*inclusiveFileType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (localBackupDir) {
      res["LocalBackupDir"] = boost::any(*localBackupDir);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenceMode") != m.end() && !m["DefenceMode"].empty()) {
      defenceMode = make_shared<string>(boost::any_cast<string>(m["DefenceMode"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("ExclusiveDir") != m.end() && !m["ExclusiveDir"].empty()) {
      exclusiveDir = make_shared<string>(boost::any_cast<string>(m["ExclusiveDir"]));
    }
    if (m.find("ExclusiveFile") != m.end() && !m["ExclusiveFile"].empty()) {
      exclusiveFile = make_shared<string>(boost::any_cast<string>(m["ExclusiveFile"]));
    }
    if (m.find("ExclusiveFileType") != m.end() && !m["ExclusiveFileType"].empty()) {
      exclusiveFileType = make_shared<string>(boost::any_cast<string>(m["ExclusiveFileType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InclusiveFile") != m.end() && !m["InclusiveFile"].empty()) {
      inclusiveFile = make_shared<string>(boost::any_cast<string>(m["InclusiveFile"]));
    }
    if (m.find("InclusiveFileType") != m.end() && !m["InclusiveFileType"].empty()) {
      inclusiveFileType = make_shared<string>(boost::any_cast<string>(m["InclusiveFileType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("LocalBackupDir") != m.end() && !m["LocalBackupDir"].empty()) {
      localBackupDir = make_shared<string>(boost::any_cast<string>(m["LocalBackupDir"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ModifyWebLockUpdateConfigRequest() = default;
};
class ModifyWebLockUpdateConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyWebLockUpdateConfigResponseBody() {}

  explicit ModifyWebLockUpdateConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyWebLockUpdateConfigResponseBody() = default;
};
class ModifyWebLockUpdateConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebLockUpdateConfigResponseBody> body{};

  ModifyWebLockUpdateConfigResponse() {}

  explicit ModifyWebLockUpdateConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebLockUpdateConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebLockUpdateConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebLockUpdateConfigResponse() = default;
};
class ModifyWebPathRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> target{};
  shared_ptr<string> type{};

  ModifyWebPathRequest() {}

  explicit ModifyWebPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyWebPathRequest() = default;
};
class ModifyWebPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ModifyWebPathResponseBody() {}

  explicit ModifyWebPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyWebPathResponseBody() = default;
};
class ModifyWebPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWebPathResponseBody> body{};

  ModifyWebPathResponse() {}

  explicit ModifyWebPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWebPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWebPathResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWebPathResponse() = default;
};
class OpenSensitiveFileScanRequest : public Darabonba::Model {
public:
  shared_ptr<string> switchOn{};

  OpenSensitiveFileScanRequest() {}

  explicit OpenSensitiveFileScanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (switchOn) {
      res["SwitchOn"] = boost::any(*switchOn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SwitchOn") != m.end() && !m["SwitchOn"].empty()) {
      switchOn = make_shared<string>(boost::any_cast<string>(m["SwitchOn"]));
    }
  }


  virtual ~OpenSensitiveFileScanRequest() = default;
};
class OpenSensitiveFileScanResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> switchOn{};

  OpenSensitiveFileScanResponseBodyData() {}

  explicit OpenSensitiveFileScanResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (switchOn) {
      res["SwitchOn"] = boost::any(*switchOn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SwitchOn") != m.end() && !m["SwitchOn"].empty()) {
      switchOn = make_shared<string>(boost::any_cast<string>(m["SwitchOn"]));
    }
  }


  virtual ~OpenSensitiveFileScanResponseBodyData() = default;
};
class OpenSensitiveFileScanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<OpenSensitiveFileScanResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  OpenSensitiveFileScanResponseBody() {}

  explicit OpenSensitiveFileScanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        OpenSensitiveFileScanResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<OpenSensitiveFileScanResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~OpenSensitiveFileScanResponseBody() = default;
};
class OpenSensitiveFileScanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenSensitiveFileScanResponseBody> body{};

  OpenSensitiveFileScanResponse() {}

  explicit OpenSensitiveFileScanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenSensitiveFileScanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenSensitiveFileScanResponseBody>(model1);
      }
    }
  }


  virtual ~OpenSensitiveFileScanResponse() = default;
};
class OperateAgentClientInstallRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIds{};
  shared_ptr<string> lang{};
  shared_ptr<string> uuids{};

  OperateAgentClientInstallRequest() {}

  explicit OperateAgentClientInstallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~OperateAgentClientInstallRequest() = default;
};
class OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> recordId{};
  shared_ptr<string> uuid{};

  OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList() {}

  explicit OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<long>(boost::any_cast<long>(m["RecordId"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList() = default;
};
class OperateAgentClientInstallResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList>> aegisCelintInstallResposeList{};
  shared_ptr<string> requestId{};

  OperateAgentClientInstallResponseBody() {}

  explicit OperateAgentClientInstallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aegisCelintInstallResposeList) {
      vector<boost::any> temp1;
      for(auto item1:*aegisCelintInstallResposeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AegisCelintInstallResposeList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AegisCelintInstallResposeList") != m.end() && !m["AegisCelintInstallResposeList"].empty()) {
      if (typeid(vector<boost::any>) == m["AegisCelintInstallResposeList"].type()) {
        vector<OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AegisCelintInstallResposeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aegisCelintInstallResposeList = make_shared<vector<OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateAgentClientInstallResponseBody() = default;
};
class OperateAgentClientInstallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateAgentClientInstallResponseBody> body{};

  OperateAgentClientInstallResponse() {}

  explicit OperateAgentClientInstallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateAgentClientInstallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateAgentClientInstallResponseBody>(model1);
      }
    }
  }


  virtual ~OperateAgentClientInstallResponse() = default;
};
class OperateCommonOverallConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  OperateCommonOverallConfigRequest() {}

  explicit OperateCommonOverallConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~OperateCommonOverallConfigRequest() = default;
};
class OperateCommonOverallConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateCommonOverallConfigResponseBody() {}

  explicit OperateCommonOverallConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateCommonOverallConfigResponseBody() = default;
};
class OperateCommonOverallConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateCommonOverallConfigResponseBody> body{};

  OperateCommonOverallConfigResponse() {}

  explicit OperateCommonOverallConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateCommonOverallConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateCommonOverallConfigResponseBody>(model1);
      }
    }
  }


  virtual ~OperateCommonOverallConfigResponse() = default;
};
class OperateCommonTargetConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> targetOperations{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};

  OperateCommonTargetConfigRequest() {}

  explicit OperateCommonTargetConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (targetOperations) {
      res["TargetOperations"] = boost::any(*targetOperations);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("TargetOperations") != m.end() && !m["TargetOperations"].empty()) {
      targetOperations = make_shared<string>(boost::any_cast<string>(m["TargetOperations"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~OperateCommonTargetConfigRequest() = default;
};
class OperateCommonTargetConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateCommonTargetConfigResponseBody() {}

  explicit OperateCommonTargetConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateCommonTargetConfigResponseBody() = default;
};
class OperateCommonTargetConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateCommonTargetConfigResponseBody> body{};

  OperateCommonTargetConfigResponse() {}

  explicit OperateCommonTargetConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateCommonTargetConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateCommonTargetConfigResponseBody>(model1);
      }
    }
  }


  virtual ~OperateCommonTargetConfigResponse() = default;
};
class OperateImageBaselineWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> baselineItemKeyList{};
  shared_ptr<string> imageUuid{};
  shared_ptr<string> lang{};
  shared_ptr<string> operation{};
  shared_ptr<vector<string>> scanRange{};

  OperateImageBaselineWhitelistRequest() {}

  explicit OperateImageBaselineWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineItemKeyList) {
      res["BaselineItemKeyList"] = boost::any(*baselineItemKeyList);
    }
    if (imageUuid) {
      res["ImageUuid"] = boost::any(*imageUuid);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (scanRange) {
      res["ScanRange"] = boost::any(*scanRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineItemKeyList") != m.end() && !m["BaselineItemKeyList"].empty()) {
      baselineItemKeyList = make_shared<string>(boost::any_cast<string>(m["BaselineItemKeyList"]));
    }
    if (m.find("ImageUuid") != m.end() && !m["ImageUuid"].empty()) {
      imageUuid = make_shared<string>(boost::any_cast<string>(m["ImageUuid"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("ScanRange") != m.end() && !m["ScanRange"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScanRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScanRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scanRange = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~OperateImageBaselineWhitelistRequest() = default;
};
class OperateImageBaselineWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateImageBaselineWhitelistResponseBody() {}

  explicit OperateImageBaselineWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateImageBaselineWhitelistResponseBody() = default;
};
class OperateImageBaselineWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateImageBaselineWhitelistResponseBody> body{};

  OperateImageBaselineWhitelistResponse() {}

  explicit OperateImageBaselineWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateImageBaselineWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateImageBaselineWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~OperateImageBaselineWhitelistResponse() = default;
};
class OperateImageVulRequest : public Darabonba::Model {
public:
  shared_ptr<string> info{};
  shared_ptr<string> operateType{};
  shared_ptr<string> type{};

  OperateImageVulRequest() {}

  explicit OperateImageVulRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (info) {
      res["Info"] = boost::any(*info);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<string>(boost::any_cast<string>(m["Info"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~OperateImageVulRequest() = default;
};
class OperateImageVulResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateImageVulResponseBody() {}

  explicit OperateImageVulResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateImageVulResponseBody() = default;
};
class OperateImageVulResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateImageVulResponseBody> body{};

  OperateImageVulResponse() {}

  explicit OperateImageVulResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateImageVulResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateImageVulResponseBody>(model1);
      }
    }
  }


  virtual ~OperateImageVulResponse() = default;
};
class OperateSuspiciousOverallConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> lang{};
  shared_ptr<bool> noTargetAsOn{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  OperateSuspiciousOverallConfigRequest() {}

  explicit OperateSuspiciousOverallConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (noTargetAsOn) {
      res["NoTargetAsOn"] = boost::any(*noTargetAsOn);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NoTargetAsOn") != m.end() && !m["NoTargetAsOn"].empty()) {
      noTargetAsOn = make_shared<bool>(boost::any_cast<bool>(m["NoTargetAsOn"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~OperateSuspiciousOverallConfigRequest() = default;
};
class OperateSuspiciousOverallConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateSuspiciousOverallConfigResponseBody() {}

  explicit OperateSuspiciousOverallConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateSuspiciousOverallConfigResponseBody() = default;
};
class OperateSuspiciousOverallConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateSuspiciousOverallConfigResponseBody> body{};

  OperateSuspiciousOverallConfigResponse() {}

  explicit OperateSuspiciousOverallConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateSuspiciousOverallConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateSuspiciousOverallConfigResponseBody>(model1);
      }
    }
  }


  virtual ~OperateSuspiciousOverallConfigResponse() = default;
};
class OperateSuspiciousTargetConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> targetOperations{};
  shared_ptr<string> targetType{};
  shared_ptr<string> type{};

  OperateSuspiciousTargetConfigRequest() {}

  explicit OperateSuspiciousTargetConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (targetOperations) {
      res["TargetOperations"] = boost::any(*targetOperations);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("TargetOperations") != m.end() && !m["TargetOperations"].empty()) {
      targetOperations = make_shared<string>(boost::any_cast<string>(m["TargetOperations"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~OperateSuspiciousTargetConfigRequest() = default;
};
class OperateSuspiciousTargetConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateSuspiciousTargetConfigResponseBody() {}

  explicit OperateSuspiciousTargetConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateSuspiciousTargetConfigResponseBody() = default;
};
class OperateSuspiciousTargetConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateSuspiciousTargetConfigResponseBody> body{};

  OperateSuspiciousTargetConfigResponse() {}

  explicit OperateSuspiciousTargetConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateSuspiciousTargetConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateSuspiciousTargetConfigResponseBody>(model1);
      }
    }
  }


  virtual ~OperateSuspiciousTargetConfigResponse() = default;
};
class OperateVirusEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> operationAll{};
  shared_ptr<string> operationCode{};
  shared_ptr<string> operationRange{};

  OperateVirusEventsRequest() {}

  explicit OperateVirusEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationAll) {
      res["OperationAll"] = boost::any(*operationAll);
    }
    if (operationCode) {
      res["OperationCode"] = boost::any(*operationCode);
    }
    if (operationRange) {
      res["OperationRange"] = boost::any(*operationRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationAll") != m.end() && !m["OperationAll"].empty()) {
      operationAll = make_shared<long>(boost::any_cast<long>(m["OperationAll"]));
    }
    if (m.find("OperationCode") != m.end() && !m["OperationCode"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["OperationCode"]));
    }
    if (m.find("OperationRange") != m.end() && !m["OperationRange"].empty()) {
      operationRange = make_shared<string>(boost::any_cast<string>(m["OperationRange"]));
    }
  }


  virtual ~OperateVirusEventsRequest() = default;
};
class OperateVirusEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> taskId{};

  OperateVirusEventsResponseBody() {}

  explicit OperateVirusEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~OperateVirusEventsResponseBody() = default;
};
class OperateVirusEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateVirusEventsResponseBody> body{};

  OperateVirusEventsResponse() {}

  explicit OperateVirusEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateVirusEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateVirusEventsResponseBody>(model1);
      }
    }
  }


  virtual ~OperateVirusEventsResponse() = default;
};
class OperateVulsRequest : public Darabonba::Model {
public:
  shared_ptr<string> operateType{};
  shared_ptr<string> type{};
  shared_ptr<vector<string>> uuids{};
  shared_ptr<vector<string>> vulNames{};

  OperateVulsRequest() {}

  explicit OperateVulsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (vulNames) {
      res["VulNames"] = boost::any(*vulNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Uuids"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Uuids"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuids = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VulNames") != m.end() && !m["VulNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VulNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VulNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vulNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~OperateVulsRequest() = default;
};
class OperateVulsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateVulsResponseBody() {}

  explicit OperateVulsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateVulsResponseBody() = default;
};
class OperateVulsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateVulsResponseBody> body{};

  OperateVulsResponse() {}

  explicit OperateVulsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateVulsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateVulsResponseBody>(model1);
      }
    }
  }


  virtual ~OperateVulsResponse() = default;
};
class OperateWebLockFileEventsRequest : public Darabonba::Model {
public:
  shared_ptr<long> dealAll{};
  shared_ptr<vector<long>> eventIds{};
  shared_ptr<string> operationCode{};

  OperateWebLockFileEventsRequest() {}

  explicit OperateWebLockFileEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dealAll) {
      res["DealAll"] = boost::any(*dealAll);
    }
    if (eventIds) {
      res["EventIds"] = boost::any(*eventIds);
    }
    if (operationCode) {
      res["OperationCode"] = boost::any(*operationCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DealAll") != m.end() && !m["DealAll"].empty()) {
      dealAll = make_shared<long>(boost::any_cast<long>(m["DealAll"]));
    }
    if (m.find("EventIds") != m.end() && !m["EventIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["EventIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      eventIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("OperationCode") != m.end() && !m["OperationCode"].empty()) {
      operationCode = make_shared<string>(boost::any_cast<string>(m["OperationCode"]));
    }
  }


  virtual ~OperateWebLockFileEventsRequest() = default;
};
class OperateWebLockFileEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OperateWebLockFileEventsResponseBody() {}

  explicit OperateWebLockFileEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OperateWebLockFileEventsResponseBody() = default;
};
class OperateWebLockFileEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateWebLockFileEventsResponseBody> body{};

  OperateWebLockFileEventsResponse() {}

  explicit OperateWebLockFileEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateWebLockFileEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateWebLockFileEventsResponseBody>(model1);
      }
    }
  }


  virtual ~OperateWebLockFileEventsResponse() = default;
};
class OperationCancelIgnoreSuspEventRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> securityEventIds{};

  OperationCancelIgnoreSuspEventRequest() {}

  explicit OperationCancelIgnoreSuspEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityEventIds) {
      res["SecurityEventIds"] = boost::any(*securityEventIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityEventIds") != m.end() && !m["SecurityEventIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityEventIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityEventIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      securityEventIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~OperationCancelIgnoreSuspEventRequest() = default;
};
class OperationCancelIgnoreSuspEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> timeCost{};

  OperationCancelIgnoreSuspEventResponseBody() {}

  explicit OperationCancelIgnoreSuspEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<long>(boost::any_cast<long>(m["TimeCost"]));
    }
  }


  virtual ~OperationCancelIgnoreSuspEventResponseBody() = default;
};
class OperationCancelIgnoreSuspEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperationCancelIgnoreSuspEventResponseBody> body{};

  OperationCancelIgnoreSuspEventResponse() {}

  explicit OperationCancelIgnoreSuspEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperationCancelIgnoreSuspEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperationCancelIgnoreSuspEventResponseBody>(model1);
      }
    }
  }


  virtual ~OperationCancelIgnoreSuspEventResponse() = default;
};
class OperationSuspEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> operation{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> subOperation{};
  shared_ptr<string> suspiciousEventIds{};
  shared_ptr<string> warnType{};

  OperationSuspEventsRequest() {}

  explicit OperationSuspEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (subOperation) {
      res["SubOperation"] = boost::any(*subOperation);
    }
    if (suspiciousEventIds) {
      res["SuspiciousEventIds"] = boost::any(*suspiciousEventIds);
    }
    if (warnType) {
      res["WarnType"] = boost::any(*warnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("SubOperation") != m.end() && !m["SubOperation"].empty()) {
      subOperation = make_shared<string>(boost::any_cast<string>(m["SubOperation"]));
    }
    if (m.find("SuspiciousEventIds") != m.end() && !m["SuspiciousEventIds"].empty()) {
      suspiciousEventIds = make_shared<string>(boost::any_cast<string>(m["SuspiciousEventIds"]));
    }
    if (m.find("WarnType") != m.end() && !m["WarnType"].empty()) {
      warnType = make_shared<string>(boost::any_cast<string>(m["WarnType"]));
    }
  }


  virtual ~OperationSuspEventsRequest() = default;
};
class OperationSuspEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  OperationSuspEventsResponseBody() {}

  explicit OperationSuspEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessCode) {
      res["AccessCode"] = boost::any(*accessCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessCode") != m.end() && !m["AccessCode"].empty()) {
      accessCode = make_shared<string>(boost::any_cast<string>(m["AccessCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~OperationSuspEventsResponseBody() = default;
};
class OperationSuspEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperationSuspEventsResponseBody> body{};

  OperationSuspEventsResponse() {}

  explicit OperationSuspEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperationSuspEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperationSuspEventsResponseBody>(model1);
      }
    }
  }


  virtual ~OperationSuspEventsResponse() = default;
};
class PageImageRegistryRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> registryNameLike{};
  shared_ptr<vector<string>> registryTypeInList{};
  shared_ptr<vector<string>> registryTypeNotInList{};
  shared_ptr<string> sourceIp{};

  PageImageRegistryRequest() {}

  explicit PageImageRegistryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (registryNameLike) {
      res["RegistryNameLike"] = boost::any(*registryNameLike);
    }
    if (registryTypeInList) {
      res["RegistryTypeInList"] = boost::any(*registryTypeInList);
    }
    if (registryTypeNotInList) {
      res["RegistryTypeNotInList"] = boost::any(*registryTypeNotInList);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegistryNameLike") != m.end() && !m["RegistryNameLike"].empty()) {
      registryNameLike = make_shared<string>(boost::any_cast<string>(m["RegistryNameLike"]));
    }
    if (m.find("RegistryTypeInList") != m.end() && !m["RegistryTypeInList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RegistryTypeInList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RegistryTypeInList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      registryTypeInList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegistryTypeNotInList") != m.end() && !m["RegistryTypeNotInList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RegistryTypeNotInList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RegistryTypeNotInList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      registryTypeNotInList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~PageImageRegistryRequest() = default;
};
class PageImageRegistryResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<string> blackList{};
  shared_ptr<string> domainName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> imageCount{};
  shared_ptr<string> jenkinsEnv{};
  shared_ptr<long> netType{};
  shared_ptr<string> password{};
  shared_ptr<long> persistenceDay{};
  shared_ptr<long> protocolType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> registryHostIp{};
  shared_ptr<string> registryName{};
  shared_ptr<string> registryType{};
  shared_ptr<string> token{};
  shared_ptr<long> transPerHour{};
  shared_ptr<string> userName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> whiteList{};

  PageImageRegistryResponseBodyList() {}

  explicit PageImageRegistryResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackList) {
      res["BlackList"] = boost::any(*blackList);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageCount) {
      res["ImageCount"] = boost::any(*imageCount);
    }
    if (jenkinsEnv) {
      res["JenkinsEnv"] = boost::any(*jenkinsEnv);
    }
    if (netType) {
      res["NetType"] = boost::any(*netType);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (persistenceDay) {
      res["PersistenceDay"] = boost::any(*persistenceDay);
    }
    if (protocolType) {
      res["ProtocolType"] = boost::any(*protocolType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (registryHostIp) {
      res["RegistryHostIp"] = boost::any(*registryHostIp);
    }
    if (registryName) {
      res["RegistryName"] = boost::any(*registryName);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (transPerHour) {
      res["TransPerHour"] = boost::any(*transPerHour);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (whiteList) {
      res["WhiteList"] = boost::any(*whiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackList") != m.end() && !m["BlackList"].empty()) {
      blackList = make_shared<string>(boost::any_cast<string>(m["BlackList"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ImageCount") != m.end() && !m["ImageCount"].empty()) {
      imageCount = make_shared<long>(boost::any_cast<long>(m["ImageCount"]));
    }
    if (m.find("JenkinsEnv") != m.end() && !m["JenkinsEnv"].empty()) {
      jenkinsEnv = make_shared<string>(boost::any_cast<string>(m["JenkinsEnv"]));
    }
    if (m.find("NetType") != m.end() && !m["NetType"].empty()) {
      netType = make_shared<long>(boost::any_cast<long>(m["NetType"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PersistenceDay") != m.end() && !m["PersistenceDay"].empty()) {
      persistenceDay = make_shared<long>(boost::any_cast<long>(m["PersistenceDay"]));
    }
    if (m.find("ProtocolType") != m.end() && !m["ProtocolType"].empty()) {
      protocolType = make_shared<long>(boost::any_cast<long>(m["ProtocolType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegistryHostIp") != m.end() && !m["RegistryHostIp"].empty()) {
      registryHostIp = make_shared<string>(boost::any_cast<string>(m["RegistryHostIp"]));
    }
    if (m.find("RegistryName") != m.end() && !m["RegistryName"].empty()) {
      registryName = make_shared<string>(boost::any_cast<string>(m["RegistryName"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("TransPerHour") != m.end() && !m["TransPerHour"].empty()) {
      transPerHour = make_shared<long>(boost::any_cast<long>(m["TransPerHour"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("WhiteList") != m.end() && !m["WhiteList"].empty()) {
      whiteList = make_shared<string>(boost::any_cast<string>(m["WhiteList"]));
    }
  }


  virtual ~PageImageRegistryResponseBodyList() = default;
};
class PageImageRegistryResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  PageImageRegistryResponseBodyPageInfo() {}

  explicit PageImageRegistryResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~PageImageRegistryResponseBodyPageInfo() = default;
};
class PageImageRegistryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<PageImageRegistryResponseBodyList>> list{};
  shared_ptr<PageImageRegistryResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};

  PageImageRegistryResponseBody() {}

  explicit PageImageRegistryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<PageImageRegistryResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PageImageRegistryResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<PageImageRegistryResponseBodyList>>(expect1);
      }
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        PageImageRegistryResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<PageImageRegistryResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PageImageRegistryResponseBody() = default;
};
class PageImageRegistryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PageImageRegistryResponseBody> body{};

  PageImageRegistryResponse() {}

  explicit PageImageRegistryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PageImageRegistryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PageImageRegistryResponseBody>(model1);
      }
    }
  }


  virtual ~PageImageRegistryResponse() = default;
};
class PauseClientRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuids{};
  shared_ptr<string> value{};

  PauseClientRequest() {}

  explicit PauseClientRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PauseClientRequest() = default;
};
class PauseClientResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PauseClientResponseBody() {}

  explicit PauseClientResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PauseClientResponseBody() = default;
};
class PauseClientResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PauseClientResponseBody> body{};

  PauseClientResponse() {}

  explicit PauseClientResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PauseClientResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PauseClientResponseBody>(model1);
      }
    }
  }


  virtual ~PauseClientResponse() = default;
};
class PublicCreateImageScanTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> digests{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> regionIds{};
  shared_ptr<string> registryTypes{};
  shared_ptr<string> repoIds{};
  shared_ptr<string> repoNames{};
  shared_ptr<string> repoNamespaces{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> tags{};

  PublicCreateImageScanTaskRequest() {}

  explicit PublicCreateImageScanTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (digests) {
      res["Digests"] = boost::any(*digests);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (regionIds) {
      res["RegionIds"] = boost::any(*regionIds);
    }
    if (registryTypes) {
      res["RegistryTypes"] = boost::any(*registryTypes);
    }
    if (repoIds) {
      res["RepoIds"] = boost::any(*repoIds);
    }
    if (repoNames) {
      res["RepoNames"] = boost::any(*repoNames);
    }
    if (repoNamespaces) {
      res["RepoNamespaces"] = boost::any(*repoNamespaces);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Digests") != m.end() && !m["Digests"].empty()) {
      digests = make_shared<string>(boost::any_cast<string>(m["Digests"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("RegionIds") != m.end() && !m["RegionIds"].empty()) {
      regionIds = make_shared<string>(boost::any_cast<string>(m["RegionIds"]));
    }
    if (m.find("RegistryTypes") != m.end() && !m["RegistryTypes"].empty()) {
      registryTypes = make_shared<string>(boost::any_cast<string>(m["RegistryTypes"]));
    }
    if (m.find("RepoIds") != m.end() && !m["RepoIds"].empty()) {
      repoIds = make_shared<string>(boost::any_cast<string>(m["RepoIds"]));
    }
    if (m.find("RepoNames") != m.end() && !m["RepoNames"].empty()) {
      repoNames = make_shared<string>(boost::any_cast<string>(m["RepoNames"]));
    }
    if (m.find("RepoNamespaces") != m.end() && !m["RepoNamespaces"].empty()) {
      repoNamespaces = make_shared<string>(boost::any_cast<string>(m["RepoNamespaces"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~PublicCreateImageScanTaskRequest() = default;
};
class PublicCreateImageScanTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> canCreate{};
  shared_ptr<long> collectTime{};
  shared_ptr<long> execTime{};
  shared_ptr<long> finishCount{};
  shared_ptr<long> progress{};
  shared_ptr<string> result{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<long> totalCount{};

  PublicCreateImageScanTaskResponseBodyData() {}

  explicit PublicCreateImageScanTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canCreate) {
      res["CanCreate"] = boost::any(*canCreate);
    }
    if (collectTime) {
      res["CollectTime"] = boost::any(*collectTime);
    }
    if (execTime) {
      res["ExecTime"] = boost::any(*execTime);
    }
    if (finishCount) {
      res["FinishCount"] = boost::any(*finishCount);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanCreate") != m.end() && !m["CanCreate"].empty()) {
      canCreate = make_shared<bool>(boost::any_cast<bool>(m["CanCreate"]));
    }
    if (m.find("CollectTime") != m.end() && !m["CollectTime"].empty()) {
      collectTime = make_shared<long>(boost::any_cast<long>(m["CollectTime"]));
    }
    if (m.find("ExecTime") != m.end() && !m["ExecTime"].empty()) {
      execTime = make_shared<long>(boost::any_cast<long>(m["ExecTime"]));
    }
    if (m.find("FinishCount") != m.end() && !m["FinishCount"].empty()) {
      finishCount = make_shared<long>(boost::any_cast<long>(m["FinishCount"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~PublicCreateImageScanTaskResponseBodyData() = default;
};
class PublicCreateImageScanTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<PublicCreateImageScanTaskResponseBodyData> data{};
  shared_ptr<string> requestId{};

  PublicCreateImageScanTaskResponseBody() {}

  explicit PublicCreateImageScanTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PublicCreateImageScanTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PublicCreateImageScanTaskResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublicCreateImageScanTaskResponseBody() = default;
};
class PublicCreateImageScanTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublicCreateImageScanTaskResponseBody> body{};

  PublicCreateImageScanTaskResponse() {}

  explicit PublicCreateImageScanTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublicCreateImageScanTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublicCreateImageScanTaskResponseBody>(model1);
      }
    }
  }


  virtual ~PublicCreateImageScanTaskResponse() = default;
};
class PublicPreCheckImageScanTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> digests{};
  shared_ptr<string> instanceIds{};
  shared_ptr<string> regionIds{};
  shared_ptr<string> registryTypes{};
  shared_ptr<string> repoIds{};
  shared_ptr<string> repoNames{};
  shared_ptr<string> repoNamespaces{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> tags{};

  PublicPreCheckImageScanTaskRequest() {}

  explicit PublicPreCheckImageScanTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (digests) {
      res["Digests"] = boost::any(*digests);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (regionIds) {
      res["RegionIds"] = boost::any(*regionIds);
    }
    if (registryTypes) {
      res["RegistryTypes"] = boost::any(*registryTypes);
    }
    if (repoIds) {
      res["RepoIds"] = boost::any(*repoIds);
    }
    if (repoNames) {
      res["RepoNames"] = boost::any(*repoNames);
    }
    if (repoNamespaces) {
      res["RepoNamespaces"] = boost::any(*repoNamespaces);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Digests") != m.end() && !m["Digests"].empty()) {
      digests = make_shared<string>(boost::any_cast<string>(m["Digests"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("RegionIds") != m.end() && !m["RegionIds"].empty()) {
      regionIds = make_shared<string>(boost::any_cast<string>(m["RegionIds"]));
    }
    if (m.find("RegistryTypes") != m.end() && !m["RegistryTypes"].empty()) {
      registryTypes = make_shared<string>(boost::any_cast<string>(m["RegistryTypes"]));
    }
    if (m.find("RepoIds") != m.end() && !m["RepoIds"].empty()) {
      repoIds = make_shared<string>(boost::any_cast<string>(m["RepoIds"]));
    }
    if (m.find("RepoNames") != m.end() && !m["RepoNames"].empty()) {
      repoNames = make_shared<string>(boost::any_cast<string>(m["RepoNames"]));
    }
    if (m.find("RepoNamespaces") != m.end() && !m["RepoNamespaces"].empty()) {
      repoNamespaces = make_shared<string>(boost::any_cast<string>(m["RepoNamespaces"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~PublicPreCheckImageScanTaskRequest() = default;
};
class PublicPreCheckImageScanTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> needAuthCount{};
  shared_ptr<long> scanImageCount{};

  PublicPreCheckImageScanTaskResponseBodyData() {}

  explicit PublicPreCheckImageScanTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (needAuthCount) {
      res["NeedAuthCount"] = boost::any(*needAuthCount);
    }
    if (scanImageCount) {
      res["ScanImageCount"] = boost::any(*scanImageCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NeedAuthCount") != m.end() && !m["NeedAuthCount"].empty()) {
      needAuthCount = make_shared<long>(boost::any_cast<long>(m["NeedAuthCount"]));
    }
    if (m.find("ScanImageCount") != m.end() && !m["ScanImageCount"].empty()) {
      scanImageCount = make_shared<long>(boost::any_cast<long>(m["ScanImageCount"]));
    }
  }


  virtual ~PublicPreCheckImageScanTaskResponseBodyData() = default;
};
class PublicPreCheckImageScanTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<PublicPreCheckImageScanTaskResponseBodyData> data{};
  shared_ptr<string> requestId{};

  PublicPreCheckImageScanTaskResponseBody() {}

  explicit PublicPreCheckImageScanTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PublicPreCheckImageScanTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PublicPreCheckImageScanTaskResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublicPreCheckImageScanTaskResponseBody() = default;
};
class PublicPreCheckImageScanTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublicPreCheckImageScanTaskResponseBody> body{};

  PublicPreCheckImageScanTaskResponse() {}

  explicit PublicPreCheckImageScanTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublicPreCheckImageScanTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublicPreCheckImageScanTaskResponseBody>(model1);
      }
    }
  }


  virtual ~PublicPreCheckImageScanTaskResponse() = default;
};
class PublicSyncAndCreateImageScanTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> images{};
  shared_ptr<string> sourceIp{};

  PublicSyncAndCreateImageScanTaskRequest() {}

  explicit PublicSyncAndCreateImageScanTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (images) {
      res["Images"] = boost::any(*images);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      images = make_shared<string>(boost::any_cast<string>(m["Images"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~PublicSyncAndCreateImageScanTaskRequest() = default;
};
class PublicSyncAndCreateImageScanTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> canCreate{};
  shared_ptr<long> collectTime{};
  shared_ptr<long> execTime{};
  shared_ptr<long> finishCount{};
  shared_ptr<long> progress{};
  shared_ptr<string> result{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<long> totalCount{};

  PublicSyncAndCreateImageScanTaskResponseBodyData() {}

  explicit PublicSyncAndCreateImageScanTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canCreate) {
      res["CanCreate"] = boost::any(*canCreate);
    }
    if (collectTime) {
      res["CollectTime"] = boost::any(*collectTime);
    }
    if (execTime) {
      res["ExecTime"] = boost::any(*execTime);
    }
    if (finishCount) {
      res["FinishCount"] = boost::any(*finishCount);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanCreate") != m.end() && !m["CanCreate"].empty()) {
      canCreate = make_shared<bool>(boost::any_cast<bool>(m["CanCreate"]));
    }
    if (m.find("CollectTime") != m.end() && !m["CollectTime"].empty()) {
      collectTime = make_shared<long>(boost::any_cast<long>(m["CollectTime"]));
    }
    if (m.find("ExecTime") != m.end() && !m["ExecTime"].empty()) {
      execTime = make_shared<long>(boost::any_cast<long>(m["ExecTime"]));
    }
    if (m.find("FinishCount") != m.end() && !m["FinishCount"].empty()) {
      finishCount = make_shared<long>(boost::any_cast<long>(m["FinishCount"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~PublicSyncAndCreateImageScanTaskResponseBodyData() = default;
};
class PublicSyncAndCreateImageScanTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<PublicSyncAndCreateImageScanTaskResponseBodyData> data{};
  shared_ptr<string> requestId{};

  PublicSyncAndCreateImageScanTaskResponseBody() {}

  explicit PublicSyncAndCreateImageScanTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PublicSyncAndCreateImageScanTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PublicSyncAndCreateImageScanTaskResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublicSyncAndCreateImageScanTaskResponseBody() = default;
};
class PublicSyncAndCreateImageScanTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublicSyncAndCreateImageScanTaskResponseBody> body{};

  PublicSyncAndCreateImageScanTaskResponse() {}

  explicit PublicSyncAndCreateImageScanTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublicSyncAndCreateImageScanTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublicSyncAndCreateImageScanTaskResponseBody>(model1);
      }
    }
  }


  virtual ~PublicSyncAndCreateImageScanTaskResponse() = default;
};
class QueryDiscoverDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> createMark{};

  QueryDiscoverDatabaseRequest() {}

  explicit QueryDiscoverDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createMark) {
      res["CreateMark"] = boost::any(*createMark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateMark") != m.end() && !m["CreateMark"].empty()) {
      createMark = make_shared<string>(boost::any_cast<string>(m["CreateMark"]));
    }
  }


  virtual ~QueryDiscoverDatabaseRequest() = default;
};
class QueryDiscoverDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> taskProgress{};

  QueryDiscoverDatabaseResponseBody() {}

  explicit QueryDiscoverDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskProgress) {
      res["TaskProgress"] = boost::any(*taskProgress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskProgress") != m.end() && !m["TaskProgress"].empty()) {
      taskProgress = make_shared<long>(boost::any_cast<long>(m["TaskProgress"]));
    }
  }


  virtual ~QueryDiscoverDatabaseResponseBody() = default;
};
class QueryDiscoverDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDiscoverDatabaseResponseBody> body{};

  QueryDiscoverDatabaseResponse() {}

  explicit QueryDiscoverDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDiscoverDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDiscoverDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDiscoverDatabaseResponse() = default;
};
class QueryGroupIdByGroupNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> sourceIp{};

  QueryGroupIdByGroupNameRequest() {}

  explicit QueryGroupIdByGroupNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~QueryGroupIdByGroupNameRequest() = default;
};
class QueryGroupIdByGroupNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> groupId{};
  shared_ptr<string> requestId{};

  QueryGroupIdByGroupNameResponseBody() {}

  explicit QueryGroupIdByGroupNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryGroupIdByGroupNameResponseBody() = default;
};
class QueryGroupIdByGroupNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryGroupIdByGroupNameResponseBody> body{};

  QueryGroupIdByGroupNameResponse() {}

  explicit QueryGroupIdByGroupNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryGroupIdByGroupNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryGroupIdByGroupNameResponseBody>(model1);
      }
    }
  }


  virtual ~QueryGroupIdByGroupNameResponse() = default;
};
class QueryGroupedSecurityEventMarkMissListRequest : public Darabonba::Model {
public:
  shared_ptr<long> currentPage{};
  shared_ptr<string> disposalWay{};
  shared_ptr<string> eventName{};
  shared_ptr<string> from{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> remark{};
  shared_ptr<string> sourceIp{};

  QueryGroupedSecurityEventMarkMissListRequest() {}

  explicit QueryGroupedSecurityEventMarkMissListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (disposalWay) {
      res["DisposalWay"] = boost::any(*disposalWay);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("DisposalWay") != m.end() && !m["DisposalWay"].empty()) {
      disposalWay = make_shared<string>(boost::any_cast<string>(m["DisposalWay"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~QueryGroupedSecurityEventMarkMissListRequest() = default;
};
class QueryGroupedSecurityEventMarkMissListResponseBodyList : public Darabonba::Model {
public:
  shared_ptr<long> aliUid{};
  shared_ptr<string> disposalWay{};
  shared_ptr<string> eventName{};
  shared_ptr<string> eventNameOriginal{};
  shared_ptr<string> eventType{};
  shared_ptr<string> eventTypeOriginal{};
  shared_ptr<string> field{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> filedAliasName{};
  shared_ptr<string> operate{};
  shared_ptr<string> uuids{};

  QueryGroupedSecurityEventMarkMissListResponseBodyList() {}

  explicit QueryGroupedSecurityEventMarkMissListResponseBodyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliUid) {
      res["AliUid"] = boost::any(*aliUid);
    }
    if (disposalWay) {
      res["DisposalWay"] = boost::any(*disposalWay);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (eventNameOriginal) {
      res["EventNameOriginal"] = boost::any(*eventNameOriginal);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (eventTypeOriginal) {
      res["EventTypeOriginal"] = boost::any(*eventTypeOriginal);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (filedAliasName) {
      res["FiledAliasName"] = boost::any(*filedAliasName);
    }
    if (operate) {
      res["Operate"] = boost::any(*operate);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliUid") != m.end() && !m["AliUid"].empty()) {
      aliUid = make_shared<long>(boost::any_cast<long>(m["AliUid"]));
    }
    if (m.find("DisposalWay") != m.end() && !m["DisposalWay"].empty()) {
      disposalWay = make_shared<string>(boost::any_cast<string>(m["DisposalWay"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("EventNameOriginal") != m.end() && !m["EventNameOriginal"].empty()) {
      eventNameOriginal = make_shared<string>(boost::any_cast<string>(m["EventNameOriginal"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("EventTypeOriginal") != m.end() && !m["EventTypeOriginal"].empty()) {
      eventTypeOriginal = make_shared<string>(boost::any_cast<string>(m["EventTypeOriginal"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("FiledAliasName") != m.end() && !m["FiledAliasName"].empty()) {
      filedAliasName = make_shared<string>(boost::any_cast<string>(m["FiledAliasName"]));
    }
    if (m.find("Operate") != m.end() && !m["Operate"].empty()) {
      operate = make_shared<string>(boost::any_cast<string>(m["Operate"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~QueryGroupedSecurityEventMarkMissListResponseBodyList() = default;
};
class QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> currentPage{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo() {}

  explicit QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo() = default;
};
class QueryGroupedSecurityEventMarkMissListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QueryGroupedSecurityEventMarkMissListResponseBodyList>> list{};
  shared_ptr<string> message{};
  shared_ptr<QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo> pageInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryGroupedSecurityEventMarkMissListResponseBody() {}

  explicit QueryGroupedSecurityEventMarkMissListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageInfo) {
      res["PageInfo"] = pageInfo ? boost::any(pageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<QueryGroupedSecurityEventMarkMissListResponseBodyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryGroupedSecurityEventMarkMissListResponseBodyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<QueryGroupedSecurityEventMarkMissListResponseBodyList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageInfo") != m.end() && !m["PageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfo"].type()) {
        QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfo"]));
        pageInfo = make_shared<QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryGroupedSecurityEventMarkMissListResponseBody() = default;
};
class QueryGroupedSecurityEventMarkMissListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryGroupedSecurityEventMarkMissListResponseBody> body{};

  QueryGroupedSecurityEventMarkMissListResponse() {}

  explicit QueryGroupedSecurityEventMarkMissListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryGroupedSecurityEventMarkMissListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryGroupedSecurityEventMarkMissListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryGroupedSecurityEventMarkMissListResponse() = default;
};
class QueryJenkinsImageRegistryPersistenceDayRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  QueryJenkinsImageRegistryPersistenceDayRequest() {}

  explicit QueryJenkinsImageRegistryPersistenceDayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~QueryJenkinsImageRegistryPersistenceDayRequest() = default;
};
class QueryJenkinsImageRegistryPersistenceDayResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<long> timeCost{};

  QueryJenkinsImageRegistryPersistenceDayResponseBody() {}

  explicit QueryJenkinsImageRegistryPersistenceDayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<long>(boost::any_cast<long>(m["TimeCost"]));
    }
  }


  virtual ~QueryJenkinsImageRegistryPersistenceDayResponseBody() = default;
};
class QueryJenkinsImageRegistryPersistenceDayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryJenkinsImageRegistryPersistenceDayResponseBody> body{};

  QueryJenkinsImageRegistryPersistenceDayResponse() {}

  explicit QueryJenkinsImageRegistryPersistenceDayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryJenkinsImageRegistryPersistenceDayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryJenkinsImageRegistryPersistenceDayResponseBody>(model1);
      }
    }
  }


  virtual ~QueryJenkinsImageRegistryPersistenceDayResponse() = default;
};
class QueryPreCheckDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceUuid{};
  shared_ptr<string> taskId{};
  shared_ptr<string> uniRegionId{};

  QueryPreCheckDatabaseRequest() {}

  explicit QueryPreCheckDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceUuid) {
      res["InstanceUuid"] = boost::any(*instanceUuid);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (uniRegionId) {
      res["UniRegionId"] = boost::any(*uniRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceUuid") != m.end() && !m["InstanceUuid"].empty()) {
      instanceUuid = make_shared<string>(boost::any_cast<string>(m["InstanceUuid"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("UniRegionId") != m.end() && !m["UniRegionId"].empty()) {
      uniRegionId = make_shared<string>(boost::any_cast<string>(m["UniRegionId"]));
    }
  }


  virtual ~QueryPreCheckDatabaseRequest() = default;
};
class QueryPreCheckDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> completedTime{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<long> progress{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<long> updatedTime{};

  QueryPreCheckDatabaseResponseBody() {}

  explicit QueryPreCheckDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completedTime) {
      res["CompletedTime"] = boost::any(*completedTime);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompletedTime") != m.end() && !m["CompletedTime"].empty()) {
      completedTime = make_shared<long>(boost::any_cast<long>(m["CompletedTime"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<long>(boost::any_cast<long>(m["UpdatedTime"]));
    }
  }


  virtual ~QueryPreCheckDatabaseResponseBody() = default;
};
class QueryPreCheckDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryPreCheckDatabaseResponseBody> body{};

  QueryPreCheckDatabaseResponse() {}

  explicit QueryPreCheckDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPreCheckDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPreCheckDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPreCheckDatabaseResponse() = default;
};
class RebootMachineRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuid{};

  RebootMachineRequest() {}

  explicit RebootMachineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~RebootMachineRequest() = default;
};
class RebootMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RebootMachineResponseBody() {}

  explicit RebootMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebootMachineResponseBody() = default;
};
class RebootMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RebootMachineResponseBody> body{};

  RebootMachineResponse() {}

  explicit RebootMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootMachineResponseBody>(model1);
      }
    }
  }


  virtual ~RebootMachineResponse() = default;
};
class RefreshAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetType{};
  shared_ptr<long> cloudAssetSubType{};
  shared_ptr<long> cloudAssetType{};

  RefreshAssetsRequest() {}

  explicit RefreshAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    if (cloudAssetSubType) {
      res["CloudAssetSubType"] = boost::any(*cloudAssetSubType);
    }
    if (cloudAssetType) {
      res["CloudAssetType"] = boost::any(*cloudAssetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
    if (m.find("CloudAssetSubType") != m.end() && !m["CloudAssetSubType"].empty()) {
      cloudAssetSubType = make_shared<long>(boost::any_cast<long>(m["CloudAssetSubType"]));
    }
    if (m.find("CloudAssetType") != m.end() && !m["CloudAssetType"].empty()) {
      cloudAssetType = make_shared<long>(boost::any_cast<long>(m["CloudAssetType"]));
    }
  }


  virtual ~RefreshAssetsRequest() = default;
};
class RefreshAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RefreshAssetsResponseBody() {}

  explicit RefreshAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshAssetsResponseBody() = default;
};
class RefreshAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshAssetsResponseBody> body{};

  RefreshAssetsResponse() {}

  explicit RefreshAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshAssetsResponse() = default;
};
class RefreshContainerAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetType{};

  RefreshContainerAssetsRequest() {}

  explicit RefreshContainerAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetType) {
      res["AssetType"] = boost::any(*assetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetType") != m.end() && !m["AssetType"].empty()) {
      assetType = make_shared<string>(boost::any_cast<string>(m["AssetType"]));
    }
  }


  virtual ~RefreshContainerAssetsRequest() = default;
};
class RefreshContainerAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RefreshContainerAssetsResponseBody() {}

  explicit RefreshContainerAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshContainerAssetsResponseBody() = default;
};
class RefreshContainerAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshContainerAssetsResponseBody> body{};

  RefreshContainerAssetsResponse() {}

  explicit RefreshContainerAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshContainerAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshContainerAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshContainerAssetsResponse() = default;
};
class RemoveCheckInstanceResultWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<vector<string>> instanceIds{};

  RemoveCheckInstanceResultWhiteListRequest() {}

  explicit RemoveCheckInstanceResultWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveCheckInstanceResultWhiteListRequest() = default;
};
class RemoveCheckInstanceResultWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveCheckInstanceResultWhiteListResponseBody() {}

  explicit RemoveCheckInstanceResultWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveCheckInstanceResultWhiteListResponseBody() = default;
};
class RemoveCheckInstanceResultWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveCheckInstanceResultWhiteListResponseBody> body{};

  RemoveCheckInstanceResultWhiteListResponse() {}

  explicit RemoveCheckInstanceResultWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveCheckInstanceResultWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveCheckInstanceResultWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveCheckInstanceResultWhiteListResponse() = default;
};
class RemoveCheckResultWhiteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkGroupId{};
  shared_ptr<vector<long>> checkIds{};
  shared_ptr<string> type{};

  RemoveCheckResultWhiteListRequest() {}

  explicit RemoveCheckResultWhiteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkGroupId) {
      res["CheckGroupId"] = boost::any(*checkGroupId);
    }
    if (checkIds) {
      res["CheckIds"] = boost::any(*checkIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckGroupId") != m.end() && !m["CheckGroupId"].empty()) {
      checkGroupId = make_shared<string>(boost::any_cast<string>(m["CheckGroupId"]));
    }
    if (m.find("CheckIds") != m.end() && !m["CheckIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CheckIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CheckIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      checkIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RemoveCheckResultWhiteListRequest() = default;
};
class RemoveCheckResultWhiteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RemoveCheckResultWhiteListResponseBody() {}

  explicit RemoveCheckResultWhiteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveCheckResultWhiteListResponseBody() = default;
};
class RemoveCheckResultWhiteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveCheckResultWhiteListResponseBody> body{};

  RemoveCheckResultWhiteListResponse() {}

  explicit RemoveCheckResultWhiteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveCheckResultWhiteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveCheckResultWhiteListResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveCheckResultWhiteListResponse() = default;
};
class RollbackSuspEventQuaraFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<long> quaraFileId{};
  shared_ptr<string> sourceIp{};

  RollbackSuspEventQuaraFileRequest() {}

  explicit RollbackSuspEventQuaraFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (quaraFileId) {
      res["QuaraFileId"] = boost::any(*quaraFileId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("QuaraFileId") != m.end() && !m["QuaraFileId"].empty()) {
      quaraFileId = make_shared<long>(boost::any_cast<long>(m["QuaraFileId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~RollbackSuspEventQuaraFileRequest() = default;
};
class RollbackSuspEventQuaraFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackSuspEventQuaraFileResponseBody() {}

  explicit RollbackSuspEventQuaraFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackSuspEventQuaraFileResponseBody() = default;
};
class RollbackSuspEventQuaraFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackSuspEventQuaraFileResponseBody> body{};

  RollbackSuspEventQuaraFileResponse() {}

  explicit RollbackSuspEventQuaraFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackSuspEventQuaraFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackSuspEventQuaraFileResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackSuspEventQuaraFileResponse() = default;
};
class SasInstallCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceIp{};

  SasInstallCodeRequest() {}

  explicit SasInstallCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~SasInstallCodeRequest() = default;
};
class SasInstallCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};

  SasInstallCodeResponseBody() {}

  explicit SasInstallCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["data"]));
    }
  }


  virtual ~SasInstallCodeResponseBody() = default;
};
class SasInstallCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SasInstallCodeResponseBody> body{};

  SasInstallCodeResponse() {}

  explicit SasInstallCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SasInstallCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SasInstallCodeResponseBody>(model1);
      }
    }
  }


  virtual ~SasInstallCodeResponse() = default;
};
class SaveImageBaselineStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> baselineItemList{};
  shared_ptr<string> lang{};
  shared_ptr<long> strategyId{};
  shared_ptr<string> strategyName{};

  SaveImageBaselineStrategyRequest() {}

  explicit SaveImageBaselineStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineItemList) {
      res["BaselineItemList"] = boost::any(*baselineItemList);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineItemList") != m.end() && !m["BaselineItemList"].empty()) {
      baselineItemList = make_shared<string>(boost::any_cast<string>(m["BaselineItemList"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<long>(boost::any_cast<long>(m["StrategyId"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
  }


  virtual ~SaveImageBaselineStrategyRequest() = default;
};
class SaveImageBaselineStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SaveImageBaselineStrategyResponseBody() {}

  explicit SaveImageBaselineStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SaveImageBaselineStrategyResponseBody() = default;
};
class SaveImageBaselineStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveImageBaselineStrategyResponseBody> body{};

  SaveImageBaselineStrategyResponse() {}

  explicit SaveImageBaselineStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveImageBaselineStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveImageBaselineStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~SaveImageBaselineStrategyResponse() = default;
};
class SaveSuspEventUserSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> levelsOn{};

  SaveSuspEventUserSettingRequest() {}

  explicit SaveSuspEventUserSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (levelsOn) {
      res["LevelsOn"] = boost::any(*levelsOn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("LevelsOn") != m.end() && !m["LevelsOn"].empty()) {
      levelsOn = make_shared<string>(boost::any_cast<string>(m["LevelsOn"]));
    }
  }


  virtual ~SaveSuspEventUserSettingRequest() = default;
};
class SaveSuspEventUserSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveSuspEventUserSettingResponseBody() {}

  explicit SaveSuspEventUserSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveSuspEventUserSettingResponseBody() = default;
};
class SaveSuspEventUserSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveSuspEventUserSettingResponseBody> body{};

  SaveSuspEventUserSettingResponse() {}

  explicit SaveSuspEventUserSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveSuspEventUserSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveSuspEventUserSettingResponseBody>(model1);
      }
    }
  }


  virtual ~SaveSuspEventUserSettingResponse() = default;
};
class SetClusterInterceptionConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterIds{};
  shared_ptr<long> switchOn{};
  shared_ptr<long> switchType{};

  SetClusterInterceptionConfigRequest() {}

  explicit SetClusterInterceptionConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterIds) {
      res["ClusterIds"] = boost::any(*clusterIds);
    }
    if (switchOn) {
      res["SwitchOn"] = boost::any(*switchOn);
    }
    if (switchType) {
      res["SwitchType"] = boost::any(*switchType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterIds") != m.end() && !m["ClusterIds"].empty()) {
      clusterIds = make_shared<string>(boost::any_cast<string>(m["ClusterIds"]));
    }
    if (m.find("SwitchOn") != m.end() && !m["SwitchOn"].empty()) {
      switchOn = make_shared<long>(boost::any_cast<long>(m["SwitchOn"]));
    }
    if (m.find("SwitchType") != m.end() && !m["SwitchType"].empty()) {
      switchType = make_shared<long>(boost::any_cast<long>(m["SwitchType"]));
    }
  }


  virtual ~SetClusterInterceptionConfigRequest() = default;
};
class SetClusterInterceptionConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  SetClusterInterceptionConfigResponseBody() {}

  explicit SetClusterInterceptionConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~SetClusterInterceptionConfigResponseBody() = default;
};
class SetClusterInterceptionConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetClusterInterceptionConfigResponseBody> body{};

  SetClusterInterceptionConfigResponse() {}

  explicit SetClusterInterceptionConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetClusterInterceptionConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetClusterInterceptionConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetClusterInterceptionConfigResponse() = default;
};
class SetRegistryScanDayNumRequest : public Darabonba::Model {
public:
  shared_ptr<long> scanDayNum{};

  SetRegistryScanDayNumRequest() {}

  explicit SetRegistryScanDayNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scanDayNum) {
      res["ScanDayNum"] = boost::any(*scanDayNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScanDayNum") != m.end() && !m["ScanDayNum"].empty()) {
      scanDayNum = make_shared<long>(boost::any_cast<long>(m["ScanDayNum"]));
    }
  }


  virtual ~SetRegistryScanDayNumRequest() = default;
};
class SetRegistryScanDayNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetRegistryScanDayNumResponseBody() {}

  explicit SetRegistryScanDayNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetRegistryScanDayNumResponseBody() = default;
};
class SetRegistryScanDayNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetRegistryScanDayNumResponseBody> body{};

  SetRegistryScanDayNumResponse() {}

  explicit SetRegistryScanDayNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetRegistryScanDayNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetRegistryScanDayNumResponseBody>(model1);
      }
    }
  }


  virtual ~SetRegistryScanDayNumResponse() = default;
};
class StartBaselineSecurityCheckRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> itemIds{};
  shared_ptr<string> lang{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> type{};

  StartBaselineSecurityCheckRequest() {}

  explicit StartBaselineSecurityCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemIds) {
      res["ItemIds"] = boost::any(*itemIds);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemIds") != m.end() && !m["ItemIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      itemIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~StartBaselineSecurityCheckRequest() = default;
};
class StartBaselineSecurityCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartBaselineSecurityCheckResponseBody() {}

  explicit StartBaselineSecurityCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartBaselineSecurityCheckResponseBody() = default;
};
class StartBaselineSecurityCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartBaselineSecurityCheckResponseBody> body{};

  StartBaselineSecurityCheckResponse() {}

  explicit StartBaselineSecurityCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartBaselineSecurityCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartBaselineSecurityCheckResponseBody>(model1);
      }
    }
  }


  virtual ~StartBaselineSecurityCheckResponse() = default;
};
class StartDiscoverDatabaseTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createMark{};
  shared_ptr<string> requestId{};

  StartDiscoverDatabaseTaskResponseBody() {}

  explicit StartDiscoverDatabaseTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createMark) {
      res["CreateMark"] = boost::any(*createMark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateMark") != m.end() && !m["CreateMark"].empty()) {
      createMark = make_shared<string>(boost::any_cast<string>(m["CreateMark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartDiscoverDatabaseTaskResponseBody() = default;
};
class StartDiscoverDatabaseTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartDiscoverDatabaseTaskResponseBody> body{};

  StartDiscoverDatabaseTaskResponse() {}

  explicit StartDiscoverDatabaseTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDiscoverDatabaseTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDiscoverDatabaseTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StartDiscoverDatabaseTaskResponse() = default;
};
class StartPreCheckDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseType{};
  shared_ptr<string> instanceUuid{};
  shared_ptr<string> uniRegionId{};

  StartPreCheckDatabaseRequest() {}

  explicit StartPreCheckDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseType) {
      res["DatabaseType"] = boost::any(*databaseType);
    }
    if (instanceUuid) {
      res["InstanceUuid"] = boost::any(*instanceUuid);
    }
    if (uniRegionId) {
      res["UniRegionId"] = boost::any(*uniRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseType") != m.end() && !m["DatabaseType"].empty()) {
      databaseType = make_shared<string>(boost::any_cast<string>(m["DatabaseType"]));
    }
    if (m.find("InstanceUuid") != m.end() && !m["InstanceUuid"].empty()) {
      instanceUuid = make_shared<string>(boost::any_cast<string>(m["InstanceUuid"]));
    }
    if (m.find("UniRegionId") != m.end() && !m["UniRegionId"].empty()) {
      uniRegionId = make_shared<string>(boost::any_cast<string>(m["UniRegionId"]));
    }
  }


  virtual ~StartPreCheckDatabaseRequest() = default;
};
class StartPreCheckDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createMark{};
  shared_ptr<string> requestId{};

  StartPreCheckDatabaseResponseBody() {}

  explicit StartPreCheckDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createMark) {
      res["CreateMark"] = boost::any(*createMark);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateMark") != m.end() && !m["CreateMark"].empty()) {
      createMark = make_shared<string>(boost::any_cast<string>(m["CreateMark"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartPreCheckDatabaseResponseBody() = default;
};
class StartPreCheckDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartPreCheckDatabaseResponseBody> body{};

  StartPreCheckDatabaseResponse() {}

  explicit StartPreCheckDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartPreCheckDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartPreCheckDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~StartPreCheckDatabaseResponse() = default;
};
class StartVirusScanTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> targetInfo{};

  StartVirusScanTaskRequest() {}

  explicit StartVirusScanTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetInfo) {
      res["TargetInfo"] = boost::any(*targetInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetInfo") != m.end() && !m["TargetInfo"].empty()) {
      targetInfo = make_shared<string>(boost::any_cast<string>(m["TargetInfo"]));
    }
  }


  virtual ~StartVirusScanTaskRequest() = default;
};
class StartVirusScanTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> scanTaskId{};

  StartVirusScanTaskResponseBody() {}

  explicit StartVirusScanTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scanTaskId) {
      res["ScanTaskId"] = boost::any(*scanTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScanTaskId") != m.end() && !m["ScanTaskId"].empty()) {
      scanTaskId = make_shared<long>(boost::any_cast<long>(m["ScanTaskId"]));
    }
  }


  virtual ~StartVirusScanTaskResponseBody() = default;
};
class StartVirusScanTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartVirusScanTaskResponseBody> body{};

  StartVirusScanTaskResponse() {}

  explicit StartVirusScanTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartVirusScanTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartVirusScanTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StartVirusScanTaskResponse() = default;
};
class SubmitCheckResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> operateCode{};

  SubmitCheckResponseBodyData() {}

  explicit SubmitCheckResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateCode) {
      res["OperateCode"] = boost::any(*operateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateCode") != m.end() && !m["OperateCode"].empty()) {
      operateCode = make_shared<string>(boost::any_cast<string>(m["OperateCode"]));
    }
  }


  virtual ~SubmitCheckResponseBodyData() = default;
};
class SubmitCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitCheckResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  SubmitCheckResponseBody() {}

  explicit SubmitCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitCheckResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitCheckResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SubmitCheckResponseBody() = default;
};
class SubmitCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitCheckResponseBody> body{};

  SubmitCheckResponse() {}

  explicit SubmitCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitCheckResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitCheckResponse() = default;
};
class UnbindAegisRequest : public Darabonba::Model {
public:
  shared_ptr<string> uuids{};

  UnbindAegisRequest() {}

  explicit UnbindAegisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~UnbindAegisRequest() = default;
};
class UnbindAegisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindAegisResponseBody() {}

  explicit UnbindAegisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindAegisResponseBody() = default;
};
class UnbindAegisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindAegisResponseBody> body{};

  UnbindAegisResponse() {}

  explicit UnbindAegisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindAegisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindAegisResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindAegisResponse() = default;
};
class UninstallBackupClientRequest : public Darabonba::Model {
public:
  shared_ptr<string> policyVersion{};
  shared_ptr<string> uuid{};
  shared_ptr<vector<string>> uuidList{};

  UninstallBackupClientRequest() {}

  explicit UninstallBackupClientRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyVersion) {
      res["PolicyVersion"] = boost::any(*policyVersion);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (uuidList) {
      res["UuidList"] = boost::any(*uuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyVersion") != m.end() && !m["PolicyVersion"].empty()) {
      policyVersion = make_shared<string>(boost::any_cast<string>(m["PolicyVersion"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("UuidList") != m.end() && !m["UuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      uuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UninstallBackupClientRequest() = default;
};
class UninstallBackupClientResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UninstallBackupClientResponseBody() {}

  explicit UninstallBackupClientResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UninstallBackupClientResponseBody() = default;
};
class UninstallBackupClientResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallBackupClientResponseBody> body{};

  UninstallBackupClientResponse() {}

  explicit UninstallBackupClientResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallBackupClientResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallBackupClientResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallBackupClientResponse() = default;
};
class UninstallUniBackupAgentRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};

  UninstallUniBackupAgentRequest() {}

  explicit UninstallUniBackupAgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
  }


  virtual ~UninstallUniBackupAgentRequest() = default;
};
class UninstallUniBackupAgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UninstallUniBackupAgentResponseBody() {}

  explicit UninstallUniBackupAgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UninstallUniBackupAgentResponseBody() = default;
};
class UninstallUniBackupAgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallUniBackupAgentResponseBody> body{};

  UninstallUniBackupAgentResponse() {}

  explicit UninstallUniBackupAgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallUniBackupAgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallUniBackupAgentResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallUniBackupAgentResponse() = default;
};
class UpdateHoneypotRequest : public Darabonba::Model {
public:
  shared_ptr<string> honeypotId{};
  shared_ptr<string> honeypotName{};
  shared_ptr<string> lang{};
  shared_ptr<string> meta{};

  UpdateHoneypotRequest() {}

  explicit UpdateHoneypotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotId) {
      res["HoneypotId"] = boost::any(*honeypotId);
    }
    if (honeypotName) {
      res["HoneypotName"] = boost::any(*honeypotName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (meta) {
      res["Meta"] = boost::any(*meta);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotId") != m.end() && !m["HoneypotId"].empty()) {
      honeypotId = make_shared<string>(boost::any_cast<string>(m["HoneypotId"]));
    }
    if (m.find("HoneypotName") != m.end() && !m["HoneypotName"].empty()) {
      honeypotName = make_shared<string>(boost::any_cast<string>(m["HoneypotName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Meta") != m.end() && !m["Meta"].empty()) {
      meta = make_shared<string>(boost::any_cast<string>(m["Meta"]));
    }
  }


  virtual ~UpdateHoneypotRequest() = default;
};
class UpdateHoneypotResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> honeypotId{};
  shared_ptr<string> honeypotImageDisplayName{};
  shared_ptr<string> honeypotImageName{};
  shared_ptr<string> honeypotName{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> presetId{};
  shared_ptr<vector<string>> state{};

  UpdateHoneypotResponseBodyData() {}

  explicit UpdateHoneypotResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotId) {
      res["HoneypotId"] = boost::any(*honeypotId);
    }
    if (honeypotImageDisplayName) {
      res["HoneypotImageDisplayName"] = boost::any(*honeypotImageDisplayName);
    }
    if (honeypotImageName) {
      res["HoneypotImageName"] = boost::any(*honeypotImageName);
    }
    if (honeypotName) {
      res["HoneypotName"] = boost::any(*honeypotName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (presetId) {
      res["PresetId"] = boost::any(*presetId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotId") != m.end() && !m["HoneypotId"].empty()) {
      honeypotId = make_shared<string>(boost::any_cast<string>(m["HoneypotId"]));
    }
    if (m.find("HoneypotImageDisplayName") != m.end() && !m["HoneypotImageDisplayName"].empty()) {
      honeypotImageDisplayName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageDisplayName"]));
    }
    if (m.find("HoneypotImageName") != m.end() && !m["HoneypotImageName"].empty()) {
      honeypotImageName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageName"]));
    }
    if (m.find("HoneypotName") != m.end() && !m["HoneypotName"].empty()) {
      honeypotName = make_shared<string>(boost::any_cast<string>(m["HoneypotName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("PresetId") != m.end() && !m["PresetId"].empty()) {
      presetId = make_shared<string>(boost::any_cast<string>(m["PresetId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["State"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["State"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      state = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateHoneypotResponseBodyData() = default;
};
class UpdateHoneypotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateHoneypotResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateHoneypotResponseBody() {}

  explicit UpdateHoneypotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateHoneypotResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateHoneypotResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateHoneypotResponseBody() = default;
};
class UpdateHoneypotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateHoneypotResponseBody> body{};

  UpdateHoneypotResponse() {}

  explicit UpdateHoneypotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHoneypotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHoneypotResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHoneypotResponse() = default;
};
class UpdateHoneypotNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> availableProbeNum{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<vector<string>> securityGroupProbeIpList{};

  UpdateHoneypotNodeRequest() {}

  explicit UpdateHoneypotNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableProbeNum) {
      res["AvailableProbeNum"] = boost::any(*availableProbeNum);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (securityGroupProbeIpList) {
      res["SecurityGroupProbeIpList"] = boost::any(*securityGroupProbeIpList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableProbeNum") != m.end() && !m["AvailableProbeNum"].empty()) {
      availableProbeNum = make_shared<long>(boost::any_cast<long>(m["AvailableProbeNum"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("SecurityGroupProbeIpList") != m.end() && !m["SecurityGroupProbeIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupProbeIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupProbeIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupProbeIpList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateHoneypotNodeRequest() = default;
};
class UpdateHoneypotNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateHoneypotNodeResponseBody() {}

  explicit UpdateHoneypotNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateHoneypotNodeResponseBody() = default;
};
class UpdateHoneypotNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateHoneypotNodeResponseBody> body{};

  UpdateHoneypotNodeResponse() {}

  explicit UpdateHoneypotNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHoneypotNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHoneypotNodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHoneypotNodeResponse() = default;
};
class UpdateHoneypotPresetRequest : public Darabonba::Model {
public:
  shared_ptr<string> honeypotImageName{};
  shared_ptr<string> honeypotPresetId{};
  shared_ptr<string> lang{};
  shared_ptr<string> meta{};
  shared_ptr<string> presetName{};

  UpdateHoneypotPresetRequest() {}

  explicit UpdateHoneypotPresetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (honeypotImageName) {
      res["HoneypotImageName"] = boost::any(*honeypotImageName);
    }
    if (honeypotPresetId) {
      res["HoneypotPresetId"] = boost::any(*honeypotPresetId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (meta) {
      res["Meta"] = boost::any(*meta);
    }
    if (presetName) {
      res["PresetName"] = boost::any(*presetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoneypotImageName") != m.end() && !m["HoneypotImageName"].empty()) {
      honeypotImageName = make_shared<string>(boost::any_cast<string>(m["HoneypotImageName"]));
    }
    if (m.find("HoneypotPresetId") != m.end() && !m["HoneypotPresetId"].empty()) {
      honeypotPresetId = make_shared<string>(boost::any_cast<string>(m["HoneypotPresetId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Meta") != m.end() && !m["Meta"].empty()) {
      meta = make_shared<string>(boost::any_cast<string>(m["Meta"]));
    }
    if (m.find("PresetName") != m.end() && !m["PresetName"].empty()) {
      presetName = make_shared<string>(boost::any_cast<string>(m["PresetName"]));
    }
  }


  virtual ~UpdateHoneypotPresetRequest() = default;
};
class UpdateHoneypotPresetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateHoneypotPresetResponseBody() {}

  explicit UpdateHoneypotPresetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateHoneypotPresetResponseBody() = default;
};
class UpdateHoneypotPresetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateHoneypotPresetResponseBody> body{};

  UpdateHoneypotPresetResponse() {}

  explicit UpdateHoneypotPresetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHoneypotPresetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHoneypotPresetResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHoneypotPresetResponse() = default;
};
class UpdateHoneypotProbeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> arp{};
  shared_ptr<string> displayName{};
  shared_ptr<string> lang{};
  shared_ptr<bool> ping{};
  shared_ptr<string> probeId{};
  shared_ptr<vector<string>> serviceIpList{};

  UpdateHoneypotProbeRequest() {}

  explicit UpdateHoneypotProbeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arp) {
      res["Arp"] = boost::any(*arp);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (ping) {
      res["Ping"] = boost::any(*ping);
    }
    if (probeId) {
      res["ProbeId"] = boost::any(*probeId);
    }
    if (serviceIpList) {
      res["ServiceIpList"] = boost::any(*serviceIpList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arp") != m.end() && !m["Arp"].empty()) {
      arp = make_shared<bool>(boost::any_cast<bool>(m["Arp"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Ping") != m.end() && !m["Ping"].empty()) {
      ping = make_shared<bool>(boost::any_cast<bool>(m["Ping"]));
    }
    if (m.find("ProbeId") != m.end() && !m["ProbeId"].empty()) {
      probeId = make_shared<string>(boost::any_cast<string>(m["ProbeId"]));
    }
    if (m.find("ServiceIpList") != m.end() && !m["ServiceIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceIpList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateHoneypotProbeRequest() = default;
};
class UpdateHoneypotProbeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateHoneypotProbeResponseBody() {}

  explicit UpdateHoneypotProbeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateHoneypotProbeResponseBody() = default;
};
class UpdateHoneypotProbeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateHoneypotProbeResponseBody> body{};

  UpdateHoneypotProbeResponse() {}

  explicit UpdateHoneypotProbeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHoneypotProbeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHoneypotProbeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHoneypotProbeResponse() = default;
};
class UpdateJenkinsImageRegistryNameRequest : public Darabonba::Model {
public:
  shared_ptr<long> registryId{};
  shared_ptr<string> registryName{};
  shared_ptr<string> sourceIp{};

  UpdateJenkinsImageRegistryNameRequest() {}

  explicit UpdateJenkinsImageRegistryNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (registryId) {
      res["RegistryId"] = boost::any(*registryId);
    }
    if (registryName) {
      res["RegistryName"] = boost::any(*registryName);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegistryId") != m.end() && !m["RegistryId"].empty()) {
      registryId = make_shared<long>(boost::any_cast<long>(m["RegistryId"]));
    }
    if (m.find("RegistryName") != m.end() && !m["RegistryName"].empty()) {
      registryName = make_shared<string>(boost::any_cast<string>(m["RegistryName"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~UpdateJenkinsImageRegistryNameRequest() = default;
};
class UpdateJenkinsImageRegistryNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<long> timeCost{};

  UpdateJenkinsImageRegistryNameResponseBody() {}

  explicit UpdateJenkinsImageRegistryNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<long>(boost::any_cast<long>(m["TimeCost"]));
    }
  }


  virtual ~UpdateJenkinsImageRegistryNameResponseBody() = default;
};
class UpdateJenkinsImageRegistryNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateJenkinsImageRegistryNameResponseBody> body{};

  UpdateJenkinsImageRegistryNameResponse() {}

  explicit UpdateJenkinsImageRegistryNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateJenkinsImageRegistryNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateJenkinsImageRegistryNameResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateJenkinsImageRegistryNameResponse() = default;
};
class UpdateJenkinsImageRegistryPersistenceDayRequest : public Darabonba::Model {
public:
  shared_ptr<long> persistenceDay{};
  shared_ptr<long> registryId{};
  shared_ptr<string> sourceIp{};

  UpdateJenkinsImageRegistryPersistenceDayRequest() {}

  explicit UpdateJenkinsImageRegistryPersistenceDayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (persistenceDay) {
      res["PersistenceDay"] = boost::any(*persistenceDay);
    }
    if (registryId) {
      res["RegistryId"] = boost::any(*registryId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PersistenceDay") != m.end() && !m["PersistenceDay"].empty()) {
      persistenceDay = make_shared<long>(boost::any_cast<long>(m["PersistenceDay"]));
    }
    if (m.find("RegistryId") != m.end() && !m["RegistryId"].empty()) {
      registryId = make_shared<long>(boost::any_cast<long>(m["RegistryId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~UpdateJenkinsImageRegistryPersistenceDayRequest() = default;
};
class UpdateJenkinsImageRegistryPersistenceDayResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<long> timeCost{};

  UpdateJenkinsImageRegistryPersistenceDayResponseBody() {}

  explicit UpdateJenkinsImageRegistryPersistenceDayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<long>(boost::any_cast<long>(m["TimeCost"]));
    }
  }


  virtual ~UpdateJenkinsImageRegistryPersistenceDayResponseBody() = default;
};
class UpdateJenkinsImageRegistryPersistenceDayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateJenkinsImageRegistryPersistenceDayResponseBody> body{};

  UpdateJenkinsImageRegistryPersistenceDayResponse() {}

  explicit UpdateJenkinsImageRegistryPersistenceDayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateJenkinsImageRegistryPersistenceDayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateJenkinsImageRegistryPersistenceDayResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateJenkinsImageRegistryPersistenceDayResponse() = default;
};
class UpgradeBackupPolicyVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  UpgradeBackupPolicyVersionRequest() {}

  explicit UpgradeBackupPolicyVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpgradeBackupPolicyVersionRequest() = default;
};
class UpgradeBackupPolicyVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpgradeBackupPolicyVersionResponseBody() {}

  explicit UpgradeBackupPolicyVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpgradeBackupPolicyVersionResponseBody() = default;
};
class UpgradeBackupPolicyVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeBackupPolicyVersionResponseBody> body{};

  UpgradeBackupPolicyVersionResponse() {}

  explicit UpgradeBackupPolicyVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeBackupPolicyVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeBackupPolicyVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeBackupPolicyVersionResponse() = default;
};
class ValidateHcWarningsRequest : public Darabonba::Model {
public:
  shared_ptr<string> riskIds{};
  shared_ptr<string> sourceIp{};
  shared_ptr<string> uuids{};

  ValidateHcWarningsRequest() {}

  explicit ValidateHcWarningsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (riskIds) {
      res["RiskIds"] = boost::any(*riskIds);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    if (uuids) {
      res["Uuids"] = boost::any(*uuids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RiskIds") != m.end() && !m["RiskIds"].empty()) {
      riskIds = make_shared<string>(boost::any_cast<string>(m["RiskIds"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
    if (m.find("Uuids") != m.end() && !m["Uuids"].empty()) {
      uuids = make_shared<string>(boost::any_cast<string>(m["Uuids"]));
    }
  }


  virtual ~ValidateHcWarningsRequest() = default;
};
class ValidateHcWarningsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ValidateHcWarningsResponseBody() {}

  explicit ValidateHcWarningsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ValidateHcWarningsResponseBody() = default;
};
class ValidateHcWarningsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidateHcWarningsResponseBody> body{};

  ValidateHcWarningsResponse() {}

  explicit ValidateHcWarningsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidateHcWarningsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidateHcWarningsResponseBody>(model1);
      }
    }
  }


  virtual ~ValidateHcWarningsResponse() = default;
};
class VerifyCheckInstanceResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> checkId{};
  shared_ptr<vector<string>> instanceIds{};

  VerifyCheckInstanceResultRequest() {}

  explicit VerifyCheckInstanceResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<long>(boost::any_cast<long>(m["CheckId"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~VerifyCheckInstanceResultRequest() = default;
};
class VerifyCheckInstanceResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failInstances{};
  shared_ptr<string> operateCode{};

  VerifyCheckInstanceResultResponseBodyData() {}

  explicit VerifyCheckInstanceResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failInstances) {
      res["FailInstances"] = boost::any(*failInstances);
    }
    if (operateCode) {
      res["OperateCode"] = boost::any(*operateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailInstances") != m.end() && !m["FailInstances"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailInstances"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailInstances"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failInstances = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OperateCode") != m.end() && !m["OperateCode"].empty()) {
      operateCode = make_shared<string>(boost::any_cast<string>(m["OperateCode"]));
    }
  }


  virtual ~VerifyCheckInstanceResultResponseBodyData() = default;
};
class VerifyCheckInstanceResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<VerifyCheckInstanceResultResponseBodyData> data{};
  shared_ptr<string> requestId{};

  VerifyCheckInstanceResultResponseBody() {}

  explicit VerifyCheckInstanceResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        VerifyCheckInstanceResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<VerifyCheckInstanceResultResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyCheckInstanceResultResponseBody() = default;
};
class VerifyCheckInstanceResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyCheckInstanceResultResponseBody> body{};

  VerifyCheckInstanceResultResponse() {}

  explicit VerifyCheckInstanceResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyCheckInstanceResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyCheckInstanceResultResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyCheckInstanceResultResponse() = default;
};
class VerifyCheckResultRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> checkIds{};

  VerifyCheckResultRequest() {}

  explicit VerifyCheckResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkIds) {
      res["CheckIds"] = boost::any(*checkIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckIds") != m.end() && !m["CheckIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CheckIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CheckIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      checkIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~VerifyCheckResultRequest() = default;
};
class VerifyCheckResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> operateCode{};

  VerifyCheckResultResponseBodyData() {}

  explicit VerifyCheckResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateCode) {
      res["OperateCode"] = boost::any(*operateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateCode") != m.end() && !m["OperateCode"].empty()) {
      operateCode = make_shared<string>(boost::any_cast<string>(m["OperateCode"]));
    }
  }


  virtual ~VerifyCheckResultResponseBodyData() = default;
};
class VerifyCheckResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<VerifyCheckResultResponseBodyData> data{};
  shared_ptr<string> requestId{};

  VerifyCheckResultResponseBody() {}

  explicit VerifyCheckResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        VerifyCheckResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<VerifyCheckResultResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyCheckResultResponseBody() = default;
};
class VerifyCheckResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyCheckResultResponseBody> body{};

  VerifyCheckResultResponse() {}

  explicit VerifyCheckResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyCheckResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyCheckResultResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyCheckResultResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddCheckInstanceResultWhiteListResponse addCheckInstanceResultWhiteListWithOptions(shared_ptr<AddCheckInstanceResultWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCheckInstanceResultWhiteListResponse addCheckInstanceResultWhiteList(shared_ptr<AddCheckInstanceResultWhiteListRequest> request);
  AddCheckResultWhiteListResponse addCheckResultWhiteListWithOptions(shared_ptr<AddCheckResultWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCheckResultWhiteListResponse addCheckResultWhiteList(shared_ptr<AddCheckResultWhiteListRequest> request);
  AddClientUserDefineRuleResponse addClientUserDefineRuleWithOptions(shared_ptr<AddClientUserDefineRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddClientUserDefineRuleResponse addClientUserDefineRule(shared_ptr<AddClientUserDefineRuleRequest> request);
  AddInstallCodeResponse addInstallCodeWithOptions(shared_ptr<AddInstallCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddInstallCodeResponse addInstallCode(shared_ptr<AddInstallCodeRequest> request);
  AddPrivateRegistryResponse addPrivateRegistryWithOptions(shared_ptr<AddPrivateRegistryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPrivateRegistryResponse addPrivateRegistry(shared_ptr<AddPrivateRegistryRequest> request);
  AddTagWithUuidResponse addTagWithUuidWithOptions(shared_ptr<AddTagWithUuidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTagWithUuidResponse addTagWithUuid(shared_ptr<AddTagWithUuidRequest> request);
  AddUninstallClientsByUuidsResponse addUninstallClientsByUuidsWithOptions(shared_ptr<AddUninstallClientsByUuidsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddUninstallClientsByUuidsResponse addUninstallClientsByUuids(shared_ptr<AddUninstallClientsByUuidsRequest> request);
  AddVpcHoneyPotResponse addVpcHoneyPotWithOptions(shared_ptr<AddVpcHoneyPotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddVpcHoneyPotResponse addVpcHoneyPot(shared_ptr<AddVpcHoneyPotRequest> request);
  AdvanceSecurityEventOperationsResponse advanceSecurityEventOperationsWithOptions(shared_ptr<AdvanceSecurityEventOperationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AdvanceSecurityEventOperationsResponse advanceSecurityEventOperations(shared_ptr<AdvanceSecurityEventOperationsRequest> request);
  BatchOperateCommonOverallConfigResponse batchOperateCommonOverallConfigWithOptions(shared_ptr<BatchOperateCommonOverallConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchOperateCommonOverallConfigResponse batchOperateCommonOverallConfig(shared_ptr<BatchOperateCommonOverallConfigRequest> request);
  BindAuthToMachineResponse bindAuthToMachineWithOptions(shared_ptr<BindAuthToMachineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindAuthToMachineResponse bindAuthToMachine(shared_ptr<BindAuthToMachineRequest> request);
  CancelOnceTaskResponse cancelOnceTaskWithOptions(shared_ptr<CancelOnceTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelOnceTaskResponse cancelOnceTask(shared_ptr<CancelOnceTaskRequest> request);
  ChangeCheckConfigResponse changeCheckConfigWithOptions(shared_ptr<ChangeCheckConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeCheckConfigResponse changeCheckConfig(shared_ptr<ChangeCheckConfigRequest> request);
  ChangeCheckCustomConfigResponse changeCheckCustomConfigWithOptions(shared_ptr<ChangeCheckCustomConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeCheckCustomConfigResponse changeCheckCustomConfig(shared_ptr<ChangeCheckCustomConfigRequest> request);
  CheckQuaraFileIdResponse checkQuaraFileIdWithOptions(shared_ptr<CheckQuaraFileIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckQuaraFileIdResponse checkQuaraFileId(shared_ptr<CheckQuaraFileIdRequest> request);
  CheckSecurityEventIdResponse checkSecurityEventIdWithOptions(shared_ptr<CheckSecurityEventIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckSecurityEventIdResponse checkSecurityEventId(shared_ptr<CheckSecurityEventIdRequest> request);
  CheckUserHasEcsResponse checkUserHasEcsWithOptions(shared_ptr<CheckUserHasEcsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckUserHasEcsResponse checkUserHasEcs(shared_ptr<CheckUserHasEcsRequest> request);
  ConfirmVirusEventsResponse confirmVirusEventsWithOptions(shared_ptr<ConfirmVirusEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmVirusEventsResponse confirmVirusEvents(shared_ptr<ConfirmVirusEventsRequest> request);
  CreateAntiBruteForceRuleResponse createAntiBruteForceRuleWithOptions(shared_ptr<CreateAntiBruteForceRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntiBruteForceRuleResponse createAntiBruteForceRule(shared_ptr<CreateAntiBruteForceRuleRequest> request);
  CreateBackupPolicyResponse createBackupPolicyWithOptions(shared_ptr<CreateBackupPolicyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBackupPolicyResponse createBackupPolicy(shared_ptr<CreateBackupPolicyRequest> request);
  CreateContainerScanTaskResponse createContainerScanTaskWithOptions(shared_ptr<CreateContainerScanTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateContainerScanTaskResponse createContainerScanTask(shared_ptr<CreateContainerScanTaskRequest> request);
  CreateCustomBlockRecordResponse createCustomBlockRecordWithOptions(shared_ptr<CreateCustomBlockRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomBlockRecordResponse createCustomBlockRecord(shared_ptr<CreateCustomBlockRecordRequest> request);
  CreateCycleTaskResponse createCycleTaskWithOptions(shared_ptr<CreateCycleTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCycleTaskResponse createCycleTask(shared_ptr<CreateCycleTaskRequest> request);
  CreateFileDetectResponse createFileDetectWithOptions(shared_ptr<CreateFileDetectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFileDetectResponse createFileDetect(shared_ptr<CreateFileDetectRequest> request);
  CreateFileDetectUploadUrlResponse createFileDetectUploadUrlWithOptions(shared_ptr<CreateFileDetectUploadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFileDetectUploadUrlResponse createFileDetectUploadUrl(shared_ptr<CreateFileDetectUploadUrlRequest> request);
  CreateHoneypotResponse createHoneypotWithOptions(shared_ptr<CreateHoneypotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHoneypotResponse createHoneypot(shared_ptr<CreateHoneypotRequest> request);
  CreateHoneypotNodeResponse createHoneypotNodeWithOptions(shared_ptr<CreateHoneypotNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHoneypotNodeResponse createHoneypotNode(shared_ptr<CreateHoneypotNodeRequest> request);
  CreateHoneypotPresetResponse createHoneypotPresetWithOptions(shared_ptr<CreateHoneypotPresetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHoneypotPresetResponse createHoneypotPreset(shared_ptr<CreateHoneypotPresetRequest> request);
  CreateHoneypotProbeResponse createHoneypotProbeWithOptions(shared_ptr<CreateHoneypotProbeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHoneypotProbeResponse createHoneypotProbe(shared_ptr<CreateHoneypotProbeRequest> request);
  CreateInterceptionRuleResponse createInterceptionRuleWithOptions(shared_ptr<CreateInterceptionRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInterceptionRuleResponse createInterceptionRule(shared_ptr<CreateInterceptionRuleRequest> request);
  CreateInterceptionTargetResponse createInterceptionTargetWithOptions(shared_ptr<CreateInterceptionTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInterceptionTargetResponse createInterceptionTarget(shared_ptr<CreateInterceptionTargetRequest> request);
  CreateJenkinsImageRegistryResponse createJenkinsImageRegistryWithOptions(shared_ptr<CreateJenkinsImageRegistryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateJenkinsImageRegistryResponse createJenkinsImageRegistry(shared_ptr<CreateJenkinsImageRegistryRequest> request);
  CreateOrUpdateAssetGroupResponse createOrUpdateAssetGroupWithOptions(shared_ptr<CreateOrUpdateAssetGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrUpdateAssetGroupResponse createOrUpdateAssetGroup(shared_ptr<CreateOrUpdateAssetGroupRequest> request);
  CreateRestoreJobResponse createRestoreJobWithOptions(shared_ptr<CreateRestoreJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRestoreJobResponse createRestoreJob(shared_ptr<CreateRestoreJobRequest> request);
  CreateServiceLinkedRoleResponse createServiceLinkedRoleWithOptions(shared_ptr<CreateServiceLinkedRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateServiceLinkedRoleResponse createServiceLinkedRole(shared_ptr<CreateServiceLinkedRoleRequest> request);
  CreateSimilarSecurityEventsQueryTaskResponse createSimilarSecurityEventsQueryTaskWithOptions(shared_ptr<CreateSimilarSecurityEventsQueryTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSimilarSecurityEventsQueryTaskResponse createSimilarSecurityEventsQueryTask(shared_ptr<CreateSimilarSecurityEventsQueryTaskRequest> request);
  CreateSuspEventNoteResponse createSuspEventNoteWithOptions(shared_ptr<CreateSuspEventNoteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSuspEventNoteResponse createSuspEventNote(shared_ptr<CreateSuspEventNoteRequest> request);
  CreateUniBackupPolicyResponse createUniBackupPolicyWithOptions(shared_ptr<CreateUniBackupPolicyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUniBackupPolicyResponse createUniBackupPolicy(shared_ptr<CreateUniBackupPolicyRequest> request);
  CreateUniRestorePlanResponse createUniRestorePlanWithOptions(shared_ptr<CreateUniRestorePlanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUniRestorePlanResponse createUniRestorePlan(shared_ptr<CreateUniRestorePlanRequest> request);
  CreateVulAutoRepairConfigResponse createVulAutoRepairConfigWithOptions(shared_ptr<CreateVulAutoRepairConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVulAutoRepairConfigResponse createVulAutoRepairConfig(shared_ptr<CreateVulAutoRepairConfigRequest> request);
  DeleteAntiBruteForceRuleResponse deleteAntiBruteForceRuleWithOptions(shared_ptr<DeleteAntiBruteForceRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAntiBruteForceRuleResponse deleteAntiBruteForceRule(shared_ptr<DeleteAntiBruteForceRuleRequest> request);
  DeleteBackupPolicyResponse deleteBackupPolicyWithOptions(shared_ptr<DeleteBackupPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBackupPolicyResponse deleteBackupPolicy(shared_ptr<DeleteBackupPolicyRequest> request);
  DeleteBackupPolicyMachineResponse deleteBackupPolicyMachineWithOptions(shared_ptr<DeleteBackupPolicyMachineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBackupPolicyMachineResponse deleteBackupPolicyMachine(shared_ptr<DeleteBackupPolicyMachineRequest> request);
  DeleteClientUserDefineRuleResponse deleteClientUserDefineRuleWithOptions(shared_ptr<DeleteClientUserDefineRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteClientUserDefineRuleResponse deleteClientUserDefineRule(shared_ptr<DeleteClientUserDefineRuleRequest> request);
  DeleteCustomBlockRecordResponse deleteCustomBlockRecordWithOptions(shared_ptr<DeleteCustomBlockRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomBlockRecordResponse deleteCustomBlockRecord(shared_ptr<DeleteCustomBlockRecordRequest> request);
  DeleteCycleTaskResponse deleteCycleTaskWithOptions(shared_ptr<DeleteCycleTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCycleTaskResponse deleteCycleTask(shared_ptr<DeleteCycleTaskRequest> request);
  DeleteGroupResponse deleteGroupWithOptions(shared_ptr<DeleteGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGroupResponse deleteGroup(shared_ptr<DeleteGroupRequest> request);
  DeleteHoneypotResponse deleteHoneypotWithOptions(shared_ptr<DeleteHoneypotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHoneypotResponse deleteHoneypot(shared_ptr<DeleteHoneypotRequest> request);
  DeleteHoneypotNodeResponse deleteHoneypotNodeWithOptions(shared_ptr<DeleteHoneypotNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHoneypotNodeResponse deleteHoneypotNode(shared_ptr<DeleteHoneypotNodeRequest> request);
  DeleteHoneypotPresetResponse deleteHoneypotPresetWithOptions(shared_ptr<DeleteHoneypotPresetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHoneypotPresetResponse deleteHoneypotPreset(shared_ptr<DeleteHoneypotPresetRequest> request);
  DeleteHoneypotProbeResponse deleteHoneypotProbeWithOptions(shared_ptr<DeleteHoneypotProbeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHoneypotProbeResponse deleteHoneypotProbe(shared_ptr<DeleteHoneypotProbeRequest> request);
  DeleteInstallCodeResponse deleteInstallCodeWithOptions(shared_ptr<DeleteInstallCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstallCodeResponse deleteInstallCode(shared_ptr<DeleteInstallCodeRequest> request);
  DeleteInterceptionRuleResponse deleteInterceptionRuleWithOptions(shared_ptr<DeleteInterceptionRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInterceptionRuleResponse deleteInterceptionRule(shared_ptr<DeleteInterceptionRuleRequest> request);
  DeleteInterceptionTargetResponse deleteInterceptionTargetWithOptions(shared_ptr<DeleteInterceptionTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInterceptionTargetResponse deleteInterceptionTarget(shared_ptr<DeleteInterceptionTargetRequest> request);
  DeleteLoginBaseConfigResponse deleteLoginBaseConfigWithOptions(shared_ptr<DeleteLoginBaseConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLoginBaseConfigResponse deleteLoginBaseConfig(shared_ptr<DeleteLoginBaseConfigRequest> request);
  DeletePrivateRegistryResponse deletePrivateRegistryWithOptions(shared_ptr<DeletePrivateRegistryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePrivateRegistryResponse deletePrivateRegistry(shared_ptr<DeletePrivateRegistryRequest> request);
  DeleteSecurityEventMarkMissListResponse deleteSecurityEventMarkMissListWithOptions(shared_ptr<DeleteSecurityEventMarkMissListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSecurityEventMarkMissListResponse deleteSecurityEventMarkMissList(shared_ptr<DeleteSecurityEventMarkMissListRequest> request);
  DeleteStrategyResponse deleteStrategyWithOptions(shared_ptr<DeleteStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStrategyResponse deleteStrategy(shared_ptr<DeleteStrategyRequest> request);
  DeleteSuspEventNodeResponse deleteSuspEventNodeWithOptions(shared_ptr<DeleteSuspEventNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSuspEventNodeResponse deleteSuspEventNode(shared_ptr<DeleteSuspEventNodeRequest> request);
  DeleteTagWithUuidResponse deleteTagWithUuidWithOptions(shared_ptr<DeleteTagWithUuidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTagWithUuidResponse deleteTagWithUuid(shared_ptr<DeleteTagWithUuidRequest> request);
  DeleteUniBackupPolicyResponse deleteUniBackupPolicyWithOptions(shared_ptr<DeleteUniBackupPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUniBackupPolicyResponse deleteUniBackupPolicy(shared_ptr<DeleteUniBackupPolicyRequest> request);
  DeleteVpcHoneyPotResponse deleteVpcHoneyPotWithOptions(shared_ptr<DeleteVpcHoneyPotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpcHoneyPotResponse deleteVpcHoneyPot(shared_ptr<DeleteVpcHoneyPotRequest> request);
  DeleteVulWhitelistResponse deleteVulWhitelistWithOptions(shared_ptr<DeleteVulWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVulWhitelistResponse deleteVulWhitelist(shared_ptr<DeleteVulWhitelistRequest> request);
  DescribeAccessKeyLeakDetailResponse describeAccessKeyLeakDetailWithOptions(shared_ptr<DescribeAccessKeyLeakDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccessKeyLeakDetailResponse describeAccessKeyLeakDetail(shared_ptr<DescribeAccessKeyLeakDetailRequest> request);
  DescribeAccesskeyLeakListResponse describeAccesskeyLeakListWithOptions(shared_ptr<DescribeAccesskeyLeakListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccesskeyLeakListResponse describeAccesskeyLeakList(shared_ptr<DescribeAccesskeyLeakListRequest> request);
  DescribeAffectedAssetsResponse describeAffectedAssetsWithOptions(shared_ptr<DescribeAffectedAssetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAffectedAssetsResponse describeAffectedAssets(shared_ptr<DescribeAffectedAssetsRequest> request);
  DescribeAffectedMaliciousFileImagesResponse describeAffectedMaliciousFileImagesWithOptions(shared_ptr<DescribeAffectedMaliciousFileImagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAffectedMaliciousFileImagesResponse describeAffectedMaliciousFileImages(shared_ptr<DescribeAffectedMaliciousFileImagesRequest> request);
  DescribeAgentInstallStatusResponse describeAgentInstallStatusWithOptions(shared_ptr<DescribeAgentInstallStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAgentInstallStatusResponse describeAgentInstallStatus(shared_ptr<DescribeAgentInstallStatusRequest> request);
  DescribeAlarmEventDetailResponse describeAlarmEventDetailWithOptions(shared_ptr<DescribeAlarmEventDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlarmEventDetailResponse describeAlarmEventDetail(shared_ptr<DescribeAlarmEventDetailRequest> request);
  DescribeAlarmEventStackInfoResponse describeAlarmEventStackInfoWithOptions(shared_ptr<DescribeAlarmEventStackInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAlarmEventStackInfoResponse describeAlarmEventStackInfo(shared_ptr<DescribeAlarmEventStackInfoRequest> request);
  DescribeAllEntityResponse describeAllEntityWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAllEntityResponse describeAllEntity();
  DescribeAllGroupsResponse describeAllGroupsWithOptions(shared_ptr<DescribeAllGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAllGroupsResponse describeAllGroups(shared_ptr<DescribeAllGroupsRequest> request);
  DescribeAllImageBaselineResponse describeAllImageBaselineWithOptions(shared_ptr<DescribeAllImageBaselineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAllImageBaselineResponse describeAllImageBaseline(shared_ptr<DescribeAllImageBaselineRequest> request);
  DescribeAntiBruteForceRulesResponse describeAntiBruteForceRulesWithOptions(shared_ptr<DescribeAntiBruteForceRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntiBruteForceRulesResponse describeAntiBruteForceRules(shared_ptr<DescribeAntiBruteForceRulesRequest> request);
  DescribeAppVulScanCycleResponse describeAppVulScanCycleWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppVulScanCycleResponse describeAppVulScanCycle();
  DescribeAssetDetailByUuidResponse describeAssetDetailByUuidWithOptions(shared_ptr<DescribeAssetDetailByUuidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAssetDetailByUuidResponse describeAssetDetailByUuid(shared_ptr<DescribeAssetDetailByUuidRequest> request);
  DescribeAssetDetailByUuidsResponse describeAssetDetailByUuidsWithOptions(shared_ptr<DescribeAssetDetailByUuidsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAssetDetailByUuidsResponse describeAssetDetailByUuids(shared_ptr<DescribeAssetDetailByUuidsRequest> request);
  DescribeAssetSummaryResponse describeAssetSummaryWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAssetSummaryResponse describeAssetSummary();
  DescribeAssetsSecurityEventSummaryResponse describeAssetsSecurityEventSummaryWithOptions(shared_ptr<DescribeAssetsSecurityEventSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAssetsSecurityEventSummaryResponse describeAssetsSecurityEventSummary(shared_ptr<DescribeAssetsSecurityEventSummaryRequest> request);
  DescribeAttackAnalysisDataResponse describeAttackAnalysisDataWithOptions(shared_ptr<DescribeAttackAnalysisDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAttackAnalysisDataResponse describeAttackAnalysisData(shared_ptr<DescribeAttackAnalysisDataRequest> request);
  DescribeAutoDelConfigResponse describeAutoDelConfigWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAutoDelConfigResponse describeAutoDelConfig();
  DescribeBackUpExportInfoResponse describeBackUpExportInfoWithOptions(shared_ptr<DescribeBackUpExportInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackUpExportInfoResponse describeBackUpExportInfo(shared_ptr<DescribeBackUpExportInfoRequest> request);
  DescribeBackupClientsResponse describeBackupClientsWithOptions(shared_ptr<DescribeBackupClientsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupClientsResponse describeBackupClients(shared_ptr<DescribeBackupClientsRequest> request);
  DescribeBackupFilesResponse describeBackupFilesWithOptions(shared_ptr<DescribeBackupFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupFilesResponse describeBackupFiles(shared_ptr<DescribeBackupFilesRequest> request);
  DescribeBackupMachineStatusResponse describeBackupMachineStatusWithOptions(shared_ptr<DescribeBackupMachineStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupMachineStatusResponse describeBackupMachineStatus(shared_ptr<DescribeBackupMachineStatusRequest> request);
  DescribeBackupPoliciesResponse describeBackupPoliciesWithOptions(shared_ptr<DescribeBackupPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupPoliciesResponse describeBackupPolicies(shared_ptr<DescribeBackupPoliciesRequest> request);
  DescribeBackupPolicyResponse describeBackupPolicyWithOptions(shared_ptr<DescribeBackupPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupPolicyResponse describeBackupPolicy(shared_ptr<DescribeBackupPolicyRequest> request);
  DescribeBackupRestoreCountResponse describeBackupRestoreCountWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupRestoreCountResponse describeBackupRestoreCount();
  DescribeBruteForceRecordsResponse describeBruteForceRecordsWithOptions(shared_ptr<DescribeBruteForceRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBruteForceRecordsResponse describeBruteForceRecords(shared_ptr<DescribeBruteForceRecordsRequest> request);
  DescribeBruteForceSummaryResponse describeBruteForceSummaryWithOptions(shared_ptr<DescribeBruteForceSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBruteForceSummaryResponse describeBruteForceSummary(shared_ptr<DescribeBruteForceSummaryRequest> request);
  DescribeCheckEcsWarningsResponse describeCheckEcsWarningsWithOptions(shared_ptr<DescribeCheckEcsWarningsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckEcsWarningsResponse describeCheckEcsWarnings(shared_ptr<DescribeCheckEcsWarningsRequest> request);
  DescribeCheckFixDetailsResponse describeCheckFixDetailsWithOptions(shared_ptr<DescribeCheckFixDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckFixDetailsResponse describeCheckFixDetails(shared_ptr<DescribeCheckFixDetailsRequest> request);
  DescribeCheckWarningDetailResponse describeCheckWarningDetailWithOptions(shared_ptr<DescribeCheckWarningDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckWarningDetailResponse describeCheckWarningDetail(shared_ptr<DescribeCheckWarningDetailRequest> request);
  DescribeCheckWarningMachinesResponse describeCheckWarningMachinesWithOptions(shared_ptr<DescribeCheckWarningMachinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckWarningMachinesResponse describeCheckWarningMachines(shared_ptr<DescribeCheckWarningMachinesRequest> request);
  DescribeCheckWarningSummaryResponse describeCheckWarningSummaryWithOptions(shared_ptr<DescribeCheckWarningSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckWarningSummaryResponse describeCheckWarningSummary(shared_ptr<DescribeCheckWarningSummaryRequest> request);
  DescribeCheckWarningsResponse describeCheckWarningsWithOptions(shared_ptr<DescribeCheckWarningsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCheckWarningsResponse describeCheckWarnings(shared_ptr<DescribeCheckWarningsRequest> request);
  DescribeClientConfSetupResponse describeClientConfSetupWithOptions(shared_ptr<DescribeClientConfSetupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClientConfSetupResponse describeClientConfSetup(shared_ptr<DescribeClientConfSetupRequest> request);
  DescribeClientConfStrategyResponse describeClientConfStrategyWithOptions(shared_ptr<DescribeClientConfStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClientConfStrategyResponse describeClientConfStrategy(shared_ptr<DescribeClientConfStrategyRequest> request);
  DescribeCloudCenterInstancesResponse describeCloudCenterInstancesWithOptions(shared_ptr<DescribeCloudCenterInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudCenterInstancesResponse describeCloudCenterInstances(shared_ptr<DescribeCloudCenterInstancesRequest> request);
  DescribeCloudProductFieldStatisticsResponse describeCloudProductFieldStatisticsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudProductFieldStatisticsResponse describeCloudProductFieldStatistics();
  DescribeClusterBasicInfoResponse describeClusterBasicInfoWithOptions(shared_ptr<DescribeClusterBasicInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterBasicInfoResponse describeClusterBasicInfo(shared_ptr<DescribeClusterBasicInfoRequest> request);
  DescribeClusterInfoListResponse describeClusterInfoListWithOptions(shared_ptr<DescribeClusterInfoListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterInfoListResponse describeClusterInfoList(shared_ptr<DescribeClusterInfoListRequest> request);
  DescribeClusterNetworkResponse describeClusterNetworkWithOptions(shared_ptr<DescribeClusterNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterNetworkResponse describeClusterNetwork(shared_ptr<DescribeClusterNetworkRequest> request);
  DescribeClusterVulStatisticsResponse describeClusterVulStatisticsWithOptions(shared_ptr<DescribeClusterVulStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClusterVulStatisticsResponse describeClusterVulStatistics(shared_ptr<DescribeClusterVulStatisticsRequest> request);
  DescribeCommonOverallConfigResponse describeCommonOverallConfigWithOptions(shared_ptr<DescribeCommonOverallConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCommonOverallConfigResponse describeCommonOverallConfig(shared_ptr<DescribeCommonOverallConfigRequest> request);
  DescribeCommonOverallConfigListResponse describeCommonOverallConfigListWithOptions(shared_ptr<DescribeCommonOverallConfigListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCommonOverallConfigListResponse describeCommonOverallConfigList(shared_ptr<DescribeCommonOverallConfigListRequest> request);
  DescribeCommonTargetConfigResponse describeCommonTargetConfigWithOptions(shared_ptr<DescribeCommonTargetConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCommonTargetConfigResponse describeCommonTargetConfig(shared_ptr<DescribeCommonTargetConfigRequest> request);
  DescribeCommonTargetResultListResponse describeCommonTargetResultListWithOptions(shared_ptr<DescribeCommonTargetResultListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCommonTargetResultListResponse describeCommonTargetResultList(shared_ptr<DescribeCommonTargetResultListRequest> request);
  DescribeConcernNecessityResponse describeConcernNecessityWithOptions(shared_ptr<DescribeConcernNecessityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConcernNecessityResponse describeConcernNecessity(shared_ptr<DescribeConcernNecessityRequest> request);
  DescribeContainerCriteriaResponse describeContainerCriteriaWithOptions(shared_ptr<DescribeContainerCriteriaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContainerCriteriaResponse describeContainerCriteria(shared_ptr<DescribeContainerCriteriaRequest> request);
  DescribeContainerInstancesResponse describeContainerInstancesWithOptions(shared_ptr<DescribeContainerInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContainerInstancesResponse describeContainerInstances(shared_ptr<DescribeContainerInstancesRequest> request);
  DescribeContainerStatisticsResponse describeContainerStatisticsWithOptions(shared_ptr<DescribeContainerStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContainerStatisticsResponse describeContainerStatistics(shared_ptr<DescribeContainerStatisticsRequest> request);
  DescribeContainerTagsResponse describeContainerTagsWithOptions(shared_ptr<DescribeContainerTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeContainerTagsResponse describeContainerTags(shared_ptr<DescribeContainerTagsRequest> request);
  DescribeCountNotScannedImageResponse describeCountNotScannedImageWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCountNotScannedImageResponse describeCountNotScannedImage();
  DescribeCountScannedImageResponse describeCountScannedImageWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCountScannedImageResponse describeCountScannedImage();
  DescribeCriteriaResponse describeCriteriaWithOptions(shared_ptr<DescribeCriteriaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCriteriaResponse describeCriteria(shared_ptr<DescribeCriteriaRequest> request);
  DescribeCustomBlockRecordsResponse describeCustomBlockRecordsWithOptions(shared_ptr<DescribeCustomBlockRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomBlockRecordsResponse describeCustomBlockRecords(shared_ptr<DescribeCustomBlockRecordsRequest> request);
  DescribeCycleTaskListResponse describeCycleTaskListWithOptions(shared_ptr<DescribeCycleTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCycleTaskListResponse describeCycleTaskList(shared_ptr<DescribeCycleTaskListRequest> request);
  DescribeDingTalkResponse describeDingTalkWithOptions(shared_ptr<DescribeDingTalkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDingTalkResponse describeDingTalk(shared_ptr<DescribeDingTalkRequest> request);
  DescribeDomainCountResponse describeDomainCountWithOptions(shared_ptr<DescribeDomainCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainCountResponse describeDomainCount(shared_ptr<DescribeDomainCountRequest> request);
  DescribeDomainDetailResponse describeDomainDetailWithOptions(shared_ptr<DescribeDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainDetailResponse describeDomainDetail(shared_ptr<DescribeDomainDetailRequest> request);
  DescribeDomainListResponse describeDomainListWithOptions(shared_ptr<DescribeDomainListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainListResponse describeDomainList(shared_ptr<DescribeDomainListRequest> request);
  DescribeEmgUserAgreementResponse describeEmgUserAgreementWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEmgUserAgreementResponse describeEmgUserAgreement();
  DescribeEmgVulItemResponse describeEmgVulItemWithOptions(shared_ptr<DescribeEmgVulItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEmgVulItemResponse describeEmgVulItem(shared_ptr<DescribeEmgVulItemRequest> request);
  DescribeEventLevelCountResponse describeEventLevelCountWithOptions(shared_ptr<DescribeEventLevelCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventLevelCountResponse describeEventLevelCount(shared_ptr<DescribeEventLevelCountRequest> request);
  DescribeEventOnStageResponse describeEventOnStageWithOptions(shared_ptr<DescribeEventOnStageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEventOnStageResponse describeEventOnStage(shared_ptr<DescribeEventOnStageRequest> request);
  DescribeExcludeSystemPathResponse describeExcludeSystemPathWithOptions(shared_ptr<DescribeExcludeSystemPathRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExcludeSystemPathResponse describeExcludeSystemPath(shared_ptr<DescribeExcludeSystemPathRequest> request);
  DescribeExportInfoResponse describeExportInfoWithOptions(shared_ptr<DescribeExportInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExportInfoResponse describeExportInfo(shared_ptr<DescribeExportInfoRequest> request);
  DescribeExposedCheckWarningResponse describeExposedCheckWarningWithOptions(shared_ptr<DescribeExposedCheckWarningRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedCheckWarningResponse describeExposedCheckWarning(shared_ptr<DescribeExposedCheckWarningRequest> request);
  DescribeExposedInstanceCriteriaResponse describeExposedInstanceCriteriaWithOptions(shared_ptr<DescribeExposedInstanceCriteriaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedInstanceCriteriaResponse describeExposedInstanceCriteria(shared_ptr<DescribeExposedInstanceCriteriaRequest> request);
  DescribeExposedInstanceDetailResponse describeExposedInstanceDetailWithOptions(shared_ptr<DescribeExposedInstanceDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedInstanceDetailResponse describeExposedInstanceDetail(shared_ptr<DescribeExposedInstanceDetailRequest> request);
  DescribeExposedInstanceListResponse describeExposedInstanceListWithOptions(shared_ptr<DescribeExposedInstanceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedInstanceListResponse describeExposedInstanceList(shared_ptr<DescribeExposedInstanceListRequest> request);
  DescribeExposedStatisticsResponse describeExposedStatisticsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedStatisticsResponse describeExposedStatistics();
  DescribeExposedStatisticsDetailResponse describeExposedStatisticsDetailWithOptions(shared_ptr<DescribeExposedStatisticsDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExposedStatisticsDetailResponse describeExposedStatisticsDetail(shared_ptr<DescribeExposedStatisticsDetailRequest> request);
  DescribeFieldStatisticsResponse describeFieldStatisticsWithOptions(shared_ptr<DescribeFieldStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFieldStatisticsResponse describeFieldStatistics(shared_ptr<DescribeFieldStatisticsRequest> request);
  DescribeFrontVulPatchListResponse describeFrontVulPatchListWithOptions(shared_ptr<DescribeFrontVulPatchListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFrontVulPatchListResponse describeFrontVulPatchList(shared_ptr<DescribeFrontVulPatchListRequest> request);
  DescribeGroupStructResponse describeGroupStructWithOptions(shared_ptr<DescribeGroupStructRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupStructResponse describeGroupStruct(shared_ptr<DescribeGroupStructRequest> request);
  DescribeGroupedContainerInstancesResponse describeGroupedContainerInstancesWithOptions(shared_ptr<DescribeGroupedContainerInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupedContainerInstancesResponse describeGroupedContainerInstances(shared_ptr<DescribeGroupedContainerInstancesRequest> request);
  DescribeGroupedInstancesResponse describeGroupedInstancesWithOptions(shared_ptr<DescribeGroupedInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupedInstancesResponse describeGroupedInstances(shared_ptr<DescribeGroupedInstancesRequest> request);
  DescribeGroupedMaliciousFilesResponse describeGroupedMaliciousFilesWithOptions(shared_ptr<DescribeGroupedMaliciousFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupedMaliciousFilesResponse describeGroupedMaliciousFiles(shared_ptr<DescribeGroupedMaliciousFilesRequest> request);
  DescribeGroupedTagsResponse describeGroupedTagsWithOptions(shared_ptr<DescribeGroupedTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupedTagsResponse describeGroupedTags(shared_ptr<DescribeGroupedTagsRequest> request);
  DescribeGroupedVulResponse describeGroupedVulWithOptions(shared_ptr<DescribeGroupedVulRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupedVulResponse describeGroupedVul(shared_ptr<DescribeGroupedVulRequest> request);
  DescribeHcExportInfoResponse describeHcExportInfoWithOptions(shared_ptr<DescribeHcExportInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHcExportInfoResponse describeHcExportInfo(shared_ptr<DescribeHcExportInfoRequest> request);
  DescribeHoneyPotAuthResponse describeHoneyPotAuthWithOptions(shared_ptr<DescribeHoneyPotAuthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHoneyPotAuthResponse describeHoneyPotAuth(shared_ptr<DescribeHoneyPotAuthRequest> request);
  DescribeHoneyPotSuspStatisticsResponse describeHoneyPotSuspStatisticsWithOptions(shared_ptr<DescribeHoneyPotSuspStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHoneyPotSuspStatisticsResponse describeHoneyPotSuspStatistics(shared_ptr<DescribeHoneyPotSuspStatisticsRequest> request);
  DescribeImageResponse describeImageWithOptions(shared_ptr<DescribeImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageResponse describeImage(shared_ptr<DescribeImageRequest> request);
  DescribeImageBaselineCheckResultResponse describeImageBaselineCheckResultWithOptions(shared_ptr<DescribeImageBaselineCheckResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageBaselineCheckResultResponse describeImageBaselineCheckResult(shared_ptr<DescribeImageBaselineCheckResultRequest> request);
  DescribeImageBaselineCheckSummaryResponse describeImageBaselineCheckSummaryWithOptions(shared_ptr<DescribeImageBaselineCheckSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageBaselineCheckSummaryResponse describeImageBaselineCheckSummary(shared_ptr<DescribeImageBaselineCheckSummaryRequest> request);
  DescribeImageBaselineDetailResponse describeImageBaselineDetailWithOptions(shared_ptr<DescribeImageBaselineDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageBaselineDetailResponse describeImageBaselineDetail(shared_ptr<DescribeImageBaselineDetailRequest> request);
  DescribeImageBaselineItemListResponse describeImageBaselineItemListWithOptions(shared_ptr<DescribeImageBaselineItemListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageBaselineItemListResponse describeImageBaselineItemList(shared_ptr<DescribeImageBaselineItemListRequest> request);
  DescribeImageBaselineStrategyResponse describeImageBaselineStrategyWithOptions(shared_ptr<DescribeImageBaselineStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageBaselineStrategyResponse describeImageBaselineStrategy(shared_ptr<DescribeImageBaselineStrategyRequest> request);
  DescribeImageCriteriaResponse describeImageCriteriaWithOptions(shared_ptr<DescribeImageCriteriaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageCriteriaResponse describeImageCriteria(shared_ptr<DescribeImageCriteriaRequest> request);
  DescribeImageFixTaskResponse describeImageFixTaskWithOptions(shared_ptr<DescribeImageFixTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageFixTaskResponse describeImageFixTask(shared_ptr<DescribeImageFixTaskRequest> request);
  DescribeImageGroupedVulListResponse describeImageGroupedVulListWithOptions(shared_ptr<DescribeImageGroupedVulListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageGroupedVulListResponse describeImageGroupedVulList(shared_ptr<DescribeImageGroupedVulListRequest> request);
  DescribeImageInfoListResponse describeImageInfoListWithOptions(shared_ptr<DescribeImageInfoListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageInfoListResponse describeImageInfoList(shared_ptr<DescribeImageInfoListRequest> request);
  DescribeImageInstancesResponse describeImageInstancesWithOptions(shared_ptr<DescribeImageInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageInstancesResponse describeImageInstances(shared_ptr<DescribeImageInstancesRequest> request);
  DescribeImageLatestScanTaskResponse describeImageLatestScanTaskWithOptions(shared_ptr<DescribeImageLatestScanTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageLatestScanTaskResponse describeImageLatestScanTask(shared_ptr<DescribeImageLatestScanTaskRequest> request);
  DescribeImageListBySensitiveFileResponse describeImageListBySensitiveFileWithOptions(shared_ptr<DescribeImageListBySensitiveFileRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageListBySensitiveFileResponse describeImageListBySensitiveFile(shared_ptr<DescribeImageListBySensitiveFileRequest> request);
  DescribeImageListWithBaselineNameResponse describeImageListWithBaselineNameWithOptions(shared_ptr<DescribeImageListWithBaselineNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageListWithBaselineNameResponse describeImageListWithBaselineName(shared_ptr<DescribeImageListWithBaselineNameRequest> request);
  DescribeImageRepoCriteriaResponse describeImageRepoCriteriaWithOptions(shared_ptr<DescribeImageRepoCriteriaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageRepoCriteriaResponse describeImageRepoCriteria(shared_ptr<DescribeImageRepoCriteriaRequest> request);
  DescribeImageRepoDetailListResponse describeImageRepoDetailListWithOptions(shared_ptr<DescribeImageRepoDetailListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageRepoDetailListResponse describeImageRepoDetailList(shared_ptr<DescribeImageRepoDetailListRequest> request);
  DescribeImageRepoListResponse describeImageRepoListWithOptions(shared_ptr<DescribeImageRepoListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageRepoListResponse describeImageRepoList(shared_ptr<DescribeImageRepoListRequest> request);
  DescribeImageScanAuthCountResponse describeImageScanAuthCountWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageScanAuthCountResponse describeImageScanAuthCount();
  DescribeImageScanAuthorizationResponse describeImageScanAuthorizationWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageScanAuthorizationResponse describeImageScanAuthorization();
  DescribeImageSensitiveFileByKeyResponse describeImageSensitiveFileByKeyWithOptions(shared_ptr<DescribeImageSensitiveFileByKeyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageSensitiveFileByKeyResponse describeImageSensitiveFileByKey(shared_ptr<DescribeImageSensitiveFileByKeyRequest> request);
  DescribeImageSensitiveFileListResponse describeImageSensitiveFileListWithOptions(shared_ptr<DescribeImageSensitiveFileListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageSensitiveFileListResponse describeImageSensitiveFileList(shared_ptr<DescribeImageSensitiveFileListRequest> request);
  DescribeImageStatisticsResponse describeImageStatisticsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageStatisticsResponse describeImageStatistics();
  DescribeImageVulListResponse describeImageVulListWithOptions(shared_ptr<DescribeImageVulListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImageVulListResponse describeImageVulList(shared_ptr<DescribeImageVulListRequest> request);
  DescribeInstallCaptchaResponse describeInstallCaptchaWithOptions(shared_ptr<DescribeInstallCaptchaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstallCaptchaResponse describeInstallCaptcha(shared_ptr<DescribeInstallCaptchaRequest> request);
  DescribeInstallCodeResponse describeInstallCodeWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstallCodeResponse describeInstallCode();
  DescribeInstallCodesResponse describeInstallCodesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstallCodesResponse describeInstallCodes();
  DescribeInstanceAntiBruteForceRulesResponse describeInstanceAntiBruteForceRulesWithOptions(shared_ptr<DescribeInstanceAntiBruteForceRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceAntiBruteForceRulesResponse describeInstanceAntiBruteForceRules(shared_ptr<DescribeInstanceAntiBruteForceRulesRequest> request);
  DescribeInstanceRebootStatusResponse describeInstanceRebootStatusWithOptions(shared_ptr<DescribeInstanceRebootStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceRebootStatusResponse describeInstanceRebootStatus(shared_ptr<DescribeInstanceRebootStatusRequest> request);
  DescribeInstanceStatisticsResponse describeInstanceStatisticsWithOptions(shared_ptr<DescribeInstanceStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceStatisticsResponse describeInstanceStatistics(shared_ptr<DescribeInstanceStatisticsRequest> request);
  DescribeIpTagsResponse describeIpTagsWithOptions(shared_ptr<DescribeIpTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpTagsResponse describeIpTags(shared_ptr<DescribeIpTagsRequest> request);
  DescribeLatestScanTaskResponse describeLatestScanTaskWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLatestScanTaskResponse describeLatestScanTask();
  DescribeLogMetaResponse describeLogMetaWithOptions(shared_ptr<DescribeLogMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogMetaResponse describeLogMeta(shared_ptr<DescribeLogMetaRequest> request);
  DescribeLogShipperStatusResponse describeLogShipperStatusWithOptions(shared_ptr<DescribeLogShipperStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogShipperStatusResponse describeLogShipperStatus(shared_ptr<DescribeLogShipperStatusRequest> request);
  DescribeLoginBaseConfigsResponse describeLoginBaseConfigsWithOptions(shared_ptr<DescribeLoginBaseConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoginBaseConfigsResponse describeLoginBaseConfigs(shared_ptr<DescribeLoginBaseConfigsRequest> request);
  DescribeLoginSwitchConfigsResponse describeLoginSwitchConfigsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLoginSwitchConfigsResponse describeLoginSwitchConfigs();
  DescribeLogstoreStorageResponse describeLogstoreStorageWithOptions(shared_ptr<DescribeLogstoreStorageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogstoreStorageResponse describeLogstoreStorage(shared_ptr<DescribeLogstoreStorageRequest> request);
  DescribeMachineCanRebootResponse describeMachineCanRebootWithOptions(shared_ptr<DescribeMachineCanRebootRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMachineCanRebootResponse describeMachineCanReboot(shared_ptr<DescribeMachineCanRebootRequest> request);
  DescribeModuleConfigResponse describeModuleConfigWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeModuleConfigResponse describeModuleConfig();
  DescribeNoticeConfigResponse describeNoticeConfigWithOptions(shared_ptr<DescribeNoticeConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNoticeConfigResponse describeNoticeConfig(shared_ptr<DescribeNoticeConfigRequest> request);
  DescribeNsasSuspEventTypeResponse describeNsasSuspEventTypeWithOptions(shared_ptr<DescribeNsasSuspEventTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNsasSuspEventTypeResponse describeNsasSuspEventType(shared_ptr<DescribeNsasSuspEventTypeRequest> request);
  DescribeOfflineMachinesResponse describeOfflineMachinesWithOptions(shared_ptr<DescribeOfflineMachinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOfflineMachinesResponse describeOfflineMachines(shared_ptr<DescribeOfflineMachinesRequest> request);
  DescribeOnceTaskResponse describeOnceTaskWithOptions(shared_ptr<DescribeOnceTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOnceTaskResponse describeOnceTask(shared_ptr<DescribeOnceTaskRequest> request);
  DescribeOnceTaskLeafRecordPageResponse describeOnceTaskLeafRecordPageWithOptions(shared_ptr<DescribeOnceTaskLeafRecordPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOnceTaskLeafRecordPageResponse describeOnceTaskLeafRecordPage(shared_ptr<DescribeOnceTaskLeafRecordPageRequest> request);
  DescribePropertyCountResponse describePropertyCountWithOptions(shared_ptr<DescribePropertyCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyCountResponse describePropertyCount(shared_ptr<DescribePropertyCountRequest> request);
  DescribePropertyCronDetailResponse describePropertyCronDetailWithOptions(shared_ptr<DescribePropertyCronDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyCronDetailResponse describePropertyCronDetail(shared_ptr<DescribePropertyCronDetailRequest> request);
  DescribePropertyCronItemResponse describePropertyCronItemWithOptions(shared_ptr<DescribePropertyCronItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyCronItemResponse describePropertyCronItem(shared_ptr<DescribePropertyCronItemRequest> request);
  DescribePropertyPortDetailResponse describePropertyPortDetailWithOptions(shared_ptr<DescribePropertyPortDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyPortDetailResponse describePropertyPortDetail(shared_ptr<DescribePropertyPortDetailRequest> request);
  DescribePropertyPortItemResponse describePropertyPortItemWithOptions(shared_ptr<DescribePropertyPortItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyPortItemResponse describePropertyPortItem(shared_ptr<DescribePropertyPortItemRequest> request);
  DescribePropertyProcDetailResponse describePropertyProcDetailWithOptions(shared_ptr<DescribePropertyProcDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyProcDetailResponse describePropertyProcDetail(shared_ptr<DescribePropertyProcDetailRequest> request);
  DescribePropertyProcItemResponse describePropertyProcItemWithOptions(shared_ptr<DescribePropertyProcItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyProcItemResponse describePropertyProcItem(shared_ptr<DescribePropertyProcItemRequest> request);
  DescribePropertyScaDetailResponse describePropertyScaDetailWithOptions(shared_ptr<DescribePropertyScaDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyScaDetailResponse describePropertyScaDetail(shared_ptr<DescribePropertyScaDetailRequest> request);
  DescribePropertyScaItemResponse describePropertyScaItemWithOptions(shared_ptr<DescribePropertyScaItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyScaItemResponse describePropertyScaItem(shared_ptr<DescribePropertyScaItemRequest> request);
  DescribePropertyScheduleConfigResponse describePropertyScheduleConfigWithOptions(shared_ptr<DescribePropertyScheduleConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyScheduleConfigResponse describePropertyScheduleConfig(shared_ptr<DescribePropertyScheduleConfigRequest> request);
  DescribePropertySoftwareDetailResponse describePropertySoftwareDetailWithOptions(shared_ptr<DescribePropertySoftwareDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertySoftwareDetailResponse describePropertySoftwareDetail(shared_ptr<DescribePropertySoftwareDetailRequest> request);
  DescribePropertySoftwareItemResponse describePropertySoftwareItemWithOptions(shared_ptr<DescribePropertySoftwareItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertySoftwareItemResponse describePropertySoftwareItem(shared_ptr<DescribePropertySoftwareItemRequest> request);
  DescribePropertyTypeScaItemResponse describePropertyTypeScaItemWithOptions(shared_ptr<DescribePropertyTypeScaItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyTypeScaItemResponse describePropertyTypeScaItem(shared_ptr<DescribePropertyTypeScaItemRequest> request);
  DescribePropertyUsageNewestResponse describePropertyUsageNewestWithOptions(shared_ptr<DescribePropertyUsageNewestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyUsageNewestResponse describePropertyUsageNewest(shared_ptr<DescribePropertyUsageNewestRequest> request);
  DescribePropertyUserDetailResponse describePropertyUserDetailWithOptions(shared_ptr<DescribePropertyUserDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyUserDetailResponse describePropertyUserDetail(shared_ptr<DescribePropertyUserDetailRequest> request);
  DescribePropertyUserItemResponse describePropertyUserItemWithOptions(shared_ptr<DescribePropertyUserItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePropertyUserItemResponse describePropertyUserItem(shared_ptr<DescribePropertyUserItemRequest> request);
  DescribeQuaraFileDownloadInfoResponse describeQuaraFileDownloadInfoWithOptions(shared_ptr<DescribeQuaraFileDownloadInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeQuaraFileDownloadInfoResponse describeQuaraFileDownloadInfo(shared_ptr<DescribeQuaraFileDownloadInfoRequest> request);
  DescribeRestoreJobsResponse describeRestoreJobsWithOptions(shared_ptr<DescribeRestoreJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRestoreJobsResponse describeRestoreJobs(shared_ptr<DescribeRestoreJobsRequest> request);
  DescribeRestorePlansResponse describeRestorePlansWithOptions(shared_ptr<DescribeRestorePlansRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRestorePlansResponse describeRestorePlans(shared_ptr<DescribeRestorePlansRequest> request);
  DescribeRiskCheckItemResultResponse describeRiskCheckItemResultWithOptions(shared_ptr<DescribeRiskCheckItemResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskCheckItemResultResponse describeRiskCheckItemResult(shared_ptr<DescribeRiskCheckItemResultRequest> request);
  DescribeRiskCheckResultResponse describeRiskCheckResultWithOptions(shared_ptr<DescribeRiskCheckResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskCheckResultResponse describeRiskCheckResult(shared_ptr<DescribeRiskCheckResultRequest> request);
  DescribeRiskCheckSummaryResponse describeRiskCheckSummaryWithOptions(shared_ptr<DescribeRiskCheckSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskCheckSummaryResponse describeRiskCheckSummary(shared_ptr<DescribeRiskCheckSummaryRequest> request);
  DescribeRiskItemTypeResponse describeRiskItemTypeWithOptions(shared_ptr<DescribeRiskItemTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskItemTypeResponse describeRiskItemType(shared_ptr<DescribeRiskItemTypeRequest> request);
  DescribeRiskListCheckResultResponse describeRiskListCheckResultWithOptions(shared_ptr<DescribeRiskListCheckResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskListCheckResultResponse describeRiskListCheckResult(shared_ptr<DescribeRiskListCheckResultRequest> request);
  DescribeRiskTypeResponse describeRiskTypeWithOptions(shared_ptr<DescribeRiskTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRiskTypeResponse describeRiskType(shared_ptr<DescribeRiskTypeRequest> request);
  DescribeRisksResponse describeRisksWithOptions(shared_ptr<DescribeRisksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRisksResponse describeRisks(shared_ptr<DescribeRisksRequest> request);
  DescribeSasPmAgentListResponse describeSasPmAgentListWithOptions(shared_ptr<DescribeSasPmAgentListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSasPmAgentListResponse describeSasPmAgentList(shared_ptr<DescribeSasPmAgentListRequest> request);
  DescribeScanTaskProgressResponse describeScanTaskProgressWithOptions(shared_ptr<DescribeScanTaskProgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScanTaskProgressResponse describeScanTaskProgress(shared_ptr<DescribeScanTaskProgressRequest> request);
  DescribeScanTaskStatisticsResponse describeScanTaskStatisticsWithOptions(shared_ptr<DescribeScanTaskStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeScanTaskStatisticsResponse describeScanTaskStatistics(shared_ptr<DescribeScanTaskStatisticsRequest> request);
  DescribeSearchConditionResponse describeSearchConditionWithOptions(shared_ptr<DescribeSearchConditionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSearchConditionResponse describeSearchCondition(shared_ptr<DescribeSearchConditionRequest> request);
  DescribeSecureSuggestionResponse describeSecureSuggestionWithOptions(shared_ptr<DescribeSecureSuggestionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecureSuggestionResponse describeSecureSuggestion(shared_ptr<DescribeSecureSuggestionRequest> request);
  DescribeSecurityCheckScheduleConfigResponse describeSecurityCheckScheduleConfigWithOptions(shared_ptr<DescribeSecurityCheckScheduleConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityCheckScheduleConfigResponse describeSecurityCheckScheduleConfig(shared_ptr<DescribeSecurityCheckScheduleConfigRequest> request);
  DescribeSecurityEventOperationStatusResponse describeSecurityEventOperationStatusWithOptions(shared_ptr<DescribeSecurityEventOperationStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityEventOperationStatusResponse describeSecurityEventOperationStatus(shared_ptr<DescribeSecurityEventOperationStatusRequest> request);
  DescribeSecurityEventOperationsResponse describeSecurityEventOperationsWithOptions(shared_ptr<DescribeSecurityEventOperationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityEventOperationsResponse describeSecurityEventOperations(shared_ptr<DescribeSecurityEventOperationsRequest> request);
  DescribeSecurityStatInfoResponse describeSecurityStatInfoWithOptions(shared_ptr<DescribeSecurityStatInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityStatInfoResponse describeSecurityStatInfo(shared_ptr<DescribeSecurityStatInfoRequest> request);
  DescribeServiceLinkedRoleStatusResponse describeServiceLinkedRoleStatusWithOptions(shared_ptr<DescribeServiceLinkedRoleStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeServiceLinkedRoleStatusResponse describeServiceLinkedRoleStatus(shared_ptr<DescribeServiceLinkedRoleStatusRequest> request);
  DescribeSimilarEventScenariosResponse describeSimilarEventScenariosWithOptions(shared_ptr<DescribeSimilarEventScenariosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSimilarEventScenariosResponse describeSimilarEventScenarios(shared_ptr<DescribeSimilarEventScenariosRequest> request);
  DescribeSimilarSecurityEventsResponse describeSimilarSecurityEventsWithOptions(shared_ptr<DescribeSimilarSecurityEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSimilarSecurityEventsResponse describeSimilarSecurityEvents(shared_ptr<DescribeSimilarSecurityEventsRequest> request);
  DescribeSnapshotsResponse describeSnapshotsWithOptions(shared_ptr<DescribeSnapshotsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotsResponse describeSnapshots(shared_ptr<DescribeSnapshotsRequest> request);
  DescribeStrategyResponse describeStrategyWithOptions(shared_ptr<DescribeStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStrategyResponse describeStrategy(shared_ptr<DescribeStrategyRequest> request);
  DescribeStrategyDetailResponse describeStrategyDetailWithOptions(shared_ptr<DescribeStrategyDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStrategyDetailResponse describeStrategyDetail(shared_ptr<DescribeStrategyDetailRequest> request);
  DescribeStrategyExecDetailResponse describeStrategyExecDetailWithOptions(shared_ptr<DescribeStrategyExecDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStrategyExecDetailResponse describeStrategyExecDetail(shared_ptr<DescribeStrategyExecDetailRequest> request);
  DescribeStrategyTargetResponse describeStrategyTargetWithOptions(shared_ptr<DescribeStrategyTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeStrategyTargetResponse describeStrategyTarget(shared_ptr<DescribeStrategyTargetRequest> request);
  DescribeSummaryInfoResponse describeSummaryInfoWithOptions(shared_ptr<DescribeSummaryInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSummaryInfoResponse describeSummaryInfo(shared_ptr<DescribeSummaryInfoRequest> request);
  DescribeSupportRegionResponse describeSupportRegionWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSupportRegionResponse describeSupportRegion();
  DescribeSuspEventDetailResponse describeSuspEventDetailWithOptions(shared_ptr<DescribeSuspEventDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSuspEventDetailResponse describeSuspEventDetail(shared_ptr<DescribeSuspEventDetailRequest> request);
  DescribeSuspEventExportInfoResponse describeSuspEventExportInfoWithOptions(shared_ptr<DescribeSuspEventExportInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSuspEventExportInfoResponse describeSuspEventExportInfo(shared_ptr<DescribeSuspEventExportInfoRequest> request);
  DescribeSuspEventQuaraFilesResponse describeSuspEventQuaraFilesWithOptions(shared_ptr<DescribeSuspEventQuaraFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSuspEventQuaraFilesResponse describeSuspEventQuaraFiles(shared_ptr<DescribeSuspEventQuaraFilesRequest> request);
  DescribeSuspEventUserSettingResponse describeSuspEventUserSettingWithOptions(shared_ptr<DescribeSuspEventUserSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSuspEventUserSettingResponse describeSuspEventUserSetting(shared_ptr<DescribeSuspEventUserSettingRequest> request);
  DescribeSuspEventsResponse describeSuspEventsWithOptions(shared_ptr<DescribeSuspEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSuspEventsResponse describeSuspEvents(shared_ptr<DescribeSuspEventsRequest> request);
  DescribeSuspiciousOverallConfigResponse describeSuspiciousOverallConfigWithOptions(shared_ptr<DescribeSuspiciousOverallConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSuspiciousOverallConfigResponse describeSuspiciousOverallConfig(shared_ptr<DescribeSuspiciousOverallConfigRequest> request);
  DescribeSuspiciousUUIDConfigResponse describeSuspiciousUUIDConfigWithOptions(shared_ptr<DescribeSuspiciousUUIDConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSuspiciousUUIDConfigResponse describeSuspiciousUUIDConfig(shared_ptr<DescribeSuspiciousUUIDConfigRequest> request);
  DescribeTargetResponse describeTargetWithOptions(shared_ptr<DescribeTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTargetResponse describeTarget(shared_ptr<DescribeTargetRequest> request);
  DescribeTaskErrorLogResponse describeTaskErrorLogWithOptions(shared_ptr<DescribeTaskErrorLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTaskErrorLogResponse describeTaskErrorLog(shared_ptr<DescribeTaskErrorLogRequest> request);
  DescribeTotalStatisticsResponse describeTotalStatisticsWithOptions(shared_ptr<DescribeTotalStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTotalStatisticsResponse describeTotalStatistics(shared_ptr<DescribeTotalStatisticsRequest> request);
  DescribeTraceInfoDetailResponse describeTraceInfoDetailWithOptions(shared_ptr<DescribeTraceInfoDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTraceInfoDetailResponse describeTraceInfoDetail(shared_ptr<DescribeTraceInfoDetailRequest> request);
  DescribeTraceInfoNodeResponse describeTraceInfoNodeWithOptions(shared_ptr<DescribeTraceInfoNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTraceInfoNodeResponse describeTraceInfoNode(shared_ptr<DescribeTraceInfoNodeRequest> request);
  DescribeUniBackupDatabaseResponse describeUniBackupDatabaseWithOptions(shared_ptr<DescribeUniBackupDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUniBackupDatabaseResponse describeUniBackupDatabase(shared_ptr<DescribeUniBackupDatabaseRequest> request);
  DescribeUniBackupPoliciesResponse describeUniBackupPoliciesWithOptions(shared_ptr<DescribeUniBackupPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUniBackupPoliciesResponse describeUniBackupPolicies(shared_ptr<DescribeUniBackupPoliciesRequest> request);
  DescribeUniBackupPolicyDetailResponse describeUniBackupPolicyDetailWithOptions(shared_ptr<DescribeUniBackupPolicyDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUniBackupPolicyDetailResponse describeUniBackupPolicyDetail(shared_ptr<DescribeUniBackupPolicyDetailRequest> request);
  DescribeUniRecoverableListResponse describeUniRecoverableListWithOptions(shared_ptr<DescribeUniRecoverableListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUniRecoverableListResponse describeUniRecoverableList(shared_ptr<DescribeUniRecoverableListRequest> request);
  DescribeUniSupportRegionResponse describeUniSupportRegionWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUniSupportRegionResponse describeUniSupportRegion();
  DescribeUserBackupMachinesResponse describeUserBackupMachinesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserBackupMachinesResponse describeUserBackupMachines();
  DescribeUserBaselineAuthorizationResponse describeUserBaselineAuthorizationWithOptions(shared_ptr<DescribeUserBaselineAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserBaselineAuthorizationResponse describeUserBaselineAuthorization(shared_ptr<DescribeUserBaselineAuthorizationRequest> request);
  DescribeUserLayoutAuthorizationResponse describeUserLayoutAuthorizationWithOptions(shared_ptr<DescribeUserLayoutAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserLayoutAuthorizationResponse describeUserLayoutAuthorization(shared_ptr<DescribeUserLayoutAuthorizationRequest> request);
  DescribeUuidsByVulNamesResponse describeUuidsByVulNamesWithOptions(shared_ptr<DescribeUuidsByVulNamesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUuidsByVulNamesResponse describeUuidsByVulNames(shared_ptr<DescribeUuidsByVulNamesRequest> request);
  DescribeVendorListResponse describeVendorListWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVendorListResponse describeVendorList();
  DescribeVersionConfigResponse describeVersionConfigWithOptions(shared_ptr<DescribeVersionConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVersionConfigResponse describeVersionConfig(shared_ptr<DescribeVersionConfigRequest> request);
  DescribeVpcHoneyPotCriteriaResponse describeVpcHoneyPotCriteriaWithOptions(shared_ptr<DescribeVpcHoneyPotCriteriaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcHoneyPotCriteriaResponse describeVpcHoneyPotCriteria(shared_ptr<DescribeVpcHoneyPotCriteriaRequest> request);
  DescribeVpcHoneyPotListResponse describeVpcHoneyPotListWithOptions(shared_ptr<DescribeVpcHoneyPotListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcHoneyPotListResponse describeVpcHoneyPotList(shared_ptr<DescribeVpcHoneyPotListRequest> request);
  DescribeVpcListResponse describeVpcListWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcListResponse describeVpcList();
  DescribeVulCheckTaskStatusDetailResponse describeVulCheckTaskStatusDetailWithOptions(shared_ptr<DescribeVulCheckTaskStatusDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulCheckTaskStatusDetailResponse describeVulCheckTaskStatusDetail(shared_ptr<DescribeVulCheckTaskStatusDetailRequest> request);
  DescribeVulConfigResponse describeVulConfigWithOptions(shared_ptr<DescribeVulConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulConfigResponse describeVulConfig(shared_ptr<DescribeVulConfigRequest> request);
  DescribeVulDetailsResponse describeVulDetailsWithOptions(shared_ptr<DescribeVulDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulDetailsResponse describeVulDetails(shared_ptr<DescribeVulDetailsRequest> request);
  DescribeVulExportInfoResponse describeVulExportInfoWithOptions(shared_ptr<DescribeVulExportInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulExportInfoResponse describeVulExportInfo(shared_ptr<DescribeVulExportInfoRequest> request);
  DescribeVulFixStatisticsResponse describeVulFixStatisticsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulFixStatisticsResponse describeVulFixStatistics();
  DescribeVulListResponse describeVulListWithOptions(shared_ptr<DescribeVulListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulListResponse describeVulList(shared_ptr<DescribeVulListRequest> request);
  DescribeVulListPageResponse describeVulListPageWithOptions(shared_ptr<DescribeVulListPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulListPageResponse describeVulListPage(shared_ptr<DescribeVulListPageRequest> request);
  DescribeVulNumStatisticsResponse describeVulNumStatisticsWithOptions(shared_ptr<DescribeVulNumStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulNumStatisticsResponse describeVulNumStatistics(shared_ptr<DescribeVulNumStatisticsRequest> request);
  DescribeVulTargetConfigResponse describeVulTargetConfigWithOptions(shared_ptr<DescribeVulTargetConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulTargetConfigResponse describeVulTargetConfig(shared_ptr<DescribeVulTargetConfigRequest> request);
  DescribeVulTargetStatisticsResponse describeVulTargetStatisticsWithOptions(shared_ptr<DescribeVulTargetStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulTargetStatisticsResponse describeVulTargetStatistics(shared_ptr<DescribeVulTargetStatisticsRequest> request);
  DescribeVulWhitelistResponse describeVulWhitelistWithOptions(shared_ptr<DescribeVulWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVulWhitelistResponse describeVulWhitelist(shared_ptr<DescribeVulWhitelistRequest> request);
  DescribeWarningExportInfoResponse describeWarningExportInfoWithOptions(shared_ptr<DescribeWarningExportInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWarningExportInfoResponse describeWarningExportInfo(shared_ptr<DescribeWarningExportInfoRequest> request);
  DescribeWarningMachinesResponse describeWarningMachinesWithOptions(shared_ptr<DescribeWarningMachinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWarningMachinesResponse describeWarningMachines(shared_ptr<DescribeWarningMachinesRequest> request);
  DescribeWebLockBindListResponse describeWebLockBindListWithOptions(shared_ptr<DescribeWebLockBindListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockBindListResponse describeWebLockBindList(shared_ptr<DescribeWebLockBindListRequest> request);
  DescribeWebLockConfigListResponse describeWebLockConfigListWithOptions(shared_ptr<DescribeWebLockConfigListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockConfigListResponse describeWebLockConfigList(shared_ptr<DescribeWebLockConfigListRequest> request);
  DescribeWebLockExclusiveFileTypeResponse describeWebLockExclusiveFileTypeWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockExclusiveFileTypeResponse describeWebLockExclusiveFileType();
  DescribeWebLockFileChangeStatisticsResponse describeWebLockFileChangeStatisticsWithOptions(shared_ptr<DescribeWebLockFileChangeStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockFileChangeStatisticsResponse describeWebLockFileChangeStatistics(shared_ptr<DescribeWebLockFileChangeStatisticsRequest> request);
  DescribeWebLockFileEventsResponse describeWebLockFileEventsWithOptions(shared_ptr<DescribeWebLockFileEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockFileEventsResponse describeWebLockFileEvents(shared_ptr<DescribeWebLockFileEventsRequest> request);
  DescribeWebLockFileTypeSummaryResponse describeWebLockFileTypeSummaryWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockFileTypeSummaryResponse describeWebLockFileTypeSummary();
  DescribeWebLockInclusiveFileTypeResponse describeWebLockInclusiveFileTypeWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockInclusiveFileTypeResponse describeWebLockInclusiveFileType();
  DescribeWebLockProcessBlockStatisticsResponse describeWebLockProcessBlockStatisticsWithOptions(shared_ptr<DescribeWebLockProcessBlockStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockProcessBlockStatisticsResponse describeWebLockProcessBlockStatistics(shared_ptr<DescribeWebLockProcessBlockStatisticsRequest> request);
  DescribeWebLockProcessListResponse describeWebLockProcessListWithOptions(shared_ptr<DescribeWebLockProcessListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockProcessListResponse describeWebLockProcessList(shared_ptr<DescribeWebLockProcessListRequest> request);
  DescribeWebLockStatusResponse describeWebLockStatusWithOptions(shared_ptr<DescribeWebLockStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockStatusResponse describeWebLockStatus(shared_ptr<DescribeWebLockStatusRequest> request);
  DescribeWebLockTotalFileChangeCountResponse describeWebLockTotalFileChangeCountWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebLockTotalFileChangeCountResponse describeWebLockTotalFileChangeCount();
  DescribeWebPathResponse describeWebPathWithOptions(shared_ptr<DescribeWebPathRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWebPathResponse describeWebPath(shared_ptr<DescribeWebPathRequest> request);
  DisableBruteForceRecordResponse disableBruteForceRecordWithOptions(shared_ptr<DisableBruteForceRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableBruteForceRecordResponse disableBruteForceRecord(shared_ptr<DisableBruteForceRecordRequest> request);
  DisableCustomBlockRecordResponse disableCustomBlockRecordWithOptions(shared_ptr<DisableCustomBlockRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableCustomBlockRecordResponse disableCustomBlockRecord(shared_ptr<DisableCustomBlockRecordRequest> request);
  EnableBruteForceRecordResponse enableBruteForceRecordWithOptions(shared_ptr<EnableBruteForceRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableBruteForceRecordResponse enableBruteForceRecord(shared_ptr<EnableBruteForceRecordRequest> request);
  EnableCustomBlockRecordResponse enableCustomBlockRecordWithOptions(shared_ptr<EnableCustomBlockRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableCustomBlockRecordResponse enableCustomBlockRecord(shared_ptr<EnableCustomBlockRecordRequest> request);
  ExecStrategyResponse execStrategyWithOptions(shared_ptr<ExecStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecStrategyResponse execStrategy(shared_ptr<ExecStrategyRequest> request);
  ExportRecordResponse exportRecordWithOptions(shared_ptr<ExportRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportRecordResponse exportRecord(shared_ptr<ExportRecordRequest> request);
  ExportSuspEventsResponse exportSuspEventsWithOptions(shared_ptr<ExportSuspEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportSuspEventsResponse exportSuspEvents(shared_ptr<ExportSuspEventsRequest> request);
  ExportVulResponse exportVulWithOptions(shared_ptr<ExportVulRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportVulResponse exportVul(shared_ptr<ExportVulRequest> request);
  ExportWarningResponse exportWarningWithOptions(shared_ptr<ExportWarningRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportWarningResponse exportWarning(shared_ptr<ExportWarningRequest> request);
  FindContainerNetworkConnectResponse findContainerNetworkConnectWithOptions(shared_ptr<FindContainerNetworkConnectRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindContainerNetworkConnectResponse findContainerNetworkConnect(shared_ptr<FindContainerNetworkConnectRequest> request);
  FixCheckWarningsResponse fixCheckWarningsWithOptions(shared_ptr<FixCheckWarningsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FixCheckWarningsResponse fixCheckWarnings(shared_ptr<FixCheckWarningsRequest> request);
  GenerateOnceTaskResponse generateOnceTaskWithOptions(shared_ptr<GenerateOnceTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateOnceTaskResponse generateOnceTask(shared_ptr<GenerateOnceTaskRequest> request);
  GetAlarmMachineCountResponse getAlarmMachineCountWithOptions(shared_ptr<GetAlarmMachineCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAlarmMachineCountResponse getAlarmMachineCount(shared_ptr<GetAlarmMachineCountRequest> request);
  GetAppNetworkResponse getAppNetworkWithOptions(shared_ptr<GetAppNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAppNetworkResponse getAppNetwork(shared_ptr<GetAppNetworkRequest> request);
  GetAssetsPropertyDetailResponse getAssetsPropertyDetailWithOptions(shared_ptr<GetAssetsPropertyDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAssetsPropertyDetailResponse getAssetsPropertyDetail(shared_ptr<GetAssetsPropertyDetailRequest> request);
  GetAssetsPropertyItemResponse getAssetsPropertyItemWithOptions(shared_ptr<GetAssetsPropertyItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAssetsPropertyItemResponse getAssetsPropertyItem(shared_ptr<GetAssetsPropertyItemRequest> request);
  GetBackupStorageCountResponse getBackupStorageCountWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBackupStorageCountResponse getBackupStorageCount();
  GetCheckConfigResponse getCheckConfigWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCheckConfigResponse getCheckConfig();
  GetCheckDetailResponse getCheckDetailWithOptions(shared_ptr<GetCheckDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCheckDetailResponse getCheckDetail(shared_ptr<GetCheckDetailRequest> request);
  GetCheckProcessResponse getCheckProcessWithOptions(shared_ptr<GetCheckProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCheckProcessResponse getCheckProcess(shared_ptr<GetCheckProcessRequest> request);
  GetCheckRiskStatisticsResponse getCheckRiskStatisticsWithOptions(shared_ptr<GetCheckRiskStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCheckRiskStatisticsResponse getCheckRiskStatistics(shared_ptr<GetCheckRiskStatisticsRequest> request);
  GetCheckSummaryResponse getCheckSummaryWithOptions(shared_ptr<GetCheckSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCheckSummaryResponse getCheckSummary(shared_ptr<GetCheckSummaryRequest> request);
  GetClientUserDefineRuleResponse getClientUserDefineRuleWithOptions(shared_ptr<GetClientUserDefineRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClientUserDefineRuleResponse getClientUserDefineRule(shared_ptr<GetClientUserDefineRuleRequest> request);
  GetCloudAssetCriteriaResponse getCloudAssetCriteriaWithOptions(shared_ptr<GetCloudAssetCriteriaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCloudAssetCriteriaResponse getCloudAssetCriteria(shared_ptr<GetCloudAssetCriteriaRequest> request);
  GetCloudAssetDetailResponse getCloudAssetDetailWithOptions(shared_ptr<GetCloudAssetDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCloudAssetDetailResponse getCloudAssetDetail(shared_ptr<GetCloudAssetDetailRequest> request);
  GetCloudAssetSummaryResponse getCloudAssetSummaryWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCloudAssetSummaryResponse getCloudAssetSummary();
  GetClusterCheckItemWarningStatisticsResponse getClusterCheckItemWarningStatisticsWithOptions(shared_ptr<GetClusterCheckItemWarningStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterCheckItemWarningStatisticsResponse getClusterCheckItemWarningStatistics(shared_ptr<GetClusterCheckItemWarningStatisticsRequest> request);
  GetClusterRuleSummaryResponse getClusterRuleSummaryWithOptions(shared_ptr<GetClusterRuleSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterRuleSummaryResponse getClusterRuleSummary(shared_ptr<GetClusterRuleSummaryRequest> request);
  GetClusterSuspEventStatisticsResponse getClusterSuspEventStatisticsWithOptions(shared_ptr<GetClusterSuspEventStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterSuspEventStatisticsResponse getClusterSuspEventStatistics(shared_ptr<GetClusterSuspEventStatisticsRequest> request);
  GetFileDetectApiInvokeInfoResponse getFileDetectApiInvokeInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileDetectApiInvokeInfoResponse getFileDetectApiInvokeInfo();
  GetFileDetectResultResponse getFileDetectResultWithOptions(shared_ptr<GetFileDetectResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileDetectResultResponse getFileDetectResult(shared_ptr<GetFileDetectResultRequest> request);
  GetHoneypotNodeResponse getHoneypotNodeWithOptions(shared_ptr<GetHoneypotNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHoneypotNodeResponse getHoneypotNode(shared_ptr<GetHoneypotNodeRequest> request);
  GetHoneypotPresetResponse getHoneypotPresetWithOptions(shared_ptr<GetHoneypotPresetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHoneypotPresetResponse getHoneypotPreset(shared_ptr<GetHoneypotPresetRequest> request);
  GetHoneypotProbeResponse getHoneypotProbeWithOptions(shared_ptr<GetHoneypotProbeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHoneypotProbeResponse getHoneypotProbe(shared_ptr<GetHoneypotProbeRequest> request);
  GetImageScanNumInPeriodResponse getImageScanNumInPeriodWithOptions(shared_ptr<GetImageScanNumInPeriodRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetImageScanNumInPeriodResponse getImageScanNumInPeriod(shared_ptr<GetImageScanNumInPeriodRequest> request);
  GetInterceptionRuleDetailResponse getInterceptionRuleDetailWithOptions(shared_ptr<GetInterceptionRuleDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInterceptionRuleDetailResponse getInterceptionRuleDetail(shared_ptr<GetInterceptionRuleDetailRequest> request);
  GetInterceptionSummaryResponse getInterceptionSummaryWithOptions(shared_ptr<GetInterceptionSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInterceptionSummaryResponse getInterceptionSummary(shared_ptr<GetInterceptionSummaryRequest> request);
  GetInterceptionTargetDetailResponse getInterceptionTargetDetailWithOptions(shared_ptr<GetInterceptionTargetDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInterceptionTargetDetailResponse getInterceptionTargetDetail(shared_ptr<GetInterceptionTargetDetailRequest> request);
  GetLastOnceTaskInfoResponse getLastOnceTaskInfoWithOptions(shared_ptr<GetLastOnceTaskInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLastOnceTaskInfoResponse getLastOnceTaskInfo(shared_ptr<GetLastOnceTaskInfoRequest> request);
  GetModuleConfigResponse getModuleConfigWithOptions(shared_ptr<GetModuleConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetModuleConfigResponse getModuleConfig(shared_ptr<GetModuleConfigRequest> request);
  GetOnceTaskResultInfoResponse getOnceTaskResultInfoWithOptions(shared_ptr<GetOnceTaskResultInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOnceTaskResultInfoResponse getOnceTaskResultInfo(shared_ptr<GetOnceTaskResultInfoRequest> request);
  GetPropertyScheduleConfigResponse getPropertyScheduleConfigWithOptions(shared_ptr<GetPropertyScheduleConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPropertyScheduleConfigResponse getPropertyScheduleConfig(shared_ptr<GetPropertyScheduleConfigRequest> request);
  GetRulesCountResponse getRulesCountWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRulesCountResponse getRulesCount();
  GetSuspiciousStatisticsResponse getSuspiciousStatisticsWithOptions(shared_ptr<GetSuspiciousStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSuspiciousStatisticsResponse getSuspiciousStatistics(shared_ptr<GetSuspiciousStatisticsRequest> request);
  GetVulStatisticsResponse getVulStatisticsWithOptions(shared_ptr<GetVulStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVulStatisticsResponse getVulStatistics(shared_ptr<GetVulStatisticsRequest> request);
  GetVulWhitelistResponse getVulWhitelistWithOptions(shared_ptr<GetVulWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVulWhitelistResponse getVulWhitelist(shared_ptr<GetVulWhitelistRequest> request);
  HandleSecurityEventsResponse handleSecurityEventsWithOptions(shared_ptr<HandleSecurityEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HandleSecurityEventsResponse handleSecurityEvents(shared_ptr<HandleSecurityEventsRequest> request);
  HandleSimilarSecurityEventsResponse handleSimilarSecurityEventsWithOptions(shared_ptr<HandleSimilarSecurityEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HandleSimilarSecurityEventsResponse handleSimilarSecurityEvents(shared_ptr<HandleSimilarSecurityEventsRequest> request);
  IgnoreCheckItemsResponse ignoreCheckItemsWithOptions(shared_ptr<IgnoreCheckItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IgnoreCheckItemsResponse ignoreCheckItems(shared_ptr<IgnoreCheckItemsRequest> request);
  IgnoreHcCheckWarningsResponse ignoreHcCheckWarningsWithOptions(shared_ptr<IgnoreHcCheckWarningsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IgnoreHcCheckWarningsResponse ignoreHcCheckWarnings(shared_ptr<IgnoreHcCheckWarningsRequest> request);
  InstallBackupClientResponse installBackupClientWithOptions(shared_ptr<InstallBackupClientRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallBackupClientResponse installBackupClient(shared_ptr<InstallBackupClientRequest> request);
  InstallCloudMonitorResponse installCloudMonitorWithOptions(shared_ptr<InstallCloudMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallCloudMonitorResponse installCloudMonitor(shared_ptr<InstallCloudMonitorRequest> request);
  InstallPmAgentResponse installPmAgentWithOptions(shared_ptr<InstallPmAgentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallPmAgentResponse installPmAgent(shared_ptr<InstallPmAgentRequest> request);
  InstallUniBackupAgentResponse installUniBackupAgentWithOptions(shared_ptr<InstallUniBackupAgentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallUniBackupAgentResponse installUniBackupAgent(shared_ptr<InstallUniBackupAgentRequest> request);
  JoinWebLockProcessWhiteListResponse joinWebLockProcessWhiteListWithOptions(shared_ptr<JoinWebLockProcessWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinWebLockProcessWhiteListResponse joinWebLockProcessWhiteList(shared_ptr<JoinWebLockProcessWhiteListRequest> request);
  ListAvailableHoneypotResponse listAvailableHoneypotWithOptions(shared_ptr<ListAvailableHoneypotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAvailableHoneypotResponse listAvailableHoneypot(shared_ptr<ListAvailableHoneypotRequest> request);
  ListCheckInstanceResultResponse listCheckInstanceResultWithOptions(shared_ptr<ListCheckInstanceResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCheckInstanceResultResponse listCheckInstanceResult(shared_ptr<ListCheckInstanceResultRequest> request);
  ListCheckItemWarningMachineResponse listCheckItemWarningMachineWithOptions(shared_ptr<ListCheckItemWarningMachineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCheckItemWarningMachineResponse listCheckItemWarningMachine(shared_ptr<ListCheckItemWarningMachineRequest> request);
  ListCheckItemWarningSummaryResponse listCheckItemWarningSummaryWithOptions(shared_ptr<ListCheckItemWarningSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCheckItemWarningSummaryResponse listCheckItemWarningSummary(shared_ptr<ListCheckItemWarningSummaryRequest> request);
  ListCheckResultResponse listCheckResultWithOptions(shared_ptr<ListCheckResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCheckResultResponse listCheckResult(shared_ptr<ListCheckResultRequest> request);
  ListCheckStandardResponse listCheckStandardWithOptions(shared_ptr<ListCheckStandardRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCheckStandardResponse listCheckStandard(shared_ptr<ListCheckStandardRequest> request);
  ListClientUserDefineRuleTypesResponse listClientUserDefineRuleTypesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClientUserDefineRuleTypesResponse listClientUserDefineRuleTypes();
  ListClientUserDefineRulesResponse listClientUserDefineRulesWithOptions(shared_ptr<ListClientUserDefineRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClientUserDefineRulesResponse listClientUserDefineRules(shared_ptr<ListClientUserDefineRulesRequest> request);
  ListCloudAssetInstancesResponse listCloudAssetInstancesWithOptions(shared_ptr<ListCloudAssetInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCloudAssetInstancesResponse listCloudAssetInstances(shared_ptr<ListCloudAssetInstancesRequest> request);
  ListClusterCnnfStatusDetailResponse listClusterCnnfStatusDetailWithOptions(shared_ptr<ListClusterCnnfStatusDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterCnnfStatusDetailResponse listClusterCnnfStatusDetail(shared_ptr<ListClusterCnnfStatusDetailRequest> request);
  ListClusterInterceptionConfigResponse listClusterInterceptionConfigWithOptions(shared_ptr<ListClusterInterceptionConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClusterInterceptionConfigResponse listClusterInterceptionConfig(shared_ptr<ListClusterInterceptionConfigRequest> request);
  ListHoneypotResponse listHoneypotWithOptions(shared_ptr<ListHoneypotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHoneypotResponse listHoneypot(shared_ptr<ListHoneypotRequest> request);
  ListHoneypotAlarmEventsResponse listHoneypotAlarmEventsWithOptions(shared_ptr<ListHoneypotAlarmEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHoneypotAlarmEventsResponse listHoneypotAlarmEvents(shared_ptr<ListHoneypotAlarmEventsRequest> request);
  ListHoneypotNodeResponse listHoneypotNodeWithOptions(shared_ptr<ListHoneypotNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHoneypotNodeResponse listHoneypotNode(shared_ptr<ListHoneypotNodeRequest> request);
  ListHoneypotPresetResponse listHoneypotPresetWithOptions(shared_ptr<ListHoneypotPresetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHoneypotPresetResponse listHoneypotPreset(shared_ptr<ListHoneypotPresetRequest> request);
  ListHoneypotProbeResponse listHoneypotProbeWithOptions(shared_ptr<ListHoneypotProbeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHoneypotProbeResponse listHoneypotProbe(shared_ptr<ListHoneypotProbeRequest> request);
  ListImageRegistryRegionResponse listImageRegistryRegionWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListImageRegistryRegionResponse listImageRegistryRegion();
  ListImageRiskResponse listImageRiskWithOptions(shared_ptr<ListImageRiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListImageRiskResponse listImageRisk(shared_ptr<ListImageRiskRequest> request);
  ListInstanceCatalogResponse listInstanceCatalogWithOptions(shared_ptr<ListInstanceCatalogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceCatalogResponse listInstanceCatalog(shared_ptr<ListInstanceCatalogRequest> request);
  ListInterceptionHistoryResponse listInterceptionHistoryWithOptions(shared_ptr<ListInterceptionHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInterceptionHistoryResponse listInterceptionHistory(shared_ptr<ListInterceptionHistoryRequest> request);
  ListInterceptionRulePageResponse listInterceptionRulePageWithOptions(shared_ptr<ListInterceptionRulePageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInterceptionRulePageResponse listInterceptionRulePage(shared_ptr<ListInterceptionRulePageRequest> request);
  ListInterceptionTargetPageResponse listInterceptionTargetPageWithOptions(shared_ptr<ListInterceptionTargetPageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInterceptionTargetPageResponse listInterceptionTargetPage(shared_ptr<ListInterceptionTargetPageRequest> request);
  ListPluginForUuidResponse listPluginForUuidWithOptions(shared_ptr<ListPluginForUuidRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPluginForUuidResponse listPluginForUuid(shared_ptr<ListPluginForUuidRequest> request);
  ListPodRiskResponse listPodRiskWithOptions(shared_ptr<ListPodRiskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPodRiskResponse listPodRisk(shared_ptr<ListPodRiskRequest> request);
  ListPrivateRegistryListResponse listPrivateRegistryListWithOptions(shared_ptr<ListPrivateRegistryListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrivateRegistryListResponse listPrivateRegistryList(shared_ptr<ListPrivateRegistryListRequest> request);
  ListPrivateRegistryTypeResponse listPrivateRegistryTypeWithOptions(shared_ptr<ListPrivateRegistryTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrivateRegistryTypeResponse listPrivateRegistryType(shared_ptr<ListPrivateRegistryTypeRequest> request);
  ListRuleTargetAllResponse listRuleTargetAllWithOptions(shared_ptr<ListRuleTargetAllRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRuleTargetAllResponse listRuleTargetAll(shared_ptr<ListRuleTargetAllRequest> request);
  ListSystemAggregationRulesResponse listSystemAggregationRulesWithOptions(shared_ptr<ListSystemAggregationRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSystemAggregationRulesResponse listSystemAggregationRules(shared_ptr<ListSystemAggregationRulesRequest> request);
  ListSystemClientRuleTypesResponse listSystemClientRuleTypesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSystemClientRuleTypesResponse listSystemClientRuleTypes();
  ListSystemClientRulesResponse listSystemClientRulesWithOptions(shared_ptr<ListSystemClientRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSystemClientRulesResponse listSystemClientRules(shared_ptr<ListSystemClientRulesRequest> request);
  ListSystemRuleAggregationTypesResponse listSystemRuleAggregationTypesWithOptions(shared_ptr<ListSystemRuleAggregationTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSystemRuleAggregationTypesResponse listSystemRuleAggregationTypes(shared_ptr<ListSystemRuleAggregationTypesRequest> request);
  ListUninstallAegisMachinesResponse listUninstallAegisMachinesWithOptions(shared_ptr<ListUninstallAegisMachinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUninstallAegisMachinesResponse listUninstallAegisMachines(shared_ptr<ListUninstallAegisMachinesRequest> request);
  ListUuidsByWebPathResponse listUuidsByWebPathWithOptions(shared_ptr<ListUuidsByWebPathRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUuidsByWebPathResponse listUuidsByWebPath(shared_ptr<ListUuidsByWebPathRequest> request);
  ListVulAutoRepairConfigResponse listVulAutoRepairConfigWithOptions(shared_ptr<ListVulAutoRepairConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVulAutoRepairConfigResponse listVulAutoRepairConfig(shared_ptr<ListVulAutoRepairConfigRequest> request);
  ModifyAccessKeyLeakDealResponse modifyAccessKeyLeakDealWithOptions(shared_ptr<ModifyAccessKeyLeakDealRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAccessKeyLeakDealResponse modifyAccessKeyLeakDeal(shared_ptr<ModifyAccessKeyLeakDealRequest> request);
  ModifyAntiBruteForceRuleResponse modifyAntiBruteForceRuleWithOptions(shared_ptr<ModifyAntiBruteForceRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAntiBruteForceRuleResponse modifyAntiBruteForceRule(shared_ptr<ModifyAntiBruteForceRuleRequest> request);
  ModifyAppVulScanCycleResponse modifyAppVulScanCycleWithOptions(shared_ptr<ModifyAppVulScanCycleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAppVulScanCycleResponse modifyAppVulScanCycle(shared_ptr<ModifyAppVulScanCycleRequest> request);
  ModifyAssetGroupResponse modifyAssetGroupWithOptions(shared_ptr<ModifyAssetGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAssetGroupResponse modifyAssetGroup(shared_ptr<ModifyAssetGroupRequest> request);
  ModifyAssetImportantResponse modifyAssetImportantWithOptions(shared_ptr<ModifyAssetImportantRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAssetImportantResponse modifyAssetImportant(shared_ptr<ModifyAssetImportantRequest> request);
  ModifyAutoDelConfigResponse modifyAutoDelConfigWithOptions(shared_ptr<ModifyAutoDelConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAutoDelConfigResponse modifyAutoDelConfig(shared_ptr<ModifyAutoDelConfigRequest> request);
  ModifyBackupPolicyResponse modifyBackupPolicyWithOptions(shared_ptr<ModifyBackupPolicyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBackupPolicyResponse modifyBackupPolicy(shared_ptr<ModifyBackupPolicyRequest> request);
  ModifyBackupPolicyStatusResponse modifyBackupPolicyStatusWithOptions(shared_ptr<ModifyBackupPolicyStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBackupPolicyStatusResponse modifyBackupPolicyStatus(shared_ptr<ModifyBackupPolicyStatusRequest> request);
  ModifyClearLogstoreStorageResponse modifyClearLogstoreStorageWithOptions(shared_ptr<ModifyClearLogstoreStorageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClearLogstoreStorageResponse modifyClearLogstoreStorage(shared_ptr<ModifyClearLogstoreStorageRequest> request);
  ModifyClientConfSetupResponse modifyClientConfSetupWithOptions(shared_ptr<ModifyClientConfSetupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClientConfSetupResponse modifyClientConfSetup(shared_ptr<ModifyClientConfSetupRequest> request);
  ModifyClientConfStrategyResponse modifyClientConfStrategyWithOptions(shared_ptr<ModifyClientConfStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClientConfStrategyResponse modifyClientConfStrategy(shared_ptr<ModifyClientConfStrategyRequest> request);
  ModifyClientUserDefineRuleResponse modifyClientUserDefineRuleWithOptions(shared_ptr<ModifyClientUserDefineRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClientUserDefineRuleResponse modifyClientUserDefineRule(shared_ptr<ModifyClientUserDefineRuleRequest> request);
  ModifyClusterCnnfStatusUserConfirmResponse modifyClusterCnnfStatusUserConfirmWithOptions(shared_ptr<ModifyClusterCnnfStatusUserConfirmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClusterCnnfStatusUserConfirmResponse modifyClusterCnnfStatusUserConfirm(shared_ptr<ModifyClusterCnnfStatusUserConfirmRequest> request);
  ModifyConcernNecessityResponse modifyConcernNecessityWithOptions(shared_ptr<ModifyConcernNecessityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyConcernNecessityResponse modifyConcernNecessity(shared_ptr<ModifyConcernNecessityRequest> request);
  ModifyCreateVulWhitelistResponse modifyCreateVulWhitelistWithOptions(shared_ptr<ModifyCreateVulWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCreateVulWhitelistResponse modifyCreateVulWhitelist(shared_ptr<ModifyCreateVulWhitelistRequest> request);
  ModifyCustomBlockRecordResponse modifyCustomBlockRecordWithOptions(shared_ptr<ModifyCustomBlockRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCustomBlockRecordResponse modifyCustomBlockRecord(shared_ptr<ModifyCustomBlockRecordRequest> request);
  ModifyCycleTaskResponse modifyCycleTaskWithOptions(shared_ptr<ModifyCycleTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCycleTaskResponse modifyCycleTask(shared_ptr<ModifyCycleTaskRequest> request);
  ModifyEmgVulSubmitResponse modifyEmgVulSubmitWithOptions(shared_ptr<ModifyEmgVulSubmitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyEmgVulSubmitResponse modifyEmgVulSubmit(shared_ptr<ModifyEmgVulSubmitRequest> request);
  ModifyGroupPropertyResponse modifyGroupPropertyWithOptions(shared_ptr<ModifyGroupPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyGroupPropertyResponse modifyGroupProperty(shared_ptr<ModifyGroupPropertyRequest> request);
  ModifyInstanceAntiBruteForceRuleResponse modifyInstanceAntiBruteForceRuleWithOptions(shared_ptr<ModifyInstanceAntiBruteForceRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAntiBruteForceRuleResponse modifyInstanceAntiBruteForceRule(shared_ptr<ModifyInstanceAntiBruteForceRuleRequest> request);
  ModifyInterceptionRuleResponse modifyInterceptionRuleWithOptions(shared_ptr<ModifyInterceptionRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInterceptionRuleResponse modifyInterceptionRule(shared_ptr<ModifyInterceptionRuleRequest> request);
  ModifyInterceptionRuleSwitchResponse modifyInterceptionRuleSwitchWithOptions(shared_ptr<ModifyInterceptionRuleSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInterceptionRuleSwitchResponse modifyInterceptionRuleSwitch(shared_ptr<ModifyInterceptionRuleSwitchRequest> request);
  ModifyInterceptionTargetResponse modifyInterceptionTargetWithOptions(shared_ptr<ModifyInterceptionTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInterceptionTargetResponse modifyInterceptionTarget(shared_ptr<ModifyInterceptionTargetRequest> request);
  ModifyLogMetaStatusResponse modifyLogMetaStatusWithOptions(shared_ptr<ModifyLogMetaStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLogMetaStatusResponse modifyLogMetaStatus(shared_ptr<ModifyLogMetaStatusRequest> request);
  ModifyLoginBaseConfigResponse modifyLoginBaseConfigWithOptions(shared_ptr<ModifyLoginBaseConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLoginBaseConfigResponse modifyLoginBaseConfig(shared_ptr<ModifyLoginBaseConfigRequest> request);
  ModifyLoginSwitchConfigResponse modifyLoginSwitchConfigWithOptions(shared_ptr<ModifyLoginSwitchConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLoginSwitchConfigResponse modifyLoginSwitchConfig(shared_ptr<ModifyLoginSwitchConfigRequest> request);
  ModifyNoticeConfigResponse modifyNoticeConfigWithOptions(shared_ptr<ModifyNoticeConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyNoticeConfigResponse modifyNoticeConfig(shared_ptr<ModifyNoticeConfigRequest> request);
  ModifyOpenLogShipperResponse modifyOpenLogShipperWithOptions(shared_ptr<ModifyOpenLogShipperRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOpenLogShipperResponse modifyOpenLogShipper(shared_ptr<ModifyOpenLogShipperRequest> request);
  ModifyOperateVulResponse modifyOperateVulWithOptions(shared_ptr<ModifyOperateVulRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyOperateVulResponse modifyOperateVul(shared_ptr<ModifyOperateVulRequest> request);
  ModifyPropertyScheduleConfigResponse modifyPropertyScheduleConfigWithOptions(shared_ptr<ModifyPropertyScheduleConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPropertyScheduleConfigResponse modifyPropertyScheduleConfig(shared_ptr<ModifyPropertyScheduleConfigRequest> request);
  ModifyPushAllTaskResponse modifyPushAllTaskWithOptions(shared_ptr<ModifyPushAllTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPushAllTaskResponse modifyPushAllTask(shared_ptr<ModifyPushAllTaskRequest> request);
  ModifyRiskCheckStatusResponse modifyRiskCheckStatusWithOptions(shared_ptr<ModifyRiskCheckStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRiskCheckStatusResponse modifyRiskCheckStatus(shared_ptr<ModifyRiskCheckStatusRequest> request);
  ModifyRiskSingleResultStatusResponse modifyRiskSingleResultStatusWithOptions(shared_ptr<ModifyRiskSingleResultStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRiskSingleResultStatusResponse modifyRiskSingleResultStatus(shared_ptr<ModifyRiskSingleResultStatusRequest> request);
  ModifySecurityCheckScheduleConfigResponse modifySecurityCheckScheduleConfigWithOptions(shared_ptr<ModifySecurityCheckScheduleConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityCheckScheduleConfigResponse modifySecurityCheckScheduleConfig(shared_ptr<ModifySecurityCheckScheduleConfigRequest> request);
  ModifySecurityEventMarkMissIndividuallyResponse modifySecurityEventMarkMissIndividuallyWithOptions(shared_ptr<ModifySecurityEventMarkMissIndividuallyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityEventMarkMissIndividuallyResponse modifySecurityEventMarkMissIndividually(shared_ptr<ModifySecurityEventMarkMissIndividuallyRequest> request);
  ModifyStartVulScanResponse modifyStartVulScanWithOptions(shared_ptr<ModifyStartVulScanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStartVulScanResponse modifyStartVulScan(shared_ptr<ModifyStartVulScanRequest> request);
  ModifyStrategyResponse modifyStrategyWithOptions(shared_ptr<ModifyStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStrategyResponse modifyStrategy(shared_ptr<ModifyStrategyRequest> request);
  ModifyStrategyTargetResponse modifyStrategyTargetWithOptions(shared_ptr<ModifyStrategyTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyStrategyTargetResponse modifyStrategyTarget(shared_ptr<ModifyStrategyTargetRequest> request);
  ModifyTagWithUuidResponse modifyTagWithUuidWithOptions(shared_ptr<ModifyTagWithUuidRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTagWithUuidResponse modifyTagWithUuid(shared_ptr<ModifyTagWithUuidRequest> request);
  ModifyUniBackupPolicyResponse modifyUniBackupPolicyWithOptions(shared_ptr<ModifyUniBackupPolicyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUniBackupPolicyResponse modifyUniBackupPolicy(shared_ptr<ModifyUniBackupPolicyRequest> request);
  ModifyVpcHoneyPotResponse modifyVpcHoneyPotWithOptions(shared_ptr<ModifyVpcHoneyPotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpcHoneyPotResponse modifyVpcHoneyPot(shared_ptr<ModifyVpcHoneyPotRequest> request);
  ModifyVulConfigResponse modifyVulConfigWithOptions(shared_ptr<ModifyVulConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVulConfigResponse modifyVulConfig(shared_ptr<ModifyVulConfigRequest> request);
  ModifyVulTargetResponse modifyVulTargetWithOptions(shared_ptr<ModifyVulTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVulTargetResponse modifyVulTarget(shared_ptr<ModifyVulTargetRequest> request);
  ModifyVulTargetConfigResponse modifyVulTargetConfigWithOptions(shared_ptr<ModifyVulTargetConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVulTargetConfigResponse modifyVulTargetConfig(shared_ptr<ModifyVulTargetConfigRequest> request);
  ModifyVulWhitelistTargetResponse modifyVulWhitelistTargetWithOptions(shared_ptr<ModifyVulWhitelistTargetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVulWhitelistTargetResponse modifyVulWhitelistTarget(shared_ptr<ModifyVulWhitelistTargetRequest> request);
  ModifyWebLockCreateConfigResponse modifyWebLockCreateConfigWithOptions(shared_ptr<ModifyWebLockCreateConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockCreateConfigResponse modifyWebLockCreateConfig(shared_ptr<ModifyWebLockCreateConfigRequest> request);
  ModifyWebLockDeleteConfigResponse modifyWebLockDeleteConfigWithOptions(shared_ptr<ModifyWebLockDeleteConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockDeleteConfigResponse modifyWebLockDeleteConfig(shared_ptr<ModifyWebLockDeleteConfigRequest> request);
  ModifyWebLockProcessStatusResponse modifyWebLockProcessStatusWithOptions(shared_ptr<ModifyWebLockProcessStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockProcessStatusResponse modifyWebLockProcessStatus(shared_ptr<ModifyWebLockProcessStatusRequest> request);
  ModifyWebLockStartResponse modifyWebLockStartWithOptions(shared_ptr<ModifyWebLockStartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockStartResponse modifyWebLockStart(shared_ptr<ModifyWebLockStartRequest> request);
  ModifyWebLockStatusResponse modifyWebLockStatusWithOptions(shared_ptr<ModifyWebLockStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockStatusResponse modifyWebLockStatus(shared_ptr<ModifyWebLockStatusRequest> request);
  ModifyWebLockUnbindResponse modifyWebLockUnbindWithOptions(shared_ptr<ModifyWebLockUnbindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockUnbindResponse modifyWebLockUnbind(shared_ptr<ModifyWebLockUnbindRequest> request);
  ModifyWebLockUpdateConfigResponse modifyWebLockUpdateConfigWithOptions(shared_ptr<ModifyWebLockUpdateConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebLockUpdateConfigResponse modifyWebLockUpdateConfig(shared_ptr<ModifyWebLockUpdateConfigRequest> request);
  ModifyWebPathResponse modifyWebPathWithOptions(shared_ptr<ModifyWebPathRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWebPathResponse modifyWebPath(shared_ptr<ModifyWebPathRequest> request);
  OpenSensitiveFileScanResponse openSensitiveFileScanWithOptions(shared_ptr<OpenSensitiveFileScanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenSensitiveFileScanResponse openSensitiveFileScan(shared_ptr<OpenSensitiveFileScanRequest> request);
  OperateAgentClientInstallResponse operateAgentClientInstallWithOptions(shared_ptr<OperateAgentClientInstallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateAgentClientInstallResponse operateAgentClientInstall(shared_ptr<OperateAgentClientInstallRequest> request);
  OperateCommonOverallConfigResponse operateCommonOverallConfigWithOptions(shared_ptr<OperateCommonOverallConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateCommonOverallConfigResponse operateCommonOverallConfig(shared_ptr<OperateCommonOverallConfigRequest> request);
  OperateCommonTargetConfigResponse operateCommonTargetConfigWithOptions(shared_ptr<OperateCommonTargetConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateCommonTargetConfigResponse operateCommonTargetConfig(shared_ptr<OperateCommonTargetConfigRequest> request);
  OperateImageBaselineWhitelistResponse operateImageBaselineWhitelistWithOptions(shared_ptr<OperateImageBaselineWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateImageBaselineWhitelistResponse operateImageBaselineWhitelist(shared_ptr<OperateImageBaselineWhitelistRequest> request);
  OperateImageVulResponse operateImageVulWithOptions(shared_ptr<OperateImageVulRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateImageVulResponse operateImageVul(shared_ptr<OperateImageVulRequest> request);
  OperateSuspiciousOverallConfigResponse operateSuspiciousOverallConfigWithOptions(shared_ptr<OperateSuspiciousOverallConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateSuspiciousOverallConfigResponse operateSuspiciousOverallConfig(shared_ptr<OperateSuspiciousOverallConfigRequest> request);
  OperateSuspiciousTargetConfigResponse operateSuspiciousTargetConfigWithOptions(shared_ptr<OperateSuspiciousTargetConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateSuspiciousTargetConfigResponse operateSuspiciousTargetConfig(shared_ptr<OperateSuspiciousTargetConfigRequest> request);
  OperateVirusEventsResponse operateVirusEventsWithOptions(shared_ptr<OperateVirusEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateVirusEventsResponse operateVirusEvents(shared_ptr<OperateVirusEventsRequest> request);
  OperateVulsResponse operateVulsWithOptions(shared_ptr<OperateVulsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateVulsResponse operateVuls(shared_ptr<OperateVulsRequest> request);
  OperateWebLockFileEventsResponse operateWebLockFileEventsWithOptions(shared_ptr<OperateWebLockFileEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateWebLockFileEventsResponse operateWebLockFileEvents(shared_ptr<OperateWebLockFileEventsRequest> request);
  OperationCancelIgnoreSuspEventResponse operationCancelIgnoreSuspEventWithOptions(shared_ptr<OperationCancelIgnoreSuspEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperationCancelIgnoreSuspEventResponse operationCancelIgnoreSuspEvent(shared_ptr<OperationCancelIgnoreSuspEventRequest> request);
  OperationSuspEventsResponse operationSuspEventsWithOptions(shared_ptr<OperationSuspEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperationSuspEventsResponse operationSuspEvents(shared_ptr<OperationSuspEventsRequest> request);
  PageImageRegistryResponse pageImageRegistryWithOptions(shared_ptr<PageImageRegistryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PageImageRegistryResponse pageImageRegistry(shared_ptr<PageImageRegistryRequest> request);
  PauseClientResponse pauseClientWithOptions(shared_ptr<PauseClientRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PauseClientResponse pauseClient(shared_ptr<PauseClientRequest> request);
  PublicCreateImageScanTaskResponse publicCreateImageScanTaskWithOptions(shared_ptr<PublicCreateImageScanTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublicCreateImageScanTaskResponse publicCreateImageScanTask(shared_ptr<PublicCreateImageScanTaskRequest> request);
  PublicPreCheckImageScanTaskResponse publicPreCheckImageScanTaskWithOptions(shared_ptr<PublicPreCheckImageScanTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublicPreCheckImageScanTaskResponse publicPreCheckImageScanTask(shared_ptr<PublicPreCheckImageScanTaskRequest> request);
  PublicSyncAndCreateImageScanTaskResponse publicSyncAndCreateImageScanTaskWithOptions(shared_ptr<PublicSyncAndCreateImageScanTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublicSyncAndCreateImageScanTaskResponse publicSyncAndCreateImageScanTask(shared_ptr<PublicSyncAndCreateImageScanTaskRequest> request);
  QueryDiscoverDatabaseResponse queryDiscoverDatabaseWithOptions(shared_ptr<QueryDiscoverDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDiscoverDatabaseResponse queryDiscoverDatabase(shared_ptr<QueryDiscoverDatabaseRequest> request);
  QueryGroupIdByGroupNameResponse queryGroupIdByGroupNameWithOptions(shared_ptr<QueryGroupIdByGroupNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryGroupIdByGroupNameResponse queryGroupIdByGroupName(shared_ptr<QueryGroupIdByGroupNameRequest> request);
  QueryGroupedSecurityEventMarkMissListResponse queryGroupedSecurityEventMarkMissListWithOptions(shared_ptr<QueryGroupedSecurityEventMarkMissListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryGroupedSecurityEventMarkMissListResponse queryGroupedSecurityEventMarkMissList(shared_ptr<QueryGroupedSecurityEventMarkMissListRequest> request);
  QueryJenkinsImageRegistryPersistenceDayResponse queryJenkinsImageRegistryPersistenceDayWithOptions(shared_ptr<QueryJenkinsImageRegistryPersistenceDayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryJenkinsImageRegistryPersistenceDayResponse queryJenkinsImageRegistryPersistenceDay(shared_ptr<QueryJenkinsImageRegistryPersistenceDayRequest> request);
  QueryPreCheckDatabaseResponse queryPreCheckDatabaseWithOptions(shared_ptr<QueryPreCheckDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPreCheckDatabaseResponse queryPreCheckDatabase(shared_ptr<QueryPreCheckDatabaseRequest> request);
  RebootMachineResponse rebootMachineWithOptions(shared_ptr<RebootMachineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootMachineResponse rebootMachine(shared_ptr<RebootMachineRequest> request);
  RefreshAssetsResponse refreshAssetsWithOptions(shared_ptr<RefreshAssetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshAssetsResponse refreshAssets(shared_ptr<RefreshAssetsRequest> request);
  RefreshContainerAssetsResponse refreshContainerAssetsWithOptions(shared_ptr<RefreshContainerAssetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshContainerAssetsResponse refreshContainerAssets(shared_ptr<RefreshContainerAssetsRequest> request);
  RemoveCheckInstanceResultWhiteListResponse removeCheckInstanceResultWhiteListWithOptions(shared_ptr<RemoveCheckInstanceResultWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveCheckInstanceResultWhiteListResponse removeCheckInstanceResultWhiteList(shared_ptr<RemoveCheckInstanceResultWhiteListRequest> request);
  RemoveCheckResultWhiteListResponse removeCheckResultWhiteListWithOptions(shared_ptr<RemoveCheckResultWhiteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveCheckResultWhiteListResponse removeCheckResultWhiteList(shared_ptr<RemoveCheckResultWhiteListRequest> request);
  RollbackSuspEventQuaraFileResponse rollbackSuspEventQuaraFileWithOptions(shared_ptr<RollbackSuspEventQuaraFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackSuspEventQuaraFileResponse rollbackSuspEventQuaraFile(shared_ptr<RollbackSuspEventQuaraFileRequest> request);
  SasInstallCodeResponse sasInstallCodeWithOptions(shared_ptr<SasInstallCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SasInstallCodeResponse sasInstallCode(shared_ptr<SasInstallCodeRequest> request);
  SaveImageBaselineStrategyResponse saveImageBaselineStrategyWithOptions(shared_ptr<SaveImageBaselineStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveImageBaselineStrategyResponse saveImageBaselineStrategy(shared_ptr<SaveImageBaselineStrategyRequest> request);
  SaveSuspEventUserSettingResponse saveSuspEventUserSettingWithOptions(shared_ptr<SaveSuspEventUserSettingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveSuspEventUserSettingResponse saveSuspEventUserSetting(shared_ptr<SaveSuspEventUserSettingRequest> request);
  SetClusterInterceptionConfigResponse setClusterInterceptionConfigWithOptions(shared_ptr<SetClusterInterceptionConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetClusterInterceptionConfigResponse setClusterInterceptionConfig(shared_ptr<SetClusterInterceptionConfigRequest> request);
  SetRegistryScanDayNumResponse setRegistryScanDayNumWithOptions(shared_ptr<SetRegistryScanDayNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetRegistryScanDayNumResponse setRegistryScanDayNum(shared_ptr<SetRegistryScanDayNumRequest> request);
  StartBaselineSecurityCheckResponse startBaselineSecurityCheckWithOptions(shared_ptr<StartBaselineSecurityCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartBaselineSecurityCheckResponse startBaselineSecurityCheck(shared_ptr<StartBaselineSecurityCheckRequest> request);
  StartDiscoverDatabaseTaskResponse startDiscoverDatabaseTaskWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDiscoverDatabaseTaskResponse startDiscoverDatabaseTask();
  StartPreCheckDatabaseResponse startPreCheckDatabaseWithOptions(shared_ptr<StartPreCheckDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartPreCheckDatabaseResponse startPreCheckDatabase(shared_ptr<StartPreCheckDatabaseRequest> request);
  StartVirusScanTaskResponse startVirusScanTaskWithOptions(shared_ptr<StartVirusScanTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartVirusScanTaskResponse startVirusScanTask(shared_ptr<StartVirusScanTaskRequest> request);
  SubmitCheckResponse submitCheckWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitCheckResponse submitCheck();
  UnbindAegisResponse unbindAegisWithOptions(shared_ptr<UnbindAegisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindAegisResponse unbindAegis(shared_ptr<UnbindAegisRequest> request);
  UninstallBackupClientResponse uninstallBackupClientWithOptions(shared_ptr<UninstallBackupClientRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallBackupClientResponse uninstallBackupClient(shared_ptr<UninstallBackupClientRequest> request);
  UninstallUniBackupAgentResponse uninstallUniBackupAgentWithOptions(shared_ptr<UninstallUniBackupAgentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallUniBackupAgentResponse uninstallUniBackupAgent(shared_ptr<UninstallUniBackupAgentRequest> request);
  UpdateHoneypotResponse updateHoneypotWithOptions(shared_ptr<UpdateHoneypotRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHoneypotResponse updateHoneypot(shared_ptr<UpdateHoneypotRequest> request);
  UpdateHoneypotNodeResponse updateHoneypotNodeWithOptions(shared_ptr<UpdateHoneypotNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHoneypotNodeResponse updateHoneypotNode(shared_ptr<UpdateHoneypotNodeRequest> request);
  UpdateHoneypotPresetResponse updateHoneypotPresetWithOptions(shared_ptr<UpdateHoneypotPresetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHoneypotPresetResponse updateHoneypotPreset(shared_ptr<UpdateHoneypotPresetRequest> request);
  UpdateHoneypotProbeResponse updateHoneypotProbeWithOptions(shared_ptr<UpdateHoneypotProbeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHoneypotProbeResponse updateHoneypotProbe(shared_ptr<UpdateHoneypotProbeRequest> request);
  UpdateJenkinsImageRegistryNameResponse updateJenkinsImageRegistryNameWithOptions(shared_ptr<UpdateJenkinsImageRegistryNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateJenkinsImageRegistryNameResponse updateJenkinsImageRegistryName(shared_ptr<UpdateJenkinsImageRegistryNameRequest> request);
  UpdateJenkinsImageRegistryPersistenceDayResponse updateJenkinsImageRegistryPersistenceDayWithOptions(shared_ptr<UpdateJenkinsImageRegistryPersistenceDayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateJenkinsImageRegistryPersistenceDayResponse updateJenkinsImageRegistryPersistenceDay(shared_ptr<UpdateJenkinsImageRegistryPersistenceDayRequest> request);
  UpgradeBackupPolicyVersionResponse upgradeBackupPolicyVersionWithOptions(shared_ptr<UpgradeBackupPolicyVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeBackupPolicyVersionResponse upgradeBackupPolicyVersion(shared_ptr<UpgradeBackupPolicyVersionRequest> request);
  ValidateHcWarningsResponse validateHcWarningsWithOptions(shared_ptr<ValidateHcWarningsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidateHcWarningsResponse validateHcWarnings(shared_ptr<ValidateHcWarningsRequest> request);
  VerifyCheckInstanceResultResponse verifyCheckInstanceResultWithOptions(shared_ptr<VerifyCheckInstanceResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyCheckInstanceResultResponse verifyCheckInstanceResult(shared_ptr<VerifyCheckInstanceResultRequest> request);
  VerifyCheckResultResponse verifyCheckResultWithOptions(shared_ptr<VerifyCheckResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyCheckResultResponse verifyCheckResult(shared_ptr<VerifyCheckResultRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Sas20181203

#endif
