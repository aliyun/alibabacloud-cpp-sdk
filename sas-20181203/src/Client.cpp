#include <darabonba/Core.hpp>
#include <alibabacloud/Sas20181203.hpp>
#include <alibabacloud/Utils.hpp>
#include <alibabacloud/Openapi.hpp>
#include <map>
#include <darabonba/Runtime.hpp>
using namespace std;
using namespace Darabonba;
using json = nlohmann::json;
using namespace AlibabaCloud::OpenApi;
using namespace AlibabaCloud::Sas20181203::Models;
using OpenApiClient = AlibabaCloud::OpenApi::Client;
using namespace AlibabaCloud::OpenApi::Utils::Models;
namespace AlibabaCloud
{
namespace Sas20181203
{

AlibabaCloud::Sas20181203::Client::Client(Config &config): OpenApiClient(config){
  this->_endpointRule = "regional";
  this->_endpointMap = json({
    {"cn-qingdao" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-beijing" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-zhangjiakou" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-huhehaote" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-wulanchabu" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-hangzhou" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-shanghai" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-nanjing" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-fuzhou" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-shenzhen" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-heyuan" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-guangzhou" , "tds.cn-shanghai.aliyuncs.com"},
    {"ap-southeast-2" , "tds.ap-southeast-1.aliyuncs.com"},
    {"ap-southeast-6" , "tds.ap-southeast-1.aliyuncs.com"},
    {"ap-northeast-2" , "tds.ap-southeast-1.aliyuncs.com"},
    {"ap-southeast-3" , "tds.ap-southeast-1.aliyuncs.com"},
    {"ap-northeast-1" , "tds.ap-southeast-1.aliyuncs.com"},
    {"ap-southeast-7" , "tds.ap-southeast-1.aliyuncs.com"},
    {"cn-chengdu" , "tds.cn-shanghai.aliyuncs.com"},
    {"ap-southeast-1" , "tds.ap-southeast-1.aliyuncs.com"},
    {"ap-southeast-5" , "tds.ap-southeast-1.aliyuncs.com"},
    {"cn-hongkong" , "tds.cn-shanghai.aliyuncs.com"},
    {"eu-central-1" , "tds.ap-southeast-1.aliyuncs.com"},
    {"us-east-1" , "tds.ap-southeast-1.aliyuncs.com"},
    {"us-west-1" , "tds.ap-southeast-1.aliyuncs.com"},
    {"eu-west-1" , "tds.ap-southeast-1.aliyuncs.com"},
    {"me-east-1" , "tds.ap-southeast-1.aliyuncs.com"},
    {"me-central-1" , "tds.ap-southeast-1.aliyuncs.com"},
    {"ap-south-1" , "tds.ap-southeast-1.aliyuncs.com"},
    {"cn-beijing-finance-1" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-hangzhou-finance" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-shanghai-finance-1" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-shenzhen-finance-1" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-heyuan-acdr-1" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-north-2-gov-1" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-qingdao-acdr-ut-1" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-shanghai-mybk" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-wuhan-lr" , "tds.cn-shanghai.aliyuncs.com"},
    {"cn-zhengzhou-jva" , "tds.cn-shanghai.aliyuncs.com"}
  }).get<map<string, string>>();
  checkConfig(config);
  this->_endpoint = getEndpoint("sas", _regionId, _endpointRule, _network, _suffix, _endpointMap, _endpoint);
}


string Client::getEndpoint(const string &productId, const string &regionId, const string &endpointRule, const string &network, const string &suffix, const map<string, string> &endpointMap, const string &endpoint) {
  if (!Darabonba::isNull(endpoint)) {
    return endpoint;
  }

  if (!Darabonba::isNull(endpointMap) && !Darabonba::isNull(endpointMap.at(regionId))) {
    return endpointMap.at(regionId);
  }

  return Utils::Utils::getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

/**
 * @summary Select an operation for assets.
 *
 * @param request AddAssetSelectionCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddAssetSelectionCriteriaResponse
 */
AddAssetSelectionCriteriaResponse Client::addAssetSelectionCriteriaWithOptions(const AddAssetSelectionCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCriteriaOperation()) {
    query["CriteriaOperation"] = request.criteriaOperation();
  }

  if (!!request.hasSelectionKey()) {
    query["SelectionKey"] = request.selectionKey();
  }

  if (!!request.hasTargetOperationList()) {
    query["TargetOperationList"] = request.targetOperationList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddAssetSelectionCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddAssetSelectionCriteriaResponse>();
}

/**
 * @summary Select an operation for assets.
 *
 * @param request AddAssetSelectionCriteriaRequest
 * @return AddAssetSelectionCriteriaResponse
 */
AddAssetSelectionCriteriaResponse Client::addAssetSelectionCriteria(const AddAssetSelectionCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addAssetSelectionCriteriaWithOptions(request, runtime);
}

/**
 * @summary Creates a whitelist rule for a baseline check item.
 *
 * @param request AddBaselineCheckWhiteRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddBaselineCheckWhiteRecordResponse
 */
AddBaselineCheckWhiteRecordResponse Client::addBaselineCheckWhiteRecordWithOptions(const AddBaselineCheckWhiteRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasReason()) {
    query["Reason"] = request.reason();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddBaselineCheckWhiteRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddBaselineCheckWhiteRecordResponse>();
}

/**
 * @summary Creates a whitelist rule for a baseline check item.
 *
 * @param request AddBaselineCheckWhiteRecordRequest
 * @return AddBaselineCheckWhiteRecordResponse
 */
AddBaselineCheckWhiteRecordResponse Client::addBaselineCheckWhiteRecord(const AddBaselineCheckWhiteRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addBaselineCheckWhiteRecordWithOptions(request, runtime);
}

/**
 * @summary Adds instances on which risks are detected based on check items of the configuration assessment feature to a whitelist.
 *
 * @param request AddCheckInstanceResultWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCheckInstanceResultWhiteListResponse
 */
AddCheckInstanceResultWhiteListResponse Client::addCheckInstanceResultWhiteListWithOptions(const AddCheckInstanceResultWhiteListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckGroupId()) {
    query["CheckGroupId"] = request.checkGroupId();
  }

  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  if (!!request.hasInstanceList()) {
    query["InstanceList"] = request.instanceList();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddCheckInstanceResultWhiteList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddCheckInstanceResultWhiteListResponse>();
}

/**
 * @summary Adds instances on which risks are detected based on check items of the configuration assessment feature to a whitelist.
 *
 * @param request AddCheckInstanceResultWhiteListRequest
 * @return AddCheckInstanceResultWhiteListResponse
 */
AddCheckInstanceResultWhiteListResponse Client::addCheckInstanceResultWhiteList(const AddCheckInstanceResultWhiteListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addCheckInstanceResultWhiteListWithOptions(request, runtime);
}

/**
 * @summary Adds the check items of the configuration assessment feature to the whitelist.
 *
 * @param request AddCheckResultWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCheckResultWhiteListResponse
 */
AddCheckResultWhiteListResponse Client::addCheckResultWhiteListWithOptions(const AddCheckResultWhiteListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckIds()) {
    query["CheckIds"] = request.checkIds();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddCheckResultWhiteList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddCheckResultWhiteListResponse>();
}

/**
 * @summary Adds the check items of the configuration assessment feature to the whitelist.
 *
 * @param request AddCheckResultWhiteListRequest
 * @return AddCheckResultWhiteListResponse
 */
AddCheckResultWhiteListResponse Client::addCheckResultWhiteList(const AddCheckResultWhiteListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addCheckResultWhiteListWithOptions(request, runtime);
}

/**
 * @summary Creates a custom defense rule.
 *
 * @param request AddClientUserDefineRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddClientUserDefineRuleResponse
 */
AddClientUserDefineRuleResponse Client::addClientUserDefineRuleWithOptions(const AddClientUserDefineRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasActionType()) {
    query["ActionType"] = request.actionType();
  }

  if (!!request.hasCmdline()) {
    query["Cmdline"] = request.cmdline();
  }

  if (!!request.hasDomain()) {
    query["Domain"] = request.domain();
  }

  if (!!request.hasFilePath()) {
    query["FilePath"] = request.filePath();
  }

  if (!!request.hasIP()) {
    query["IP"] = request.IP();
  }

  if (!!request.hasMd5List()) {
    query["Md5List"] = request.md5List();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNewFilePath()) {
    query["NewFilePath"] = request.newFilePath();
  }

  if (!!request.hasParentCmdline()) {
    query["ParentCmdline"] = request.parentCmdline();
  }

  if (!!request.hasParentProcPath()) {
    query["ParentProcPath"] = request.parentProcPath();
  }

  if (!!request.hasPlatform()) {
    query["Platform"] = request.platform();
  }

  if (!!request.hasPort()) {
    query["Port"] = request.port();
  }

  if (!!request.hasPortStr()) {
    query["PortStr"] = request.portStr();
  }

  if (!!request.hasProcPath()) {
    query["ProcPath"] = request.procPath();
  }

  if (!!request.hasRegistryContent()) {
    query["RegistryContent"] = request.registryContent();
  }

  if (!!request.hasRegistryKey()) {
    query["RegistryKey"] = request.registryKey();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddClientUserDefineRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddClientUserDefineRuleResponse>();
}

/**
 * @summary Creates a custom defense rule.
 *
 * @param request AddClientUserDefineRuleRequest
 * @return AddClientUserDefineRuleResponse
 */
AddClientUserDefineRuleResponse Client::addClientUserDefineRule(const AddClientUserDefineRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addClientUserDefineRuleWithOptions(request, runtime);
}

/**
 * @summary Adds the configuration information of multi-cloud assets.
 *
 * @param request AddCloudVendorAccountAKRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCloudVendorAccountAKResponse
 */
AddCloudVendorAccountAKResponse Client::addCloudVendorAccountAKWithOptions(const AddCloudVendorAccountAKRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAkType()) {
    query["AkType"] = request.akType();
  }

  if (!!request.hasAuthModules()) {
    query["AuthModules"] = request.authModules();
  }

  if (!!request.hasCtdrCloudUserId()) {
    query["CtdrCloudUserId"] = request.ctdrCloudUserId();
  }

  if (!!request.hasDomain()) {
    query["Domain"] = request.domain();
  }

  if (!!request.hasExtendInfo()) {
    query["ExtendInfo"] = request.extendInfo();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRegions()) {
    query["Regions"] = request.regions();
  }

  if (!!request.hasSecretId()) {
    query["SecretId"] = request.secretId();
  }

  if (!!request.hasSecretKey()) {
    query["SecretKey"] = request.secretKey();
  }

  if (!!request.hasSubscriptionIds()) {
    query["SubscriptionIds"] = request.subscriptionIds();
  }

  if (!!request.hasTenantId()) {
    query["TenantId"] = request.tenantId();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  if (!!request.hasVendorAuthAlias()) {
    query["VendorAuthAlias"] = request.vendorAuthAlias();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddCloudVendorAccountAK"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddCloudVendorAccountAKResponse>();
}

/**
 * @summary Adds the configuration information of multi-cloud assets.
 *
 * @param request AddCloudVendorAccountAKRequest
 * @return AddCloudVendorAccountAKResponse
 */
AddCloudVendorAccountAKResponse Client::addCloudVendorAccountAK(const AddCloudVendorAccountAKRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addCloudVendorAccountAKWithOptions(request, runtime);
}

/**
 * @summary Adds configurations of connecting the audit logs of a third-party cloud asset.
 *
 * @param request AddCloudVendorTrialConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCloudVendorTrialConfigResponse
 */
AddCloudVendorTrialConfigResponse Client::addCloudVendorTrialConfigWithOptions(const AddCloudVendorTrialConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAuthId()) {
    query["AuthId"] = request.authId();
  }

  if (!!request.hasAuthInfo()) {
    query["AuthInfo"] = request.authInfo();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddCloudVendorTrialConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddCloudVendorTrialConfigResponse>();
}

/**
 * @summary Adds configurations of connecting the audit logs of a third-party cloud asset.
 *
 * @param request AddCloudVendorTrialConfigRequest
 * @return AddCloudVendorTrialConfigResponse
 */
AddCloudVendorTrialConfigResponse Client::addCloudVendorTrialConfig(const AddCloudVendorTrialConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addCloudVendorTrialConfigWithOptions(request, runtime);
}

/**
 * @summary Creates a rule for non-image program defense.
 *
 * @param tmpReq AddContainerDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddContainerDefenseRuleResponse
 */
AddContainerDefenseRuleResponse Client::addContainerDefenseRuleWithOptions(const AddContainerDefenseRuleRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  AddContainerDefenseRuleShrinkRequest request = AddContainerDefenseRuleShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasWhitelist()) {
    request.setWhitelistShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.whitelist(), "Whitelist", "json"));
  }

  json query = {};
  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasRuleAction()) {
    query["RuleAction"] = request.ruleAction();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasRuleSwitch()) {
    query["RuleSwitch"] = request.ruleSwitch();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  if (!!request.hasScope()) {
    query["Scope"] = request.scope();
  }

  if (!!request.hasWhitelistShrink()) {
    query["Whitelist"] = request.whitelistShrink();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddContainerDefenseRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddContainerDefenseRuleResponse>();
}

/**
 * @summary Creates a rule for non-image program defense.
 *
 * @param request AddContainerDefenseRuleRequest
 * @return AddContainerDefenseRuleResponse
 */
AddContainerDefenseRuleResponse Client::addContainerDefenseRule(const AddContainerDefenseRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addContainerDefenseRuleWithOptions(request, runtime);
}

/**
 * @summary Creates a defense rule against container escapes.
 *
 * @param request AddContainerPluginRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddContainerPluginRuleResponse
 */
AddContainerPluginRuleResponse Client::addContainerPluginRuleWithOptions(const AddContainerPluginRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMode()) {
    query["Mode"] = request.mode();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasRuleTemplateId()) {
    query["RuleTemplateId"] = request.ruleTemplateId();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  if (!!request.hasSelectedPolicy()) {
    query["SelectedPolicy"] = request.selectedPolicy();
  }

  if (!!request.hasWhiteImages()) {
    query["WhiteImages"] = request.whiteImages();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddContainerPluginRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddContainerPluginRuleResponse>();
}

/**
 * @summary Creates a defense rule against container escapes.
 *
 * @param request AddContainerPluginRuleRequest
 * @return AddContainerPluginRuleResponse
 */
AddContainerPluginRuleResponse Client::addContainerPluginRule(const AddContainerPluginRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addContainerPluginRuleWithOptions(request, runtime);
}

/**
 * @summary Creates an IDC probe to add assets in a data center to Security Center and manage the assets by using the Security Center console.
 *
 * @description Security Center allows you to create an IDC probe only on servers on which the Security Center agent is installed.
 *
 * @param request AddIdcProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddIdcProbeResponse
 */
AddIdcProbeResponse Client::addIdcProbeWithOptions(const AddIdcProbeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIdcName()) {
    query["IdcName"] = request.idcName();
  }

  if (!!request.hasIdcRegion()) {
    query["IdcRegion"] = request.idcRegion();
  }

  if (!!request.hasIntervalPeriod()) {
    query["IntervalPeriod"] = request.intervalPeriod();
  }

  if (!!request.hasIpSegments()) {
    query["IpSegments"] = request.ipSegments();
  }

  if (!!request.hasLinuxPort()) {
    query["LinuxPort"] = request.linuxPort();
  }

  if (!!request.hasPeriodUnit()) {
    query["PeriodUnit"] = request.periodUnit();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  if (!!request.hasWinPort()) {
    query["WinPort"] = request.winPort();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddIdcProbe"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddIdcProbeResponse>();
}

/**
 * @summary Creates an IDC probe to add assets in a data center to Security Center and manage the assets by using the Security Center console.
 *
 * @description Security Center allows you to create an IDC probe only on servers on which the Security Center agent is installed.
 *
 * @param request AddIdcProbeRequest
 * @return AddIdcProbeResponse
 */
AddIdcProbeResponse Client::addIdcProbe(const AddIdcProbeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addIdcProbeWithOptions(request, runtime);
}

/**
 * @summary Creates an alert handling rule.
 *
 * @param request AddImageEventOperationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddImageEventOperationResponse
 */
AddImageEventOperationResponse Client::addImageEventOperationWithOptions(const AddImageEventOperationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConditions()) {
    query["Conditions"] = request.conditions();
  }

  if (!!request.hasEventKey()) {
    query["EventKey"] = request.eventKey();
  }

  if (!!request.hasEventName()) {
    query["EventName"] = request.eventName();
  }

  if (!!request.hasEventType()) {
    query["EventType"] = request.eventType();
  }

  if (!!request.hasNote()) {
    query["Note"] = request.note();
  }

  if (!!request.hasOperationCode()) {
    query["OperationCode"] = request.operationCode();
  }

  if (!!request.hasScenarios()) {
    query["Scenarios"] = request.scenarios();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddImageEventOperation"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddImageEventOperationResponse>();
}

/**
 * @summary Creates an alert handling rule.
 *
 * @param request AddImageEventOperationRequest
 * @return AddImageEventOperationResponse
 */
AddImageEventOperationResponse Client::addImageEventOperation(const AddImageEventOperationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addImageEventOperationWithOptions(request, runtime);
}

/**
 * @summary Adds image vulnerabilities to the whitelist.
 *
 * @param request AddImageVulWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddImageVulWhiteListResponse
 */
AddImageVulWhiteListResponse Client::addImageVulWhiteListWithOptions(const AddImageVulWhiteListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasReason()) {
    query["Reason"] = request.reason();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasWhitelist()) {
    query["Whitelist"] = request.whitelist();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddImageVulWhiteList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddImageVulWhiteListResponse>();
}

/**
 * @summary Adds image vulnerabilities to the whitelist.
 *
 * @param request AddImageVulWhiteListRequest
 * @return AddImageVulWhiteListResponse
 */
AddImageVulWhiteListResponse Client::addImageVulWhiteList(const AddImageVulWhiteListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addImageVulWhiteListWithOptions(request, runtime);
}

/**
 * @summary Creates a command that is used to install the Security Center agent.
 *
 * @param request AddInstallCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddInstallCodeResponse
 */
AddInstallCodeResponse Client::addInstallCodeWithOptions(const AddInstallCodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExpiredDate()) {
    query["ExpiredDate"] = request.expiredDate();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasOnlyImage()) {
    query["OnlyImage"] = request.onlyImage();
  }

  if (!!request.hasOs()) {
    query["Os"] = request.os();
  }

  if (!!request.hasPrivateLinkId()) {
    query["PrivateLinkId"] = request.privateLinkId();
  }

  if (!!request.hasProxyCluster()) {
    query["ProxyCluster"] = request.proxyCluster();
  }

  if (!!request.hasVendorName()) {
    query["VendorName"] = request.vendorName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddInstallCode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddInstallCodeResponse>();
}

/**
 * @summary Creates a command that is used to install the Security Center agent.
 *
 * @param request AddInstallCodeRequest
 * @return AddInstallCodeResponse
 */
AddInstallCodeResponse Client::addInstallCode(const AddInstallCodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addInstallCodeWithOptions(request, runtime);
}

/**
 * @summary Adds a self-managed image repository.
 *
 * @param request AddPrivateRegistryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddPrivateRegistryResponse
 */
AddPrivateRegistryResponse Client::addPrivateRegistryWithOptions(const AddPrivateRegistryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDomainName()) {
    query["DomainName"] = request.domainName();
  }

  if (!!request.hasExtraParam()) {
    query["ExtraParam"] = request.extraParam();
  }

  if (!!request.hasNetType()) {
    query["NetType"] = request.netType();
  }

  if (!!request.hasPassword()) {
    query["Password"] = request.password();
  }

  if (!!request.hasPort()) {
    query["Port"] = request.port();
  }

  if (!!request.hasProtocolType()) {
    query["ProtocolType"] = request.protocolType();
  }

  if (!!request.hasRegistryHostIp()) {
    query["RegistryHostIp"] = request.registryHostIp();
  }

  if (!!request.hasRegistryRegionId()) {
    query["RegistryRegionId"] = request.registryRegionId();
  }

  if (!!request.hasRegistryType()) {
    query["RegistryType"] = request.registryType();
  }

  if (!!request.hasRegistryVersion()) {
    query["RegistryVersion"] = request.registryVersion();
  }

  if (!!request.hasTransPerHour()) {
    query["TransPerHour"] = request.transPerHour();
  }

  if (!!request.hasUserName()) {
    query["UserName"] = request.userName();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddPrivateRegistry"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddPrivateRegistryResponse>();
}

/**
 * @summary Adds a self-managed image repository.
 *
 * @param request AddPrivateRegistryRequest
 * @return AddPrivateRegistryResponse
 */
AddPrivateRegistryResponse Client::addPrivateRegistry(const AddPrivateRegistryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addPrivateRegistryWithOptions(request, runtime);
}

/**
 * @summary Add or update the whitelist for VPC purchases
 *
 * @param request AddProtectVpcListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddProtectVpcListResponse
 */
AddProtectVpcListResponse Client::addProtectVpcListWithOptions(const AddProtectVpcListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAddVpcInstanceIdList()) {
    query["AddVpcInstanceIdList"] = request.addVpcInstanceIdList();
  }

  if (!!request.hasDelVpcInstanceIdList()) {
    query["DelVpcInstanceIdList"] = request.delVpcInstanceIdList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddProtectVpcList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddProtectVpcListResponse>();
}

/**
 * @summary Add or update the whitelist for VPC purchases
 *
 * @param request AddProtectVpcListRequest
 * @return AddProtectVpcListResponse
 */
AddProtectVpcListResponse Client::addProtectVpcList(const AddProtectVpcListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addProtectVpcListWithOptions(request, runtime);
}

/**
 * @summary Upgrades the Security Center agent in batches.
 *
 * @param request AddPublishBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddPublishBatchResponse
 */
AddPublishBatchResponse Client::addPublishBatchWithOptions(const AddPublishBatchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBatchName()) {
    query["BatchName"] = request.batchName();
  }

  if (!!request.hasInterval()) {
    query["Interval"] = request.interval();
  }

  if (!!request.hasOperationBase()) {
    query["OperationBase"] = request.operationBase();
  }

  if (!!request.hasUpgradeVersion()) {
    query["UpgradeVersion"] = request.upgradeVersion();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddPublishBatch"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddPublishBatchResponse>();
}

/**
 * @summary Upgrades the Security Center agent in batches.
 *
 * @param request AddPublishBatchRequest
 * @return AddPublishBatchResponse
 */
AddPublishBatchResponse Client::addPublishBatch(const AddPublishBatchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addPublishBatchWithOptions(request, runtime);
}

/**
 * @summary Creates a rule for container tamper-proofing.
 *
 * @param request AddSasContainerWebDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddSasContainerWebDefenseRuleResponse
 */
AddSasContainerWebDefenseRuleResponse Client::addSasContainerWebDefenseRuleWithOptions(const AddSasContainerWebDefenseRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPathConfDTOList()) {
    query["PathConfDTOList"] = request.pathConfDTOList();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddSasContainerWebDefenseRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddSasContainerWebDefenseRuleResponse>();
}

/**
 * @summary Creates a rule for container tamper-proofing.
 *
 * @param request AddSasContainerWebDefenseRuleRequest
 * @return AddSasContainerWebDefenseRuleResponse
 */
AddSasContainerWebDefenseRuleResponse Client::addSasContainerWebDefenseRule(const AddSasContainerWebDefenseRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addSasContainerWebDefenseRuleWithOptions(request, runtime);
}

/**
 * @summary Enables the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
 *
 * @param request AddSasModuleTrialRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddSasModuleTrialResponse
 */
AddSasModuleTrialResponse Client::addSasModuleTrialWithOptions(const AddSasModuleTrialRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasModuleCode()) {
    query["ModuleCode"] = request.moduleCode();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddSasModuleTrial"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddSasModuleTrialResponse>();
}

/**
 * @summary Enables the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
 *
 * @param request AddSasModuleTrialRequest
 * @return AddSasModuleTrialResponse
 */
AddSasModuleTrialResponse Client::addSasModuleTrial(const AddSasModuleTrialRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addSasModuleTrialWithOptions(request, runtime);
}

/**
 * @summary Adds a tag to assets.
 *
 * @description Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
 *
 * @param request AddTagWithUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddTagWithUuidResponse
 */
AddTagWithUuidResponse Client::addTagWithUuidWithOptions(const AddTagWithUuidRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTagName()) {
    query["TagName"] = request.tagName();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddTagWithUuid"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddTagWithUuidResponse>();
}

/**
 * @summary Adds a tag to assets.
 *
 * @description Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
 *
 * @param request AddTagWithUuidRequest
 * @return AddTagWithUuidResponse
 */
AddTagWithUuidResponse Client::addTagWithUuid(const AddTagWithUuidRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addTagWithUuidWithOptions(request, runtime);
}

/**
 * @summary Adds servers from which you want to uninstall the Security Center agent.
 *
 * @param request AddUninstallClientsByUuidsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddUninstallClientsByUuidsResponse
 */
AddUninstallClientsByUuidsResponse Client::addUninstallClientsByUuidsWithOptions(const AddUninstallClientsByUuidsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCallMethod()) {
    query["CallMethod"] = request.callMethod();
  }

  if (!!request.hasFeedback()) {
    query["Feedback"] = request.feedback();
  }

  if (!!request.hasRegion()) {
    query["Region"] = request.region();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddUninstallClientsByUuids"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddUninstallClientsByUuidsResponse>();
}

/**
 * @summary Adds servers from which you want to uninstall the Security Center agent.
 *
 * @param request AddUninstallClientsByUuidsRequest
 * @return AddUninstallClientsByUuidsResponse
 */
AddUninstallClientsByUuidsResponse Client::addUninstallClientsByUuids(const AddUninstallClientsByUuidsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addUninstallClientsByUuidsWithOptions(request, runtime);
}

/**
 * @summary Creates a honeypot.
 *
 * @param request AddVpcHoneyPotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddVpcHoneyPotResponse
 */
AddVpcHoneyPotResponse Client::addVpcHoneyPotWithOptions(const AddVpcHoneyPotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AddVpcHoneyPot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AddVpcHoneyPotResponse>();
}

/**
 * @summary Creates a honeypot.
 *
 * @param request AddVpcHoneyPotRequest
 * @return AddVpcHoneyPotResponse
 */
AddVpcHoneyPotResponse Client::addVpcHoneyPot(const AddVpcHoneyPotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return addVpcHoneyPotWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of an advanced whitelist rule.
 *
 * @param request AdvanceSecurityEventOperationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AdvanceSecurityEventOperationsResponse
 */
AdvanceSecurityEventOperationsResponse Client::advanceSecurityEventOperationsWithOptions(const AdvanceSecurityEventOperationsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventName()) {
    query["EventName"] = request.eventName();
  }

  if (!!request.hasEventType()) {
    query["EventType"] = request.eventType();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "AdvanceSecurityEventOperations"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<AdvanceSecurityEventOperationsResponse>();
}

/**
 * @summary Queries the configurations of an advanced whitelist rule.
 *
 * @param request AdvanceSecurityEventOperationsRequest
 * @return AdvanceSecurityEventOperationsResponse
 */
AdvanceSecurityEventOperationsResponse Client::advanceSecurityEventOperations(const AdvanceSecurityEventOperationsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return advanceSecurityEventOperationsWithOptions(request, runtime);
}

/**
 * @summary Adds alert description in batches.
 *
 * @param request BatchCreateMaliciousNoteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCreateMaliciousNoteResponse
 */
BatchCreateMaliciousNoteResponse Client::batchCreateMaliciousNoteWithOptions(const BatchCreateMaliciousNoteRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasImageMaliciousFileList()) {
    query["ImageMaliciousFileList"] = request.imageMaliciousFileList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "BatchCreateMaliciousNote"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<BatchCreateMaliciousNoteResponse>();
}

/**
 * @summary Adds alert description in batches.
 *
 * @param request BatchCreateMaliciousNoteRequest
 * @return BatchCreateMaliciousNoteResponse
 */
BatchCreateMaliciousNoteResponse Client::batchCreateMaliciousNote(const BatchCreateMaliciousNoteRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return batchCreateMaliciousNoteWithOptions(request, runtime);
}

/**
 * @summary Deletes whitelist rules for alerts generated for sensitive files that are detected by using the agentless detection feature in batches.
 *
 * @param request BatchDeleteMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteMaliciousFileWhitelistConfigResponse
 */
BatchDeleteMaliciousFileWhitelistConfigResponse Client::batchDeleteMaliciousFileWhitelistConfigWithOptions(const BatchDeleteMaliciousFileWhitelistConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigIdList()) {
    query["ConfigIdList"] = request.configIdList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "BatchDeleteMaliciousFileWhitelistConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<BatchDeleteMaliciousFileWhitelistConfigResponse>();
}

/**
 * @summary Deletes whitelist rules for alerts generated for sensitive files that are detected by using the agentless detection feature in batches.
 *
 * @param request BatchDeleteMaliciousFileWhitelistConfigRequest
 * @return BatchDeleteMaliciousFileWhitelistConfigResponse
 */
BatchDeleteMaliciousFileWhitelistConfigResponse Client::batchDeleteMaliciousFileWhitelistConfig(const BatchDeleteMaliciousFileWhitelistConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return batchDeleteMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

/**
 * @summary Enables or disables multiple features in proactive defense at a time.
 *
 * @param request BatchOperateCommonOverallConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchOperateCommonOverallConfigResponse
 */
BatchOperateCommonOverallConfigResponse Client::batchOperateCommonOverallConfigWithOptions(const BatchOperateCommonOverallConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasTypeList()) {
    query["TypeList"] = request.typeList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "BatchOperateCommonOverallConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<BatchOperateCommonOverallConfigResponse>();
}

/**
 * @summary Enables or disables multiple features in proactive defense at a time.
 *
 * @param request BatchOperateCommonOverallConfigRequest
 * @return BatchOperateCommonOverallConfigResponse
 */
BatchOperateCommonOverallConfigResponse Client::batchOperateCommonOverallConfig(const BatchOperateCommonOverallConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return batchOperateCommonOverallConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies multiple alert whitelist rules of sensitive files that are detected by using the agentless detection feature at a time.
 *
 * @param request BatchUpdateMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdateMaliciousFileWhitelistConfigResponse
 */
BatchUpdateMaliciousFileWhitelistConfigResponse Client::batchUpdateMaliciousFileWhitelistConfigWithOptions(const BatchUpdateMaliciousFileWhitelistConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigList()) {
    query["ConfigList"] = request.configList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "BatchUpdateMaliciousFileWhitelistConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<BatchUpdateMaliciousFileWhitelistConfigResponse>();
}

/**
 * @summary Modifies multiple alert whitelist rules of sensitive files that are detected by using the agentless detection feature at a time.
 *
 * @param request BatchUpdateMaliciousFileWhitelistConfigRequest
 * @return BatchUpdateMaliciousFileWhitelistConfigResponse
 */
BatchUpdateMaliciousFileWhitelistConfigResponse Client::batchUpdateMaliciousFileWhitelistConfig(const BatchUpdateMaliciousFileWhitelistConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return batchUpdateMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

/**
 * @summary Binds servers to Security Center or unbinds servers from Security Center.
 *
 * @param request BindAuthToMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindAuthToMachineResponse
 */
BindAuthToMachineResponse Client::bindAuthToMachineWithOptions(const BindAuthToMachineRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAuthVersion()) {
    query["AuthVersion"] = request.authVersion();
  }

  if (!!request.hasAutoBind()) {
    query["AutoBind"] = request.autoBind();
  }

  if (!!request.hasBind()) {
    query["Bind"] = request.bind();
  }

  if (!!request.hasBindAll()) {
    query["BindAll"] = request.bindAll();
  }

  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasIsPreBind()) {
    query["IsPreBind"] = request.isPreBind();
  }

  if (!!request.hasLogicalExp()) {
    query["LogicalExp"] = request.logicalExp();
  }

  if (!!request.hasNtmVersion()) {
    query["NtmVersion"] = request.ntmVersion();
  }

  if (!!request.hasPreBindOrderId()) {
    query["PreBindOrderId"] = request.preBindOrderId();
  }

  if (!!request.hasUnBind()) {
    query["UnBind"] = request.unBind();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "BindAuthToMachine"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<BindAuthToMachineResponse>();
}

/**
 * @summary Binds servers to Security Center or unbinds servers from Security Center.
 *
 * @param request BindAuthToMachineRequest
 * @return BindAuthToMachineResponse
 */
BindAuthToMachineResponse Client::bindAuthToMachine(const BindAuthToMachineRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return bindAuthToMachineWithOptions(request, runtime);
}

/**
 * @summary Adds servers to Security Center over a proxy server. After you create a proxy cluster and deploy a proxy server, you can connect a server to the proxy cluster as a client. This way, the server is added to Security Center over the proxy server and is protected.
 *
 * @param request BindHybridProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindHybridProxyResponse
 */
BindHybridProxyResponse Client::bindHybridProxyWithOptions(const BindHybridProxyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasYundunUuids()) {
    query["YundunUuids"] = request.yundunUuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "BindHybridProxy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<BindHybridProxyResponse>();
}

/**
 * @summary Adds servers to Security Center over a proxy server. After you create a proxy cluster and deploy a proxy server, you can connect a server to the proxy cluster as a client. This way, the server is added to Security Center over the proxy server and is protected.
 *
 * @param request BindHybridProxyRequest
 * @return BindHybridProxyResponse
 */
BindHybridProxyResponse Client::bindHybridProxy(const BindHybridProxyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return bindHybridProxyWithOptions(request, runtime);
}

/**
 * @summary Cancels the main task.
 *
 * @param request CancelOnceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelOnceTaskResponse
 */
CancelOnceTaskResponse Client::cancelOnceTaskWithOptions(const CancelOnceTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CancelOnceTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CancelOnceTaskResponse>();
}

/**
 * @summary Cancels the main task.
 *
 * @param request CancelOnceTaskRequest
 * @return CancelOnceTaskResponse
 */
CancelOnceTaskResponse Client::cancelOnceTask(const CancelOnceTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return cancelOnceTaskWithOptions(request, runtime);
}

/**
 * @summary Modifies the interval of asset synchronization configurations.
 *
 * @param request ChangeAssetRefreshTaskConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeAssetRefreshTaskConfigResponse
 */
ChangeAssetRefreshTaskConfigResponse Client::changeAssetRefreshTaskConfigWithOptions(const ChangeAssetRefreshTaskConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssetRefreshConfigs()) {
    query["AssetRefreshConfigs"] = request.assetRefreshConfigs();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ChangeAssetRefreshTaskConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ChangeAssetRefreshTaskConfigResponse>();
}

/**
 * @summary Modifies the interval of asset synchronization configurations.
 *
 * @param request ChangeAssetRefreshTaskConfigRequest
 * @return ChangeAssetRefreshTaskConfigResponse
 */
ChangeAssetRefreshTaskConfigResponse Client::changeAssetRefreshTaskConfig(const ChangeAssetRefreshTaskConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return changeAssetRefreshTaskConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration items of the configuration assessment feature.
 *
 * @param tmpReq ChangeCheckConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeCheckConfigResponse
 */
ChangeCheckConfigResponse Client::changeCheckConfigWithOptions(const ChangeCheckConfigRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  ChangeCheckConfigShrinkRequest request = ChangeCheckConfigShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasConfigRequirementIds()) {
    request.setConfigRequirementIdsShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.configRequirementIds(), "ConfigRequirementIds", "json"));
  }

  if (!!tmpReq.hasConfigStandardIds()) {
    request.setConfigStandardIdsShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.configStandardIds(), "ConfigStandardIds", "json"));
  }

  json query = {};
  if (!!request.hasAddedCheck()) {
    query["AddedCheck"] = request.addedCheck();
  }

  if (!!request.hasConfigRequirementIdsShrink()) {
    query["ConfigRequirementIds"] = request.configRequirementIdsShrink();
  }

  if (!!request.hasConfigStandardIdsShrink()) {
    query["ConfigStandardIds"] = request.configStandardIdsShrink();
  }

  if (!!request.hasConfigure()) {
    query["Configure"] = request.configure();
  }

  if (!!request.hasCycleDays()) {
    query["CycleDays"] = request.cycleDays();
  }

  if (!!request.hasEnableAddCheck()) {
    query["EnableAddCheck"] = request.enableAddCheck();
  }

  if (!!request.hasEnableAutoCheck()) {
    query["EnableAutoCheck"] = request.enableAutoCheck();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRemovedCheck()) {
    query["RemovedCheck"] = request.removedCheck();
  }

  if (!!request.hasStandardIds()) {
    query["StandardIds"] = request.standardIds();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasSystemConfig()) {
    query["SystemConfig"] = request.systemConfig();
  }

  if (!!request.hasVendors()) {
    query["Vendors"] = request.vendors();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ChangeCheckConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ChangeCheckConfigResponse>();
}

/**
 * @summary Modifies the configuration items of the configuration assessment feature.
 *
 * @param request ChangeCheckConfigRequest
 * @return ChangeCheckConfigResponse
 */
ChangeCheckConfigResponse Client::changeCheckConfig(const ChangeCheckConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return changeCheckConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies the custom configuration items of a check item.
 *
 * @param request ChangeCheckCustomConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeCheckCustomConfigResponse
 */
ChangeCheckCustomConfigResponse Client::changeCheckCustomConfigWithOptions(const ChangeCheckCustomConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasCustomConfigs()) {
    query["CustomConfigs"] = request.customConfigs();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRepairConfigs()) {
    query["RepairConfigs"] = request.repairConfigs();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ChangeCheckCustomConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ChangeCheckCustomConfigResponse>();
}

/**
 * @summary Modifies the custom configuration items of a check item.
 *
 * @param request ChangeCheckCustomConfigRequest
 * @return ChangeCheckCustomConfigResponse
 */
ChangeCheckCustomConfigResponse Client::changeCheckCustomConfig(const ChangeCheckCustomConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return changeCheckCustomConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies the details of the deduction modules of the security score feature, including custom settings.
 *
 * @param request ChangeSecurityScoreRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeSecurityScoreRuleResponse
 */
ChangeSecurityScoreRuleResponse Client::changeSecurityScoreRuleWithOptions(const ChangeSecurityScoreRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCalType()) {
    query["CalType"] = request.calType();
  }

  if (!!request.hasResetSecurityScoreRule()) {
    query["ResetSecurityScoreRule"] = request.resetSecurityScoreRule();
  }

  if (!!request.hasSecurityScoreCategoryList()) {
    query["SecurityScoreCategoryList"] = request.securityScoreCategoryList();
  }

  if (!!request.hasSecurityScoreRuleList()) {
    query["SecurityScoreRuleList"] = request.securityScoreRuleList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ChangeSecurityScoreRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ChangeSecurityScoreRuleResponse>();
}

/**
 * @summary Modifies the details of the deduction modules of the security score feature, including custom settings.
 *
 * @param request ChangeSecurityScoreRuleRequest
 * @return ChangeSecurityScoreRuleResponse
 */
ChangeSecurityScoreRuleResponse Client::changeSecurityScoreRule(const ChangeSecurityScoreRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return changeSecurityScoreRuleWithOptions(request, runtime);
}

/**
 * @summary Modifies the language settings of log analysis. The modification on the language settings takes effect within 12 hours and affects only the language of the descriptions for security events in security logs.
 *
 * @param request ChangeUserLangRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeUserLangResponse
 */
ChangeUserLangResponse Client::changeUserLangWithOptions(const ChangeUserLangRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUserLang()) {
    query["UserLang"] = request.userLang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ChangeUserLang"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ChangeUserLangResponse>();
}

/**
 * @summary Modifies the language settings of log analysis. The modification on the language settings takes effect within 12 hours and affects only the language of the descriptions for security events in security logs.
 *
 * @param request ChangeUserLangRequest
 * @return ChangeUserLangResponse
 */
ChangeUserLangResponse Client::changeUserLang(const ChangeUserLangRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return changeUserLangWithOptions(request, runtime);
}

/**
 * @summary Checks whether one or more alert events are generated on a specified server based on the IDs of the alert events.
 *
 * @param request CheckSecurityEventIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckSecurityEventIdResponse
 */
CheckSecurityEventIdResponse Client::checkSecurityEventIdWithOptions(const CheckSecurityEventIdRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSecurityEventIds()) {
    query["SecurityEventIds"] = request.securityEventIds();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CheckSecurityEventId"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CheckSecurityEventIdResponse>();
}

/**
 * @summary Checks whether one or more alert events are generated on a specified server based on the IDs of the alert events.
 *
 * @param request CheckSecurityEventIdRequest
 * @return CheckSecurityEventIdResponse
 */
CheckSecurityEventIdResponse Client::checkSecurityEventId(const CheckSecurityEventIdRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return checkSecurityEventIdWithOptions(request, runtime);
}

/**
 * @summary Checks a Security Token Service (STS) token and returns the ID of the Alibaba Cloud account.
 *
 * @param request CheckStsTokenAuthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckStsTokenAuthResponse
 */
CheckStsTokenAuthResponse Client::checkStsTokenAuthWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "CheckStsTokenAuth"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CheckStsTokenAuthResponse>();
}

/**
 * @summary Checks a Security Token Service (STS) token and returns the ID of the Alibaba Cloud account.
 *
 * @return CheckStsTokenAuthResponse
 */
CheckStsTokenAuthResponse Client::checkStsTokenAuth() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return checkStsTokenAuthWithOptions(runtime);
}

/**
 * @summary Checks whether the remaining quota of the vulnerability fixing feature is sufficient for a free trial user of Security Center and queries the quota usage required for the current fix operation.
 *
 * @description You can call this operation to check whether the remaining quota of the vulnerability fixing feature is sufficient in free trial scenarios. This operation does not trigger vulnerability fixing.
 *
 * @param request CheckTrialFixCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckTrialFixCountResponse
 */
CheckTrialFixCountResponse Client::checkTrialFixCountWithOptions(const CheckTrialFixCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInfo()) {
    query["Info"] = request.info();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  if (!!request.hasVulNames()) {
    query["VulNames"] = request.vulNames();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CheckTrialFixCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CheckTrialFixCountResponse>();
}

/**
 * @summary Checks whether the remaining quota of the vulnerability fixing feature is sufficient for a free trial user of Security Center and queries the quota usage required for the current fix operation.
 *
 * @description You can call this operation to check whether the remaining quota of the vulnerability fixing feature is sufficient in free trial scenarios. This operation does not trigger vulnerability fixing.
 *
 * @param request CheckTrialFixCountRequest
 * @return CheckTrialFixCountResponse
 */
CheckTrialFixCountResponse Client::checkTrialFixCount(const CheckTrialFixCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return checkTrialFixCountWithOptions(request, runtime);
}

/**
 * @summary Checks whether Elastic Compute Service (ECS) instances exist.
 *
 * @param request CheckUserHasEcsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckUserHasEcsResponse
 */
CheckUserHasEcsResponse Client::checkUserHasEcsWithOptions(const CheckUserHasEcsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CheckUserHasEcs"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CheckUserHasEcsResponse>();
}

/**
 * @summary Checks whether Elastic Compute Service (ECS) instances exist.
 *
 * @param request CheckUserHasEcsRequest
 * @return CheckUserHasEcsResponse
 */
CheckUserHasEcsResponse Client::checkUserHasEcs(const CheckUserHasEcsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return checkUserHasEcsWithOptions(request, runtime);
}

/**
 * @summary Confirms the alert events that you want to handle.
 *
 * @param request ConfirmVirusEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfirmVirusEventsResponse
 */
ConfirmVirusEventsResponse Client::confirmVirusEventsWithOptions(const ConfirmVirusEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOperationAll()) {
    query["OperationAll"] = request.operationAll();
  }

  if (!!request.hasOperationCode()) {
    query["OperationCode"] = request.operationCode();
  }

  if (!!request.hasOperationRange()) {
    query["OperationRange"] = request.operationRange();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ConfirmVirusEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ConfirmVirusEventsResponse>();
}

/**
 * @summary Confirms the alert events that you want to handle.
 *
 * @param request ConfirmVirusEventsRequest
 * @return ConfirmVirusEventsResponse
 */
ConfirmVirusEventsResponse Client::confirmVirusEvents(const ConfirmVirusEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return confirmVirusEventsWithOptions(request, runtime);
}

/**
 * @summary Clones an existing security report. The new security report has the same configuration as the existing security report.
 *
 * @param request CopyCustomizeReportConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyCustomizeReportConfigResponse
 */
CopyCustomizeReportConfigResponse Client::copyCustomizeReportConfigWithOptions(const CopyCustomizeReportConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasReportId()) {
    query["ReportId"] = request.reportId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CopyCustomizeReportConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CopyCustomizeReportConfigResponse>();
}

/**
 * @summary Clones an existing security report. The new security report has the same configuration as the existing security report.
 *
 * @param request CopyCustomizeReportConfigRequest
 * @return CopyCustomizeReportConfigResponse
 */
CopyCustomizeReportConfigResponse Client::copyCustomizeReportConfig(const CopyCustomizeReportConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return copyCustomizeReportConfigWithOptions(request, runtime);
}

/**
 * @summary Creates an agentless detection task.
 *
 * @param request CreateAgentlessScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAgentlessScanTaskResponse
 */
CreateAgentlessScanTaskResponse Client::createAgentlessScanTaskWithOptions(const CreateAgentlessScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssetSelectionType()) {
    query["AssetSelectionType"] = request.assetSelectionType();
  }

  if (!!request.hasAutoDeleteDays()) {
    query["AutoDeleteDays"] = request.autoDeleteDays();
  }

  if (!!request.hasReleaseAfterScan()) {
    query["ReleaseAfterScan"] = request.releaseAfterScan();
  }

  if (!!request.hasScanDataDisk()) {
    query["ScanDataDisk"] = request.scanDataDisk();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateAgentlessScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateAgentlessScanTaskResponse>();
}

/**
 * @summary Creates an agentless detection task.
 *
 * @param request CreateAgentlessScanTaskRequest
 * @return CreateAgentlessScanTaskResponse
 */
CreateAgentlessScanTaskResponse Client::createAgentlessScanTask(const CreateAgentlessScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createAgentlessScanTaskWithOptions(request, runtime);
}

/**
 * @summary Creates a defense rule against brute-force attacks.
 *
 * @param tmpReq CreateAntiBruteForceRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAntiBruteForceRuleResponse
 */
CreateAntiBruteForceRuleResponse Client::createAntiBruteForceRuleWithOptions(const CreateAntiBruteForceRuleRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  CreateAntiBruteForceRuleShrinkRequest request = CreateAntiBruteForceRuleShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasProtocolType()) {
    request.setProtocolTypeShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.protocolType(), "ProtocolType", "json"));
  }

  json query = {};
  if (!!request.hasDefaultRule()) {
    query["DefaultRule"] = request.defaultRule();
  }

  if (!!request.hasFailCount()) {
    query["FailCount"] = request.failCount();
  }

  if (!!request.hasForbiddenTime()) {
    query["ForbiddenTime"] = request.forbiddenTime();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasProtocolTypeShrink()) {
    query["ProtocolType"] = request.protocolTypeShrink();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasSpan()) {
    query["Span"] = request.span();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateAntiBruteForceRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateAntiBruteForceRuleResponse>();
}

/**
 * @summary Creates a defense rule against brute-force attacks.
 *
 * @param request CreateAntiBruteForceRuleRequest
 * @return CreateAntiBruteForceRuleResponse
 */
CreateAntiBruteForceRuleResponse Client::createAntiBruteForceRule(const CreateAntiBruteForceRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createAntiBruteForceRuleWithOptions(request, runtime);
}

/**
 * @summary Create asset selection configurations.
 *
 * @param request CreateAssetSelectionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAssetSelectionConfigResponse
 */
CreateAssetSelectionConfigResponse Client::createAssetSelectionConfigWithOptions(const CreateAssetSelectionConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBusinessType()) {
    query["BusinessType"] = request.businessType();
  }

  if (!!request.hasPlatform()) {
    query["Platform"] = request.platform();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateAssetSelectionConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateAssetSelectionConfigResponse>();
}

/**
 * @summary Create asset selection configurations.
 *
 * @param request CreateAssetSelectionConfigRequest
 * @return CreateAssetSelectionConfigResponse
 */
CreateAssetSelectionConfigResponse Client::createAssetSelectionConfig(const CreateAssetSelectionConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createAssetSelectionConfigWithOptions(request, runtime);
}

/**
 * @summary Create attack path sensitive asset configuration.
 *
 * @param request CreateAttackPathSensitiveAssetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAttackPathSensitiveAssetConfigResponse
 */
CreateAttackPathSensitiveAssetConfigResponse Client::createAttackPathSensitiveAssetConfigWithOptions(const CreateAttackPathSensitiveAssetConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAttackPathAssetList()) {
    query["AttackPathAssetList"] = request.attackPathAssetList();
  }

  if (!!request.hasConfigType()) {
    query["ConfigType"] = request.configType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateAttackPathSensitiveAssetConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateAttackPathSensitiveAssetConfigResponse>();
}

/**
 * @summary Create attack path sensitive asset configuration.
 *
 * @param request CreateAttackPathSensitiveAssetConfigRequest
 * @return CreateAttackPathSensitiveAssetConfigResponse
 */
CreateAttackPathSensitiveAssetConfigResponse Client::createAttackPathSensitiveAssetConfig(const CreateAttackPathSensitiveAssetConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createAttackPathSensitiveAssetConfigWithOptions(request, runtime);
}

/**
 * @summary Create Attack Path Whitelist.
 *
 * @param request CreateAttackPathWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAttackPathWhitelistResponse
 */
CreateAttackPathWhitelistResponse Client::createAttackPathWhitelistWithOptions(const CreateAttackPathWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAttackPathAssetList()) {
    query["AttackPathAssetList"] = request.attackPathAssetList();
  }

  if (!!request.hasPathName()) {
    query["PathName"] = request.pathName();
  }

  if (!!request.hasPathType()) {
    query["PathType"] = request.pathType();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasWhitelistName()) {
    query["WhitelistName"] = request.whitelistName();
  }

  if (!!request.hasWhitelistType()) {
    query["WhitelistType"] = request.whitelistType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateAttackPathWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateAttackPathWhitelistResponse>();
}

/**
 * @summary Create Attack Path Whitelist.
 *
 * @param request CreateAttackPathWhitelistRequest
 * @return CreateAttackPathWhitelistResponse
 */
CreateAttackPathWhitelistResponse Client::createAttackPathWhitelist(const CreateAttackPathWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createAttackPathWhitelistWithOptions(request, runtime);
}

/**
 * @summary Creates a witness.
 *
 * @param request CreateAttestorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAttestorResponse
 */
CreateAttestorResponse Client::createAttestorWithOptions(const CreateAttestorRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasKeyId()) {
    query["KeyId"] = request.keyId();
  }

  if (!!request.hasKeyRegionId()) {
    query["KeyRegionId"] = request.keyRegionId();
  }

  if (!!request.hasKeyVersionId()) {
    query["KeyVersionId"] = request.keyVersionId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateAttestor"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateAttestorResponse>();
}

/**
 * @summary Creates a witness.
 *
 * @param request CreateAttestorRequest
 * @return CreateAttestorResponse
 */
CreateAttestorResponse Client::createAttestor(const CreateAttestorRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createAttestorWithOptions(request, runtime);
}

/**
 * @summary Creates an anti-ransomware policy for servers.
 *
 * @param tmpReq CreateBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBackupPolicyResponse
 */
CreateBackupPolicyResponse Client::createBackupPolicyWithOptions(const CreateBackupPolicyRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  CreateBackupPolicyShrinkRequest request = CreateBackupPolicyShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasPolicy()) {
    request.setPolicyShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.policy(), "Policy", "json"));
  }

  json query = {};
  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPolicyShrink()) {
    query["Policy"] = request.policyShrink();
  }

  if (!!request.hasPolicyRegionId()) {
    query["PolicyRegionId"] = request.policyRegionId();
  }

  if (!!request.hasPolicyVersion()) {
    query["PolicyVersion"] = request.policyVersion();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateBackupPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateBackupPolicyResponse>();
}

/**
 * @summary Creates an anti-ransomware policy for servers.
 *
 * @param request CreateBackupPolicyRequest
 * @return CreateBackupPolicyResponse
 */
CreateBackupPolicyResponse Client::createBackupPolicy(const CreateBackupPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createBackupPolicyWithOptions(request, runtime);
}

/**
 * @summary Queries the parameters that are required to upload a file for detection.
 *
 * @param request CreateBatchUploadUrlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBatchUploadUrlResponse
 */
CreateBatchUploadUrlResponse Client::createBatchUploadUrlWithOptions(const CreateBatchUploadUrlRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMd5List()) {
    query["Md5List"] = request.md5List();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateBatchUploadUrl"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateBatchUploadUrlResponse>();
}

/**
 * @summary Queries the parameters that are required to upload a file for detection.
 *
 * @param request CreateBatchUploadUrlRequest
 * @return CreateBatchUploadUrlResponse
 */
CreateBatchUploadUrlResponse Client::createBatchUploadUrl(const CreateBatchUploadUrlRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createBatchUploadUrlWithOptions(request, runtime);
}

/**
 * @summary Creates a binary security policy.
 *
 * @param request CreateBinarySecurityPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBinarySecurityPolicyResponse
 */
CreateBinarySecurityPolicyResponse Client::createBinarySecurityPolicyWithOptions(const CreateBinarySecurityPolicyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusters()) {
    query["Clusters"] = request.clusters();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPolicy()) {
    query["Policy"] = request.policy();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateBinarySecurityPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateBinarySecurityPolicyResponse>();
}

/**
 * @summary Creates a binary security policy.
 *
 * @param request CreateBinarySecurityPolicyRequest
 * @return CreateBinarySecurityPolicyResponse
 */
CreateBinarySecurityPolicyResponse Client::createBinarySecurityPolicy(const CreateBinarySecurityPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createBinarySecurityPolicyWithOptions(request, runtime);
}

/**
 * @summary Creates a container scan task.
 *
 * @param request CreateContainerScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateContainerScanTaskResponse
 */
CreateContainerScanTaskResponse Client::createContainerScanTaskWithOptions(const CreateContainerScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasContainerIds()) {
    query["ContainerIds"] = request.containerIds();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateContainerScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateContainerScanTaskResponse>();
}

/**
 * @summary Creates a container scan task.
 *
 * @param request CreateContainerScanTaskRequest
 * @return CreateContainerScanTaskResponse
 */
CreateContainerScanTaskResponse Client::createContainerScanTask(const CreateContainerScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createContainerScanTaskWithOptions(request, runtime);
}

/**
 * @summary Creates a scan task for a running container application based on the application name.
 *
 * @param request CreateContainerScanTaskByAppNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateContainerScanTaskByAppNameResponse
 */
CreateContainerScanTaskByAppNameResponse Client::createContainerScanTaskByAppNameWithOptions(const CreateContainerScanTaskByAppNameRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppNames()) {
    query["AppNames"] = request.appNames();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateContainerScanTaskByAppName"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateContainerScanTaskByAppNameResponse>();
}

/**
 * @summary Creates a scan task for a running container application based on the application name.
 *
 * @param request CreateContainerScanTaskByAppNameRequest
 * @return CreateContainerScanTaskByAppNameResponse
 */
CreateContainerScanTaskByAppNameResponse Client::createContainerScanTaskByAppName(const CreateContainerScanTaskByAppNameRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createContainerScanTaskByAppNameWithOptions(request, runtime);
}

/**
 * @summary Creates an IP address blocking policy for one or more servers.
 *
 * @param request CreateCustomBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomBlockRecordResponse
 */
CreateCustomBlockRecordResponse Client::createCustomBlockRecordWithOptions(const CreateCustomBlockRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBlockIp()) {
    query["BlockIp"] = request.blockIp();
  }

  if (!!request.hasBound()) {
    query["Bound"] = request.bound();
  }

  if (!!request.hasExpireTime()) {
    query["ExpireTime"] = request.expireTime();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateCustomBlockRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateCustomBlockRecordResponse>();
}

/**
 * @summary Creates an IP address blocking policy for one or more servers.
 *
 * @param request CreateCustomBlockRecordRequest
 * @return CreateCustomBlockRecordResponse
 */
CreateCustomBlockRecordResponse Client::createCustomBlockRecord(const CreateCustomBlockRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createCustomBlockRecordWithOptions(request, runtime);
}

/**
 * @summary Creates custom weak password rules.
 *
 * @param request CreateCustomizedDictRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomizedDictResponse
 */
CreateCustomizedDictResponse Client::createCustomizedDictWithOptions(const CreateCustomizedDictRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasOverride()) {
    query["Override"] = request.override();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateCustomizedDict"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateCustomizedDictResponse>();
}

/**
 * @summary Creates custom weak password rules.
 *
 * @param request CreateCustomizedDictRequest
 * @return CreateCustomizedDictResponse
 */
CreateCustomizedDictResponse Client::createCustomizedDict(const CreateCustomizedDictRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createCustomizedDictWithOptions(request, runtime);
}

/**
 * @summary Creates a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
 *
 * @param request CreateCycleTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCycleTaskResponse
 */
CreateCycleTaskResponse Client::createCycleTaskWithOptions(const CreateCycleTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEnable()) {
    query["Enable"] = request.enable();
  }

  if (!!request.hasFirstDateStr()) {
    query["FirstDateStr"] = request.firstDateStr();
  }

  if (!!request.hasIntervalPeriod()) {
    query["IntervalPeriod"] = request.intervalPeriod();
  }

  if (!!request.hasParam()) {
    query["Param"] = request.param();
  }

  if (!!request.hasPeriodUnit()) {
    query["PeriodUnit"] = request.periodUnit();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasTargetEndTime()) {
    query["TargetEndTime"] = request.targetEndTime();
  }

  if (!!request.hasTargetStartTime()) {
    query["TargetStartTime"] = request.targetStartTime();
  }

  if (!!request.hasTaskName()) {
    query["TaskName"] = request.taskName();
  }

  if (!!request.hasTaskType()) {
    query["TaskType"] = request.taskType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateCycleTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateCycleTaskResponse>();
}

/**
 * @summary Creates a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
 *
 * @param request CreateCycleTaskRequest
 * @return CreateCycleTaskResponse
 */
CreateCycleTaskResponse Client::createCycleTask(const CreateCycleTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createCycleTaskWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI CreateDynamicDict is deprecated, please use Sas::2018-12-03::CreateCustomizedDict instead.
 *
 * @summary Creates a dynamic dictionary of weak passwords.
 *
 * @param request CreateDynamicDictRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDynamicDictResponse
 */
CreateDynamicDictResponse Client::createDynamicDictWithOptions(const CreateDynamicDictRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOverride()) {
    query["Override"] = request.override();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateDynamicDict"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateDynamicDictResponse>();
}

/**
 * @deprecated OpenAPI CreateDynamicDict is deprecated, please use Sas::2018-12-03::CreateCustomizedDict instead.
 *
 * @summary Creates a dynamic dictionary of weak passwords.
 *
 * @param request CreateDynamicDictRequest
 * @return CreateDynamicDictResponse
 */
CreateDynamicDictResponse Client::createDynamicDict(const CreateDynamicDictRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createDynamicDictWithOptions(request, runtime);
}

/**
 * @summary Pushes a file to the cloud for detection.
 *
 * @description You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request CreateFileDetectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileDetectResponse
 */
CreateFileDetectResponse Client::createFileDetectWithOptions(const CreateFileDetectRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDecompress()) {
    query["Decompress"] = request.decompress();
  }

  if (!!request.hasDecompressMaxFileCount()) {
    query["DecompressMaxFileCount"] = request.decompressMaxFileCount();
  }

  if (!!request.hasDecompressMaxLayer()) {
    query["DecompressMaxLayer"] = request.decompressMaxLayer();
  }

  if (!!request.hasDownloadUrl()) {
    query["DownloadUrl"] = request.downloadUrl();
  }

  if (!!request.hasHashKey()) {
    query["HashKey"] = request.hashKey();
  }

  if (!!request.hasOssKey()) {
    query["OssKey"] = request.ossKey();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateFileDetect"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateFileDetectResponse>();
}

/**
 * @summary Pushes a file to the cloud for detection.
 *
 * @description You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request CreateFileDetectRequest
 * @return CreateFileDetectResponse
 */
CreateFileDetectResponse Client::createFileDetect(const CreateFileDetectRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createFileDetectWithOptions(request, runtime);
}

/**
 * @summary Queries the parameters that are required to upload a file for detection.
 *
 * @description You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
 * The form upload method is provided by OSS. For more information, see [Form upload](https://help.aliyun.com/document_detail/84788.html).
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request CreateFileDetectUploadUrlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileDetectUploadUrlResponse
 */
CreateFileDetectUploadUrlResponse Client::createFileDetectUploadUrlWithOptions(const CreateFileDetectUploadUrlRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHashKeyContextList()) {
    query["HashKeyContextList"] = request.hashKeyContextList();
  }

  if (!!request.hasHashKeyList()) {
    query["HashKeyList"] = request.hashKeyList();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateFileDetectUploadUrl"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateFileDetectUploadUrlResponse>();
}

/**
 * @summary Queries the parameters that are required to upload a file for detection.
 *
 * @description You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
 * The form upload method is provided by OSS. For more information, see [Form upload](https://help.aliyun.com/document_detail/84788.html).
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request CreateFileDetectUploadUrlRequest
 * @return CreateFileDetectUploadUrlResponse
 */
CreateFileDetectUploadUrlResponse Client::createFileDetectUploadUrl(const CreateFileDetectUploadUrlRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createFileDetectUploadUrlWithOptions(request, runtime);
}

/**
 * @summary Creates a core file monitoring rule.
 *
 * @param request CreateFileProtectRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileProtectRuleResponse
 */
CreateFileProtectRuleResponse Client::createFileProtectRuleWithOptions(const CreateFileProtectRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAlertLevel()) {
    query["AlertLevel"] = request.alertLevel();
  }

  if (!!request.hasFileOps()) {
    query["FileOps"] = request.fileOps();
  }

  if (!!request.hasFilePaths()) {
    query["FilePaths"] = request.filePaths();
  }

  if (!!request.hasPlatform()) {
    query["Platform"] = request.platform();
  }

  if (!!request.hasProcPaths()) {
    query["ProcPaths"] = request.procPaths();
  }

  if (!!request.hasRuleAction()) {
    query["RuleAction"] = request.ruleAction();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasSwitchId()) {
    query["SwitchId"] = request.switchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateFileProtectRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateFileProtectRuleResponse>();
}

/**
 * @summary Creates a core file monitoring rule.
 *
 * @param request CreateFileProtectRuleRequest
 * @return CreateFileProtectRuleResponse
 */
CreateFileProtectRuleResponse Client::createFileProtectRule(const CreateFileProtectRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createFileProtectRuleWithOptions(request, runtime);
}

/**
 * @summary Specifies the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @param request CreateFileUploadLimitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileUploadLimitResponse
 */
CreateFileUploadLimitResponse Client::createFileUploadLimitWithOptions(const CreateFileUploadLimitRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLimit()) {
    query["Limit"] = request.limit();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateFileUploadLimit"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateFileUploadLimitResponse>();
}

/**
 * @summary Specifies the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @param request CreateFileUploadLimitRequest
 * @return CreateFileUploadLimitResponse
 */
CreateFileUploadLimitResponse Client::createFileUploadLimit(const CreateFileUploadLimitRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createFileUploadLimitWithOptions(request, runtime);
}

/**
 * @summary Creates a honeypot.
 *
 * @param request CreateHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHoneypotResponse
 */
CreateHoneypotResponse Client::createHoneypotWithOptions(const CreateHoneypotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneypotImageId()) {
    query["HoneypotImageId"] = request.honeypotImageId();
  }

  if (!!request.hasHoneypotImageName()) {
    query["HoneypotImageName"] = request.honeypotImageName();
  }

  if (!!request.hasHoneypotName()) {
    query["HoneypotName"] = request.honeypotName();
  }

  if (!!request.hasMeta()) {
    query["Meta"] = request.meta();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateHoneypot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateHoneypotResponse>();
}

/**
 * @summary Creates a honeypot.
 *
 * @param request CreateHoneypotRequest
 * @return CreateHoneypotResponse
 */
CreateHoneypotResponse Client::createHoneypot(const CreateHoneypotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createHoneypotWithOptions(request, runtime);
}

/**
 * @summary Creates a management node.
 *
 * @param request CreateHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHoneypotNodeResponse
 */
CreateHoneypotNodeResponse Client::createHoneypotNodeWithOptions(const CreateHoneypotNodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllowHoneypotAccessInternet()) {
    query["AllowHoneypotAccessInternet"] = request.allowHoneypotAccessInternet();
  }

  if (!!request.hasAvailableProbeNum()) {
    query["AvailableProbeNum"] = request.availableProbeNum();
  }

  if (!!request.hasNodeName()) {
    query["NodeName"] = request.nodeName();
  }

  if (!!request.hasSecurityGroupProbeIpList()) {
    query["SecurityGroupProbeIpList"] = request.securityGroupProbeIpList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateHoneypotNode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateHoneypotNodeResponse>();
}

/**
 * @summary Creates a management node.
 *
 * @param request CreateHoneypotNodeRequest
 * @return CreateHoneypotNodeResponse
 */
CreateHoneypotNodeResponse Client::createHoneypotNode(const CreateHoneypotNodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createHoneypotNodeWithOptions(request, runtime);
}

/**
 * @summary Creates a honeypot template.
 *
 * @param request CreateHoneypotPresetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHoneypotPresetResponse
 */
CreateHoneypotPresetResponse Client::createHoneypotPresetWithOptions(const CreateHoneypotPresetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneypotImageName()) {
    query["HoneypotImageName"] = request.honeypotImageName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMeta()) {
    query["Meta"] = request.meta();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  if (!!request.hasPresetName()) {
    query["PresetName"] = request.presetName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateHoneypotPreset"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateHoneypotPresetResponse>();
}

/**
 * @summary Creates a honeypot template.
 *
 * @param request CreateHoneypotPresetRequest
 * @return CreateHoneypotPresetResponse
 */
CreateHoneypotPresetResponse Client::createHoneypotPreset(const CreateHoneypotPresetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createHoneypotPresetWithOptions(request, runtime);
}

/**
 * @summary Creates a probe.
 *
 * @param request CreateHoneypotProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHoneypotProbeResponse
 */
CreateHoneypotProbeResponse Client::createHoneypotProbeWithOptions(const CreateHoneypotProbeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasArp()) {
    query["Arp"] = request.arp();
  }

  if (!!request.hasBusinessGroupId()) {
    query["BusinessGroupId"] = request.businessGroupId();
  }

  if (!!request.hasControlNodeId()) {
    query["ControlNodeId"] = request.controlNodeId();
  }

  if (!!request.hasDisplayName()) {
    query["DisplayName"] = request.displayName();
  }

  if (!!request.hasHoneypotBindList()) {
    query["HoneypotBindList"] = request.honeypotBindList();
  }

  if (!!request.hasPing()) {
    query["Ping"] = request.ping();
  }

  if (!!request.hasProbeType()) {
    query["ProbeType"] = request.probeType();
  }

  if (!!request.hasProbeVersion()) {
    query["ProbeVersion"] = request.probeVersion();
  }

  if (!!request.hasProxyIp()) {
    query["ProxyIp"] = request.proxyIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateHoneypotProbe"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateHoneypotProbeResponse>();
}

/**
 * @summary Creates a probe.
 *
 * @param request CreateHoneypotProbeRequest
 * @return CreateHoneypotProbeResponse
 */
CreateHoneypotProbeResponse Client::createHoneypotProbe(const CreateHoneypotProbeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createHoneypotProbeWithOptions(request, runtime);
}

/**
 * @summary Creates a monitoring or forwarding service for a probe.
 *
 * @param request CreateHoneypotProbeBindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHoneypotProbeBindResponse
 */
CreateHoneypotProbeBindResponse Client::createHoneypotProbeBindWithOptions(const CreateHoneypotProbeBindRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBindPortList()) {
    query["BindPortList"] = request.bindPortList();
  }

  if (!!request.hasHoneypotId()) {
    query["HoneypotId"] = request.honeypotId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasProbeId()) {
    query["ProbeId"] = request.probeId();
  }

  if (!!request.hasServiceIpList()) {
    query["ServiceIpList"] = request.serviceIpList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateHoneypotProbeBind"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateHoneypotProbeBindResponse>();
}

/**
 * @summary Creates a monitoring or forwarding service for a probe.
 *
 * @param request CreateHoneypotProbeBindRequest
 * @return CreateHoneypotProbeBindResponse
 */
CreateHoneypotProbeBindResponse Client::createHoneypotProbeBind(const CreateHoneypotProbeBindRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createHoneypotProbeBindWithOptions(request, runtime);
}

/**
 * @summary Creates a hybrid-cloud proxy cluster.
 *
 * @param request CreateHybridProxyClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateHybridProxyClusterResponse
 */
CreateHybridProxyClusterResponse Client::createHybridProxyClusterWithOptions(const CreateHybridProxyClusterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasIp()) {
    query["Ip"] = request.ip();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateHybridProxyCluster"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateHybridProxyClusterResponse>();
}

/**
 * @summary Creates a hybrid-cloud proxy cluster.
 *
 * @param request CreateHybridProxyClusterRequest
 * @return CreateHybridProxyClusterResponse
 */
CreateHybridProxyClusterResponse Client::createHybridProxyCluster(const CreateHybridProxyClusterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createHybridProxyClusterWithOptions(request, runtime);
}

/**
 * @summary Creates a defense rule in the container firewall module.
 *
 * @param tmpReq CreateInterceptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateInterceptionRuleResponse
 */
CreateInterceptionRuleResponse Client::createInterceptionRuleWithOptions(const CreateInterceptionRuleRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  CreateInterceptionRuleShrinkRequest request = CreateInterceptionRuleShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasDstTargetList()) {
    request.setDstTargetListShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.dstTargetList(), "DstTargetList", "json"));
  }

  if (!!tmpReq.hasSrcTarget()) {
    request.setSrcTargetShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.srcTarget(), "SrcTarget", "json"));
  }

  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasDstTargetListShrink()) {
    query["DstTargetList"] = request.dstTargetListShrink();
  }

  if (!!request.hasInterceptType()) {
    query["InterceptType"] = request.interceptType();
  }

  if (!!request.hasOrderIndex()) {
    query["OrderIndex"] = request.orderIndex();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasRuleSwitch()) {
    query["RuleSwitch"] = request.ruleSwitch();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  if (!!request.hasSrcTargetShrink()) {
    query["SrcTarget"] = request.srcTargetShrink();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateInterceptionRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateInterceptionRuleResponse>();
}

/**
 * @summary Creates a defense rule in the container firewall module.
 *
 * @param request CreateInterceptionRuleRequest
 * @return CreateInterceptionRuleResponse
 */
CreateInterceptionRuleResponse Client::createInterceptionRule(const CreateInterceptionRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createInterceptionRuleWithOptions(request, runtime);
}

/**
 * @summary Creates a defense object.
 *
 * @param request CreateInterceptionTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateInterceptionTargetResponse
 */
CreateInterceptionTargetResponse Client::createInterceptionTargetWithOptions(const CreateInterceptionTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppName()) {
    query["AppName"] = request.appName();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasImageList()) {
    query["ImageList"] = request.imageList();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasTagList()) {
    query["TagList"] = request.tagList();
  }

  if (!!request.hasTargetName()) {
    query["TargetName"] = request.targetName();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateInterceptionTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateInterceptionTargetResponse>();
}

/**
 * @summary Creates a defense object.
 *
 * @param request CreateInterceptionTargetRequest
 * @return CreateInterceptionTargetResponse
 */
CreateInterceptionTargetResponse Client::createInterceptionTarget(const CreateInterceptionTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createInterceptionTargetWithOptions(request, runtime);
}

/**
 * @summary Creates a Jenkins image repository.
 *
 * @param request CreateJenkinsImageRegistryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateJenkinsImageRegistryResponse
 */
CreateJenkinsImageRegistryResponse Client::createJenkinsImageRegistryWithOptions(const CreateJenkinsImageRegistryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  json body = {};
  if (!!request.hasDomainName()) {
    body["DomainName"] = request.domainName();
  }

  if (!!request.hasExtraParam()) {
    body["ExtraParam"] = request.extraParam();
  }

  if (!!request.hasNetType()) {
    body["NetType"] = request.netType();
  }

  if (!!request.hasPassword()) {
    body["Password"] = request.password();
  }

  if (!!request.hasPersistenceDay()) {
    body["PersistenceDay"] = request.persistenceDay();
  }

  if (!!request.hasProtocolType()) {
    body["ProtocolType"] = request.protocolType();
  }

  if (!!request.hasRegionId()) {
    body["RegionId"] = request.regionId();
  }

  if (!!request.hasRegistryHostIp()) {
    body["RegistryHostIp"] = request.registryHostIp();
  }

  if (!!request.hasRegistryName()) {
    body["RegistryName"] = request.registryName();
  }

  if (!!request.hasRegistryType()) {
    body["RegistryType"] = request.registryType();
  }

  if (!!request.hasRegistryVersion()) {
    body["RegistryVersion"] = request.registryVersion();
  }

  if (!!request.hasTransPerHour()) {
    body["TransPerHour"] = request.transPerHour();
  }

  if (!!request.hasUserName()) {
    body["UserName"] = request.userName();
  }

  if (!!request.hasVpcId()) {
    body["VpcId"] = request.vpcId();
  }

  if (!!request.hasWhiteList()) {
    body["WhiteList"] = request.whiteList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "CreateJenkinsImageRegistry"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateJenkinsImageRegistryResponse>();
}

/**
 * @summary Creates a Jenkins image repository.
 *
 * @param request CreateJenkinsImageRegistryRequest
 * @return CreateJenkinsImageRegistryResponse
 */
CreateJenkinsImageRegistryResponse Client::createJenkinsImageRegistry(const CreateJenkinsImageRegistryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createJenkinsImageRegistryWithOptions(request, runtime);
}

/**
 * @summary Creates a Jenkins scan task.
 *
 * @param request CreateJenkinsImageScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateJenkinsImageScanTaskResponse
 */
CreateJenkinsImageScanTaskResponse Client::createJenkinsImageScanTaskWithOptions(const CreateJenkinsImageScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasJenkinsEnv()) {
    query["JenkinsEnv"] = request.jenkinsEnv();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  json body = {};
  if (!!request.hasDigest()) {
    body["Digest"] = request.digest();
  }

  if (!!request.hasImageCreate()) {
    body["ImageCreate"] = request.imageCreate();
  }

  if (!!request.hasImageId()) {
    body["ImageId"] = request.imageId();
  }

  if (!!request.hasImageSize()) {
    body["ImageSize"] = request.imageSize();
  }

  if (!!request.hasImageUpdate()) {
    body["ImageUpdate"] = request.imageUpdate();
  }

  if (!!request.hasNamespace()) {
    body["Namespace"] = request._namespace();
  }

  if (!!request.hasRepoName()) {
    body["RepoName"] = request.repoName();
  }

  if (!!request.hasTag()) {
    body["Tag"] = request.tag();
  }

  if (!!request.hasToken()) {
    body["Token"] = request.token();
  }

  if (!!request.hasUuid()) {
    body["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "CreateJenkinsImageScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateJenkinsImageScanTaskResponse>();
}

/**
 * @summary Creates a Jenkins scan task.
 *
 * @param request CreateJenkinsImageScanTaskRequest
 * @return CreateJenkinsImageScanTaskResponse
 */
CreateJenkinsImageScanTaskResponse Client::createJenkinsImageScanTask(const CreateJenkinsImageScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createJenkinsImageScanTaskWithOptions(request, runtime);
}

/**
 * @summary Creates an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request CreateMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMaliciousFileWhitelistConfigResponse
 */
CreateMaliciousFileWhitelistConfigResponse Client::createMaliciousFileWhitelistConfigWithOptions(const CreateMaliciousFileWhitelistConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventName()) {
    query["EventName"] = request.eventName();
  }

  if (!!request.hasField()) {
    query["Field"] = request.field();
  }

  if (!!request.hasFieldValue()) {
    query["FieldValue"] = request.fieldValue();
  }

  if (!!request.hasOperator()) {
    query["Operator"] = request._operator();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasTargetValue()) {
    query["TargetValue"] = request.targetValue();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateMaliciousFileWhitelistConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateMaliciousFileWhitelistConfigResponse>();
}

/**
 * @summary Creates an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request CreateMaliciousFileWhitelistConfigRequest
 * @return CreateMaliciousFileWhitelistConfigResponse
 */
CreateMaliciousFileWhitelistConfigResponse Client::createMaliciousFileWhitelistConfig(const CreateMaliciousFileWhitelistConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

/**
 * @summary Adds remarks to alert events for agentless detection.
 *
 * @param request CreateMaliciousNoteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMaliciousNoteResponse
 */
CreateMaliciousNoteResponse Client::createMaliciousNoteWithOptions(const CreateMaliciousNoteRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventId()) {
    query["EventId"] = request.eventId();
  }

  if (!!request.hasNote()) {
    query["Note"] = request.note();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateMaliciousNote"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateMaliciousNoteResponse>();
}

/**
 * @summary Adds remarks to alert events for agentless detection.
 *
 * @param request CreateMaliciousNoteRequest
 * @return CreateMaliciousNoteResponse
 */
CreateMaliciousNoteResponse Client::createMaliciousNote(const CreateMaliciousNoteRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createMaliciousNoteWithOptions(request, runtime);
}

/**
 * @summary Creates a list of members of the account monitored by Security Center type by using the multi-account management feature.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @param request CreateMonitorAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMonitorAccountResponse
 */
CreateMonitorAccountResponse Client::createMonitorAccountWithOptions(const CreateMonitorAccountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAccountIds()) {
    query["AccountIds"] = request.accountIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateMonitorAccount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateMonitorAccountResponse>();
}

/**
 * @summary Creates a list of members of the account monitored by Security Center type by using the multi-account management feature.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @param request CreateMonitorAccountRequest
 * @return CreateMonitorAccountResponse
 */
CreateMonitorAccountResponse Client::createMonitorAccount(const CreateMonitorAccountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createMonitorAccountWithOptions(request, runtime);
}

/**
 * @summary Installs the components that are required by at-risk image blocking. The components are policy-template-controller, gatekeeper, and logtail-ds.
 *
 * @param request CreateOpaClusterPluginRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOpaClusterPluginResponse
 */
CreateOpaClusterPluginResponse Client::createOpaClusterPluginWithOptions(const CreateOpaClusterPluginRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterIds()) {
    query["ClusterIds"] = request.clusterIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateOpaClusterPlugin"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateOpaClusterPluginResponse>();
}

/**
 * @summary Installs the components that are required by at-risk image blocking. The components are policy-template-controller, gatekeeper, and logtail-ds.
 *
 * @param request CreateOpaClusterPluginRequest
 * @return CreateOpaClusterPluginResponse
 */
CreateOpaClusterPluginResponse Client::createOpaClusterPlugin(const CreateOpaClusterPluginRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createOpaClusterPluginWithOptions(request, runtime);
}

/**
 * @summary Creates a rule to block at-risk images.
 *
 * @param tmpReq CreateOpaStrategyNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOpaStrategyNewResponse
 */
CreateOpaStrategyNewResponse Client::createOpaStrategyNewWithOptions(const CreateOpaStrategyNewRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  CreateOpaStrategyNewShrinkRequest request = CreateOpaStrategyNewShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasAlarmDetail()) {
    request.setAlarmDetailShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.alarmDetail(), "AlarmDetail", "json"));
  }

  json query = {};
  if (!!request.hasAlarmDetailShrink()) {
    query["AlarmDetail"] = request.alarmDetailShrink();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasImageName()) {
    query["ImageName"] = request.imageName();
  }

  if (!!request.hasLabel()) {
    query["Label"] = request.label();
  }

  if (!!request.hasMaliciousImage()) {
    query["MaliciousImage"] = request.maliciousImage();
  }

  if (!!request.hasRuleAction()) {
    query["RuleAction"] = request.ruleAction();
  }

  if (!!request.hasScopes()) {
    query["Scopes"] = request.scopes();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasStrategyName()) {
    query["StrategyName"] = request.strategyName();
  }

  if (!!request.hasStrategyTemplateId()) {
    query["StrategyTemplateId"] = request.strategyTemplateId();
  }

  if (!!request.hasUnScanedImage()) {
    query["UnScanedImage"] = request.unScanedImage();
  }

  if (!!request.hasWhiteList()) {
    query["WhiteList"] = request.whiteList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateOpaStrategyNew"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateOpaStrategyNewResponse>();
}

/**
 * @summary Creates a rule to block at-risk images.
 *
 * @param request CreateOpaStrategyNewRequest
 * @return CreateOpaStrategyNewResponse
 */
CreateOpaStrategyNewResponse Client::createOpaStrategyNew(const CreateOpaStrategyNewRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createOpaStrategyNewWithOptions(request, runtime);
}

/**
 * @summary Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
 *
 * @description A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
 *
 * @param request CreateOrUpdateAssetGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrUpdateAssetGroupResponse
 */
CreateOrUpdateAssetGroupResponse Client::createOrUpdateAssetGroupWithOptions(const CreateOrUpdateAssetGroupRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasGroupName()) {
    query["GroupName"] = request.groupName();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateOrUpdateAssetGroup"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateOrUpdateAssetGroupResponse>();
}

/**
 * @summary Modifies the mapping between an asset and an asset group. For example, you can call this operation to modify the server group to which the asset belongs or the asset list of the asset group.
 *
 * @description A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
 *
 * @param request CreateOrUpdateAssetGroupRequest
 * @return CreateOrUpdateAssetGroupResponse
 */
CreateOrUpdateAssetGroupResponse Client::createOrUpdateAssetGroup(const CreateOrUpdateAssetGroupRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createOrUpdateAssetGroupWithOptions(request, runtime);
}

/**
 * @summary Creates an asset auto-tagging rule or modifies an asset auto-tagging rule that is created on the Asset Management Rule tab.
 *
 * @param request CreateOrUpdateAutoTagRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrUpdateAutoTagRuleResponse
 */
CreateOrUpdateAutoTagRuleResponse Client::createOrUpdateAutoTagRuleWithOptions(const CreateOrUpdateAutoTagRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckAll()) {
    query["CheckAll"] = request.checkAll();
  }

  if (!!request.hasExpression()) {
    query["Expression"] = request.expression();
  }

  if (!!request.hasRuleDesc()) {
    query["RuleDesc"] = request.ruleDesc();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasTagContext()) {
    query["TagContext"] = request.tagContext();
  }

  if (!!request.hasTagType()) {
    query["TagType"] = request.tagType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateOrUpdateAutoTagRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateOrUpdateAutoTagRuleResponse>();
}

/**
 * @summary Creates an asset auto-tagging rule or modifies an asset auto-tagging rule that is created on the Asset Management Rule tab.
 *
 * @param request CreateOrUpdateAutoTagRuleRequest
 * @return CreateOrUpdateAutoTagRuleResponse
 */
CreateOrUpdateAutoTagRuleResponse Client::createOrUpdateAutoTagRule(const CreateOrUpdateAutoTagRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createOrUpdateAutoTagRuleWithOptions(request, runtime);
}

/**
 * @summary Creates or modifies a DingTalk chatbot that sends notifications.
 *
 * @param request CreateOrUpdateDingTalkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrUpdateDingTalkResponse
 */
CreateOrUpdateDingTalkResponse Client::createOrUpdateDingTalkWithOptions(const CreateOrUpdateDingTalkRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigList()) {
    query["ConfigList"] = request.configList();
  }

  if (!!request.hasDingTalkLang()) {
    query["DingTalkLang"] = request.dingTalkLang();
  }

  if (!!request.hasGroupIdList()) {
    query["GroupIdList"] = request.groupIdList();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasIntervalTime()) {
    query["IntervalTime"] = request.intervalTime();
  }

  if (!!request.hasRuleActionName()) {
    query["RuleActionName"] = request.ruleActionName();
  }

  if (!!request.hasSendUrl()) {
    query["SendUrl"] = request.sendUrl();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateOrUpdateDingTalk"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateOrUpdateDingTalkResponse>();
}

/**
 * @summary Creates or modifies a DingTalk chatbot that sends notifications.
 *
 * @param request CreateOrUpdateDingTalkRequest
 * @return CreateOrUpdateDingTalkResponse
 */
CreateOrUpdateDingTalkResponse Client::createOrUpdateDingTalk(const CreateOrUpdateDingTalkRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createOrUpdateDingTalkWithOptions(request, runtime);
}

/**
 * @summary Creates a bucket check task.
 *
 * @param request CreateOssBucketScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOssBucketScanTaskResponse
 */
CreateOssBucketScanTaskResponse Client::createOssBucketScanTaskWithOptions(const CreateOssBucketScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllKeyPrefix()) {
    query["AllKeyPrefix"] = request.allKeyPrefix();
  }

  if (!!request.hasBucketNameList()) {
    query["BucketNameList"] = request.bucketNameList();
  }

  if (!!request.hasDecompressMaxFileCount()) {
    query["DecompressMaxFileCount"] = request.decompressMaxFileCount();
  }

  if (!!request.hasDecompressMaxLayer()) {
    query["DecompressMaxLayer"] = request.decompressMaxLayer();
  }

  if (!!request.hasDecryptionList()) {
    query["DecryptionList"] = request.decryptionList();
  }

  if (!!request.hasExcludeKeySuffixList()) {
    query["ExcludeKeySuffixList"] = request.excludeKeySuffixList();
  }

  if (!!request.hasKeyPrefixList()) {
    query["KeyPrefixList"] = request.keyPrefixList();
  }

  if (!!request.hasKeySuffixList()) {
    query["KeySuffixList"] = request.keySuffixList();
  }

  if (!!request.hasLastModifiedStartTime()) {
    query["LastModifiedStartTime"] = request.lastModifiedStartTime();
  }

  if (!!request.hasScanMode()) {
    query["ScanMode"] = request.scanMode();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateOssBucketScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateOssBucketScanTaskResponse>();
}

/**
 * @summary Creates a bucket check task.
 *
 * @param request CreateOssBucketScanTaskRequest
 * @return CreateOssBucketScanTaskResponse
 */
CreateOssBucketScanTaskResponse Client::createOssBucketScanTask(const CreateOssBucketScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createOssBucketScanTaskWithOptions(request, runtime);
}

/**
 * @summary Creates a policy for detecting malicious Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
 *
 * @param request CreateOssScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOssScanConfigResponse
 */
CreateOssScanConfigResponse Client::createOssScanConfigWithOptions(const CreateOssScanConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllKeyPrefix()) {
    query["AllKeyPrefix"] = request.allKeyPrefix();
  }

  if (!!request.hasBucketNameList()) {
    query["BucketNameList"] = request.bucketNameList();
  }

  if (!!request.hasDecompressMaxFileCount()) {
    query["DecompressMaxFileCount"] = request.decompressMaxFileCount();
  }

  if (!!request.hasDecompressMaxLayer()) {
    query["DecompressMaxLayer"] = request.decompressMaxLayer();
  }

  if (!!request.hasDecryptionList()) {
    query["DecryptionList"] = request.decryptionList();
  }

  if (!!request.hasEnable()) {
    query["Enable"] = request.enable();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasKeyPrefixList()) {
    query["KeyPrefixList"] = request.keyPrefixList();
  }

  if (!!request.hasKeySuffixList()) {
    query["KeySuffixList"] = request.keySuffixList();
  }

  if (!!request.hasLastModifiedStartTime()) {
    query["LastModifiedStartTime"] = request.lastModifiedStartTime();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasRealTimeIncr()) {
    query["RealTimeIncr"] = request.realTimeIncr();
  }

  if (!!request.hasScanDayList()) {
    query["ScanDayList"] = request.scanDayList();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateOssScanConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateOssScanConfigResponse>();
}

/**
 * @summary Creates a policy for detecting malicious Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
 *
 * @param request CreateOssScanConfigRequest
 * @return CreateOssScanConfigResponse
 */
CreateOssScanConfigResponse Client::createOssScanConfig(const CreateOssScanConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createOssScanConfigWithOptions(request, runtime);
}

/**
 * @summary Creates an automatic account management policy for members of the account monitored by Security Center type by using the multi-account management feature. After the policy is created, the members that are newly added to the specified resource directory are automatically added to the list of members of the account monitored by Security Center type.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @param request CreateRdDefaultSyncListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRdDefaultSyncListResponse
 */
CreateRdDefaultSyncListResponse Client::createRdDefaultSyncListWithOptions(const CreateRdDefaultSyncListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFolderIds()) {
    query["FolderIds"] = request.folderIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateRdDefaultSyncList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateRdDefaultSyncListResponse>();
}

/**
 * @summary Creates an automatic account management policy for members of the account monitored by Security Center type by using the multi-account management feature. After the policy is created, the members that are newly added to the specified resource directory are automatically added to the list of members of the account monitored by Security Center type.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @param request CreateRdDefaultSyncListRequest
 * @return CreateRdDefaultSyncListResponse
 */
CreateRdDefaultSyncListResponse Client::createRdDefaultSyncList(const CreateRdDefaultSyncListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createRdDefaultSyncListWithOptions(request, runtime);
}

/**
 * @summary Creates a restoration task.
 *
 * @param request CreateRestoreJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRestoreJobResponse
 */
CreateRestoreJobResponse Client::createRestoreJobWithOptions(const CreateRestoreJobRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIncludes()) {
    query["Includes"] = request.includes();
  }

  if (!!request.hasSnapshotHash()) {
    query["SnapshotHash"] = request.snapshotHash();
  }

  if (!!request.hasSnapshotId()) {
    query["SnapshotId"] = request.snapshotId();
  }

  if (!!request.hasSnapshotVersion()) {
    query["SnapshotVersion"] = request.snapshotVersion();
  }

  if (!!request.hasSourceType()) {
    query["SourceType"] = request.sourceType();
  }

  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  if (!!request.hasVaultId()) {
    query["VaultId"] = request.vaultId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateRestoreJob"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateRestoreJobResponse>();
}

/**
 * @summary Creates a restoration task.
 *
 * @param request CreateRestoreJobRequest
 * @return CreateRestoreJobResponse
 */
CreateRestoreJobResponse Client::createRestoreJob(const CreateRestoreJobRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createRestoreJobWithOptions(request, runtime);
}

/**
 * @summary Applies for a trial of Security Center.
 *
 * @param tmpReq CreateSasTrialRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSasTrialResponse
 */
CreateSasTrialResponse Client::createSasTrialWithOptions(const CreateSasTrialRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  CreateSasTrialShrinkRequest request = CreateSasTrialShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasRequestForm()) {
    request.setRequestFormShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.requestForm(), "RequestForm", "json"));
  }

  json body = {};
  if (!!request.hasFromEcs()) {
    body["FromEcs"] = request.fromEcs();
  }

  if (!!request.hasLang()) {
    body["Lang"] = request.lang();
  }

  if (!!request.hasRequestFormShrink()) {
    body["RequestForm"] = request.requestFormShrink();
  }

  if (!!request.hasTryType()) {
    body["TryType"] = request.tryType();
  }

  if (!!request.hasTryVersion()) {
    body["TryVersion"] = request.tryVersion();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"body" , Utils::Utils::parseToMap(body)}
  }).get<map<string, json>>());
  Params params = Params(json({
    {"action" , "CreateSasTrial"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateSasTrialResponse>();
}

/**
 * @summary Applies for a trial of Security Center.
 *
 * @param request CreateSasTrialRequest
 * @return CreateSasTrialResponse
 */
CreateSasTrialResponse Client::createSasTrial(const CreateSasTrialRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createSasTrialWithOptions(request, runtime);
}

/**
 * @summary Creates a service-linked role and authorizes Security Center to access cloud resources.
 *
 * @description For more information about service-linked roles, see [Service-linked roles](https://help.aliyun.com/document_detail/160674.html).
 *
 * @param request CreateServiceLinkedRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceLinkedRoleResponse
 */
CreateServiceLinkedRoleResponse Client::createServiceLinkedRoleWithOptions(const CreateServiceLinkedRoleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasServiceLinkedRole()) {
    query["ServiceLinkedRole"] = request.serviceLinkedRole();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateServiceLinkedRole"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateServiceLinkedRoleResponse>();
}

/**
 * @summary Creates a service-linked role and authorizes Security Center to access cloud resources.
 *
 * @description For more information about service-linked roles, see [Service-linked roles](https://help.aliyun.com/document_detail/160674.html).
 *
 * @param request CreateServiceLinkedRoleRequest
 * @return CreateServiceLinkedRoleResponse
 */
CreateServiceLinkedRoleResponse Client::createServiceLinkedRole(const CreateServiceLinkedRoleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createServiceLinkedRoleWithOptions(request, runtime);
}

/**
 * @summary Create a service trail.
 *
 * @param request CreateServiceTrailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceTrailResponse
 */
CreateServiceTrailResponse Client::createServiceTrailWithOptions(const CreateServiceTrailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateServiceTrail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateServiceTrailResponse>();
}

/**
 * @summary Create a service trail.
 *
 * @param request CreateServiceTrailRequest
 * @return CreateServiceTrailResponse
 */
CreateServiceTrailResponse Client::createServiceTrail(const CreateServiceTrailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createServiceTrailWithOptions(request, runtime);
}

/**
 * @summary Creates a task to query alert events that are triggered by the same rule or of the same alert type.
 *
 * @param request CreateSimilarSecurityEventsQueryTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSimilarSecurityEventsQueryTaskResponse
 */
CreateSimilarSecurityEventsQueryTaskResponse Client::createSimilarSecurityEventsQueryTaskWithOptions(const CreateSimilarSecurityEventsQueryTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityEventId()) {
    query["SecurityEventId"] = request.securityEventId();
  }

  if (!!request.hasSimilarEventScenarioCode()) {
    query["SimilarEventScenarioCode"] = request.similarEventScenarioCode();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateSimilarSecurityEventsQueryTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateSimilarSecurityEventsQueryTaskResponse>();
}

/**
 * @summary Creates a task to query alert events that are triggered by the same rule or of the same alert type.
 *
 * @param request CreateSimilarSecurityEventsQueryTaskRequest
 * @return CreateSimilarSecurityEventsQueryTaskResponse
 */
CreateSimilarSecurityEventsQueryTaskResponse Client::createSimilarSecurityEventsQueryTask(const CreateSimilarSecurityEventsQueryTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createSimilarSecurityEventsQueryTaskWithOptions(request, runtime);
}

/**
 * @summary Creates a task on the My Policies tab of the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request CreateSoarStrategyTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSoarStrategyTaskResponse
 */
CreateSoarStrategyTaskResponse Client::createSoarStrategyTaskWithOptions(const CreateSoarStrategyTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasStrategyName()) {
    query["StrategyName"] = request.strategyName();
  }

  if (!!request.hasStrategyTaskName()) {
    query["StrategyTaskName"] = request.strategyTaskName();
  }

  if (!!request.hasStrategyTaskParams()) {
    query["StrategyTaskParams"] = request.strategyTaskParams();
  }

  if (!!request.hasStrategyTaskPlanExeTime()) {
    query["StrategyTaskPlanExeTime"] = request.strategyTaskPlanExeTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateSoarStrategyTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateSoarStrategyTaskResponse>();
}

/**
 * @summary Creates a task on the My Policies tab of the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request CreateSoarStrategyTaskRequest
 * @return CreateSoarStrategyTaskResponse
 */
CreateSoarStrategyTaskResponse Client::createSoarStrategyTask(const CreateSoarStrategyTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createSoarStrategyTaskWithOptions(request, runtime);
}

/**
 * @summary Adds remarks to an alert event.
 *
 * @param request CreateSuspEventNoteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSuspEventNoteResponse
 */
CreateSuspEventNoteResponse Client::createSuspEventNoteWithOptions(const CreateSuspEventNoteRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventId()) {
    query["EventId"] = request.eventId();
  }

  if (!!request.hasNote()) {
    query["Note"] = request.note();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateSuspEventNote"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateSuspEventNoteResponse>();
}

/**
 * @summary Adds remarks to an alert event.
 *
 * @param request CreateSuspEventNoteRequest
 * @return CreateSuspEventNoteResponse
 */
CreateSuspEventNoteResponse Client::createSuspEventNote(const CreateSuspEventNoteRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createSuspEventNoteWithOptions(request, runtime);
}

/**
 * @summary Creates an anti-ransomware policy for a database.
 *
 * @param tmpReq CreateUniBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUniBackupPolicyResponse
 */
CreateUniBackupPolicyResponse Client::createUniBackupPolicyWithOptions(const CreateUniBackupPolicyRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  CreateUniBackupPolicyShrinkRequest request = CreateUniBackupPolicyShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasFullPlan()) {
    request.setFullPlanShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.fullPlan(), "FullPlan", "json"));
  }

  if (!!tmpReq.hasIncPlan()) {
    request.setIncPlanShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.incPlan(), "IncPlan", "json"));
  }

  json query = {};
  if (!!request.hasAccountName()) {
    query["AccountName"] = request.accountName();
  }

  if (!!request.hasAccountPassword()) {
    query["AccountPassword"] = request.accountPassword();
  }

  if (!!request.hasDatabaseAddByUser()) {
    query["DatabaseAddByUser"] = request.databaseAddByUser();
  }

  if (!!request.hasDatabaseType()) {
    query["DatabaseType"] = request.databaseType();
  }

  if (!!request.hasFullPlanShrink()) {
    query["FullPlan"] = request.fullPlanShrink();
  }

  if (!!request.hasIncPlanShrink()) {
    query["IncPlan"] = request.incPlanShrink();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasPolicyName()) {
    query["PolicyName"] = request.policyName();
  }

  if (!!request.hasRetention()) {
    query["Retention"] = request.retention();
  }

  if (!!request.hasSpeedLimiter()) {
    query["SpeedLimiter"] = request.speedLimiter();
  }

  if (!!request.hasUniRegionId()) {
    query["UniRegionId"] = request.uniRegionId();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateUniBackupPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateUniBackupPolicyResponse>();
}

/**
 * @summary Creates an anti-ransomware policy for a database.
 *
 * @param request CreateUniBackupPolicyRequest
 * @return CreateUniBackupPolicyResponse
 */
CreateUniBackupPolicyResponse Client::createUniBackupPolicy(const CreateUniBackupPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createUniBackupPolicyWithOptions(request, runtime);
}

/**
 * @summary Creates a restoration task for a database.
 *
 * @param request CreateUniRestorePlanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUniRestorePlanResponse
 */
CreateUniRestorePlanResponse Client::createUniRestorePlanWithOptions(const CreateUniRestorePlanRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDatabase()) {
    query["Database"] = request.database();
  }

  if (!!request.hasInstanceUuid()) {
    query["InstanceUuid"] = request.instanceUuid();
  }

  if (!!request.hasPolicyId()) {
    query["PolicyId"] = request.policyId();
  }

  if (!!request.hasResetScn()) {
    query["ResetScn"] = request.resetScn();
  }

  if (!!request.hasResetTime()) {
    query["ResetTime"] = request.resetTime();
  }

  if (!!request.hasRestoreInfo()) {
    query["RestoreInfo"] = request.restoreInfo();
  }

  if (!!request.hasTimePoint()) {
    query["TimePoint"] = request.timePoint();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateUniRestorePlan"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateUniRestorePlanResponse>();
}

/**
 * @summary Creates a restoration task for a database.
 *
 * @param request CreateUniRestorePlanRequest
 * @return CreateUniRestorePlanResponse
 */
CreateUniRestorePlanResponse Client::createUniRestorePlan(const CreateUniRestorePlanRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createUniRestorePlanWithOptions(request, runtime);
}

/**
 * @summary Creates the risk level settings for baseline check items.
 *
 * @param request CreateUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUserSettingResponse
 */
CreateUserSettingResponse Client::createUserSettingWithOptions(const CreateUserSettingRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAlertLevels()) {
    query["AlertLevels"] = request.alertLevels();
  }

  if (!!request.hasInvalidWarningKeepDays()) {
    query["InvalidWarningKeepDays"] = request.invalidWarningKeepDays();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateUserSetting"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateUserSettingResponse>();
}

/**
 * @summary Creates the risk level settings for baseline check items.
 *
 * @param request CreateUserSettingRequest
 * @return CreateUserSettingResponse
 */
CreateUserSettingResponse Client::createUserSetting(const CreateUserSettingRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createUserSettingWithOptions(request, runtime);
}

/**
 * @summary Creates a one-time virus scan task that is immediately executed.
 *
 * @param request CreateVirusScanOnceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVirusScanOnceTaskResponse
 */
CreateVirusScanOnceTaskResponse Client::createVirusScanOnceTaskWithOptions(const CreateVirusScanOnceTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasParam()) {
    query["Param"] = request.param();
  }

  if (!!request.hasScanPath()) {
    query["ScanPath"] = request.scanPath();
  }

  if (!!request.hasScanType()) {
    query["ScanType"] = request.scanType();
  }

  if (!!request.hasSelectionKey()) {
    query["SelectionKey"] = request.selectionKey();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVirusScanOnceTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVirusScanOnceTaskResponse>();
}

/**
 * @summary Creates a one-time virus scan task that is immediately executed.
 *
 * @param request CreateVirusScanOnceTaskRequest
 * @return CreateVirusScanOnceTaskResponse
 */
CreateVirusScanOnceTaskResponse Client::createVirusScanOnceTask(const CreateVirusScanOnceTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVirusScanOnceTaskWithOptions(request, runtime);
}

/**
 * @summary Creates a list of vulnerabilities that can be automatically fixed. After the list is created, you can select the list when you create a vulnerability fixing task on the Playbook page.
 *
 * @param request CreateVulAutoRepairConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVulAutoRepairConfigResponse
 */
CreateVulAutoRepairConfigResponse Client::createVulAutoRepairConfigWithOptions(const CreateVulAutoRepairConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasReason()) {
    query["Reason"] = request.reason();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasVulAutoRepairConfigList()) {
    query["VulAutoRepairConfigList"] = request.vulAutoRepairConfigList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "CreateVulAutoRepairConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<CreateVulAutoRepairConfigResponse>();
}

/**
 * @summary Creates a list of vulnerabilities that can be automatically fixed. After the list is created, you can select the list when you create a vulnerability fixing task on the Playbook page.
 *
 * @param request CreateVulAutoRepairConfigRequest
 * @return CreateVulAutoRepairConfigResponse
 */
CreateVulAutoRepairConfigResponse Client::createVulAutoRepairConfig(const CreateVulAutoRepairConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return createVulAutoRepairConfigWithOptions(request, runtime);
}

/**
 * @summary Deletes the specified defense rules against brute-force attacks.
 *
 * @param request DeleteAntiBruteForceRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAntiBruteForceRuleResponse
 */
DeleteAntiBruteForceRuleResponse Client::deleteAntiBruteForceRuleWithOptions(const DeleteAntiBruteForceRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIds()) {
    query["Ids"] = request.ids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteAntiBruteForceRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteAntiBruteForceRuleResponse>();
}

/**
 * @summary Deletes the specified defense rules against brute-force attacks.
 *
 * @param request DeleteAntiBruteForceRuleRequest
 * @return DeleteAntiBruteForceRuleResponse
 */
DeleteAntiBruteForceRuleResponse Client::deleteAntiBruteForceRule(const DeleteAntiBruteForceRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteAntiBruteForceRuleWithOptions(request, runtime);
}

/**
 * @summary Delete attack path sensitive asset.
 *
 * @param request DeleteAttackPathSensitiveAssetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAttackPathSensitiveAssetConfigResponse
 */
DeleteAttackPathSensitiveAssetConfigResponse Client::deleteAttackPathSensitiveAssetConfigWithOptions(const DeleteAttackPathSensitiveAssetConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAttackPathSensitiveAssetConfigId()) {
    query["AttackPathSensitiveAssetConfigId"] = request.attackPathSensitiveAssetConfigId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteAttackPathSensitiveAssetConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteAttackPathSensitiveAssetConfigResponse>();
}

/**
 * @summary Delete attack path sensitive asset.
 *
 * @param request DeleteAttackPathSensitiveAssetConfigRequest
 * @return DeleteAttackPathSensitiveAssetConfigResponse
 */
DeleteAttackPathSensitiveAssetConfigResponse Client::deleteAttackPathSensitiveAssetConfig(const DeleteAttackPathSensitiveAssetConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteAttackPathSensitiveAssetConfigWithOptions(request, runtime);
}

/**
 * @summary Delete Attack Path Whitelist.
 *
 * @param request DeleteAttackPathWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAttackPathWhitelistResponse
 */
DeleteAttackPathWhitelistResponse Client::deleteAttackPathWhitelistWithOptions(const DeleteAttackPathWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAttackPathWhitelistId()) {
    query["AttackPathWhitelistId"] = request.attackPathWhitelistId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteAttackPathWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteAttackPathWhitelistResponse>();
}

/**
 * @summary Delete Attack Path Whitelist.
 *
 * @param request DeleteAttackPathWhitelistRequest
 * @return DeleteAttackPathWhitelistResponse
 */
DeleteAttackPathWhitelistResponse Client::deleteAttackPathWhitelist(const DeleteAttackPathWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteAttackPathWhitelistWithOptions(request, runtime);
}

/**
 * @summary Deletes a witness.
 *
 * @param request DeleteAttestorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAttestorResponse
 */
DeleteAttestorResponse Client::deleteAttestorWithOptions(const DeleteAttestorRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteAttestor"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteAttestorResponse>();
}

/**
 * @summary Deletes a witness.
 *
 * @param request DeleteAttestorRequest
 * @return DeleteAttestorResponse
 */
DeleteAttestorResponse Client::deleteAttestor(const DeleteAttestorRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteAttestorWithOptions(request, runtime);
}

/**
 * @summary Deletes asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
 *
 * @param request DeleteAutoTagRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAutoTagRulesResponse
 */
DeleteAutoTagRulesResponse Client::deleteAutoTagRulesWithOptions(const DeleteAutoTagRulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRuleIdList()) {
    query["RuleIdList"] = request.ruleIdList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteAutoTagRules"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteAutoTagRulesResponse>();
}

/**
 * @summary Deletes asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
 *
 * @param request DeleteAutoTagRulesRequest
 * @return DeleteAutoTagRulesResponse
 */
DeleteAutoTagRulesResponse Client::deleteAutoTagRules(const DeleteAutoTagRulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteAutoTagRulesWithOptions(request, runtime);
}

/**
 * @summary Deletes an anti-ransomware policy.
 *
 * @param request DeleteBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBackupPolicyResponse
 */
DeleteBackupPolicyResponse Client::deleteBackupPolicyWithOptions(const DeleteBackupPolicyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasPolicyVersion()) {
    query["PolicyVersion"] = request.policyVersion();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteBackupPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteBackupPolicyResponse>();
}

/**
 * @summary Deletes an anti-ransomware policy.
 *
 * @param request DeleteBackupPolicyRequest
 * @return DeleteBackupPolicyResponse
 */
DeleteBackupPolicyResponse Client::deleteBackupPolicy(const DeleteBackupPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteBackupPolicyWithOptions(request, runtime);
}

/**
 * @summary Disables a specified anti-ransomware policy that is applied to specified servers and uninstalls the anti-ransomware agent from the servers. If the backup vaults of the servers contain only backup data of the servers, the backup vaults are deleted.
 *
 * @param request DeleteBackupPolicyMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBackupPolicyMachineResponse
 */
DeleteBackupPolicyMachineResponse Client::deleteBackupPolicyMachineWithOptions(const DeleteBackupPolicyMachineRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPolicyId()) {
    query["PolicyId"] = request.policyId();
  }

  if (!!request.hasPolicyVersion()) {
    query["PolicyVersion"] = request.policyVersion();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteBackupPolicyMachine"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteBackupPolicyMachineResponse>();
}

/**
 * @summary Disables a specified anti-ransomware policy that is applied to specified servers and uninstalls the anti-ransomware agent from the servers. If the backup vaults of the servers contain only backup data of the servers, the backup vaults are deleted.
 *
 * @param request DeleteBackupPolicyMachineRequest
 * @return DeleteBackupPolicyMachineResponse
 */
DeleteBackupPolicyMachineResponse Client::deleteBackupPolicyMachine(const DeleteBackupPolicyMachineRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteBackupPolicyMachineWithOptions(request, runtime);
}

/**
 * @summary Deletes a backup snapshot that is created for anti-ransomware.
 *
 * @param request DeleteBackupSnapshotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBackupSnapshotResponse
 */
DeleteBackupSnapshotResponse Client::deleteBackupSnapshotWithOptions(const DeleteBackupSnapshotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBackupRegionIdList()) {
    query["BackupRegionIdList"] = request.backupRegionIdList();
  }

  if (!!request.hasBackupSnapshotList()) {
    query["BackupSnapshotList"] = request.backupSnapshotList();
  }

  if (!!request.hasRetainLatestSnapshot()) {
    query["RetainLatestSnapshot"] = request.retainLatestSnapshot();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteBackupSnapshot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteBackupSnapshotResponse>();
}

/**
 * @summary Deletes a backup snapshot that is created for anti-ransomware.
 *
 * @param request DeleteBackupSnapshotRequest
 * @return DeleteBackupSnapshotResponse
 */
DeleteBackupSnapshotResponse Client::deleteBackupSnapshot(const DeleteBackupSnapshotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteBackupSnapshotWithOptions(request, runtime);
}

/**
 * @summary Deletes the whitelist record for a baseline check item.
 *
 * @param request DeleteBaselineCheckWhiteRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBaselineCheckWhiteRecordResponse
 */
DeleteBaselineCheckWhiteRecordResponse Client::deleteBaselineCheckWhiteRecordWithOptions(const DeleteBaselineCheckWhiteRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckIds()) {
    query["CheckIds"] = request.checkIds();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRecordIds()) {
    query["RecordIds"] = request.recordIds();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteBaselineCheckWhiteRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteBaselineCheckWhiteRecordResponse>();
}

/**
 * @summary Deletes the whitelist record for a baseline check item.
 *
 * @param request DeleteBaselineCheckWhiteRecordRequest
 * @return DeleteBaselineCheckWhiteRecordResponse
 */
DeleteBaselineCheckWhiteRecordResponse Client::deleteBaselineCheckWhiteRecord(const DeleteBaselineCheckWhiteRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteBaselineCheckWhiteRecordWithOptions(request, runtime);
}

/**
 * @summary Deletes a binary security policy from the container signature feature.
 *
 * @param request DeleteBinarySecurityPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBinarySecurityPolicyResponse
 */
DeleteBinarySecurityPolicyResponse Client::deleteBinarySecurityPolicyWithOptions(const DeleteBinarySecurityPolicyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteBinarySecurityPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteBinarySecurityPolicyResponse>();
}

/**
 * @summary Deletes a binary security policy from the container signature feature.
 *
 * @param request DeleteBinarySecurityPolicyRequest
 * @return DeleteBinarySecurityPolicyResponse
 */
DeleteBinarySecurityPolicyResponse Client::deleteBinarySecurityPolicy(const DeleteBinarySecurityPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteBinarySecurityPolicyWithOptions(request, runtime);
}

/**
 * @summary Delete custom scope directories in Cloud Security Posture Management (CSPM) custom checks. You can remove assigned standards, requirements, or sections.
 *
 * @param request DeleteCheckPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCheckPolicyResponse
 */
DeleteCheckPolicyResponse Client::deleteCheckPolicyWithOptions(const DeleteCheckPolicyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPolicyIds()) {
    query["PolicyIds"] = request.policyIds();
  }

  if (!!request.hasPolicyType()) {
    query["PolicyType"] = request.policyType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteCheckPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteCheckPolicyResponse>();
}

/**
 * @summary Delete custom scope directories in Cloud Security Posture Management (CSPM) custom checks. You can remove assigned standards, requirements, or sections.
 *
 * @param request DeleteCheckPolicyRequest
 * @return DeleteCheckPolicyResponse
 */
DeleteCheckPolicyResponse Client::deleteCheckPolicy(const DeleteCheckPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteCheckPolicyWithOptions(request, runtime);
}

/**
 * @summary Deletes specified custom defense rules.
 *
 * @param request DeleteClientUserDefineRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteClientUserDefineRuleResponse
 */
DeleteClientUserDefineRuleResponse Client::deleteClientUserDefineRuleWithOptions(const DeleteClientUserDefineRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIdList()) {
    query["IdList"] = request.idList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteClientUserDefineRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteClientUserDefineRuleResponse>();
}

/**
 * @summary Deletes specified custom defense rules.
 *
 * @param request DeleteClientUserDefineRuleRequest
 * @return DeleteClientUserDefineRuleResponse
 */
DeleteClientUserDefineRuleResponse Client::deleteClientUserDefineRule(const DeleteClientUserDefineRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteClientUserDefineRuleWithOptions(request, runtime);
}

/**
 * @summary Delete multi-cloud asset synchronization configuration.
 *
 * @param request DeleteCloudVendorAccountAKRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCloudVendorAccountAKResponse
 */
DeleteCloudVendorAccountAKResponse Client::deleteCloudVendorAccountAKWithOptions(const DeleteCloudVendorAccountAKRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAuthId()) {
    query["AuthId"] = request.authId();
  }

  if (!!request.hasAuthModules()) {
    query["AuthModules"] = request.authModules();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteCloudVendorAccountAK"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteCloudVendorAccountAKResponse>();
}

/**
 * @summary Delete multi-cloud asset synchronization configuration.
 *
 * @param request DeleteCloudVendorAccountAKRequest
 * @return DeleteCloudVendorAccountAKResponse
 */
DeleteCloudVendorAccountAKResponse Client::deleteCloudVendorAccountAK(const DeleteCloudVendorAccountAKRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteCloudVendorAccountAKWithOptions(request, runtime);
}

/**
 * @summary Deletes a rule for non-image program defense.
 *
 * @param request DeleteContainerDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteContainerDefenseRuleResponse
 */
DeleteContainerDefenseRuleResponse Client::deleteContainerDefenseRuleWithOptions(const DeleteContainerDefenseRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRuleIds()) {
    query["RuleIds"] = request.ruleIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteContainerDefenseRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteContainerDefenseRuleResponse>();
}

/**
 * @summary Deletes a rule for non-image program defense.
 *
 * @param request DeleteContainerDefenseRuleRequest
 * @return DeleteContainerDefenseRuleResponse
 */
DeleteContainerDefenseRuleResponse Client::deleteContainerDefenseRule(const DeleteContainerDefenseRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteContainerDefenseRuleWithOptions(request, runtime);
}

/**
 * @summary Deletes a defense rule against container escapes.
 *
 * @param request DeleteContainerPluginRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteContainerPluginRuleResponse
 */
DeleteContainerPluginRuleResponse Client::deleteContainerPluginRuleWithOptions(const DeleteContainerPluginRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteContainerPluginRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteContainerPluginRuleResponse>();
}

/**
 * @summary Deletes a defense rule against container escapes.
 *
 * @param request DeleteContainerPluginRuleRequest
 * @return DeleteContainerPluginRuleResponse
 */
DeleteContainerPluginRuleResponse Client::deleteContainerPluginRule(const DeleteContainerPluginRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteContainerPluginRuleWithOptions(request, runtime);
}

/**
 * @summary Deletes a specified IP address blocking policy from one or more servers.
 *
 * @param request DeleteCustomBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomBlockRecordResponse
 */
DeleteCustomBlockRecordResponse Client::deleteCustomBlockRecordWithOptions(const DeleteCustomBlockRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteCustomBlockRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteCustomBlockRecordResponse>();
}

/**
 * @summary Deletes a specified IP address blocking policy from one or more servers.
 *
 * @param request DeleteCustomBlockRecordRequest
 * @return DeleteCustomBlockRecordResponse
 */
DeleteCustomBlockRecordResponse Client::deleteCustomBlockRecord(const DeleteCustomBlockRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteCustomBlockRecordWithOptions(request, runtime);
}

/**
 * @summary Deletes a custom security report.
 *
 * @param request DeleteCustomizeReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomizeReportResponse
 */
DeleteCustomizeReportResponse Client::deleteCustomizeReportWithOptions(const DeleteCustomizeReportRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasReportId()) {
    query["ReportId"] = request.reportId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteCustomizeReport"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteCustomizeReportResponse>();
}

/**
 * @summary Deletes a custom security report.
 *
 * @param request DeleteCustomizeReportRequest
 * @return DeleteCustomizeReportResponse
 */
DeleteCustomizeReportResponse Client::deleteCustomizeReport(const DeleteCustomizeReportRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteCustomizeReportWithOptions(request, runtime);
}

/**
 * @summary Deletes the file that is uploaded to create custom weak password rules.
 *
 * @param request DeleteCustomizedDictRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomizedDictResponse
 */
DeleteCustomizedDictResponse Client::deleteCustomizedDictWithOptions(const DeleteCustomizedDictRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteCustomizedDict"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteCustomizedDictResponse>();
}

/**
 * @summary Deletes the file that is uploaded to create custom weak password rules.
 *
 * @param request DeleteCustomizedDictRequest
 * @return DeleteCustomizedDictResponse
 */
DeleteCustomizedDictResponse Client::deleteCustomizedDict(const DeleteCustomizedDictRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteCustomizedDictWithOptions(request, runtime);
}

/**
 * @summary Deletes a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
 *
 * @param request DeleteCycleTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCycleTaskResponse
 */
DeleteCycleTaskResponse Client::deleteCycleTaskWithOptions(const DeleteCycleTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigId()) {
    query["ConfigId"] = request.configId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteCycleTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteCycleTaskResponse>();
}

/**
 * @summary Deletes a periodic scan task. The task can be an image scan task, urgent vulnerability scan task, or virus scan task.
 *
 * @param request DeleteCycleTaskRequest
 * @return DeleteCycleTaskResponse
 */
DeleteCycleTaskResponse Client::deleteCycleTask(const DeleteCycleTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteCycleTaskWithOptions(request, runtime);
}

/**
 * @summary Deletes a DingTalk chatbot on the DingTalk Chatbot tab of the Notification Settings page.
 *
 * @param request DeleteDingTalkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDingTalkResponse
 */
DeleteDingTalkResponse Client::deleteDingTalkWithOptions(const DeleteDingTalkRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIds()) {
    query["Ids"] = request.ids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteDingTalk"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteDingTalkResponse>();
}

/**
 * @summary Deletes a DingTalk chatbot on the DingTalk Chatbot tab of the Notification Settings page.
 *
 * @param request DeleteDingTalkRequest
 * @return DeleteDingTalkResponse
 */
DeleteDingTalkResponse Client::deleteDingTalk(const DeleteDingTalkRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteDingTalkWithOptions(request, runtime);
}

/**
 * @summary Deletes core file monitoring rules.
 *
 * @param request DeleteFileProtectRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFileProtectRuleResponse
 */
DeleteFileProtectRuleResponse Client::deleteFileProtectRuleWithOptions(const DeleteFileProtectRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteFileProtectRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteFileProtectRuleResponse>();
}

/**
 * @summary Deletes core file monitoring rules.
 *
 * @param request DeleteFileProtectRuleRequest
 * @return DeleteFileProtectRuleResponse
 */
DeleteFileProtectRuleResponse Client::deleteFileProtectRule(const DeleteFileProtectRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteFileProtectRuleWithOptions(request, runtime);
}

/**
 * @summary Deletes a server group.
 *
 * @description The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
 *
 * @param request DeleteGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGroupResponse
 */
DeleteGroupResponse Client::deleteGroupWithOptions(const DeleteGroupRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteGroup"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteGroupResponse>();
}

/**
 * @summary Deletes a server group.
 *
 * @description The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
 *
 * @param request DeleteGroupRequest
 * @return DeleteGroupResponse
 */
DeleteGroupResponse Client::deleteGroup(const DeleteGroupRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteGroupWithOptions(request, runtime);
}

/**
 * @summary Deletes a specified honeypot.
 *
 * @param request DeleteHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHoneypotResponse
 */
DeleteHoneypotResponse Client::deleteHoneypotWithOptions(const DeleteHoneypotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneypotId()) {
    query["HoneypotId"] = request.honeypotId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteHoneypot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteHoneypotResponse>();
}

/**
 * @summary Deletes a specified honeypot.
 *
 * @param request DeleteHoneypotRequest
 * @return DeleteHoneypotResponse
 */
DeleteHoneypotResponse Client::deleteHoneypot(const DeleteHoneypotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteHoneypotWithOptions(request, runtime);
}

/**
 * @summary Deletes a specified management node.
 *
 * @param request DeleteHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHoneypotNodeResponse
 */
DeleteHoneypotNodeResponse Client::deleteHoneypotNodeWithOptions(const DeleteHoneypotNodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteHoneypotNode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteHoneypotNodeResponse>();
}

/**
 * @summary Deletes a specified management node.
 *
 * @param request DeleteHoneypotNodeRequest
 * @return DeleteHoneypotNodeResponse
 */
DeleteHoneypotNodeResponse Client::deleteHoneypotNode(const DeleteHoneypotNodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteHoneypotNodeWithOptions(request, runtime);
}

/**
 * @summary Deletes a specified honeypot template.
 *
 * @param request DeleteHoneypotPresetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHoneypotPresetResponse
 */
DeleteHoneypotPresetResponse Client::deleteHoneypotPresetWithOptions(const DeleteHoneypotPresetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneypotPresetId()) {
    query["HoneypotPresetId"] = request.honeypotPresetId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteHoneypotPreset"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteHoneypotPresetResponse>();
}

/**
 * @summary Deletes a specified honeypot template.
 *
 * @param request DeleteHoneypotPresetRequest
 * @return DeleteHoneypotPresetResponse
 */
DeleteHoneypotPresetResponse Client::deleteHoneypotPreset(const DeleteHoneypotPresetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteHoneypotPresetWithOptions(request, runtime);
}

/**
 * @summary Deletes a specified probe.
 *
 * @param request DeleteHoneypotProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHoneypotProbeResponse
 */
DeleteHoneypotProbeResponse Client::deleteHoneypotProbeWithOptions(const DeleteHoneypotProbeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasProbeId()) {
    query["ProbeId"] = request.probeId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteHoneypotProbe"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteHoneypotProbeResponse>();
}

/**
 * @summary Deletes a specified probe.
 *
 * @param request DeleteHoneypotProbeRequest
 * @return DeleteHoneypotProbeResponse
 */
DeleteHoneypotProbeResponse Client::deleteHoneypotProbe(const DeleteHoneypotProbeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteHoneypotProbeWithOptions(request, runtime);
}

/**
 * @summary Delete the probe service.
 *
 * @param request DeleteHoneypotProbeBindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHoneypotProbeBindResponse
 */
DeleteHoneypotProbeBindResponse Client::deleteHoneypotProbeBindWithOptions(const DeleteHoneypotProbeBindRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBindId()) {
    query["BindId"] = request.bindId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasProbeId()) {
    query["ProbeId"] = request.probeId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteHoneypotProbeBind"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteHoneypotProbeBindResponse>();
}

/**
 * @summary Delete the probe service.
 *
 * @param request DeleteHoneypotProbeBindRequest
 * @return DeleteHoneypotProbeBindResponse
 */
DeleteHoneypotProbeBindResponse Client::deleteHoneypotProbeBind(const DeleteHoneypotProbeBindRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteHoneypotProbeBindWithOptions(request, runtime);
}

/**
 * @summary Removes a proxy node from a specified proxy cluster.
 *
 * @param request DeleteHybridProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHybridProxyResponse
 */
DeleteHybridProxyResponse Client::deleteHybridProxyWithOptions(const DeleteHybridProxyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteHybridProxy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteHybridProxyResponse>();
}

/**
 * @summary Removes a proxy node from a specified proxy cluster.
 *
 * @param request DeleteHybridProxyRequest
 * @return DeleteHybridProxyResponse
 */
DeleteHybridProxyResponse Client::deleteHybridProxy(const DeleteHybridProxyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteHybridProxyWithOptions(request, runtime);
}

/**
 * @summary Deletes a proxy cluster based on the name of the proxy cluster.
 *
 * @param request DeleteHybridProxyClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteHybridProxyClusterResponse
 */
DeleteHybridProxyClusterResponse Client::deleteHybridProxyClusterWithOptions(const DeleteHybridProxyClusterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteHybridProxyCluster"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteHybridProxyClusterResponse>();
}

/**
 * @summary Deletes a proxy cluster based on the name of the proxy cluster.
 *
 * @param request DeleteHybridProxyClusterRequest
 * @return DeleteHybridProxyClusterResponse
 */
DeleteHybridProxyClusterResponse Client::deleteHybridProxyCluster(const DeleteHybridProxyClusterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteHybridProxyClusterWithOptions(request, runtime);
}

/**
 * @summary Deletes an IDC probe that is created in Security Center.
 *
 * @param request DeleteIdcProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIdcProbeResponse
 */
DeleteIdcProbeResponse Client::deleteIdcProbeWithOptions(const DeleteIdcProbeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteIdcProbe"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteIdcProbeResponse>();
}

/**
 * @summary Deletes an IDC probe that is created in Security Center.
 *
 * @param request DeleteIdcProbeRequest
 * @return DeleteIdcProbeResponse
 */
DeleteIdcProbeResponse Client::deleteIdcProbe(const DeleteIdcProbeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteIdcProbeWithOptions(request, runtime);
}

/**
 * @summary Deletes an alert handling rule.
 *
 * @param request DeleteImageEventOperationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteImageEventOperationResponse
 */
DeleteImageEventOperationResponse Client::deleteImageEventOperationWithOptions(const DeleteImageEventOperationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteImageEventOperation"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteImageEventOperationResponse>();
}

/**
 * @summary Deletes an alert handling rule.
 *
 * @param request DeleteImageEventOperationRequest
 * @return DeleteImageEventOperationResponse
 */
DeleteImageEventOperationResponse Client::deleteImageEventOperation(const DeleteImageEventOperationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteImageEventOperationWithOptions(request, runtime);
}

/**
 * @summary Deletes an image vulnerability whitelist.
 *
 * @param request DeleteImageVulWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteImageVulWhitelistResponse
 */
DeleteImageVulWhitelistResponse Client::deleteImageVulWhitelistWithOptions(const DeleteImageVulWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIds()) {
    query["Ids"] = request.ids();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteImageVulWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteImageVulWhitelistResponse>();
}

/**
 * @summary Deletes an image vulnerability whitelist.
 *
 * @param request DeleteImageVulWhitelistRequest
 * @return DeleteImageVulWhitelistResponse
 */
DeleteImageVulWhitelistResponse Client::deleteImageVulWhitelist(const DeleteImageVulWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteImageVulWhitelistWithOptions(request, runtime);
}

/**
 * @summary Deletes the command that is used to install the Security Center agent.
 *
 * @param request DeleteInstallCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInstallCodeResponse
 */
DeleteInstallCodeResponse Client::deleteInstallCodeWithOptions(const DeleteInstallCodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCaptchaCode()) {
    query["CaptchaCode"] = request.captchaCode();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteInstallCode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteInstallCodeResponse>();
}

/**
 * @summary Deletes the command that is used to install the Security Center agent.
 *
 * @param request DeleteInstallCodeRequest
 * @return DeleteInstallCodeResponse
 */
DeleteInstallCodeResponse Client::deleteInstallCode(const DeleteInstallCodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteInstallCodeWithOptions(request, runtime);
}

/**
 * @summary Deletes a defense rule in the container firewall module.
 *
 * @param request DeleteInterceptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInterceptionRuleResponse
 */
DeleteInterceptionRuleResponse Client::deleteInterceptionRuleWithOptions(const DeleteInterceptionRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasRuleIds()) {
    query["RuleIds"] = request.ruleIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteInterceptionRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteInterceptionRuleResponse>();
}

/**
 * @summary Deletes a defense rule in the container firewall module.
 *
 * @param request DeleteInterceptionRuleRequest
 * @return DeleteInterceptionRuleResponse
 */
DeleteInterceptionRuleResponse Client::deleteInterceptionRule(const DeleteInterceptionRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteInterceptionRuleWithOptions(request, runtime);
}

/**
 * @summary Removes the network objects that are in effect in the container firewall.
 *
 * @param request DeleteInterceptionTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInterceptionTargetResponse
 */
DeleteInterceptionTargetResponse Client::deleteInterceptionTargetWithOptions(const DeleteInterceptionTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTargetIds()) {
    query["TargetIds"] = request.targetIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteInterceptionTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteInterceptionTargetResponse>();
}

/**
 * @summary Removes the network objects that are in effect in the container firewall.
 *
 * @param request DeleteInterceptionTargetRequest
 * @return DeleteInterceptionTargetResponse
 */
DeleteInterceptionTargetResponse Client::deleteInterceptionTarget(const DeleteInterceptionTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteInterceptionTargetWithOptions(request, runtime);
}

/**
 * @summary Deletes the Kubernetes access information.
 *
 * @param request DeleteK8sAccessInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteK8sAccessInfoResponse
 */
DeleteK8sAccessInfoResponse Client::deleteK8sAccessInfoWithOptions(const DeleteK8sAccessInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliyunYundunGatewayApiName()) {
    query["AliyunYundunGatewayApiName"] = request.aliyunYundunGatewayApiName();
  }

  if (!!request.hasAliyunYundunGatewayPopName()) {
    query["AliyunYundunGatewayPopName"] = request.aliyunYundunGatewayPopName();
  }

  if (!!request.hasAliyunYundunGatewayProjectName()) {
    query["AliyunYundunGatewayProjectName"] = request.aliyunYundunGatewayProjectName();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteK8sAccessInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteK8sAccessInfoResponse>();
}

/**
 * @summary Deletes the Kubernetes access information.
 *
 * @param request DeleteK8sAccessInfoRequest
 * @return DeleteK8sAccessInfoResponse
 */
DeleteK8sAccessInfoResponse Client::deleteK8sAccessInfo(const DeleteK8sAccessInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteK8sAccessInfoWithOptions(request, runtime);
}

/**
 * @summary Deletes the basic configuration information from the logon security configurations for a specific asset.
 *
 * @param request DeleteLoginBaseConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLoginBaseConfigResponse
 */
DeleteLoginBaseConfigResponse Client::deleteLoginBaseConfigWithOptions(const DeleteLoginBaseConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteLoginBaseConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteLoginBaseConfigResponse>();
}

/**
 * @summary Deletes the basic configuration information from the logon security configurations for a specific asset.
 *
 * @param request DeleteLoginBaseConfigRequest
 * @return DeleteLoginBaseConfigResponse
 */
DeleteLoginBaseConfigResponse Client::deleteLoginBaseConfig(const DeleteLoginBaseConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteLoginBaseConfigWithOptions(request, runtime);
}

/**
 * @summary Deletes a whitelist rule for alerts generated for sensitive files that are detected by using the agentless detection feature.
 *
 * @param request DeleteMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMaliciousFileWhitelistConfigResponse
 */
DeleteMaliciousFileWhitelistConfigResponse Client::deleteMaliciousFileWhitelistConfigWithOptions(const DeleteMaliciousFileWhitelistConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigId()) {
    query["ConfigId"] = request.configId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteMaliciousFileWhitelistConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteMaliciousFileWhitelistConfigResponse>();
}

/**
 * @summary Deletes a whitelist rule for alerts generated for sensitive files that are detected by using the agentless detection feature.
 *
 * @param request DeleteMaliciousFileWhitelistConfigRequest
 * @return DeleteMaliciousFileWhitelistConfigResponse
 */
DeleteMaliciousFileWhitelistConfigResponse Client::deleteMaliciousFileWhitelistConfig(const DeleteMaliciousFileWhitelistConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

/**
 * @summary Removes the remarks added to alert events that are generated by the agentless detection feature.
 *
 * @param request DeleteMaliciousNoteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMaliciousNoteResponse
 */
DeleteMaliciousNoteResponse Client::deleteMaliciousNoteWithOptions(const DeleteMaliciousNoteRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasNoteId()) {
    query["NoteId"] = request.noteId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteMaliciousNote"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteMaliciousNoteResponse>();
}

/**
 * @summary Removes the remarks added to alert events that are generated by the agentless detection feature.
 *
 * @param request DeleteMaliciousNoteRequest
 * @return DeleteMaliciousNoteResponse
 */
DeleteMaliciousNoteResponse Client::deleteMaliciousNote(const DeleteMaliciousNoteRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteMaliciousNoteWithOptions(request, runtime);
}

/**
 * @summary Deletes a member of the account managed by Security Center type of the multi-account management feature.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @param request DeleteMonitorAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMonitorAccountResponse
 */
DeleteMonitorAccountResponse Client::deleteMonitorAccountWithOptions(const DeleteMonitorAccountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAccountId()) {
    query["AccountId"] = request.accountId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteMonitorAccount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteMonitorAccountResponse>();
}

/**
 * @summary Deletes a member of the account managed by Security Center type of the multi-account management feature.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @param request DeleteMonitorAccountRequest
 * @return DeleteMonitorAccountResponse
 */
DeleteMonitorAccountResponse Client::deleteMonitorAccount(const DeleteMonitorAccountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteMonitorAccountWithOptions(request, runtime);
}

/**
 * @summary Deletes rules of the at-risk image blocking type.
 *
 * @param request DeleteOpaStrategyNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOpaStrategyNewResponse
 */
DeleteOpaStrategyNewResponse Client::deleteOpaStrategyNewWithOptions(const DeleteOpaStrategyNewRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStrategyIds()) {
    query["StrategyIds"] = request.strategyIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteOpaStrategyNew"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteOpaStrategyNewResponse>();
}

/**
 * @summary Deletes rules of the at-risk image blocking type.
 *
 * @param request DeleteOpaStrategyNewRequest
 * @return DeleteOpaStrategyNewResponse
 */
DeleteOpaStrategyNewResponse Client::deleteOpaStrategyNew(const DeleteOpaStrategyNewRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteOpaStrategyNewWithOptions(request, runtime);
}

/**
 * @summary Deletes the configuration of an Object Storage Service (OSS) file detection policy.
 *
 * @param request DeleteOssScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOssScanConfigResponse
 */
DeleteOssScanConfigResponse Client::deleteOssScanConfigWithOptions(const DeleteOssScanConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteOssScanConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteOssScanConfigResponse>();
}

/**
 * @summary Deletes the configuration of an Object Storage Service (OSS) file detection policy.
 *
 * @param request DeleteOssScanConfigRequest
 * @return DeleteOssScanConfigResponse
 */
DeleteOssScanConfigResponse Client::deleteOssScanConfig(const DeleteOssScanConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteOssScanConfigWithOptions(request, runtime);
}

/**
 * @summary Deletes a private image repository by using the ID of the image repository.
 *
 * @param request DeletePrivateRegistryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePrivateRegistryResponse
 */
DeletePrivateRegistryResponse Client::deletePrivateRegistryWithOptions(const DeletePrivateRegistryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRegistryId()) {
    query["RegistryId"] = request.registryId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeletePrivateRegistry"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeletePrivateRegistryResponse>();
}

/**
 * @summary Deletes a private image repository by using the ID of the image repository.
 *
 * @param request DeletePrivateRegistryRequest
 * @return DeletePrivateRegistryResponse
 */
DeletePrivateRegistryResponse Client::deletePrivateRegistry(const DeletePrivateRegistryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deletePrivateRegistryWithOptions(request, runtime);
}

/**
 * @summary Deletes a rule for container tamper-proofing.
 *
 * @param request DeleteSasContainerWebDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSasContainerWebDefenseRuleResponse
 */
DeleteSasContainerWebDefenseRuleResponse Client::deleteSasContainerWebDefenseRuleWithOptions(const DeleteSasContainerWebDefenseRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteSasContainerWebDefenseRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteSasContainerWebDefenseRuleResponse>();
}

/**
 * @summary Deletes a rule for container tamper-proofing.
 *
 * @param request DeleteSasContainerWebDefenseRuleRequest
 * @return DeleteSasContainerWebDefenseRuleResponse
 */
DeleteSasContainerWebDefenseRuleResponse Client::deleteSasContainerWebDefenseRule(const DeleteSasContainerWebDefenseRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteSasContainerWebDefenseRuleWithOptions(request, runtime);
}

/**
 * @summary Deletes a frequently used search condition by using the asset management feature of the Assets module in the Security Center console.
 *
 * @param request DeleteSearchConditionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSearchConditionResponse
 */
DeleteSearchConditionResponse Client::deleteSearchConditionWithOptions(const DeleteSearchConditionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteSearchCondition"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteSearchConditionResponse>();
}

/**
 * @summary Deletes a frequently used search condition by using the asset management feature of the Assets module in the Security Center console.
 *
 * @param request DeleteSearchConditionRequest
 * @return DeleteSearchConditionResponse
 */
DeleteSearchConditionResponse Client::deleteSearchCondition(const DeleteSearchConditionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteSearchConditionWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DeleteSecurityEventMarkMissList is deprecated, please use Sas::2018-12-03::ModifySecurityEventMarkMissIndividually instead.
 *
 * @summary Deletes multiple custom defense rules at a time. The custom defense rules are used to add false positive alerts to the whitelist.
 *
 * @param request DeleteSecurityEventMarkMissListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSecurityEventMarkMissListResponse
 */
DeleteSecurityEventMarkMissListResponse Client::deleteSecurityEventMarkMissListWithOptions(const DeleteSecurityEventMarkMissListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIds()) {
    query["Ids"] = request.ids();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteSecurityEventMarkMissList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteSecurityEventMarkMissListResponse>();
}

/**
 * @deprecated OpenAPI DeleteSecurityEventMarkMissList is deprecated, please use Sas::2018-12-03::ModifySecurityEventMarkMissIndividually instead.
 *
 * @summary Deletes multiple custom defense rules at a time. The custom defense rules are used to add false positive alerts to the whitelist.
 *
 * @param request DeleteSecurityEventMarkMissListRequest
 * @return DeleteSecurityEventMarkMissListResponse
 */
DeleteSecurityEventMarkMissListResponse Client::deleteSecurityEventMarkMissList(const DeleteSecurityEventMarkMissListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteSecurityEventMarkMissListWithOptions(request, runtime);
}

/**
 * @summary Deletes a service trail.
 *
 * @param request DeleteServiceTrailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServiceTrailResponse
 */
DeleteServiceTrailResponse Client::deleteServiceTrailWithOptions(const DeleteServiceTrailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteServiceTrail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteServiceTrailResponse>();
}

/**
 * @summary Deletes a service trail.
 *
 * @param request DeleteServiceTrailRequest
 * @return DeleteServiceTrailResponse
 */
DeleteServiceTrailResponse Client::deleteServiceTrail(const DeleteServiceTrailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteServiceTrailWithOptions(request, runtime);
}

/**
 * @summary Deletes a policy task that is in the waiting state on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DeleteSoarStrategyTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSoarStrategyTaskResponse
 */
DeleteSoarStrategyTaskResponse Client::deleteSoarStrategyTaskWithOptions(const DeleteSoarStrategyTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStrategyTaskId()) {
    query["StrategyTaskId"] = request.strategyTaskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteSoarStrategyTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteSoarStrategyTaskResponse>();
}

/**
 * @summary Deletes a policy task that is in the waiting state on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DeleteSoarStrategyTaskRequest
 * @return DeleteSoarStrategyTaskResponse
 */
DeleteSoarStrategyTaskResponse Client::deleteSoarStrategyTask(const DeleteSoarStrategyTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteSoarStrategyTaskWithOptions(request, runtime);
}

/**
 * @summary Deletes a baseline check policy.
 *
 * @param request DeleteStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteStrategyResponse
 */
DeleteStrategyResponse Client::deleteStrategyWithOptions(const DeleteStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteStrategyResponse>();
}

/**
 * @summary Deletes a baseline check policy.
 *
 * @param request DeleteStrategyRequest
 * @return DeleteStrategyResponse
 */
DeleteStrategyResponse Client::deleteStrategy(const DeleteStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteStrategyWithOptions(request, runtime);
}

/**
 * @summary Deletes the description of an alert.
 *
 * @param request DeleteSuspEventNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSuspEventNodeResponse
 */
DeleteSuspEventNodeResponse Client::deleteSuspEventNodeWithOptions(const DeleteSuspEventNodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasNoteId()) {
    query["NoteId"] = request.noteId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteSuspEventNode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteSuspEventNodeResponse>();
}

/**
 * @summary Deletes the description of an alert.
 *
 * @param request DeleteSuspEventNodeRequest
 * @return DeleteSuspEventNodeResponse
 */
DeleteSuspEventNodeResponse Client::deleteSuspEventNode(const DeleteSuspEventNodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteSuspEventNodeWithOptions(request, runtime);
}

/**
 * @summary Removes custom tags from assets.
 *
 * @description Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
 *
 * @param request DeleteTagWithUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTagWithUuidResponse
 */
DeleteTagWithUuidResponse Client::deleteTagWithUuidWithOptions(const DeleteTagWithUuidRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTagName()) {
    query["TagName"] = request.tagName();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteTagWithUuid"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteTagWithUuidResponse>();
}

/**
 * @summary Removes custom tags from assets.
 *
 * @description Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
 *
 * @param request DeleteTagWithUuidRequest
 * @return DeleteTagWithUuidResponse
 */
DeleteTagWithUuidResponse Client::deleteTagWithUuid(const DeleteTagWithUuidRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteTagWithUuidWithOptions(request, runtime);
}

/**
 * @summary Deletes anti-ransomware policies that are created for databases.
 *
 * @param request DeleteUniBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUniBackupPolicyResponse
 */
DeleteUniBackupPolicyResponse Client::deleteUniBackupPolicyWithOptions(const DeleteUniBackupPolicyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPolicyId()) {
    query["PolicyId"] = request.policyId();
  }

  if (!!request.hasPolicyIds()) {
    query["PolicyIds"] = request.policyIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteUniBackupPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteUniBackupPolicyResponse>();
}

/**
 * @summary Deletes anti-ransomware policies that are created for databases.
 *
 * @param request DeleteUniBackupPolicyRequest
 * @return DeleteUniBackupPolicyResponse
 */
DeleteUniBackupPolicyResponse Client::deleteUniBackupPolicy(const DeleteUniBackupPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteUniBackupPolicyWithOptions(request, runtime);
}

/**
 * @summary Deletes a honeypot.
 *
 * @param request DeleteVpcHoneyPotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpcHoneyPotResponse
 */
DeleteVpcHoneyPotResponse Client::deleteVpcHoneyPotWithOptions(const DeleteVpcHoneyPotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVpcHoneyPot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVpcHoneyPotResponse>();
}

/**
 * @summary Deletes a honeypot.
 *
 * @param request DeleteVpcHoneyPotRequest
 * @return DeleteVpcHoneyPotResponse
 */
DeleteVpcHoneyPotResponse Client::deleteVpcHoneyPot(const DeleteVpcHoneyPotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVpcHoneyPotWithOptions(request, runtime);
}

/**
 * @summary Deletes configurations of of an automatic vulnerability fixing task at a time on the Playbook page.
 *
 * @param request DeleteVulAutoRepairConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVulAutoRepairConfigResponse
 */
DeleteVulAutoRepairConfigResponse Client::deleteVulAutoRepairConfigWithOptions(const DeleteVulAutoRepairConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliasName()) {
    query["AliasName"] = request.aliasName();
  }

  if (!!request.hasConfigIdList()) {
    query["ConfigIdList"] = request.configIdList();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVulAutoRepairConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVulAutoRepairConfigResponse>();
}

/**
 * @summary Deletes configurations of of an automatic vulnerability fixing task at a time on the Playbook page.
 *
 * @param request DeleteVulAutoRepairConfigRequest
 * @return DeleteVulAutoRepairConfigResponse
 */
DeleteVulAutoRepairConfigResponse Client::deleteVulAutoRepairConfig(const DeleteVulAutoRepairConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVulAutoRepairConfigWithOptions(request, runtime);
}

/**
 * @summary Deletes a specified vulnerability whitelist.
 *
 * @param request DeleteVulWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVulWhitelistResponse
 */
DeleteVulWhitelistResponse Client::deleteVulWhitelistWithOptions(const DeleteVulWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasWhitelist()) {
    query["Whitelist"] = request.whitelist();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DeleteVulWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DeleteVulWhitelistResponse>();
}

/**
 * @summary Deletes a specified vulnerability whitelist.
 *
 * @param request DeleteVulWhitelistRequest
 * @return DeleteVulWhitelistResponse
 */
DeleteVulWhitelistResponse Client::deleteVulWhitelist(const DeleteVulWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return deleteVulWhitelistWithOptions(request, runtime);
}

/**
 * @summary Queries the overview of user AI assets.
 *
 * @param request DescribeAIAssetSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAIAssetSummaryResponse
 */
DescribeAIAssetSummaryResponse Client::describeAIAssetSummaryWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeAIAssetSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAIAssetSummaryResponse>();
}

/**
 * @summary Queries the overview of user AI assets.
 *
 * @return DescribeAIAssetSummaryResponse
 */
DescribeAIAssetSummaryResponse Client::describeAIAssetSummary() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAIAssetSummaryWithOptions(runtime);
}

/**
 * @summary Queries the details of AccessKey pair leaks.
 *
 * @param request DescribeAccessKeyLeakDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccessKeyLeakDetailResponse
 */
DescribeAccessKeyLeakDetailResponse Client::describeAccessKeyLeakDetailWithOptions(const DescribeAccessKeyLeakDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAccessKeyLeakDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAccessKeyLeakDetailResponse>();
}

/**
 * @summary Queries the details of AccessKey pair leaks.
 *
 * @param request DescribeAccessKeyLeakDetailRequest
 * @return DescribeAccessKeyLeakDetailResponse
 */
DescribeAccessKeyLeakDetailResponse Client::describeAccessKeyLeakDetail(const DescribeAccessKeyLeakDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAccessKeyLeakDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the AccessKey pair leaks that are detected on your assets.
 *
 * @param request DescribeAccesskeyLeakListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccesskeyLeakListResponse
 */
DescribeAccesskeyLeakListResponse Client::describeAccesskeyLeakListWithOptions(const DescribeAccesskeyLeakListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasQuery()) {
    query["Query"] = request.query();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasStartTs()) {
    query["StartTs"] = request.startTs();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAccesskeyLeakList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAccesskeyLeakListResponse>();
}

/**
 * @summary Queries the AccessKey pair leaks that are detected on your assets.
 *
 * @param request DescribeAccesskeyLeakListRequest
 * @return DescribeAccesskeyLeakListResponse
 */
DescribeAccesskeyLeakListResponse Client::describeAccesskeyLeakList(const DescribeAccesskeyLeakListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAccesskeyLeakListWithOptions(request, runtime);
}

/**
 * @summary Queries the affected servers in the result of a virus scan task.
 *
 * @param request DescribeAffectedAssetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAffectedAssetsResponse
 */
DescribeAffectedAssetsResponse Client::describeAffectedAssetsWithOptions(const DescribeAffectedAssetsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrent()) {
    query["Current"] = request.current();
  }

  if (!!request.hasLevels()) {
    query["Levels"] = request.levels();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAffectedAssets"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAffectedAssetsResponse>();
}

/**
 * @summary Queries the affected servers in the result of a virus scan task.
 *
 * @param request DescribeAffectedAssetsRequest
 * @return DescribeAffectedAssetsResponse
 */
DescribeAffectedAssetsResponse Client::describeAffectedAssets(const DescribeAffectedAssetsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAffectedAssetsWithOptions(request, runtime);
}

/**
 * @summary Queries the details of malicious image samples.
 *
 * @param request DescribeAffectedMaliciousFileImagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAffectedMaliciousFileImagesResponse
 */
DescribeAffectedMaliciousFileImagesResponse Client::describeAffectedMaliciousFileImagesWithOptions(const DescribeAffectedMaliciousFileImagesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasContainerId()) {
    query["ContainerId"] = request.containerId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImage()) {
    query["Image"] = request.image();
  }

  if (!!request.hasImageDigest()) {
    query["ImageDigest"] = request.imageDigest();
  }

  if (!!request.hasImageLayer()) {
    query["ImageLayer"] = request.imageLayer();
  }

  if (!!request.hasImageTag()) {
    query["ImageTag"] = request.imageTag();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLevels()) {
    query["Levels"] = request.levels();
  }

  if (!!request.hasMaliciousMd5()) {
    query["MaliciousMd5"] = request.maliciousMd5();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPod()) {
    query["Pod"] = request.pod();
  }

  if (!!request.hasRepoId()) {
    query["RepoId"] = request.repoId();
  }

  if (!!request.hasRepoInstanceId()) {
    query["RepoInstanceId"] = request.repoInstanceId();
  }

  if (!!request.hasRepoName()) {
    query["RepoName"] = request.repoName();
  }

  if (!!request.hasRepoNamespace()) {
    query["RepoNamespace"] = request.repoNamespace();
  }

  if (!!request.hasRepoRegionId()) {
    query["RepoRegionId"] = request.repoRegionId();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAffectedMaliciousFileImages"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAffectedMaliciousFileImagesResponse>();
}

/**
 * @summary Queries the details of malicious image samples.
 *
 * @param request DescribeAffectedMaliciousFileImagesRequest
 * @return DescribeAffectedMaliciousFileImagesResponse
 */
DescribeAffectedMaliciousFileImagesResponse Client::describeAffectedMaliciousFileImages(const DescribeAffectedMaliciousFileImagesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAffectedMaliciousFileImagesWithOptions(request, runtime);
}

/**
 * @summary Queries the installation status of the Security Center agent after you run an installation command by using Cloud Assistant. You can call this operation to query the installation status only if the installation request is initiated within 2 minutes.
 *
 * @param request DescribeAgentInstallStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAgentInstallStatusResponse
 */
DescribeAgentInstallStatusResponse Client::describeAgentInstallStatusWithOptions(const DescribeAgentInstallStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAgentInstallStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAgentInstallStatusResponse>();
}

/**
 * @summary Queries the installation status of the Security Center agent after you run an installation command by using Cloud Assistant. You can call this operation to query the installation status only if the installation request is initiated within 2 minutes.
 *
 * @param request DescribeAgentInstallStatusRequest
 * @return DescribeAgentInstallStatusResponse
 */
DescribeAgentInstallStatusResponse Client::describeAgentInstallStatus(const DescribeAgentInstallStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAgentInstallStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the list of assets on which a specific type of sensitive files are detected by using the agentless detection feature.
 *
 * @description You can call this operation only when the agentless detection feature is purchased by using the pay-as-you-go billing method within your Alibaba Cloud account.
 *
 * @param tmpReq DescribeAgentlessSensitiveFileByKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAgentlessSensitiveFileByKeyResponse
 */
DescribeAgentlessSensitiveFileByKeyResponse Client::describeAgentlessSensitiveFileByKeyWithOptions(const DescribeAgentlessSensitiveFileByKeyRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  DescribeAgentlessSensitiveFileByKeyShrinkRequest request = DescribeAgentlessSensitiveFileByKeyShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasScanRange()) {
    request.setScanRangeShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.scanRange(), "ScanRange", "json"));
  }

  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAgentlessSensitiveFileByKey"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAgentlessSensitiveFileByKeyResponse>();
}

/**
 * @summary Queries the list of assets on which a specific type of sensitive files are detected by using the agentless detection feature.
 *
 * @description You can call this operation only when the agentless detection feature is purchased by using the pay-as-you-go billing method within your Alibaba Cloud account.
 *
 * @param request DescribeAgentlessSensitiveFileByKeyRequest
 * @return DescribeAgentlessSensitiveFileByKeyResponse
 */
DescribeAgentlessSensitiveFileByKeyResponse Client::describeAgentlessSensitiveFileByKey(const DescribeAgentlessSensitiveFileByKeyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAgentlessSensitiveFileByKeyWithOptions(request, runtime);
}

/**
 * @summary Queries the details of an alert event. An alert event consists of alerts and exceptions. Each alert event is associated with multiple exceptions.
 *
 * @param request DescribeAlarmEventDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAlarmEventDetailResponse
 */
DescribeAlarmEventDetailResponse Client::describeAlarmEventDetailWithOptions(const DescribeAlarmEventDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAlarmUniqueInfo()) {
    query["AlarmUniqueInfo"] = request.alarmUniqueInfo();
  }

  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAlarmEventDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAlarmEventDetailResponse>();
}

/**
 * @summary Queries the details of an alert event. An alert event consists of alerts and exceptions. Each alert event is associated with multiple exceptions.
 *
 * @param request DescribeAlarmEventDetailRequest
 * @return DescribeAlarmEventDetailResponse
 */
DescribeAlarmEventDetailResponse Client::describeAlarmEventDetail(const DescribeAlarmEventDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAlarmEventDetailWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeAlarmEventStackInfo is deprecated
 *
 * @summary Queries the stack information about an alert event.
 *
 * @param request DescribeAlarmEventStackInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAlarmEventStackInfoResponse
 */
DescribeAlarmEventStackInfoResponse Client::describeAlarmEventStackInfoWithOptions(const DescribeAlarmEventStackInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventName()) {
    query["EventName"] = request.eventName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUniqueInfo()) {
    query["UniqueInfo"] = request.uniqueInfo();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAlarmEventStackInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAlarmEventStackInfoResponse>();
}

/**
 * @deprecated OpenAPI DescribeAlarmEventStackInfo is deprecated
 *
 * @summary Queries the stack information about an alert event.
 *
 * @param request DescribeAlarmEventStackInfoRequest
 * @return DescribeAlarmEventStackInfoResponse
 */
DescribeAlarmEventStackInfoResponse Client::describeAlarmEventStackInfo(const DescribeAlarmEventStackInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAlarmEventStackInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the information about all server assets, including the asset group IDs and asset names.
 *
 * @param request DescribeAllEntityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllEntityResponse
 */
DescribeAllEntityResponse Client::describeAllEntityWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeAllEntity"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAllEntityResponse>();
}

/**
 * @summary Queries the information about all server assets, including the asset group IDs and asset names.
 *
 * @return DescribeAllEntityResponse
 */
DescribeAllEntityResponse Client::describeAllEntity() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAllEntityWithOptions(runtime);
}

/**
 * @summary Queries the information about all server groups.
 *
 * @param request DescribeAllGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllGroupsResponse
 */
DescribeAllGroupsResponse Client::describeAllGroupsWithOptions(const DescribeAllGroupsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAllGroups"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAllGroupsResponse>();
}

/**
 * @summary Queries the information about all server groups.
 *
 * @param request DescribeAllGroupsRequest
 * @return DescribeAllGroupsResponse
 */
DescribeAllGroupsResponse Client::describeAllGroups(const DescribeAllGroupsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAllGroupsWithOptions(request, runtime);
}

/**
 * @summary Queries baselines that are used in image baseline checks.
 *
 * @param request DescribeAllImageBaselineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllImageBaselineResponse
 */
DescribeAllImageBaselineResponse Client::describeAllImageBaselineWithOptions(const DescribeAllImageBaselineRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAllImageBaseline"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAllImageBaselineResponse>();
}

/**
 * @summary Queries baselines that are used in image baseline checks.
 *
 * @param request DescribeAllImageBaselineRequest
 * @return DescribeAllImageBaselineResponse
 */
DescribeAllImageBaselineResponse Client::describeAllImageBaseline(const DescribeAllImageBaselineRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAllImageBaselineWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics on global security events, including the numbers of unfixed vulnerabilities, baseline risks, and alerts.
 *
 * @param request DescribeAllRegionsStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllRegionsStatisticsResponse
 */
DescribeAllRegionsStatisticsResponse Client::describeAllRegionsStatisticsWithOptions(const DescribeAllRegionsStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAllRegionsStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAllRegionsStatisticsResponse>();
}

/**
 * @summary Queries the statistics on global security events, including the numbers of unfixed vulnerabilities, baseline risks, and alerts.
 *
 * @param request DescribeAllRegionsStatisticsRequest
 * @return DescribeAllRegionsStatisticsResponse
 */
DescribeAllRegionsStatisticsResponse Client::describeAllRegionsStatistics(const DescribeAllRegionsStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAllRegionsStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries created defense rules against brute-force attacks.
 *
 * @param request DescribeAntiBruteForceRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAntiBruteForceRulesResponse
 */
DescribeAntiBruteForceRulesResponse Client::describeAntiBruteForceRulesWithOptions(const DescribeAntiBruteForceRulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAntiBruteForceRules"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAntiBruteForceRulesResponse>();
}

/**
 * @summary Queries created defense rules against brute-force attacks.
 *
 * @param request DescribeAntiBruteForceRulesRequest
 * @return DescribeAntiBruteForceRulesResponse
 */
DescribeAntiBruteForceRulesResponse Client::describeAntiBruteForceRules(const DescribeAntiBruteForceRulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAntiBruteForceRulesWithOptions(request, runtime);
}

/**
 * @summary Queries the scan cycle for application vulnerabilities.
 *
 * @param request DescribeAppVulScanCycleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAppVulScanCycleResponse
 */
DescribeAppVulScanCycleResponse Client::describeAppVulScanCycleWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeAppVulScanCycle"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAppVulScanCycleResponse>();
}

/**
 * @summary Queries the scan cycle for application vulnerabilities.
 *
 * @return DescribeAppVulScanCycleResponse
 */
DescribeAppVulScanCycleResponse Client::describeAppVulScanCycle() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAppVulScanCycleWithOptions(runtime);
}

/**
 * @deprecated OpenAPI DescribeAssetDetailByUuid is deprecated, please use Sas::2018-12-03::GetAssetDetailByUuid instead.
 *
 * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
 *
 * @description This operation will be discontinued soon. You must call the [GetAssetDetailByUuid](~~GetAssetDetailByUuid~~) operation to query the details of the server.
 *
 * @param request DescribeAssetDetailByUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAssetDetailByUuidResponse
 */
DescribeAssetDetailByUuidResponse Client::describeAssetDetailByUuidWithOptions(const DescribeAssetDetailByUuidRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAssetDetailByUuid"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAssetDetailByUuidResponse>();
}

/**
 * @deprecated OpenAPI DescribeAssetDetailByUuid is deprecated, please use Sas::2018-12-03::GetAssetDetailByUuid instead.
 *
 * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
 *
 * @description This operation will be discontinued soon. You must call the [GetAssetDetailByUuid](~~GetAssetDetailByUuid~~) operation to query the details of the server.
 *
 * @param request DescribeAssetDetailByUuidRequest
 * @return DescribeAssetDetailByUuidResponse
 */
DescribeAssetDetailByUuidResponse Client::describeAssetDetailByUuid(const DescribeAssetDetailByUuidRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAssetDetailByUuidWithOptions(request, runtime);
}

/**
 * @summary Queries the details of Elastic Compute Service (ECS) instances.
 *
 * @param request DescribeAssetDetailByUuidsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAssetDetailByUuidsResponse
 */
DescribeAssetDetailByUuidsResponse Client::describeAssetDetailByUuidsWithOptions(const DescribeAssetDetailByUuidsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAssetDetailByUuids"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAssetDetailByUuidsResponse>();
}

/**
 * @summary Queries the details of Elastic Compute Service (ECS) instances.
 *
 * @param request DescribeAssetDetailByUuidsRequest
 * @return DescribeAssetDetailByUuidsResponse
 */
DescribeAssetDetailByUuidsResponse Client::describeAssetDetailByUuids(const DescribeAssetDetailByUuidsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAssetDetailByUuidsWithOptions(request, runtime);
}

/**
 * @summary The ID of the request, which is used to locate and troubleshoot issues.
 *
 * @param request DescribeAssetSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAssetSummaryResponse
 */
DescribeAssetSummaryResponse Client::describeAssetSummaryWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeAssetSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAssetSummaryResponse>();
}

/**
 * @summary The ID of the request, which is used to locate and troubleshoot issues.
 *
 * @return DescribeAssetSummaryResponse
 */
DescribeAssetSummaryResponse Client::describeAssetSummary() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAssetSummaryWithOptions(runtime);
}

/**
 * @summary Queries the number of Java processes in an asset by using the asset fingerprints feature of Security Center.
 *
 * @param request DescribeAssetsScaProcessNumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAssetsScaProcessNumResponse
 */
DescribeAssetsScaProcessNumResponse Client::describeAssetsScaProcessNumWithOptions(const DescribeAssetsScaProcessNumRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBizType()) {
    query["BizType"] = request.bizType();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAssetsScaProcessNum"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAssetsScaProcessNumResponse>();
}

/**
 * @summary Queries the number of Java processes in an asset by using the asset fingerprints feature of Security Center.
 *
 * @param request DescribeAssetsScaProcessNumRequest
 * @return DescribeAssetsScaProcessNumResponse
 */
DescribeAssetsScaProcessNumResponse Client::describeAssetsScaProcessNum(const DescribeAssetsScaProcessNumRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAssetsScaProcessNumWithOptions(request, runtime);
}

/**
 * @summary Queries the risk information about containers.
 *
 * @param request DescribeAssetsSecurityEventSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAssetsSecurityEventSummaryResponse
 */
DescribeAssetsSecurityEventSummaryResponse Client::describeAssetsSecurityEventSummaryWithOptions(const DescribeAssetsSecurityEventSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAssetsSecurityEventSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAssetsSecurityEventSummaryResponse>();
}

/**
 * @summary Queries the risk information about containers.
 *
 * @param request DescribeAssetsSecurityEventSummaryRequest
 * @return DescribeAssetsSecurityEventSummaryResponse
 */
DescribeAssetsSecurityEventSummaryResponse Client::describeAssetsSecurityEventSummary(const DescribeAssetsSecurityEventSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAssetsSecurityEventSummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of attack analysis.
 *
 * @param request DescribeAttackAnalysisDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAttackAnalysisDataResponse
 */
DescribeAttackAnalysisDataResponse Client::describeAttackAnalysisDataWithOptions(const DescribeAttackAnalysisDataRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBase64()) {
    query["Base64"] = request.base64();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasData()) {
    query["Data"] = request.data();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAttackAnalysisData"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAttackAnalysisDataResponse>();
}

/**
 * @summary Queries the statistics of attack analysis.
 *
 * @param request DescribeAttackAnalysisDataRequest
 * @return DescribeAttackAnalysisDataResponse
 */
DescribeAttackAnalysisDataResponse Client::describeAttackAnalysisData(const DescribeAttackAnalysisDataRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAttackAnalysisDataWithOptions(request, runtime);
}

/**
 * @summary Queries a list of witnesses.
 *
 * @param request DescribeAttestorsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAttestorsResponse
 */
DescribeAttestorsResponse Client::describeAttestorsWithOptions(const DescribeAttestorsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeAttestors"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAttestorsResponse>();
}

/**
 * @summary Queries a list of witnesses.
 *
 * @param request DescribeAttestorsRequest
 * @return DescribeAttestorsResponse
 */
DescribeAttestorsResponse Client::describeAttestors(const DescribeAttestorsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAttestorsWithOptions(request, runtime);
}

/**
 * @summary Queries the number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
 *
 * @param request DescribeAutoDelConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAutoDelConfigResponse
 */
DescribeAutoDelConfigResponse Client::describeAutoDelConfigWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeAutoDelConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeAutoDelConfigResponse>();
}

/**
 * @summary Queries the number of days during which a detected vulnerability is retained before the vulnerability is automatically deleted.
 *
 * @return DescribeAutoDelConfigResponse
 */
DescribeAutoDelConfigResponse Client::describeAutoDelConfig() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeAutoDelConfigWithOptions(runtime);
}

/**
 * @summary Queries the information about a file to which archived alert events are exported.
 *
 * @param request DescribeBackUpExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackUpExportInfoResponse
 */
DescribeBackUpExportInfoResponse Client::describeBackUpExportInfoWithOptions(const DescribeBackUpExportInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasExportType()) {
    query["ExportType"] = request.exportType();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBackUpExportInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBackUpExportInfoResponse>();
}

/**
 * @summary Queries the information about a file to which archived alert events are exported.
 *
 * @param request DescribeBackUpExportInfoRequest
 * @return DescribeBackUpExportInfoResponse
 */
DescribeBackUpExportInfoResponse Client::describeBackUpExportInfo(const DescribeBackUpExportInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBackUpExportInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the servers on which the anti-ransomware agent is installed in a specified region.
 *
 * @description You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
 *
 * @param request DescribeBackupClientsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupClientsResponse
 */
DescribeBackupClientsResponse Client::describeBackupClientsWithOptions(const DescribeBackupClientsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSupportRegionId()) {
    query["SupportRegionId"] = request.supportRegionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBackupClients"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBackupClientsResponse>();
}

/**
 * @summary Queries the servers on which the anti-ransomware agent is installed in a specified region.
 *
 * @description You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
 *
 * @param request DescribeBackupClientsRequest
 * @return DescribeBackupClientsResponse
 */
DescribeBackupClientsResponse Client::describeBackupClients(const DescribeBackupClientsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBackupClientsWithOptions(request, runtime);
}

/**
 * @summary Queries backup files.
 *
 * @param request DescribeBackupFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupFilesResponse
 */
DescribeBackupFilesResponse Client::describeBackupFilesWithOptions(const DescribeBackupFilesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPath()) {
    query["Path"] = request.path();
  }

  if (!!request.hasSnapshotHash()) {
    query["SnapshotHash"] = request.snapshotHash();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBackupFiles"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBackupFilesResponse>();
}

/**
 * @summary Queries backup files.
 *
 * @param request DescribeBackupFilesRequest
 * @return DescribeBackupFilesResponse
 */
DescribeBackupFilesResponse Client::describeBackupFiles(const DescribeBackupFilesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBackupFilesWithOptions(request, runtime);
}

/**
 * @summary Queries the backup status of a sever to which an anti-ransomware policy is applied.
 *
 * @param request DescribeBackupMachineStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupMachineStatusResponse
 */
DescribeBackupMachineStatusResponse Client::describeBackupMachineStatusWithOptions(const DescribeBackupMachineStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPolicyId()) {
    query["PolicyId"] = request.policyId();
  }

  if (!!request.hasPolicyVersion()) {
    query["PolicyVersion"] = request.policyVersion();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBackupMachineStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBackupMachineStatusResponse>();
}

/**
 * @summary Queries the backup status of a sever to which an anti-ransomware policy is applied.
 *
 * @param request DescribeBackupMachineStatusRequest
 * @return DescribeBackupMachineStatusResponse
 */
DescribeBackupMachineStatusResponse Client::describeBackupMachineStatus(const DescribeBackupMachineStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBackupMachineStatusWithOptions(request, runtime);
}

/**
 * @summary Queries anti-ransomware policies.
 *
 * @param request DescribeBackupPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupPoliciesResponse
 */
DescribeBackupPoliciesResponse Client::describeBackupPoliciesWithOptions(const DescribeBackupPoliciesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasMachineRemark()) {
    query["MachineRemark"] = request.machineRemark();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBackupPolicies"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBackupPoliciesResponse>();
}

/**
 * @summary Queries anti-ransomware policies.
 *
 * @param request DescribeBackupPoliciesRequest
 * @return DescribeBackupPoliciesResponse
 */
DescribeBackupPoliciesResponse Client::describeBackupPolicies(const DescribeBackupPoliciesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBackupPoliciesWithOptions(request, runtime);
}

/**
 * @summary Queries the details of an anti-ransomware policy for servers.
 *
 * @param request DescribeBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupPolicyResponse
 */
DescribeBackupPolicyResponse Client::describeBackupPolicyWithOptions(const DescribeBackupPolicyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBackupPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBackupPolicyResponse>();
}

/**
 * @summary Queries the details of an anti-ransomware policy for servers.
 *
 * @param request DescribeBackupPolicyRequest
 * @return DescribeBackupPolicyResponse
 */
DescribeBackupPolicyResponse Client::describeBackupPolicy(const DescribeBackupPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBackupPolicyWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of restoration tasks.
 *
 * @description If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
 *
 * @param request DescribeBackupRestoreCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupRestoreCountResponse
 */
DescribeBackupRestoreCountResponse Client::describeBackupRestoreCountWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeBackupRestoreCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBackupRestoreCountResponse>();
}

/**
 * @summary Queries the statistics of restoration tasks.
 *
 * @description If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
 *
 * @return DescribeBackupRestoreCountResponse
 */
DescribeBackupRestoreCountResponse Client::describeBackupRestoreCount() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBackupRestoreCountWithOptions(runtime);
}

/**
 * @summary Queries binary security policies.
 *
 * @param request DescribeBinarySecurityPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBinarySecurityPoliciesResponse
 */
DescribeBinarySecurityPoliciesResponse Client::describeBinarySecurityPoliciesWithOptions(const DescribeBinarySecurityPoliciesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBinarySecurityPolicies"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBinarySecurityPoliciesResponse>();
}

/**
 * @summary Queries binary security policies.
 *
 * @param request DescribeBinarySecurityPoliciesRequest
 * @return DescribeBinarySecurityPoliciesResponse
 */
DescribeBinarySecurityPoliciesResponse Client::describeBinarySecurityPolicies(const DescribeBinarySecurityPoliciesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBinarySecurityPoliciesWithOptions(request, runtime);
}

/**
 * @summary Queries the IP addresses that are blocked by a defense rule against brute-force attacks.
 *
 * @param request DescribeBruteForceRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBruteForceRecordsResponse
 */
DescribeBruteForceRecordsResponse Client::describeBruteForceRecordsWithOptions(const DescribeBruteForceRecordsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBlockIp()) {
    query["BlockIp"] = request.blockIp();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBruteForceRecords"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBruteForceRecordsResponse>();
}

/**
 * @summary Queries the IP addresses that are blocked by a defense rule against brute-force attacks.
 *
 * @param request DescribeBruteForceRecordsRequest
 * @return DescribeBruteForceRecordsResponse
 */
DescribeBruteForceRecordsResponse Client::describeBruteForceRecords(const DescribeBruteForceRecordsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBruteForceRecordsWithOptions(request, runtime);
}

/**
 * @summary The source IP address of the request.
 *
 * @param request DescribeBruteForceSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBruteForceSummaryResponse
 */
DescribeBruteForceSummaryResponse Client::describeBruteForceSummaryWithOptions(const DescribeBruteForceSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeBruteForceSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeBruteForceSummaryResponse>();
}

/**
 * @summary The source IP address of the request.
 *
 * @param request DescribeBruteForceSummaryRequest
 * @return DescribeBruteForceSummaryResponse
 */
DescribeBruteForceSummaryResponse Client::describeBruteForceSummary(const DescribeBruteForceSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeBruteForceSummaryWithOptions(request, runtime);
}

/**
 * @summary Check if the asset can be sold by VPC
 *
 * @param request DescribeCanAccessVpcSaleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCanAccessVpcSaleResponse
 */
DescribeCanAccessVpcSaleResponse Client::describeCanAccessVpcSaleWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeCanAccessVpcSale"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCanAccessVpcSaleResponse>();
}

/**
 * @summary Check if the asset can be sold by VPC
 *
 * @return DescribeCanAccessVpcSaleResponse
 */
DescribeCanAccessVpcSaleResponse Client::describeCanAccessVpcSale() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCanAccessVpcSaleWithOptions(runtime);
}

/**
 * @summary Queries the list of fixable vulnerabilities.
 *
 * @param request DescribeCanFixVulListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCanFixVulListResponse
 */
DescribeCanFixVulListResponse Client::describeCanFixVulListWithOptions(const DescribeCanFixVulListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliasName()) {
    query["AliasName"] = request.aliasName();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasContainerId()) {
    query["ContainerId"] = request.containerId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasDigest()) {
    query["Digest"] = request.digest();
  }

  if (!!request.hasImage()) {
    query["Image"] = request.image();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasNecessity()) {
    query["Necessity"] = request.necessity();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPod()) {
    query["Pod"] = request.pod();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRepoId()) {
    query["RepoId"] = request.repoId();
  }

  if (!!request.hasRepoId()) {
    query["RepoId"] = request.repoId();
  }

  if (!!request.hasRepoInstanceId()) {
    query["RepoInstanceId"] = request.repoInstanceId();
  }

  if (!!request.hasRepoName()) {
    query["RepoName"] = request.repoName();
  }

  if (!!request.hasRepoName()) {
    query["RepoName"] = request.repoName();
  }

  if (!!request.hasRepoNamespace()) {
    query["RepoNamespace"] = request.repoNamespace();
  }

  if (!!request.hasRepoRegionId()) {
    query["RepoRegionId"] = request.repoRegionId();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  if (!!request.hasStatusList()) {
    query["StatusList"] = request.statusList();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCanFixVulList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCanFixVulListResponse>();
}

/**
 * @summary Queries the list of fixable vulnerabilities.
 *
 * @param request DescribeCanFixVulListRequest
 * @return DescribeCanFixVulListResponse
 */
DescribeCanFixVulListResponse Client::describeCanFixVulList(const DescribeCanFixVulListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCanFixVulListWithOptions(request, runtime);
}

/**
 * @summary Checks the permissions on the trial use of Security Center.
 *
 * @param request DescribeCanTrySasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCanTrySasResponse
 */
DescribeCanTrySasResponse Client::describeCanTrySasWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeCanTrySas"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCanTrySasResponse>();
}

/**
 * @summary Checks the permissions on the trial use of Security Center.
 *
 * @return DescribeCanTrySasResponse
 */
DescribeCanTrySasResponse Client::describeCanTrySas() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCanTrySasWithOptions(runtime);
}

/**
 * @summary Queries the chart data of a security report.
 *
 * @param request DescribeChartDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChartDataResponse
 */
DescribeChartDataResponse Client::describeChartDataWithOptions(const DescribeChartDataRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCharId()) {
    query["CharId"] = request.charId();
  }

  if (!!request.hasChartId()) {
    query["ChartId"] = request.chartId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasReportId()) {
    query["ReportId"] = request.reportId();
  }

  if (!!request.hasTimeEnd()) {
    query["TimeEnd"] = request.timeEnd();
  }

  if (!!request.hasTimeStart()) {
    query["TimeStart"] = request.timeStart();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeChartData"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeChartDataResponse>();
}

/**
 * @summary Queries the chart data of a security report.
 *
 * @param request DescribeChartDataRequest
 * @return DescribeChartDataResponse
 */
DescribeChartDataResponse Client::describeChartData(const DescribeChartDataRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeChartDataWithOptions(request, runtime);
}

/**
 * @summary Queries the charts that are supported by using the security report feature of Security Center.
 *
 * @param request DescribeChartListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChartListResponse
 */
DescribeChartListResponse Client::describeChartListWithOptions(const DescribeChartListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasProjectCode()) {
    query["ProjectCode"] = request.projectCode();
  }

  if (!!request.hasReportId()) {
    query["ReportId"] = request.reportId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeChartList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeChartListResponse>();
}

/**
 * @summary Queries the charts that are supported by using the security report feature of Security Center.
 *
 * @param request DescribeChartListRequest
 * @return DescribeChartListResponse
 */
DescribeChartListResponse Client::describeChartList(const DescribeChartListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeChartListWithOptions(request, runtime);
}

/**
 * @summary Queries the number of weak passwords that can cause high risks to your assets.
 *
 * @param request DescribeCheckEcsWarningsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckEcsWarningsResponse
 */
DescribeCheckEcsWarningsResponse Client::describeCheckEcsWarningsWithOptions(const DescribeCheckEcsWarningsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCheckEcsWarnings"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCheckEcsWarningsResponse>();
}

/**
 * @summary Queries the number of weak passwords that can cause high risks to your assets.
 *
 * @param request DescribeCheckEcsWarningsRequest
 * @return DescribeCheckEcsWarningsResponse
 */
DescribeCheckEcsWarningsResponse Client::describeCheckEcsWarnings(const DescribeCheckEcsWarningsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCheckEcsWarningsWithOptions(request, runtime);
}

/**
 * @summary Queries the parameters that you can configure to fix specified risk items.
 *
 * @param request DescribeCheckFixDetailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckFixDetailsResponse
 */
DescribeCheckFixDetailsResponse Client::describeCheckFixDetailsWithOptions(const DescribeCheckFixDetailsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckIds()) {
    query["CheckIds"] = request.checkIds();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRiskId()) {
    query["RiskId"] = request.riskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCheckFixDetails"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCheckFixDetailsResponse>();
}

/**
 * @summary Queries the parameters that you can configure to fix specified risk items.
 *
 * @param request DescribeCheckFixDetailsRequest
 * @return DescribeCheckFixDetailsResponse
 */
DescribeCheckFixDetailsResponse Client::describeCheckFixDetails(const DescribeCheckFixDetailsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCheckFixDetailsWithOptions(request, runtime);
}

/**
 * @summary Queries the result of the ISO 27001 compliance check.
 *
 * @param request DescribeCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckResultResponse
 */
DescribeCheckResultResponse Client::describeCheckResultWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeCheckResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCheckResultResponse>();
}

/**
 * @summary Queries the result of the ISO 27001 compliance check.
 *
 * @return DescribeCheckResultResponse
 */
DescribeCheckResultResponse Client::describeCheckResult() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCheckResultWithOptions(runtime);
}

/**
 * @summary Queries the number of alerts that are triggered by a check item.
 *
 * @param request DescribeCheckWarningCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckWarningCountResponse
 */
DescribeCheckWarningCountResponse Client::describeCheckWarningCountWithOptions(const DescribeCheckWarningCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliUid()) {
    query["AliUid"] = request.aliUid();
  }

  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasRiskId()) {
    query["RiskId"] = request.riskId();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCheckWarningCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCheckWarningCountResponse>();
}

/**
 * @summary Queries the number of alerts that are triggered by a check item.
 *
 * @param request DescribeCheckWarningCountRequest
 * @return DescribeCheckWarningCountResponse
 */
DescribeCheckWarningCountResponse Client::describeCheckWarningCount(const DescribeCheckWarningCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCheckWarningCountWithOptions(request, runtime);
}

/**
 * @summary Queries the details about a specified check item.
 *
 * @param request DescribeCheckWarningDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckWarningDetailResponse
 */
DescribeCheckWarningDetailResponse Client::describeCheckWarningDetailWithOptions(const DescribeCheckWarningDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasCheckWarningId()) {
    query["CheckWarningId"] = request.checkWarningId();
  }

  if (!!request.hasContainerName()) {
    query["ContainerName"] = request.containerName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCheckWarningDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCheckWarningDetailResponse>();
}

/**
 * @summary Queries the details about a specified check item.
 *
 * @param request DescribeCheckWarningDetailRequest
 * @return DescribeCheckWarningDetailResponse
 */
DescribeCheckWarningDetailResponse Client::describeCheckWarningDetail(const DescribeCheckWarningDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCheckWarningDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the servers on which the same risk item is detected by specifying a baseline and a check item.
 *
 * @param request DescribeCheckWarningMachinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckWarningMachinesResponse
 */
DescribeCheckWarningMachinesResponse Client::describeCheckWarningMachinesWithOptions(const DescribeCheckWarningMachinesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFilterUuid()) {
    query["FilterUuid"] = request.filterUuid();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasRiskId()) {
    query["RiskId"] = request.riskId();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCheckWarningMachines"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCheckWarningMachinesResponse>();
}

/**
 * @summary Queries the servers on which the same risk item is detected by specifying a baseline and a check item.
 *
 * @param request DescribeCheckWarningMachinesRequest
 * @return DescribeCheckWarningMachinesResponse
 */
DescribeCheckWarningMachinesResponse Client::describeCheckWarningMachines(const DescribeCheckWarningMachinesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCheckWarningMachinesWithOptions(request, runtime);
}

/**
 * @summary Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
 *
 * @param request DescribeCheckWarningSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckWarningSummaryResponse
 */
DescribeCheckWarningSummaryResponse Client::describeCheckWarningSummaryWithOptions(const DescribeCheckWarningSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskName()) {
    query["RiskName"] = request.riskName();
  }

  if (!!request.hasRiskStatus()) {
    query["RiskStatus"] = request.riskStatus();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasTypeName()) {
    query["TypeName"] = request.typeName();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCheckWarningSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCheckWarningSummaryResponse>();
}

/**
 * @summary Queries the statistical information about baseline check results. The information includes the number of servers on which a baseline check is performed, the number of baseline check items, and the pass rate of check items in the last baseline check.
 *
 * @param request DescribeCheckWarningSummaryRequest
 * @return DescribeCheckWarningSummaryResponse
 */
DescribeCheckWarningSummaryResponse Client::describeCheckWarningSummary(const DescribeCheckWarningSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCheckWarningSummaryWithOptions(request, runtime);
}

/**
 * @summary Queries information about specified risk items and the check items of a specified server.
 *
 * @param request DescribeCheckWarningsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCheckWarningsResponse
 */
DescribeCheckWarningsResponse Client::describeCheckWarningsWithOptions(const DescribeCheckWarningsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasCheckType()) {
    query["CheckType"] = request.checkType();
  }

  if (!!request.hasContainerName()) {
    query["ContainerName"] = request.containerName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasRiskId()) {
    query["RiskId"] = request.riskId();
  }

  if (!!request.hasRiskStatus()) {
    query["RiskStatus"] = request.riskStatus();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCheckWarnings"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCheckWarningsResponse>();
}

/**
 * @summary Queries information about specified risk items and the check items of a specified server.
 *
 * @param request DescribeCheckWarningsRequest
 * @return DescribeCheckWarningsResponse
 */
DescribeCheckWarningsResponse Client::describeCheckWarnings(const DescribeCheckWarningsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCheckWarningsWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of the Security Center agent.
 *
 * @param request DescribeClientConfSetupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClientConfSetupResponse
 */
DescribeClientConfSetupResponse Client::describeClientConfSetupWithOptions(const DescribeClientConfSetupRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStrategyTag()) {
    query["StrategyTag"] = request.strategyTag();
  }

  if (!!request.hasStrategyTagValue()) {
    query["StrategyTagValue"] = request.strategyTagValue();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeClientConfSetup"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeClientConfSetupResponse>();
}

/**
 * @summary Queries the configurations of the Security Center agent.
 *
 * @param request DescribeClientConfSetupRequest
 * @return DescribeClientConfSetupResponse
 */
DescribeClientConfSetupResponse Client::describeClientConfSetup(const DescribeClientConfSetupRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeClientConfSetupWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of servers to which different tags are added.
 *
 * @param request DescribeClientConfStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClientConfStrategyResponse
 */
DescribeClientConfStrategyResponse Client::describeClientConfStrategyWithOptions(const DescribeClientConfStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasTagValue()) {
    query["TagValue"] = request.tagValue();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeClientConfStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeClientConfStrategyResponse>();
}

/**
 * @summary Queries the configurations of servers to which different tags are added.
 *
 * @param request DescribeClientConfStrategyRequest
 * @return DescribeClientConfStrategyResponse
 */
DescribeClientConfStrategyResponse Client::describeClientConfStrategy(const DescribeClientConfStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeClientConfStrategyWithOptions(request, runtime);
}

/**
 * @summary Queries a list of agent issue types.
 *
 * @param request DescribeClientProblemTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClientProblemTypeResponse
 */
DescribeClientProblemTypeResponse Client::describeClientProblemTypeWithOptions(const DescribeClientProblemTypeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeClientProblemType"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeClientProblemTypeResponse>();
}

/**
 * @summary Queries a list of agent issue types.
 *
 * @param request DescribeClientProblemTypeRequest
 * @return DescribeClientProblemTypeResponse
 */
DescribeClientProblemTypeResponse Client::describeClientProblemType(const DescribeClientProblemTypeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeClientProblemTypeWithOptions(request, runtime);
}

/**
 * @summary Queries the information about assets that meet specific search conditions. For example, you can search for assets by the instance name or region of the asset.
 *
 * @description You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
 *
 * @param request DescribeCloudCenterInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudCenterInstancesResponse
 */
DescribeCloudCenterInstancesResponse Client::describeCloudCenterInstancesWithOptions(const DescribeCloudCenterInstancesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFlags()) {
    query["Flags"] = request.flags();
  }

  if (!!request.hasImportance()) {
    query["Importance"] = request.importance();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLogicalExp()) {
    query["LogicalExp"] = request.logicalExp();
  }

  if (!!request.hasMachineTypes()) {
    query["MachineTypes"] = request.machineTypes();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasNoGroupTrace()) {
    query["NoGroupTrace"] = request.noGroupTrace();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasUseNextToken()) {
    query["UseNextToken"] = request.useNextToken();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCloudCenterInstances"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCloudCenterInstancesResponse>();
}

/**
 * @summary Queries the information about assets that meet specific search conditions. For example, you can search for assets by the instance name or region of the asset.
 *
 * @description You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
 *
 * @param request DescribeCloudCenterInstancesRequest
 * @return DescribeCloudCenterInstancesResponse
 */
DescribeCloudCenterInstancesResponse Client::describeCloudCenterInstances(const DescribeCloudCenterInstancesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCloudCenterInstancesWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeCloudProductFieldStatistics is deprecated, please use Sas::2018-12-03::GetCloudAssetSummary instead.
 *
 * @summary Queries the statistics of cloud services.
 *
 * @param request DescribeCloudProductFieldStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudProductFieldStatisticsResponse
 */
DescribeCloudProductFieldStatisticsResponse Client::describeCloudProductFieldStatisticsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeCloudProductFieldStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCloudProductFieldStatisticsResponse>();
}

/**
 * @deprecated OpenAPI DescribeCloudProductFieldStatistics is deprecated, please use Sas::2018-12-03::GetCloudAssetSummary instead.
 *
 * @summary Queries the statistics of cloud services.
 *
 * @return DescribeCloudProductFieldStatisticsResponse
 */
DescribeCloudProductFieldStatisticsResponse Client::describeCloudProductFieldStatistics() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCloudProductFieldStatisticsWithOptions(runtime);
}

/**
 * @summary Queries the multi-cloud assets added to Security Center.
 *
 * @param request DescribeCloudVendorAccountAKListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudVendorAccountAKListResponse
 */
DescribeCloudVendorAccountAKListResponse Client::describeCloudVendorAccountAKListWithOptions(const DescribeCloudVendorAccountAKListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAuthIds()) {
    query["AuthIds"] = request.authIds();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasSubAccountName()) {
    query["SubAccountName"] = request.subAccountName();
  }

  if (!!request.hasVendorAuthAlias()) {
    query["VendorAuthAlias"] = request.vendorAuthAlias();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCloudVendorAccountAKList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCloudVendorAccountAKListResponse>();
}

/**
 * @summary Queries the multi-cloud assets added to Security Center.
 *
 * @param request DescribeCloudVendorAccountAKListRequest
 * @return DescribeCloudVendorAccountAKListResponse
 */
DescribeCloudVendorAccountAKListResponse Client::describeCloudVendorAccountAKList(const DescribeCloudVendorAccountAKListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCloudVendorAccountAKListWithOptions(request, runtime);
}

/**
 * @summary Query the trail configuration attributes of the corresponding AK configuration
 *
 * @param request DescribeCloudVendorTrialConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCloudVendorTrialConfigResponse
 */
DescribeCloudVendorTrialConfigResponse Client::describeCloudVendorTrialConfigWithOptions(const DescribeCloudVendorTrialConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCloudVendorTrialConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCloudVendorTrialConfigResponse>();
}

/**
 * @summary Query the trail configuration attributes of the corresponding AK configuration
 *
 * @param request DescribeCloudVendorTrialConfigRequest
 * @return DescribeCloudVendorTrialConfigResponse
 */
DescribeCloudVendorTrialConfigResponse Client::describeCloudVendorTrialConfig(const DescribeCloudVendorTrialConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCloudVendorTrialConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the information about an cluster based on the cluster ID.
 *
 * @param request DescribeClusterBasicInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterBasicInfoResponse
 */
DescribeClusterBasicInfoResponse Client::describeClusterBasicInfoWithOptions(const DescribeClusterBasicInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeClusterBasicInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeClusterBasicInfoResponse>();
}

/**
 * @summary Queries the information about an cluster based on the cluster ID.
 *
 * @param request DescribeClusterBasicInfoRequest
 * @return DescribeClusterBasicInfoResponse
 */
DescribeClusterBasicInfoResponse Client::describeClusterBasicInfo(const DescribeClusterBasicInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeClusterBasicInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the statistical information about host security.
 *
 * @param request DescribeClusterHostSecuritySummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterHostSecuritySummaryResponse
 */
DescribeClusterHostSecuritySummaryResponse Client::describeClusterHostSecuritySummaryWithOptions(const DescribeClusterHostSecuritySummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeClusterHostSecuritySummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeClusterHostSecuritySummaryResponse>();
}

/**
 * @summary Queries the statistical information about host security.
 *
 * @param request DescribeClusterHostSecuritySummaryRequest
 * @return DescribeClusterHostSecuritySummaryResponse
 */
DescribeClusterHostSecuritySummaryResponse Client::describeClusterHostSecuritySummary(const DescribeClusterHostSecuritySummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeClusterHostSecuritySummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the statistical information about image security.
 *
 * @param request DescribeClusterImageSecuritySummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterImageSecuritySummaryResponse
 */
DescribeClusterImageSecuritySummaryResponse Client::describeClusterImageSecuritySummaryWithOptions(const DescribeClusterImageSecuritySummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasImageDigest()) {
    query["ImageDigest"] = request.imageDigest();
  }

  if (!!request.hasImageRepoName()) {
    query["ImageRepoName"] = request.imageRepoName();
  }

  if (!!request.hasImageRepoNamespace()) {
    query["ImageRepoNamespace"] = request.imageRepoNamespace();
  }

  if (!!request.hasImageTag()) {
    query["ImageTag"] = request.imageTag();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeClusterImageSecuritySummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeClusterImageSecuritySummaryResponse>();
}

/**
 * @summary Queries the statistical information about image security.
 *
 * @param request DescribeClusterImageSecuritySummaryRequest
 * @return DescribeClusterImageSecuritySummaryResponse
 */
DescribeClusterImageSecuritySummaryResponse Client::describeClusterImageSecuritySummary(const DescribeClusterImageSecuritySummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeClusterImageSecuritySummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the information about a cluster.
 *
 * @param request DescribeClusterInfoListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterInfoListResponse
 */
DescribeClusterInfoListResponse Client::describeClusterInfoListWithOptions(const DescribeClusterInfoListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeClusterInfoList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeClusterInfoListResponse>();
}

/**
 * @summary Queries the information about a cluster.
 *
 * @param request DescribeClusterInfoListRequest
 * @return DescribeClusterInfoListResponse
 */
DescribeClusterInfoListResponse Client::describeClusterInfoList(const DescribeClusterInfoListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeClusterInfoListWithOptions(request, runtime);
}

/**
 * @summary Queries information about the network topology edge by cluster.
 *
 * @param request DescribeClusterNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterNetworkResponse
 */
DescribeClusterNetworkResponse Client::describeClusterNetworkWithOptions(const DescribeClusterNetworkRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeClusterNetwork"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeClusterNetworkResponse>();
}

/**
 * @summary Queries information about the network topology edge by cluster.
 *
 * @param request DescribeClusterNetworkRequest
 * @return DescribeClusterNetworkResponse
 */
DescribeClusterNetworkResponse Client::describeClusterNetwork(const DescribeClusterNetworkRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeClusterNetworkWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of vulnerabilities that are detected on a cluster.
 *
 * @param request DescribeClusterVulStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClusterVulStatisticsResponse
 */
DescribeClusterVulStatisticsResponse Client::describeClusterVulStatisticsWithOptions(const DescribeClusterVulStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasTypes()) {
    query["Types"] = request.types();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeClusterVulStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeClusterVulStatisticsResponse>();
}

/**
 * @summary Queries the statistics of vulnerabilities that are detected on a cluster.
 *
 * @param request DescribeClusterVulStatisticsRequest
 * @return DescribeClusterVulStatisticsResponse
 */
DescribeClusterVulStatisticsResponse Client::describeClusterVulStatistics(const DescribeClusterVulStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeClusterVulStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the information about a specified feature.
 *
 * @param request DescribeCommonOverallConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCommonOverallConfigResponse
 */
DescribeCommonOverallConfigResponse Client::describeCommonOverallConfigWithOptions(const DescribeCommonOverallConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCommonOverallConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCommonOverallConfigResponse>();
}

/**
 * @summary Queries the information about a specified feature.
 *
 * @param request DescribeCommonOverallConfigRequest
 * @return DescribeCommonOverallConfigResponse
 */
DescribeCommonOverallConfigResponse Client::describeCommonOverallConfig(const DescribeCommonOverallConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCommonOverallConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of features in proactive defense.
 *
 * @param request DescribeCommonOverallConfigListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCommonOverallConfigListResponse
 */
DescribeCommonOverallConfigListResponse Client::describeCommonOverallConfigListWithOptions(const DescribeCommonOverallConfigListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTypeList()) {
    query["TypeList"] = request.typeList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCommonOverallConfigList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCommonOverallConfigListResponse>();
}

/**
 * @summary Queries the configurations of features in proactive defense.
 *
 * @param request DescribeCommonOverallConfigListRequest
 * @return DescribeCommonOverallConfigListResponse
 */
DescribeCommonOverallConfigListResponse Client::describeCommonOverallConfigList(const DescribeCommonOverallConfigListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCommonOverallConfigListWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of the proactive defense feature.
 *
 * @param request DescribeCommonTargetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCommonTargetConfigResponse
 */
DescribeCommonTargetConfigResponse Client::describeCommonTargetConfigWithOptions(const DescribeCommonTargetConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCommonTargetConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCommonTargetConfigResponse>();
}

/**
 * @summary Queries the configurations of the proactive defense feature.
 *
 * @param request DescribeCommonTargetConfigRequest
 * @return DescribeCommonTargetConfigResponse
 */
DescribeCommonTargetConfigResponse Client::describeCommonTargetConfig(const DescribeCommonTargetConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCommonTargetConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the servers based on the specified configuration item.
 *
 * @param request DescribeCommonTargetResultListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCommonTargetResultListResponse
 */
DescribeCommonTargetResultListResponse Client::describeCommonTargetResultListWithOptions(const DescribeCommonTargetResultListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCommonTargetResultList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCommonTargetResultListResponse>();
}

/**
 * @summary Queries the information about the servers based on the specified configuration item.
 *
 * @param request DescribeCommonTargetResultListRequest
 * @return DescribeCommonTargetResultListResponse
 */
DescribeCommonTargetResultListResponse Client::describeCommonTargetResultList(const DescribeCommonTargetResultListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCommonTargetResultListWithOptions(request, runtime);
}

/**
 * @summary Queries the priorities to fix vulnerabilities.
 *
 * @param request DescribeConcernNecessityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConcernNecessityResponse
 */
DescribeConcernNecessityResponse Client::describeConcernNecessityWithOptions(const DescribeConcernNecessityRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeConcernNecessity"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeConcernNecessityResponse>();
}

/**
 * @summary Queries the priorities to fix vulnerabilities.
 *
 * @param request DescribeConcernNecessityRequest
 * @return DescribeConcernNecessityResponse
 */
DescribeConcernNecessityResponse Client::describeConcernNecessity(const DescribeConcernNecessityRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeConcernNecessityWithOptions(request, runtime);
}

/**
 * @summary Queries the information about a containerized application.
 *
 * @param request DescribeContainerAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerAppsResponse
 */
DescribeContainerAppsResponse Client::describeContainerAppsWithOptions(const DescribeContainerAppsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFieldValue()) {
    query["FieldValue"] = request.fieldValue();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeContainerApps"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerAppsResponse>();
}

/**
 * @summary Queries the information about a containerized application.
 *
 * @param request DescribeContainerAppsRequest
 * @return DescribeContainerAppsResponse
 */
DescribeContainerAppsResponse Client::describeContainerApps(const DescribeContainerAppsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerAppsWithOptions(request, runtime);
}

/**
 * @summary Obtains the filter conditions that you can use to filter the containers.
 *
 * @param request DescribeContainerCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerCriteriaResponse
 */
DescribeContainerCriteriaResponse Client::describeContainerCriteriaWithOptions(const DescribeContainerCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGroupField()) {
    query["GroupField"] = request.groupField();
  }

  if (!!request.hasValue()) {
    query["Value"] = request.value();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeContainerCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerCriteriaResponse>();
}

/**
 * @summary Obtains the filter conditions that you can use to filter the containers.
 *
 * @param request DescribeContainerCriteriaRequest
 * @return DescribeContainerCriteriaResponse
 */
DescribeContainerCriteriaResponse Client::describeContainerCriteria(const DescribeContainerCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerCriteriaWithOptions(request, runtime);
}

/**
 * @summary Queries the statistical information about containers.
 *
 * @param request DescribeContainerFieldStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerFieldStatisticsResponse
 */
DescribeContainerFieldStatisticsResponse Client::describeContainerFieldStatisticsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeContainerFieldStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerFieldStatisticsResponse>();
}

/**
 * @summary Queries the statistical information about containers.
 *
 * @return DescribeContainerFieldStatisticsResponse
 */
DescribeContainerFieldStatisticsResponse Client::describeContainerFieldStatistics() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerFieldStatisticsWithOptions(runtime);
}

/**
 * @summary Queries the attribute details of containers.
 *
 * @param request DescribeContainerGroupedFieldDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerGroupedFieldDetailResponse
 */
DescribeContainerGroupedFieldDetailResponse Client::describeContainerGroupedFieldDetailWithOptions(const DescribeContainerGroupedFieldDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasGroupField()) {
    query["GroupField"] = request.groupField();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeContainerGroupedFieldDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerGroupedFieldDetailResponse>();
}

/**
 * @summary Queries the attribute details of containers.
 *
 * @param request DescribeContainerGroupedFieldDetailRequest
 * @return DescribeContainerGroupedFieldDetailResponse
 */
DescribeContainerGroupedFieldDetailResponse Client::describeContainerGroupedFieldDetail(const DescribeContainerGroupedFieldDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerGroupedFieldDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the information about containers.
 *
 * @param request DescribeContainerInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerInstancesResponse
 */
DescribeContainerInstancesResponse Client::describeContainerInstancesWithOptions(const DescribeContainerInstancesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLogicalExp()) {
    query["LogicalExp"] = request.logicalExp();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeContainerInstances"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerInstancesResponse>();
}

/**
 * @summary Queries the information about containers.
 *
 * @param request DescribeContainerInstancesRequest
 * @return DescribeContainerInstancesResponse
 */
DescribeContainerInstancesResponse Client::describeContainerInstances(const DescribeContainerInstancesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerInstancesWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of the vulnerability scan of one or more running container applications.
 *
 * @param request DescribeContainerScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerScanConfigResponse
 */
DescribeContainerScanConfigResponse Client::describeContainerScanConfigWithOptions(const DescribeContainerScanConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeContainerScanConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerScanConfigResponse>();
}

/**
 * @summary Queries the configurations of the vulnerability scan of one or more running container applications.
 *
 * @param request DescribeContainerScanConfigRequest
 * @return DescribeContainerScanConfigResponse
 */
DescribeContainerScanConfigResponse Client::describeContainerScanConfig(const DescribeContainerScanConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerScanConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the Kritis status of a Container Service for Kubernetes (ACK) cluster.
 *
 * @param request DescribeContainerServiceK8sClusterKritisStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerServiceK8sClusterKritisStatusResponse
 */
DescribeContainerServiceK8sClusterKritisStatusResponse Client::describeContainerServiceK8sClusterKritisStatusWithOptions(const DescribeContainerServiceK8sClusterKritisStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeContainerServiceK8sClusterKritisStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerServiceK8sClusterKritisStatusResponse>();
}

/**
 * @summary Queries the Kritis status of a Container Service for Kubernetes (ACK) cluster.
 *
 * @param request DescribeContainerServiceK8sClusterKritisStatusRequest
 * @return DescribeContainerServiceK8sClusterKritisStatusResponse
 */
DescribeContainerServiceK8sClusterKritisStatusResponse Client::describeContainerServiceK8sClusterKritisStatus(const DescribeContainerServiceK8sClusterKritisStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerServiceK8sClusterKritisStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the namespace of a Container Service for Kubernetes (ACK) cluster.
 *
 * @param request DescribeContainerServiceK8sClusterNamespacesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerServiceK8sClusterNamespacesResponse
 */
DescribeContainerServiceK8sClusterNamespacesResponse Client::describeContainerServiceK8sClusterNamespacesWithOptions(const DescribeContainerServiceK8sClusterNamespacesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeContainerServiceK8sClusterNamespaces"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerServiceK8sClusterNamespacesResponse>();
}

/**
 * @summary Queries the namespace of a Container Service for Kubernetes (ACK) cluster.
 *
 * @param request DescribeContainerServiceK8sClusterNamespacesRequest
 * @return DescribeContainerServiceK8sClusterNamespacesResponse
 */
DescribeContainerServiceK8sClusterNamespacesResponse Client::describeContainerServiceK8sClusterNamespaces(const DescribeContainerServiceK8sClusterNamespacesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerServiceK8sClusterNamespacesWithOptions(request, runtime);
}

/**
 * @summary Queries a list of Container Service for Kubernetes (ACK) clusters.
 *
 * @param request DescribeContainerServiceK8sClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerServiceK8sClustersResponse
 */
DescribeContainerServiceK8sClustersResponse Client::describeContainerServiceK8sClustersWithOptions(const DescribeContainerServiceK8sClustersRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeContainerServiceK8sClusters"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerServiceK8sClustersResponse>();
}

/**
 * @summary Queries a list of Container Service for Kubernetes (ACK) clusters.
 *
 * @param request DescribeContainerServiceK8sClustersRequest
 * @return DescribeContainerServiceK8sClustersResponse
 */
DescribeContainerServiceK8sClustersResponse Client::describeContainerServiceK8sClusters(const DescribeContainerServiceK8sClustersRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerServiceK8sClustersWithOptions(request, runtime);
}

/**
 * @summary Queries the alert statistics on container assets.
 *
 * @description Only users who created a Container Registry Enterprise Edition instance can call this operation.
 *
 * @param request DescribeContainerStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerStatisticsResponse
 */
DescribeContainerStatisticsResponse Client::describeContainerStatisticsWithOptions(const DescribeContainerStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeContainerStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerStatisticsResponse>();
}

/**
 * @summary Queries the alert statistics on container assets.
 *
 * @description Only users who created a Container Registry Enterprise Edition instance can call this operation.
 *
 * @param request DescribeContainerStatisticsRequest
 * @return DescribeContainerStatisticsResponse
 */
DescribeContainerStatisticsResponse Client::describeContainerStatistics(const DescribeContainerStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the details of container assets by using an attribute.
 *
 * @param request DescribeContainerTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeContainerTagsResponse
 */
DescribeContainerTagsResponse Client::describeContainerTagsWithOptions(const DescribeContainerTagsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppName()) {
    query["AppName"] = request.appName();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFieldName()) {
    query["FieldName"] = request.fieldName();
  }

  if (!!request.hasFieldValue()) {
    query["FieldValue"] = request.fieldValue();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeContainerTags"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeContainerTagsResponse>();
}

/**
 * @summary Queries the details of container assets by using an attribute.
 *
 * @param request DescribeContainerTagsRequest
 * @return DescribeContainerTagsResponse
 */
DescribeContainerTagsResponse Client::describeContainerTags(const DescribeContainerTagsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeContainerTagsWithOptions(request, runtime);
}

/**
 * @summary Queries the number of images that are not scanned.
 *
 * @param request DescribeCountNotScannedImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCountNotScannedImageResponse
 */
DescribeCountNotScannedImageResponse Client::describeCountNotScannedImageWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeCountNotScannedImage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCountNotScannedImageResponse>();
}

/**
 * @summary Queries the number of images that are not scanned.
 *
 * @return DescribeCountNotScannedImageResponse
 */
DescribeCountNotScannedImageResponse Client::describeCountNotScannedImage() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCountNotScannedImageWithOptions(runtime);
}

/**
 * @summary Queries the number of images that are scanned.
 *
 * @param request DescribeCountScannedImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCountScannedImageResponse
 */
DescribeCountScannedImageResponse Client::describeCountScannedImageWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeCountScannedImage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCountScannedImageResponse>();
}

/**
 * @summary Queries the number of images that are scanned.
 *
 * @return DescribeCountScannedImageResponse
 */
DescribeCountScannedImageResponse Client::describeCountScannedImage() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCountScannedImageWithOptions(runtime);
}

/**
 * @summary Queries the filter conditions that are used to search for assets in fuzzy match mode.
 *
 * @param request DescribeCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCriteriaResponse
 */
DescribeCriteriaResponse Client::describeCriteriaWithOptions(const DescribeCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMachineTypes()) {
    query["MachineTypes"] = request.machineTypes();
  }

  if (!!request.hasSupportAutoTag()) {
    query["SupportAutoTag"] = request.supportAutoTag();
  }

  if (!!request.hasValue()) {
    query["Value"] = request.value();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCriteriaResponse>();
}

/**
 * @summary Queries the filter conditions that are used to search for assets in fuzzy match mode.
 *
 * @param request DescribeCriteriaRequest
 * @return DescribeCriteriaResponse
 */
DescribeCriteriaResponse Client::describeCriteria(const DescribeCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCriteriaWithOptions(request, runtime);
}

/**
 * @summary Queries the list of servers on which the custom defense rule against brute-force attacks takes effect.
 *
 * @param request DescribeCustomBlockInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomBlockInstancesResponse
 */
DescribeCustomBlockInstancesResponse Client::describeCustomBlockInstancesWithOptions(const DescribeCustomBlockInstancesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBlockIp()) {
    query["BlockIp"] = request.blockIp();
  }

  if (!!request.hasBound()) {
    query["Bound"] = request.bound();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCustomBlockInstances"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCustomBlockInstancesResponse>();
}

/**
 * @summary Queries the list of servers on which the custom defense rule against brute-force attacks takes effect.
 *
 * @param request DescribeCustomBlockInstancesRequest
 * @return DescribeCustomBlockInstancesResponse
 */
DescribeCustomBlockInstancesResponse Client::describeCustomBlockInstances(const DescribeCustomBlockInstancesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCustomBlockInstancesWithOptions(request, runtime);
}

/**
 * @summary Queries the defense rules against brute-force attacks that are applied to one or more servers.
 *
 * @param request DescribeCustomBlockRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomBlockRecordsResponse
 */
DescribeCustomBlockRecordsResponse Client::describeCustomBlockRecordsWithOptions(const DescribeCustomBlockRecordsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBlockIp()) {
    query["BlockIp"] = request.blockIp();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCustomBlockRecords"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCustomBlockRecordsResponse>();
}

/**
 * @summary Queries the defense rules against brute-force attacks that are applied to one or more servers.
 *
 * @param request DescribeCustomBlockRecordsRequest
 * @return DescribeCustomBlockRecordsResponse
 */
DescribeCustomBlockRecordsResponse Client::describeCustomBlockRecords(const DescribeCustomBlockRecordsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCustomBlockRecordsWithOptions(request, runtime);
}

/**
 * @summary Obtains the configurations of a security report.
 *
 * @param request DescribeCustomizeReportConfigDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomizeReportConfigDetailResponse
 */
DescribeCustomizeReportConfigDetailResponse Client::describeCustomizeReportConfigDetailWithOptions(const DescribeCustomizeReportConfigDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasReportId()) {
    query["ReportId"] = request.reportId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCustomizeReportConfigDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCustomizeReportConfigDetailResponse>();
}

/**
 * @summary Obtains the configurations of a security report.
 *
 * @param request DescribeCustomizeReportConfigDetailRequest
 * @return DescribeCustomizeReportConfigDetailResponse
 */
DescribeCustomizeReportConfigDetailResponse Client::describeCustomizeReportConfigDetail(const DescribeCustomizeReportConfigDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCustomizeReportConfigDetailWithOptions(request, runtime);
}

/**
 * @summary Queries security reports.
 *
 * @param request DescribeCustomizeReportListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomizeReportListResponse
 */
DescribeCustomizeReportListResponse Client::describeCustomizeReportListWithOptions(const DescribeCustomizeReportListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPinned()) {
    query["Pinned"] = request.pinned();
  }

  if (!!request.hasReportStatus()) {
    query["ReportStatus"] = request.reportStatus();
  }

  if (!!request.hasReportType()) {
    query["ReportType"] = request.reportType();
  }

  if (!!request.hasReportVersion()) {
    query["ReportVersion"] = request.reportVersion();
  }

  if (!!request.hasTitle()) {
    query["Title"] = request.title();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCustomizeReportList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCustomizeReportListResponse>();
}

/**
 * @summary Queries security reports.
 *
 * @param request DescribeCustomizeReportListRequest
 * @return DescribeCustomizeReportListResponse
 */
DescribeCustomizeReportListResponse Client::describeCustomizeReportList(const DescribeCustomizeReportListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCustomizeReportListWithOptions(request, runtime);
}

/**
 * @summary Queries the Object Storage Service (OSS) information of the file that is uploaded to create custom weak password rules.
 *
 * @param request DescribeCustomizedDictUploadInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomizedDictUploadInfoResponse
 */
DescribeCustomizedDictUploadInfoResponse Client::describeCustomizedDictUploadInfoWithOptions(const DescribeCustomizedDictUploadInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCustomizedDictUploadInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCustomizedDictUploadInfoResponse>();
}

/**
 * @summary Queries the Object Storage Service (OSS) information of the file that is uploaded to create custom weak password rules.
 *
 * @param request DescribeCustomizedDictUploadInfoRequest
 * @return DescribeCustomizedDictUploadInfoResponse
 */
DescribeCustomizedDictUploadInfoResponse Client::describeCustomizedDictUploadInfo(const DescribeCustomizedDictUploadInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCustomizedDictUploadInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the servers to which custom policies are applied.
 *
 * @param request DescribeCustomizedStrategyTargetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomizedStrategyTargetsResponse
 */
DescribeCustomizedStrategyTargetsResponse Client::describeCustomizedStrategyTargetsWithOptions(const DescribeCustomizedStrategyTargetsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCustomizedStrategyTargets"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCustomizedStrategyTargetsResponse>();
}

/**
 * @summary Queries the servers to which custom policies are applied.
 *
 * @param request DescribeCustomizedStrategyTargetsRequest
 * @return DescribeCustomizedStrategyTargetsResponse
 */
DescribeCustomizedStrategyTargetsResponse Client::describeCustomizedStrategyTargets(const DescribeCustomizedStrategyTargetsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCustomizedStrategyTargetsWithOptions(request, runtime);
}

/**
 * @summary Queries periodic scan tasks. The tasks include image scan tasks, urgent vulnerability scan tasks, and virus scan tasks.
 *
 * @param request DescribeCycleTaskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCycleTaskListResponse
 */
DescribeCycleTaskListResponse Client::describeCycleTaskListWithOptions(const DescribeCycleTaskListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigId()) {
    query["ConfigId"] = request.configId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasTaskName()) {
    query["TaskName"] = request.taskName();
  }

  if (!!request.hasTaskType()) {
    query["TaskType"] = request.taskType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeCycleTaskList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeCycleTaskListResponse>();
}

/**
 * @summary Queries periodic scan tasks. The tasks include image scan tasks, urgent vulnerability scan tasks, and virus scan tasks.
 *
 * @param request DescribeCycleTaskListRequest
 * @return DescribeCycleTaskListResponse
 */
DescribeCycleTaskListResponse Client::describeCycleTaskList(const DescribeCycleTaskListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeCycleTaskListWithOptions(request, runtime);
}

/**
 * @summary Queries data sources for DingTalk notifications. You can configure the types of alerts for which you want to use a DingTalk chatbot to send notifications based on the data sources.
 *
 * @param request DescribeDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDataSourceResponse
 */
DescribeDataSourceResponse Client::describeDataSourceWithOptions(const DescribeDataSourceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigType()) {
    query["ConfigType"] = request.configType();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDataSource"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDataSourceResponse>();
}

/**
 * @summary Queries data sources for DingTalk notifications. You can configure the types of alerts for which you want to use a DingTalk chatbot to send notifications based on the data sources.
 *
 * @param request DescribeDataSourceRequest
 * @return DescribeDataSourceResponse
 */
DescribeDataSourceResponse Client::describeDataSource(const DescribeDataSourceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDataSourceWithOptions(request, runtime);
}

/**
 * @summary Queries the keywords of a custom dictionary that is generated by using weak passwords.
 *
 * @param request DescribeDefaultKeyInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDefaultKeyInfoResponse
 */
DescribeDefaultKeyInfoResponse Client::describeDefaultKeyInfoWithOptions(const DescribeDefaultKeyInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDefaultKeyInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDefaultKeyInfoResponse>();
}

/**
 * @summary Queries the keywords of a custom dictionary that is generated by using weak passwords.
 *
 * @param request DescribeDefaultKeyInfoRequest
 * @return DescribeDefaultKeyInfoResponse
 */
DescribeDefaultKeyInfoResponse Client::describeDefaultKeyInfo(const DescribeDefaultKeyInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDefaultKeyInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the default installation version of the proxy that is used in hybrid-cloud scenarios.
 *
 * @param request DescribeDefaultProxyInstallVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDefaultProxyInstallVersionResponse
 */
DescribeDefaultProxyInstallVersionResponse Client::describeDefaultProxyInstallVersionWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeDefaultProxyInstallVersion"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDefaultProxyInstallVersionResponse>();
}

/**
 * @summary Queries the default installation version of the proxy that is used in hybrid-cloud scenarios.
 *
 * @return DescribeDefaultProxyInstallVersionResponse
 */
DescribeDefaultProxyInstallVersionResponse Client::describeDefaultProxyInstallVersion() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDefaultProxyInstallVersionWithOptions(runtime);
}

/**
 * @summary Obtains DingTalk notifications.
 *
 * @param request DescribeDingTalkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDingTalkResponse
 */
DescribeDingTalkResponse Client::describeDingTalkWithOptions(const DescribeDingTalkRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRuleActionName()) {
    query["RuleActionName"] = request.ruleActionName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDingTalk"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDingTalkResponse>();
}

/**
 * @summary Obtains DingTalk notifications.
 *
 * @param request DescribeDingTalkRequest
 * @return DescribeDingTalkResponse
 */
DescribeDingTalkResponse Client::describeDingTalk(const DescribeDingTalkRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDingTalkWithOptions(request, runtime);
}

/**
 * @summary Queries the number of domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainCountResponse
 */
DescribeDomainCountResponse Client::describeDomainCountWithOptions(const DescribeDomainCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDomainCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDomainCountResponse>();
}

/**
 * @summary Queries the number of domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainCountRequest
 * @return DescribeDomainCountResponse
 */
DescribeDomainCountResponse Client::describeDomainCount(const DescribeDomainCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDomainCountWithOptions(request, runtime);
}

/**
 * @summary Queries the details of domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainDetailResponse
 */
DescribeDomainDetailResponse Client::describeDomainDetailWithOptions(const DescribeDomainDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDomainName()) {
    query["DomainName"] = request.domainName();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDomainDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDomainDetailResponse>();
}

/**
 * @summary Queries the details of domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainDetailRequest
 * @return DescribeDomainDetailResponse
 */
DescribeDomainDetailResponse Client::describeDomainDetail(const DescribeDomainDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDomainDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainListResponse
 */
DescribeDomainListResponse Client::describeDomainListWithOptions(const DescribeDomainListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDomainType()) {
    query["DomainType"] = request.domainType();
  }

  if (!!request.hasFuzzyDomain()) {
    query["FuzzyDomain"] = request.fuzzyDomain();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDomainList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDomainListResponse>();
}

/**
 * @summary Queries the information about the domain assets within your Alibaba Cloud account.
 *
 * @param request DescribeDomainListRequest
 * @return DescribeDomainListResponse
 */
DescribeDomainListResponse Client::describeDomainList(const DescribeDomainListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDomainListWithOptions(request, runtime);
}

/**
 * @summary Queries the security alert data of a website security report.
 *
 * @param request DescribeDomainSecureAlarmListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureAlarmListResponse
 */
DescribeDomainSecureAlarmListResponse Client::describeDomainSecureAlarmListWithOptions(const DescribeDomainSecureAlarmListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDomainSecureAlarmList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDomainSecureAlarmListResponse>();
}

/**
 * @summary Queries the security alert data of a website security report.
 *
 * @param request DescribeDomainSecureAlarmListRequest
 * @return DescribeDomainSecureAlarmListResponse
 */
DescribeDomainSecureAlarmListResponse Client::describeDomainSecureAlarmList(const DescribeDomainSecureAlarmListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDomainSecureAlarmListWithOptions(request, runtime);
}

/**
 * @summary Queries a list of risky websites in your website security report and the security information about the websites, including the number of vulnerabilities and the number of alerts.
 *
 * @param request DescribeDomainSecureRiskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureRiskListResponse
 */
DescribeDomainSecureRiskListResponse Client::describeDomainSecureRiskListWithOptions(const DescribeDomainSecureRiskListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDomainSecureRiskList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDomainSecureRiskListResponse>();
}

/**
 * @summary Queries a list of risky websites in your website security report and the security information about the websites, including the number of vulnerabilities and the number of alerts.
 *
 * @param request DescribeDomainSecureRiskListRequest
 * @return DescribeDomainSecureRiskListResponse
 */
DescribeDomainSecureRiskListResponse Client::describeDomainSecureRiskList(const DescribeDomainSecureRiskListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDomainSecureRiskListWithOptions(request, runtime);
}

/**
 * @summary Queries the security score in your website security report. The full score is 100.
 *
 * @param request DescribeDomainSecureScoreRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureScoreResponse
 */
DescribeDomainSecureScoreResponse Client::describeDomainSecureScoreWithOptions(const DescribeDomainSecureScoreRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDomainSecureScore"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDomainSecureScoreResponse>();
}

/**
 * @summary Queries the security score in your website security report. The full score is 100.
 *
 * @param request DescribeDomainSecureScoreRequest
 * @return DescribeDomainSecureScoreResponse
 */
DescribeDomainSecureScoreResponse Client::describeDomainSecureScore(const DescribeDomainSecureScoreRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDomainSecureScoreWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics in your website security report, including the number of websites and the number of security events.
 *
 * @param request DescribeDomainSecureStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureStatisticsResponse
 */
DescribeDomainSecureStatisticsResponse Client::describeDomainSecureStatisticsWithOptions(const DescribeDomainSecureStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDomainSecureStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDomainSecureStatisticsResponse>();
}

/**
 * @summary Queries the statistics in your website security report, including the number of websites and the number of security events.
 *
 * @param request DescribeDomainSecureStatisticsRequest
 * @return DescribeDomainSecureStatisticsResponse
 */
DescribeDomainSecureStatisticsResponse Client::describeDomainSecureStatistics(const DescribeDomainSecureStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDomainSecureStatisticsWithOptions(request, runtime);
}

/**
 * @summary Query Network Security Report - Security Suggestions
 *
 * @param request DescribeDomainSecureSuggestsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureSuggestsResponse
 */
DescribeDomainSecureSuggestsResponse Client::describeDomainSecureSuggestsWithOptions(const DescribeDomainSecureSuggestsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDomainSecureSuggests"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDomainSecureSuggestsResponse>();
}

/**
 * @summary Query Network Security Report - Security Suggestions
 *
 * @param request DescribeDomainSecureSuggestsRequest
 * @return DescribeDomainSecureSuggestsResponse
 */
DescribeDomainSecureSuggestsResponse Client::describeDomainSecureSuggests(const DescribeDomainSecureSuggestsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDomainSecureSuggestsWithOptions(request, runtime);
}

/**
 * @summary Queries a list of vulnerabilities in your website security report.
 *
 * @param request DescribeDomainSecureVulListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecureVulListResponse
 */
DescribeDomainSecureVulListResponse Client::describeDomainSecureVulListWithOptions(const DescribeDomainSecureVulListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDomainSecureVulList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDomainSecureVulListResponse>();
}

/**
 * @summary Queries a list of vulnerabilities in your website security report.
 *
 * @param request DescribeDomainSecureVulListRequest
 * @return DescribeDomainSecureVulListResponse
 */
DescribeDomainSecureVulListResponse Client::describeDomainSecureVulList(const DescribeDomainSecureVulListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDomainSecureVulListWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeDynamicDict is deprecated, please use Sas::2018-12-03::DescribeCustomizedDict instead.
 *
 * @summary Queries custom weak password rules for the baseline check feature.
 *
 * @param request DescribeDynamicDictRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDynamicDictResponse
 */
DescribeDynamicDictResponse Client::describeDynamicDictWithOptions(const DescribeDynamicDictRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDynamicDict"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDynamicDictResponse>();
}

/**
 * @deprecated OpenAPI DescribeDynamicDict is deprecated, please use Sas::2018-12-03::DescribeCustomizedDict instead.
 *
 * @summary Queries custom weak password rules for the baseline check feature.
 *
 * @param request DescribeDynamicDictRequest
 * @return DescribeDynamicDictResponse
 */
DescribeDynamicDictResponse Client::describeDynamicDict(const DescribeDynamicDictRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDynamicDictWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeDynamicDictUploadInfo is deprecated, please use Sas::2018-12-03::DescribeCustomizedDictUploadInfo instead.
 *
 * @summary Queries the information about an uploaded Object Storage Service (OSS) object that contains custom weak passwords and is used for baseline checks.
 *
 * @param request DescribeDynamicDictUploadInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDynamicDictUploadInfoResponse
 */
DescribeDynamicDictUploadInfoResponse Client::describeDynamicDictUploadInfoWithOptions(const DescribeDynamicDictUploadInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeDynamicDictUploadInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeDynamicDictUploadInfoResponse>();
}

/**
 * @deprecated OpenAPI DescribeDynamicDictUploadInfo is deprecated, please use Sas::2018-12-03::DescribeCustomizedDictUploadInfo instead.
 *
 * @summary Queries the information about an uploaded Object Storage Service (OSS) object that contains custom weak passwords and is used for baseline checks.
 *
 * @param request DescribeDynamicDictUploadInfoRequest
 * @return DescribeDynamicDictUploadInfoResponse
 */
DescribeDynamicDictUploadInfoResponse Client::describeDynamicDictUploadInfo(const DescribeDynamicDictUploadInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeDynamicDictUploadInfoWithOptions(request, runtime);
}

/**
 * @summary Queries whether Security Center is authorized to scan for urgent vulnerabilities.
 *
 * @param request DescribeEmgUserAgreementRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEmgUserAgreementResponse
 */
DescribeEmgUserAgreementResponse Client::describeEmgUserAgreementWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeEmgUserAgreement"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeEmgUserAgreementResponse>();
}

/**
 * @summary Queries whether Security Center is authorized to scan for urgent vulnerabilities.
 *
 * @return DescribeEmgUserAgreementResponse
 */
DescribeEmgUserAgreementResponse Client::describeEmgUserAgreement() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeEmgUserAgreementWithOptions(runtime);
}

/**
 * @summary Queries the details of urgent vulnerabilities.
 *
 * @param request DescribeEmgVulItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEmgVulItemResponse
 */
DescribeEmgVulItemResponse Client::describeEmgVulItemWithOptions(const DescribeEmgVulItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckType()) {
    query["CheckType"] = request.checkType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskStatus()) {
    query["RiskStatus"] = request.riskStatus();
  }

  if (!!request.hasScanType()) {
    query["ScanType"] = request.scanType();
  }

  if (!!request.hasVulName()) {
    query["VulName"] = request.vulName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeEmgVulItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeEmgVulItemResponse>();
}

/**
 * @summary Queries the details of urgent vulnerabilities.
 *
 * @param request DescribeEmgVulItemRequest
 * @return DescribeEmgVulItemResponse
 */
DescribeEmgVulItemResponse Client::describeEmgVulItem(const DescribeEmgVulItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeEmgVulItemWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of alert events by risk level.
 *
 * @param request DescribeEventLevelCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEventLevelCountResponse
 */
DescribeEventLevelCountResponse Client::describeEventLevelCountWithOptions(const DescribeEventLevelCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasContainerIds()) {
    query["ContainerIds"] = request.containerIds();
  }

  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasMultiAccountActionType()) {
    query["MultiAccountActionType"] = request.multiAccountActionType();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeEventLevelCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeEventLevelCountResponse>();
}

/**
 * @summary Queries the statistics of alert events by risk level.
 *
 * @param request DescribeEventLevelCountRequest
 * @return DescribeEventLevelCountResponse
 */
DescribeEventLevelCountResponse Client::describeEventLevelCount(const DescribeEventLevelCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeEventLevelCountWithOptions(request, runtime);
}

/**
 * @summary Queries the platforms that are supported by the feature of container threat detection.
 *
 * @param request DescribeEventOnStageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEventOnStageResponse
 */
DescribeEventOnStageResponse Client::describeEventOnStageWithOptions(const DescribeEventOnStageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeEventOnStage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeEventOnStageResponse>();
}

/**
 * @summary Queries the platforms that are supported by the feature of container threat detection.
 *
 * @param request DescribeEventOnStageRequest
 * @return DescribeEventOnStageResponse
 */
DescribeEventOnStageResponse Client::describeEventOnStage(const DescribeEventOnStageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeEventOnStageWithOptions(request, runtime);
}

/**
 * @summary Queries the directories that are excluded from anti-ransomware.
 *
 * @param request DescribeExcludeSystemPathRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExcludeSystemPathResponse
 */
DescribeExcludeSystemPathResponse Client::describeExcludeSystemPathWithOptions(const DescribeExcludeSystemPathRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeExcludeSystemPath"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExcludeSystemPathResponse>();
}

/**
 * @summary Queries the directories that are excluded from anti-ransomware.
 *
 * @param request DescribeExcludeSystemPathRequest
 * @return DescribeExcludeSystemPathResponse
 */
DescribeExcludeSystemPathResponse Client::describeExcludeSystemPath(const DescribeExcludeSystemPathRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExcludeSystemPathWithOptions(request, runtime);
}

/**
 * @summary Queries the progress of a task that exports your assets to an Excel file.
 *
 * @param request DescribeExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExportInfoResponse
 */
DescribeExportInfoResponse Client::describeExportInfoWithOptions(const DescribeExportInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExportId()) {
    query["ExportId"] = request.exportId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeExportInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExportInfoResponse>();
}

/**
 * @summary Queries the progress of a task that exports your assets to an Excel file.
 *
 * @param request DescribeExportInfoRequest
 * @return DescribeExportInfoResponse
 */
DescribeExportInfoResponse Client::describeExportInfo(const DescribeExportInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExportInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the weak password-related risks of a specified server that is exposed on the Internet.
 *
 * @param request DescribeExposedCheckWarningRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedCheckWarningResponse
 */
DescribeExposedCheckWarningResponse Client::describeExposedCheckWarningWithOptions(const DescribeExposedCheckWarningRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasTypeName()) {
    query["TypeName"] = request.typeName();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeExposedCheckWarning"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExposedCheckWarningResponse>();
}

/**
 * @summary Queries the weak password-related risks of a specified server that is exposed on the Internet.
 *
 * @param request DescribeExposedCheckWarningRequest
 * @return DescribeExposedCheckWarningResponse
 */
DescribeExposedCheckWarningResponse Client::describeExposedCheckWarning(const DescribeExposedCheckWarningRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExposedCheckWarningWithOptions(request, runtime);
}

/**
 * @summary Queries the search conditions that are used to search for exposed assets.
 *
 * @param request DescribeExposedInstanceCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedInstanceCriteriaResponse
 */
DescribeExposedInstanceCriteriaResponse Client::describeExposedInstanceCriteriaWithOptions(const DescribeExposedInstanceCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasValue()) {
    query["Value"] = request.value();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeExposedInstanceCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExposedInstanceCriteriaResponse>();
}

/**
 * @summary Queries the search conditions that are used to search for exposed assets.
 *
 * @param request DescribeExposedInstanceCriteriaRequest
 * @return DescribeExposedInstanceCriteriaResponse
 */
DescribeExposedInstanceCriteriaResponse Client::describeExposedInstanceCriteria(const DescribeExposedInstanceCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExposedInstanceCriteriaWithOptions(request, runtime);
}

/**
 * @summary Queries the details of a specified server that is exposed on the Internet.
 *
 * @param request DescribeExposedInstanceDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedInstanceDetailResponse
 */
DescribeExposedInstanceDetailResponse Client::describeExposedInstanceDetailWithOptions(const DescribeExposedInstanceDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeExposedInstanceDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExposedInstanceDetailResponse>();
}

/**
 * @summary Queries the details of a specified server that is exposed on the Internet.
 *
 * @param request DescribeExposedInstanceDetailRequest
 * @return DescribeExposedInstanceDetailResponse
 */
DescribeExposedInstanceDetailResponse Client::describeExposedInstanceDetail(const DescribeExposedInstanceDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExposedInstanceDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the assets that are exposed on the Internet.
 *
 * @param request DescribeExposedInstanceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedInstanceListResponse
 */
DescribeExposedInstanceListResponse Client::describeExposedInstanceListWithOptions(const DescribeExposedInstanceListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssetType()) {
    query["AssetType"] = request.assetType();
  }

  if (!!request.hasCspmStatus()) {
    query["CspmStatus"] = request.cspmStatus();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasExposureComponent()) {
    query["ExposureComponent"] = request.exposureComponent();
  }

  if (!!request.hasExposureComponentBizType()) {
    query["ExposureComponentBizType"] = request.exposureComponentBizType();
  }

  if (!!request.hasExposureIp()) {
    query["ExposureIp"] = request.exposureIp();
  }

  if (!!request.hasExposurePort()) {
    query["ExposurePort"] = request.exposurePort();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasHealthStatus()) {
    query["HealthStatus"] = request.healthStatus();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceName()) {
    query["InstanceName"] = request.instanceName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasVulStatus()) {
    query["VulStatus"] = request.vulStatus();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeExposedInstanceList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExposedInstanceListResponse>();
}

/**
 * @summary Queries the information about the assets that are exposed on the Internet.
 *
 * @param request DescribeExposedInstanceListRequest
 * @return DescribeExposedInstanceListResponse
 */
DescribeExposedInstanceListResponse Client::describeExposedInstanceList(const DescribeExposedInstanceListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExposedInstanceListWithOptions(request, runtime);
}

/**
 * @summary Queries the exposure statistics of the assets on the Internet.
 *
 * @param request DescribeExposedStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedStatisticsResponse
 */
DescribeExposedStatisticsResponse Client::describeExposedStatisticsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeExposedStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExposedStatisticsResponse>();
}

/**
 * @summary Queries the exposure statistics of the assets on the Internet.
 *
 * @return DescribeExposedStatisticsResponse
 */
DescribeExposedStatisticsResponse Client::describeExposedStatistics() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExposedStatisticsWithOptions(runtime);
}

/**
 * @summary Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
 *
 * @param request DescribeExposedStatisticsDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeExposedStatisticsDetailResponse
 */
DescribeExposedStatisticsDetailResponse Client::describeExposedStatisticsDetailWithOptions(const DescribeExposedStatisticsDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasStatisticsType()) {
    query["StatisticsType"] = request.statisticsType();
  }

  if (!!request.hasStatisticsTypeGatewayType()) {
    query["StatisticsTypeGatewayType"] = request.statisticsTypeGatewayType();
  }

  if (!!request.hasStatisticsTypeInstanceValue()) {
    query["StatisticsTypeInstanceValue"] = request.statisticsTypeInstanceValue();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeExposedStatisticsDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeExposedStatisticsDetailResponse>();
}

/**
 * @summary Queries the gateway assets, ports, system components, or public IP addresses that are exposed on the Internet.
 *
 * @param request DescribeExposedStatisticsDetailRequest
 * @return DescribeExposedStatisticsDetailResponse
 */
DescribeExposedStatisticsDetailResponse Client::describeExposedStatisticsDetail(const DescribeExposedStatisticsDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeExposedStatisticsDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of servers.
 *
 * @param request DescribeFieldStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFieldStatisticsResponse
 */
DescribeFieldStatisticsResponse Client::describeFieldStatisticsWithOptions(const DescribeFieldStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMachineTypes()) {
    query["MachineTypes"] = request.machineTypes();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeFieldStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeFieldStatisticsResponse>();
}

/**
 * @summary Queries the statistics of servers.
 *
 * @param request DescribeFieldStatisticsRequest
 * @return DescribeFieldStatisticsResponse
 */
DescribeFieldStatisticsResponse Client::describeFieldStatistics(const DescribeFieldStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeFieldStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the number of vulnerabilities that are fixed by the pay-as-you-go vulnerability fixing feature.
 *
 * @param request DescribeFixUsedCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFixUsedCountResponse
 */
DescribeFixUsedCountResponse Client::describeFixUsedCountWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeFixUsedCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeFixUsedCountResponse>();
}

/**
 * @summary Queries the number of vulnerabilities that are fixed by the pay-as-you-go vulnerability fixing feature.
 *
 * @return DescribeFixUsedCountResponse
 */
DescribeFixUsedCountResponse Client::describeFixUsedCount() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeFixUsedCountWithOptions(runtime);
}

/**
 * @summary Queries the pre-patches that are required to fix a specified Windows system vulnerability.
 *
 * @param request DescribeFrontVulPatchListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFrontVulPatchListResponse
 */
DescribeFrontVulPatchListResponse Client::describeFrontVulPatchListWithOptions(const DescribeFrontVulPatchListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInfo()) {
    query["Info"] = request.info();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasOperateType()) {
    query["OperateType"] = request.operateType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeFrontVulPatchList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeFrontVulPatchListResponse>();
}

/**
 * @summary Queries the pre-patches that are required to fix a specified Windows system vulnerability.
 *
 * @param request DescribeFrontVulPatchListRequest
 * @return DescribeFrontVulPatchListResponse
 */
DescribeFrontVulPatchListResponse Client::describeFrontVulPatchList(const DescribeFrontVulPatchListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeFrontVulPatchListWithOptions(request, runtime);
}

/**
 * @summary Alert Event Investigation
 *
 * @param request DescribeGraph4InvestigationOnlineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGraph4InvestigationOnlineResponse
 */
DescribeGraph4InvestigationOnlineResponse Client::describeGraph4InvestigationOnlineWithOptions(const DescribeGraph4InvestigationOnlineRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAnomalyId()) {
    query["AnomalyId"] = request.anomalyId();
  }

  if (!!request.hasAnomalyUuid()) {
    query["AnomalyUuid"] = request.anomalyUuid();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasVertexId()) {
    query["VertexId"] = request.vertexId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeGraph4InvestigationOnline"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeGraph4InvestigationOnlineResponse>();
}

/**
 * @summary Alert Event Investigation
 *
 * @param request DescribeGraph4InvestigationOnlineRequest
 * @return DescribeGraph4InvestigationOnlineResponse
 */
DescribeGraph4InvestigationOnlineResponse Client::describeGraph4InvestigationOnline(const DescribeGraph4InvestigationOnlineRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeGraph4InvestigationOnlineWithOptions(request, runtime);
}

/**
 * @summary Queries the structure of a group.
 *
 * @param request DescribeGroupStructRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupStructResponse
 */
DescribeGroupStructResponse Client::describeGroupStructWithOptions(const DescribeGroupStructRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeGroupStruct"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeGroupStructResponse>();
}

/**
 * @summary Queries the structure of a group.
 *
 * @param request DescribeGroupStructRequest
 * @return DescribeGroupStructResponse
 */
DescribeGroupStructResponse Client::describeGroupStruct(const DescribeGroupStructRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeGroupStructWithOptions(request, runtime);
}

/**
 * @summary Queries containers by group type.
 *
 * @param request DescribeGroupedContainerInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupedContainerInstancesResponse
 */
DescribeGroupedContainerInstancesResponse Client::describeGroupedContainerInstancesWithOptions(const DescribeGroupedContainerInstancesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFieldValue()) {
    query["FieldValue"] = request.fieldValue();
  }

  if (!!request.hasGroupField()) {
    query["GroupField"] = request.groupField();
  }

  if (!!request.hasLogicalExp()) {
    query["LogicalExp"] = request.logicalExp();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeGroupedContainerInstances"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeGroupedContainerInstancesResponse>();
}

/**
 * @summary Queries containers by group type.
 *
 * @param request DescribeGroupedContainerInstancesRequest
 * @return DescribeGroupedContainerInstancesResponse
 */
DescribeGroupedContainerInstancesResponse Client::describeGroupedContainerInstances(const DescribeGroupedContainerInstancesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeGroupedContainerInstancesWithOptions(request, runtime);
}

/**
 * @summary Queries the statistical information about assets based on a specified filter condition.
 *
 * @param request DescribeGroupedInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupedInstancesResponse
 */
DescribeGroupedInstancesResponse Client::describeGroupedInstancesWithOptions(const DescribeGroupedInstancesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFieldValue()) {
    query["FieldValue"] = request.fieldValue();
  }

  if (!!request.hasGroupField()) {
    query["GroupField"] = request.groupField();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMachineTypes()) {
    query["MachineTypes"] = request.machineTypes();
  }

  if (!!request.hasNoPage()) {
    query["NoPage"] = request.noPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSaleVersionCheckCode()) {
    query["SaleVersionCheckCode"] = request.saleVersionCheckCode();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  if (!!request.hasVendors()) {
    query["Vendors"] = request.vendors();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeGroupedInstances"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeGroupedInstancesResponse>();
}

/**
 * @summary Queries the statistical information about assets based on a specified filter condition.
 *
 * @param request DescribeGroupedInstancesRequest
 * @return DescribeGroupedInstancesResponse
 */
DescribeGroupedInstancesResponse Client::describeGroupedInstances(const DescribeGroupedInstancesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeGroupedInstancesWithOptions(request, runtime);
}

/**
 * @summary Queries a list of malicious image samples.
 *
 * @param request DescribeGroupedMaliciousFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupedMaliciousFilesResponse
 */
DescribeGroupedMaliciousFilesResponse Client::describeGroupedMaliciousFilesWithOptions(const DescribeGroupedMaliciousFilesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFuzzyMaliciousName()) {
    query["FuzzyMaliciousName"] = request.fuzzyMaliciousName();
  }

  if (!!request.hasImageDigest()) {
    query["ImageDigest"] = request.imageDigest();
  }

  if (!!request.hasImageLayer()) {
    query["ImageLayer"] = request.imageLayer();
  }

  if (!!request.hasImageTag()) {
    query["ImageTag"] = request.imageTag();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLevels()) {
    query["Levels"] = request.levels();
  }

  if (!!request.hasMaliciousMd5()) {
    query["MaliciousMd5"] = request.maliciousMd5();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRepoId()) {
    query["RepoId"] = request.repoId();
  }

  if (!!request.hasRepoInstanceId()) {
    query["RepoInstanceId"] = request.repoInstanceId();
  }

  if (!!request.hasRepoName()) {
    query["RepoName"] = request.repoName();
  }

  if (!!request.hasRepoNamespace()) {
    query["RepoNamespace"] = request.repoNamespace();
  }

  if (!!request.hasRepoRegionId()) {
    query["RepoRegionId"] = request.repoRegionId();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeGroupedMaliciousFiles"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeGroupedMaliciousFilesResponse>();
}

/**
 * @summary Queries a list of malicious image samples.
 *
 * @param request DescribeGroupedMaliciousFilesRequest
 * @return DescribeGroupedMaliciousFilesResponse
 */
DescribeGroupedMaliciousFilesResponse Client::describeGroupedMaliciousFiles(const DescribeGroupedMaliciousFilesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeGroupedMaliciousFilesWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of asset tags.
 *
 * @param request DescribeGroupedTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupedTagsResponse
 */
DescribeGroupedTagsResponse Client::describeGroupedTagsWithOptions(const DescribeGroupedTagsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMachineTypes()) {
    query["MachineTypes"] = request.machineTypes();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeGroupedTags"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeGroupedTagsResponse>();
}

/**
 * @summary Queries the statistics of asset tags.
 *
 * @param request DescribeGroupedTagsRequest
 * @return DescribeGroupedTagsResponse
 */
DescribeGroupedTagsResponse Client::describeGroupedTags(const DescribeGroupedTagsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeGroupedTagsWithOptions(request, runtime);
}

/**
 * @summary Queries vulnerabilities by group.
 *
 * @param request DescribeGroupedVulRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeGroupedVulResponse
 */
DescribeGroupedVulResponse Client::describeGroupedVulWithOptions(const DescribeGroupedVulRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliasName()) {
    query["AliasName"] = request.aliasName();
  }

  if (!!request.hasAssetType()) {
    query["AssetType"] = request.assetType();
  }

  if (!!request.hasAttachTypes()) {
    query["AttachTypes"] = request.attachTypes();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasCveId()) {
    query["CveId"] = request.cveId();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNecessity()) {
    query["Necessity"] = request.necessity();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRaspDefend()) {
    query["RaspDefend"] = request.raspDefend();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasSearchTags()) {
    query["SearchTags"] = request.searchTags();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeGroupedVul"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeGroupedVulResponse>();
}

/**
 * @summary Queries vulnerabilities by group.
 *
 * @param request DescribeGroupedVulRequest
 * @return DescribeGroupedVulResponse
 */
DescribeGroupedVulResponse Client::describeGroupedVul(const DescribeGroupedVulRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeGroupedVulWithOptions(request, runtime);
}

/**
 * @summary Queries the information about baseline export, including the name of the file to which baselines are exported and the download URL for the file.
 *
 * @param request DescribeHcExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHcExportInfoResponse
 */
DescribeHcExportInfoResponse Client::describeHcExportInfoWithOptions(const DescribeHcExportInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExportId()) {
    query["ExportId"] = request.exportId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeHcExportInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeHcExportInfoResponse>();
}

/**
 * @summary Queries the information about baseline export, including the name of the file to which baselines are exported and the download URL for the file.
 *
 * @param request DescribeHcExportInfoRequest
 * @return DescribeHcExportInfoResponse
 */
DescribeHcExportInfoResponse Client::describeHcExportInfo(const DescribeHcExportInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeHcExportInfoWithOptions(request, runtime);
}

/**
 * @summary Queries statistics on the quota of honeypots.
 *
 * @param request DescribeHoneyPotAuthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHoneyPotAuthResponse
 */
DescribeHoneyPotAuthResponse Client::describeHoneyPotAuthWithOptions(const DescribeHoneyPotAuthRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeHoneyPotAuth"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeHoneyPotAuthResponse>();
}

/**
 * @summary Queries statistics on the quota of honeypots.
 *
 * @param request DescribeHoneyPotAuthRequest
 * @return DescribeHoneyPotAuthResponse
 */
DescribeHoneyPotAuthResponse Client::describeHoneyPotAuth(const DescribeHoneyPotAuthRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeHoneyPotAuthWithOptions(request, runtime);
}

/**
 * @summary Queries the top five virtual private clouds (VPCs) or assets for which alerts are most frequently generated.
 *
 * @param request DescribeHoneyPotSuspStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHoneyPotSuspStatisticsResponse
 */
DescribeHoneyPotSuspStatisticsResponse Client::describeHoneyPotSuspStatisticsWithOptions(const DescribeHoneyPotSuspStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasStatisticsDays()) {
    query["StatisticsDays"] = request.statisticsDays();
  }

  if (!!request.hasStatisticsKeyType()) {
    query["StatisticsKeyType"] = request.statisticsKeyType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeHoneyPotSuspStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeHoneyPotSuspStatisticsResponse>();
}

/**
 * @summary Queries the top five virtual private clouds (VPCs) or assets for which alerts are most frequently generated.
 *
 * @param request DescribeHoneyPotSuspStatisticsRequest
 * @return DescribeHoneyPotSuspStatisticsResponse
 */
DescribeHoneyPotSuspStatisticsResponse Client::describeHoneyPotSuspStatistics(const DescribeHoneyPotSuspStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeHoneyPotSuspStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries proxy clusters by page.
 *
 * @param request DescribeHybridProxyClusterListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHybridProxyClusterListResponse
 */
DescribeHybridProxyClusterListResponse Client::describeHybridProxyClusterListWithOptions(const DescribeHybridProxyClusterListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeHybridProxyClusterList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeHybridProxyClusterListResponse>();
}

/**
 * @summary Queries proxy clusters by page.
 *
 * @param request DescribeHybridProxyClusterListRequest
 * @return DescribeHybridProxyClusterListResponse
 */
DescribeHybridProxyClusterListResponse Client::describeHybridProxyClusterList(const DescribeHybridProxyClusterListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeHybridProxyClusterListWithOptions(request, runtime);
}

/**
 * @summary Queries the servers that are connected to a proxy in a hybrid cloud by page.
 *
 * @param request DescribeHybridProxyLinkedClientListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHybridProxyLinkedClientListResponse
 */
DescribeHybridProxyLinkedClientListResponse Client::describeHybridProxyLinkedClientListWithOptions(const DescribeHybridProxyLinkedClientListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasProxyUuid()) {
    query["ProxyUuid"] = request.proxyUuid();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeHybridProxyLinkedClientList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeHybridProxyLinkedClientListResponse>();
}

/**
 * @summary Queries the servers that are connected to a proxy in a hybrid cloud by page.
 *
 * @param request DescribeHybridProxyLinkedClientListRequest
 * @return DescribeHybridProxyLinkedClientListResponse
 */
DescribeHybridProxyLinkedClientListResponse Client::describeHybridProxyLinkedClientList(const DescribeHybridProxyLinkedClientListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeHybridProxyLinkedClientListWithOptions(request, runtime);
}

/**
 * @summary Queries the proxy nodes that are deployed in a proxy cluster by page.
 *
 * @param request DescribeHybridProxyListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHybridProxyListResponse
 */
DescribeHybridProxyListResponse Client::describeHybridProxyListWithOptions(const DescribeHybridProxyListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeHybridProxyList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeHybridProxyListResponse>();
}

/**
 * @summary Queries the proxy nodes that are deployed in a proxy cluster by page.
 *
 * @param request DescribeHybridProxyListRequest
 * @return DescribeHybridProxyListResponse
 */
DescribeHybridProxyListResponse Client::describeHybridProxyList(const DescribeHybridProxyListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeHybridProxyListWithOptions(request, runtime);
}

/**
 * @summary Queries the data collection configurations of a proxy cluster.
 *
 * @param request DescribeHybridProxyPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHybridProxyPolicyResponse
 */
DescribeHybridProxyPolicyResponse Client::describeHybridProxyPolicyWithOptions(const DescribeHybridProxyPolicyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeHybridProxyPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeHybridProxyPolicyResponse>();
}

/**
 * @summary Queries the data collection configurations of a proxy cluster.
 *
 * @param request DescribeHybridProxyPolicyRequest
 * @return DescribeHybridProxyPolicyResponse
 */
DescribeHybridProxyPolicyResponse Client::describeHybridProxyPolicy(const DescribeHybridProxyPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeHybridProxyPolicyWithOptions(request, runtime);
}

/**
 * @summary Queries the search conditions that can be used to query data center assets found after scanning in fuzzy match mode.
 *
 * @param request DescribeIdcAssetCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIdcAssetCriteriaResponse
 */
DescribeIdcAssetCriteriaResponse Client::describeIdcAssetCriteriaWithOptions(const DescribeIdcAssetCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasValue()) {
    query["Value"] = request.value();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIdcAssetCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIdcAssetCriteriaResponse>();
}

/**
 * @summary Queries the search conditions that can be used to query data center assets found after scanning in fuzzy match mode.
 *
 * @param request DescribeIdcAssetCriteriaRequest
 * @return DescribeIdcAssetCriteriaResponse
 */
DescribeIdcAssetCriteriaResponse Client::describeIdcAssetCriteria(const DescribeIdcAssetCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIdcAssetCriteriaWithOptions(request, runtime);
}

/**
 * @summary Query IDC probe list
 *
 * @param request DescribeIdcProbeListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIdcProbeListResponse
 */
DescribeIdcProbeListResponse Client::describeIdcProbeListWithOptions(const DescribeIdcProbeListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasIdcName()) {
    query["IdcName"] = request.idcName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIdcProbeList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIdcProbeListResponse>();
}

/**
 * @summary Query IDC probe list
 *
 * @param request DescribeIdcProbeListRequest
 * @return DescribeIdcProbeListResponse
 */
DescribeIdcProbeListResponse Client::describeIdcProbeList(const DescribeIdcProbeListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIdcProbeListWithOptions(request, runtime);
}

/**
 * @summary Queries assets that are identified by Internet Data Center (IDC) probes.
 *
 * @param request DescribeIdcProbeScanResultListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIdcProbeScanResultListResponse
 */
DescribeIdcProbeScanResultListResponse Client::describeIdcProbeScanResultListWithOptions(const DescribeIdcProbeScanResultListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFoundEndTime()) {
    query["FoundEndTime"] = request.foundEndTime();
  }

  if (!!request.hasFoundStartTime()) {
    query["FoundStartTime"] = request.foundStartTime();
  }

  if (!!request.hasLogicalExp()) {
    query["LogicalExp"] = request.logicalExp();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeIdcProbeScanResultList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeIdcProbeScanResultListResponse>();
}

/**
 * @summary Queries assets that are identified by Internet Data Center (IDC) probes.
 *
 * @param request DescribeIdcProbeScanResultListRequest
 * @return DescribeIdcProbeScanResultListResponse
 */
DescribeIdcProbeScanResultListResponse Client::describeIdcProbeScanResultList(const DescribeIdcProbeScanResultListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeIdcProbeScanResultListWithOptions(request, runtime);
}

/**
 * @summary Queries an image digest.
 *
 * @param request DescribeImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageResponse
 */
DescribeImageResponse Client::describeImageWithOptions(const DescribeImageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasImageInstanceId()) {
    query["ImageInstanceId"] = request.imageInstanceId();
  }

  if (!!request.hasImageRegionId()) {
    query["ImageRegionId"] = request.imageRegionId();
  }

  if (!!request.hasImageRepoId()) {
    query["ImageRepoId"] = request.imageRepoId();
  }

  if (!!request.hasImageTag()) {
    query["ImageTag"] = request.imageTag();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageResponse>();
}

/**
 * @summary Queries an image digest.
 *
 * @param request DescribeImageRequest
 * @return DescribeImageResponse
 */
DescribeImageResponse Client::describeImage(const DescribeImageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageWithOptions(request, runtime);
}

/**
 * @summary Queries the security scan results of images.
 *
 * @param request DescribeImageBaselineCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBaselineCheckResultResponse
 */
DescribeImageBaselineCheckResultResponse Client::describeImageBaselineCheckResultWithOptions(const DescribeImageBaselineCheckResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCriteriaType()) {
    query["CriteriaType"] = request.criteriaType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImageUuid()) {
    query["ImageUuid"] = request.imageUuid();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskLevel()) {
    query["RiskLevel"] = request.riskLevel();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageBaselineCheckResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageBaselineCheckResultResponse>();
}

/**
 * @summary Queries the security scan results of images.
 *
 * @param request DescribeImageBaselineCheckResultRequest
 * @return DescribeImageBaselineCheckResultResponse
 */
DescribeImageBaselineCheckResultResponse Client::describeImageBaselineCheckResult(const DescribeImageBaselineCheckResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageBaselineCheckResultWithOptions(request, runtime);
}

/**
 * @summary Queries the check results of image baselines that are included in an image scan task.
 *
 * @param request DescribeImageBaselineCheckSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBaselineCheckSummaryResponse
 */
DescribeImageBaselineCheckSummaryResponse Client::describeImageBaselineCheckSummaryWithOptions(const DescribeImageBaselineCheckSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCriteriaType()) {
    query["CriteriaType"] = request.criteriaType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskLevel()) {
    query["RiskLevel"] = request.riskLevel();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageBaselineCheckSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageBaselineCheckSummaryResponse>();
}

/**
 * @summary Queries the check results of image baselines that are included in an image scan task.
 *
 * @param request DescribeImageBaselineCheckSummaryRequest
 * @return DescribeImageBaselineCheckSummaryResponse
 */
DescribeImageBaselineCheckSummaryResponse Client::describeImageBaselineCheckSummary(const DescribeImageBaselineCheckSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageBaselineCheckSummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the details about the baseline check result for an image.
 *
 * @param request DescribeImageBaselineDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBaselineDetailResponse
 */
DescribeImageBaselineDetailResponse Client::describeImageBaselineDetailWithOptions(const DescribeImageBaselineDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBaselineItemKey()) {
    query["BaselineItemKey"] = request.baselineItemKey();
  }

  if (!!request.hasImageUuid()) {
    query["ImageUuid"] = request.imageUuid();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageBaselineDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageBaselineDetailResponse>();
}

/**
 * @summary Queries the details about the baseline check result for an image.
 *
 * @param request DescribeImageBaselineDetailRequest
 * @return DescribeImageBaselineDetailResponse
 */
DescribeImageBaselineDetailResponse Client::describeImageBaselineDetail(const DescribeImageBaselineDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageBaselineDetailWithOptions(request, runtime);
}

/**
 * @summary Queries baseline check results based on images.
 *
 * @param request DescribeImageBaselineItemListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBaselineItemListResponse
 */
DescribeImageBaselineItemListResponse Client::describeImageBaselineItemListWithOptions(const DescribeImageBaselineItemListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBaselineClassKey()) {
    query["BaselineClassKey"] = request.baselineClassKey();
  }

  if (!!request.hasBaselineNameKey()) {
    query["BaselineNameKey"] = request.baselineNameKey();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImageUuid()) {
    query["ImageUuid"] = request.imageUuid();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageBaselineItemList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageBaselineItemListResponse>();
}

/**
 * @summary Queries baseline check results based on images.
 *
 * @param request DescribeImageBaselineItemListRequest
 * @return DescribeImageBaselineItemListResponse
 */
DescribeImageBaselineItemListResponse Client::describeImageBaselineItemList(const DescribeImageBaselineItemListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageBaselineItemListWithOptions(request, runtime);
}

/**
 * @summary Queries the information about a baseline check policy for images.
 *
 * @param request DescribeImageBaselineStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBaselineStrategyResponse
 */
DescribeImageBaselineStrategyResponse Client::describeImageBaselineStrategyWithOptions(const DescribeImageBaselineStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageBaselineStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageBaselineStrategyResponse>();
}

/**
 * @summary Queries the information about a baseline check policy for images.
 *
 * @param request DescribeImageBaselineStrategyRequest
 * @return DescribeImageBaselineStrategyResponse
 */
DescribeImageBaselineStrategyResponse Client::describeImageBaselineStrategy(const DescribeImageBaselineStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageBaselineStrategyWithOptions(request, runtime);
}

/**
 * @summary Queries image build command risks by page.
 *
 * @param request DescribeImageBuildRiskByKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBuildRiskByKeyResponse
 */
DescribeImageBuildRiskByKeyResponse Client::describeImageBuildRiskByKeyWithOptions(const DescribeImageBuildRiskByKeyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImageUuid()) {
    query["ImageUuid"] = request.imageUuid();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskKey()) {
    query["RiskKey"] = request.riskKey();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageBuildRiskByKey"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageBuildRiskByKeyResponse>();
}

/**
 * @summary Queries image build command risks by page.
 *
 * @param request DescribeImageBuildRiskByKeyRequest
 * @return DescribeImageBuildRiskByKeyResponse
 */
DescribeImageBuildRiskByKeyResponse Client::describeImageBuildRiskByKey(const DescribeImageBuildRiskByKeyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageBuildRiskByKeyWithOptions(request, runtime);
}

/**
 * @summary Queries a list of image build command risks by page.
 *
 * @param request DescribeImageBuildRiskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageBuildRiskListResponse
 */
DescribeImageBuildRiskListResponse Client::describeImageBuildRiskListWithOptions(const DescribeImageBuildRiskListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCriteriaType()) {
    query["CriteriaType"] = request.criteriaType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskLevel()) {
    query["RiskLevel"] = request.riskLevel();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageBuildRiskList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageBuildRiskListResponse>();
}

/**
 * @summary Queries a list of image build command risks by page.
 *
 * @param request DescribeImageBuildRiskListRequest
 * @return DescribeImageBuildRiskListResponse
 */
DescribeImageBuildRiskListResponse Client::describeImageBuildRiskList(const DescribeImageBuildRiskListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageBuildRiskListWithOptions(request, runtime);
}

/**
 * @summary Queries the search conditions that are used to query images.
 *
 * @param request DescribeImageCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageCriteriaResponse
 */
DescribeImageCriteriaResponse Client::describeImageCriteriaWithOptions(const DescribeImageCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasValue()) {
    query["Value"] = request.value();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageCriteriaResponse>();
}

/**
 * @summary Queries the search conditions that are used to query images.
 *
 * @param request DescribeImageCriteriaRequest
 * @return DescribeImageCriteriaResponse
 */
DescribeImageCriteriaResponse Client::describeImageCriteria(const DescribeImageCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageCriteriaWithOptions(request, runtime);
}

/**
 * @summary Queries the conditions for handling alert events in an image.
 *
 * @param request DescribeImageEventOperationConditionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageEventOperationConditionResponse
 */
DescribeImageEventOperationConditionResponse Client::describeImageEventOperationConditionWithOptions(const DescribeImageEventOperationConditionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventType()) {
    query["EventType"] = request.eventType();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageEventOperationCondition"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageEventOperationConditionResponse>();
}

/**
 * @summary Queries the conditions for handling alert events in an image.
 *
 * @param request DescribeImageEventOperationConditionRequest
 * @return DescribeImageEventOperationConditionResponse
 */
DescribeImageEventOperationConditionResponse Client::describeImageEventOperationCondition(const DescribeImageEventOperationConditionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageEventOperationConditionWithOptions(request, runtime);
}

/**
 * @summary Queries alert handling rules by page.
 *
 * @param request DescribeImageEventOperationPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageEventOperationPageResponse
 */
DescribeImageEventOperationPageResponse Client::describeImageEventOperationPageWithOptions(const DescribeImageEventOperationPageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEventKey()) {
    query["EventKey"] = request.eventKey();
  }

  if (!!request.hasEventName()) {
    query["EventName"] = request.eventName();
  }

  if (!!request.hasEventType()) {
    query["EventType"] = request.eventType();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageEventOperationPage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageEventOperationPageResponse>();
}

/**
 * @summary Queries alert handling rules by page.
 *
 * @param request DescribeImageEventOperationPageRequest
 * @return DescribeImageEventOperationPageResponse
 */
DescribeImageEventOperationPageResponse Client::describeImageEventOperationPage(const DescribeImageEventOperationPageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageEventOperationPageWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of the scheduled fix of image risks.
 *
 * @param request DescribeImageFixCycleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageFixCycleConfigResponse
 */
DescribeImageFixCycleConfigResponse Client::describeImageFixCycleConfigWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeImageFixCycleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageFixCycleConfigResponse>();
}

/**
 * @summary Queries the configurations of the scheduled fix of image risks.
 *
 * @return DescribeImageFixCycleConfigResponse
 */
DescribeImageFixCycleConfigResponse Client::describeImageFixCycleConfig() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageFixCycleConfigWithOptions(runtime);
}

/**
 * @summary Queries the tasks that you create to fix image risks.
 *
 * @param request DescribeImageFixTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageFixTaskResponse
 */
DescribeImageFixTaskResponse Client::describeImageFixTaskWithOptions(const DescribeImageFixTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageFixTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageFixTaskResponse>();
}

/**
 * @summary Queries the tasks that you create to fix image risks.
 *
 * @param request DescribeImageFixTaskRequest
 * @return DescribeImageFixTaskResponse
 */
DescribeImageFixTaskResponse Client::describeImageFixTask(const DescribeImageFixTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageFixTaskWithOptions(request, runtime);
}

/**
 * @summary Queries image vulnerabilities.
 *
 * @param request DescribeImageGroupedVulListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageGroupedVulListResponse
 */
DescribeImageGroupedVulListResponse Client::describeImageGroupedVulListWithOptions(const DescribeImageGroupedVulListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliasName()) {
    query["AliasName"] = request.aliasName();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasCveId()) {
    query["CveId"] = request.cveId();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasImageDigest()) {
    query["ImageDigest"] = request.imageDigest();
  }

  if (!!request.hasImageLayer()) {
    query["ImageLayer"] = request.imageLayer();
  }

  if (!!request.hasImageTag()) {
    query["ImageTag"] = request.imageTag();
  }

  if (!!request.hasIsLatest()) {
    query["IsLatest"] = request.isLatest();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNecessity()) {
    query["Necessity"] = request.necessity();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPatchId()) {
    query["PatchId"] = request.patchId();
  }

  if (!!request.hasRepoId()) {
    query["RepoId"] = request.repoId();
  }

  if (!!request.hasRepoInstanceId()) {
    query["RepoInstanceId"] = request.repoInstanceId();
  }

  if (!!request.hasRepoName()) {
    query["RepoName"] = request.repoName();
  }

  if (!!request.hasRepoNamespace()) {
    query["RepoNamespace"] = request.repoNamespace();
  }

  if (!!request.hasRepoRegionId()) {
    query["RepoRegionId"] = request.repoRegionId();
  }

  if (!!request.hasRuleTag()) {
    query["RuleTag"] = request.ruleTag();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageGroupedVulList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageGroupedVulListResponse>();
}

/**
 * @summary Queries image vulnerabilities.
 *
 * @param request DescribeImageGroupedVulListRequest
 * @return DescribeImageGroupedVulListResponse
 */
DescribeImageGroupedVulListResponse Client::describeImageGroupedVulList(const DescribeImageGroupedVulListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageGroupedVulListWithOptions(request, runtime);
}

/**
 * @summary Queries images.
 *
 * @param request DescribeImageInfoListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageInfoListResponse
 */
DescribeImageInfoListResponse Client::describeImageInfoListWithOptions(const DescribeImageInfoListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageInfoList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageInfoListResponse>();
}

/**
 * @summary Queries images.
 *
 * @param request DescribeImageInfoListRequest
 * @return DescribeImageInfoListResponse
 */
DescribeImageInfoListResponse Client::describeImageInfoList(const DescribeImageInfoListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageInfoListWithOptions(request, runtime);
}

/**
 * @summary Queries information about images.
 *
 * @param request DescribeImageInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageInstancesResponse
 */
DescribeImageInstancesResponse Client::describeImageInstancesWithOptions(const DescribeImageInstancesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLogicalExp()) {
    query["LogicalExp"] = request.logicalExp();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasScanned()) {
    query["Scanned"] = request.scanned();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageInstances"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageInstancesResponse>();
}

/**
 * @summary Queries information about images.
 *
 * @param request DescribeImageInstancesRequest
 * @return DescribeImageInstancesResponse
 */
DescribeImageInstancesResponse Client::describeImageInstances(const DescribeImageInstancesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageInstancesWithOptions(request, runtime);
}

/**
 * @summary Queries the most recent scan task that is created for an image.
 *
 * @param request DescribeImageLatestScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageLatestScanTaskResponse
 */
DescribeImageLatestScanTaskResponse Client::describeImageLatestScanTaskWithOptions(const DescribeImageLatestScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDigest()) {
    query["Digest"] = request.digest();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageLatestScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageLatestScanTaskResponse>();
}

/**
 * @summary Queries the most recent scan task that is created for an image.
 *
 * @param request DescribeImageLatestScanTaskRequest
 * @return DescribeImageLatestScanTaskResponse
 */
DescribeImageLatestScanTaskResponse Client::describeImageLatestScanTask(const DescribeImageLatestScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageLatestScanTaskWithOptions(request, runtime);
}

/**
 * @summary Queries a list of images that are affected by image build command risks by page.
 *
 * @param request DescribeImageListByBuildRiskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageListByBuildRiskResponse
 */
DescribeImageListByBuildRiskResponse Client::describeImageListByBuildRiskWithOptions(const DescribeImageListByBuildRiskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskKey()) {
    query["RiskKey"] = request.riskKey();
  }

  if (!!request.hasRiskLevel()) {
    query["RiskLevel"] = request.riskLevel();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageListByBuildRisk"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageListByBuildRiskResponse>();
}

/**
 * @summary Queries a list of images that are affected by image build command risks by page.
 *
 * @param request DescribeImageListByBuildRiskRequest
 * @return DescribeImageListByBuildRiskResponse
 */
DescribeImageListByBuildRiskResponse Client::describeImageListByBuildRisk(const DescribeImageListByBuildRiskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageListByBuildRiskWithOptions(request, runtime);
}

/**
 * @summary Queries information about images that are affected by sensitive files.
 *
 * @param tmpReq DescribeImageListBySensitiveFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageListBySensitiveFileResponse
 */
DescribeImageListBySensitiveFileResponse Client::describeImageListBySensitiveFileWithOptions(const DescribeImageListBySensitiveFileRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  DescribeImageListBySensitiveFileShrinkRequest request = DescribeImageListBySensitiveFileShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasScanRange()) {
    request.setScanRangeShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.scanRange(), "ScanRange", "json"));
  }

  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImageDigest()) {
    query["ImageDigest"] = request.imageDigest();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRepoInstanceId()) {
    query["RepoInstanceId"] = request.repoInstanceId();
  }

  if (!!request.hasRepoName()) {
    query["RepoName"] = request.repoName();
  }

  if (!!request.hasRepoNamespace()) {
    query["RepoNamespace"] = request.repoNamespace();
  }

  if (!!request.hasRiskLevel()) {
    query["RiskLevel"] = request.riskLevel();
  }

  if (!!request.hasScanRangeShrink()) {
    query["ScanRange"] = request.scanRangeShrink();
  }

  if (!!request.hasSensitiveFileKey()) {
    query["SensitiveFileKey"] = request.sensitiveFileKey();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageListBySensitiveFile"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageListBySensitiveFileResponse>();
}

/**
 * @summary Queries information about images that are affected by sensitive files.
 *
 * @param request DescribeImageListBySensitiveFileRequest
 * @return DescribeImageListBySensitiveFileResponse
 */
DescribeImageListBySensitiveFileResponse Client::describeImageListBySensitiveFile(const DescribeImageListBySensitiveFileRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageListBySensitiveFileWithOptions(request, runtime);
}

/**
 * @summary Queries the details about images in the results of image baseline checks.
 *
 * @param request DescribeImageListWithBaselineNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageListWithBaselineNameResponse
 */
DescribeImageListWithBaselineNameResponse Client::describeImageListWithBaselineNameWithOptions(const DescribeImageListWithBaselineNameRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBaselineNameKey()) {
    query["BaselineNameKey"] = request.baselineNameKey();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasContainerId()) {
    query["ContainerId"] = request.containerId();
  }

  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCriteriaType()) {
    query["CriteriaType"] = request.criteriaType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImage()) {
    query["Image"] = request.image();
  }

  if (!!request.hasImageDigest()) {
    query["ImageDigest"] = request.imageDigest();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPod()) {
    query["Pod"] = request.pod();
  }

  if (!!request.hasRepoInstanceId()) {
    query["RepoInstanceId"] = request.repoInstanceId();
  }

  if (!!request.hasRepoName()) {
    query["RepoName"] = request.repoName();
  }

  if (!!request.hasRepoNamespace()) {
    query["RepoNamespace"] = request.repoNamespace();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageListWithBaselineName"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageListWithBaselineNameResponse>();
}

/**
 * @summary Queries the details about images in the results of image baseline checks.
 *
 * @param request DescribeImageListWithBaselineNameRequest
 * @return DescribeImageListWithBaselineNameResponse
 */
DescribeImageListWithBaselineNameResponse Client::describeImageListWithBaselineName(const DescribeImageListWithBaselineNameRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageListWithBaselineNameWithOptions(request, runtime);
}

/**
 * @summary Obtains the filter conditions that are supported by the image repository.
 *
 * @param request DescribeImageRepoCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageRepoCriteriaResponse
 */
DescribeImageRepoCriteriaResponse Client::describeImageRepoCriteriaWithOptions(const DescribeImageRepoCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasValue()) {
    query["Value"] = request.value();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageRepoCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageRepoCriteriaResponse>();
}

/**
 * @summary Obtains the filter conditions that are supported by the image repository.
 *
 * @param request DescribeImageRepoCriteriaRequest
 * @return DescribeImageRepoCriteriaResponse
 */
DescribeImageRepoCriteriaResponse Client::describeImageRepoCriteria(const DescribeImageRepoCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageRepoCriteriaWithOptions(request, runtime);
}

/**
 * @summary Queries the information about image repositories.
 *
 * @param request DescribeImageRepoDetailListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageRepoDetailListResponse
 */
DescribeImageRepoDetailListResponse Client::describeImageRepoDetailListWithOptions(const DescribeImageRepoDetailListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLogicalExp()) {
    query["LogicalExp"] = request.logicalExp();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageRepoDetailList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageRepoDetailListResponse>();
}

/**
 * @summary Queries the information about image repositories.
 *
 * @param request DescribeImageRepoDetailListRequest
 * @return DescribeImageRepoDetailListResponse
 */
DescribeImageRepoDetailListResponse Client::describeImageRepoDetailList(const DescribeImageRepoDetailListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageRepoDetailListWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics and configurations of the feature that protects images.
 *
 * @param request DescribeImageRepoListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageRepoListResponse
 */
DescribeImageRepoListResponse Client::describeImageRepoListWithOptions(const DescribeImageRepoListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFieldName()) {
    query["FieldName"] = request.fieldName();
  }

  if (!!request.hasFieldValue()) {
    query["FieldValue"] = request.fieldValue();
  }

  if (!!request.hasOperateType()) {
    query["OperateType"] = request.operateType();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRepoName()) {
    query["RepoName"] = request.repoName();
  }

  if (!!request.hasRepoNamespace()) {
    query["RepoNamespace"] = request.repoNamespace();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageRepoList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageRepoListResponse>();
}

/**
 * @summary Queries the statistics and configurations of the feature that protects images.
 *
 * @param request DescribeImageRepoListRequest
 * @return DescribeImageRepoListResponse
 */
DescribeImageRepoListResponse Client::describeImageRepoList(const DescribeImageRepoListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageRepoListWithOptions(request, runtime);
}

/**
 * @summary Queries the number of images on which security alerts are generated. Security alerts are generated for risks such as vulnerabilities, baselines risks, and malicious samples.
 *
 * @param request DescribeImageRiskLevelStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageRiskLevelStatisticResponse
 */
DescribeImageRiskLevelStatisticResponse Client::describeImageRiskLevelStatisticWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeImageRiskLevelStatistic"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageRiskLevelStatisticResponse>();
}

/**
 * @summary Queries the number of images on which security alerts are generated. Security alerts are generated for risks such as vulnerabilities, baselines risks, and malicious samples.
 *
 * @return DescribeImageRiskLevelStatisticResponse
 */
DescribeImageRiskLevelStatisticResponse Client::describeImageRiskLevelStatistic() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageRiskLevelStatisticWithOptions(runtime);
}

/**
 * @summary Queries the details of the quota for container image scan.
 *
 * @param request DescribeImageScanAuthCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageScanAuthCountResponse
 */
DescribeImageScanAuthCountResponse Client::describeImageScanAuthCountWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeImageScanAuthCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageScanAuthCountResponse>();
}

/**
 * @summary Queries the details of the quota for container image scan.
 *
 * @return DescribeImageScanAuthCountResponse
 */
DescribeImageScanAuthCountResponse Client::describeImageScanAuthCount() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageScanAuthCountWithOptions(runtime);
}

/**
 * @summary Queries the number of security events detected on an image.
 *
 * @param request DescribeImageSecurityScanCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageSecurityScanCountResponse
 */
DescribeImageSecurityScanCountResponse Client::describeImageSecurityScanCountWithOptions(const DescribeImageSecurityScanCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasImageDigest()) {
    query["ImageDigest"] = request.imageDigest();
  }

  if (!!request.hasImageTag()) {
    query["ImageTag"] = request.imageTag();
  }

  if (!!request.hasImageUuid()) {
    query["ImageUuid"] = request.imageUuid();
  }

  if (!!request.hasRepoId()) {
    query["RepoId"] = request.repoId();
  }

  if (!!request.hasRepoInstanceId()) {
    query["RepoInstanceId"] = request.repoInstanceId();
  }

  if (!!request.hasRepoRegionId()) {
    query["RepoRegionId"] = request.repoRegionId();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageSecurityScanCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageSecurityScanCountResponse>();
}

/**
 * @summary Queries the number of security events detected on an image.
 *
 * @param request DescribeImageSecurityScanCountRequest
 * @return DescribeImageSecurityScanCountResponse
 */
DescribeImageSecurityScanCountResponse Client::describeImageSecurityScanCount(const DescribeImageSecurityScanCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageSecurityScanCountWithOptions(request, runtime);
}

/**
 * @summary Queries the sensitive files in an image.
 *
 * @param tmpReq DescribeImageSensitiveFileByKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageSensitiveFileByKeyResponse
 */
DescribeImageSensitiveFileByKeyResponse Client::describeImageSensitiveFileByKeyWithOptions(const DescribeImageSensitiveFileByKeyRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  DescribeImageSensitiveFileByKeyShrinkRequest request = DescribeImageSensitiveFileByKeyShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasScanRange()) {
    request.setScanRangeShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.scanRange(), "ScanRange", "json"));
  }

  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImageUuid()) {
    query["ImageUuid"] = request.imageUuid();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasScanRangeShrink()) {
    query["ScanRange"] = request.scanRangeShrink();
  }

  if (!!request.hasSensitiveFileKey()) {
    query["SensitiveFileKey"] = request.sensitiveFileKey();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageSensitiveFileByKey"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageSensitiveFileByKeyResponse>();
}

/**
 * @summary Queries the sensitive files in an image.
 *
 * @param request DescribeImageSensitiveFileByKeyRequest
 * @return DescribeImageSensitiveFileByKeyResponse
 */
DescribeImageSensitiveFileByKeyResponse Client::describeImageSensitiveFileByKey(const DescribeImageSensitiveFileByKeyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageSensitiveFileByKeyWithOptions(request, runtime);
}

/**
 * @summary Queries information about sensitive files.
 *
 * @param tmpReq DescribeImageSensitiveFileListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageSensitiveFileListResponse
 */
DescribeImageSensitiveFileListResponse Client::describeImageSensitiveFileListWithOptions(const DescribeImageSensitiveFileListRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  DescribeImageSensitiveFileListShrinkRequest request = DescribeImageSensitiveFileListShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasScanRange()) {
    request.setScanRangeShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.scanRange(), "ScanRange", "json"));
  }

  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCriteriaType()) {
    query["CriteriaType"] = request.criteriaType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImageUuid()) {
    query["ImageUuid"] = request.imageUuid();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskLevel()) {
    query["RiskLevel"] = request.riskLevel();
  }

  if (!!request.hasScanRangeShrink()) {
    query["ScanRange"] = request.scanRangeShrink();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageSensitiveFileList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageSensitiveFileListResponse>();
}

/**
 * @summary Queries information about sensitive files.
 *
 * @param request DescribeImageSensitiveFileListRequest
 * @return DescribeImageSensitiveFileListResponse
 */
DescribeImageSensitiveFileListResponse Client::describeImageSensitiveFileList(const DescribeImageSensitiveFileListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageSensitiveFileListWithOptions(request, runtime);
}

/**
 * @summary Queries the risk statistics on container images.
 *
 * @description Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
 * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
 *
 * @param request DescribeImageStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageStatisticsResponse
 */
DescribeImageStatisticsResponse Client::describeImageStatisticsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeImageStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageStatisticsResponse>();
}

/**
 * @summary Queries the risk statistics on container images.
 *
 * @description Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
 * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
 *
 * @return DescribeImageStatisticsResponse
 */
DescribeImageStatisticsResponse Client::describeImageStatistics() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageStatisticsWithOptions(runtime);
}

/**
 * @summary Queries the details of vulnerabilities that are detected by using container image scan and the affected images.
 *
 * @description To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](https://help.aliyun.com/document_detail/411723.html) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
 *
 * @param request DescribeImageVulListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageVulListResponse
 */
DescribeImageVulListResponse Client::describeImageVulListWithOptions(const DescribeImageVulListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliasName()) {
    query["AliasName"] = request.aliasName();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasContainerId()) {
    query["ContainerId"] = request.containerId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasDigest()) {
    query["Digest"] = request.digest();
  }

  if (!!request.hasImage()) {
    query["Image"] = request.image();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasNecessity()) {
    query["Necessity"] = request.necessity();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPod()) {
    query["Pod"] = request.pod();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRepoId()) {
    query["RepoId"] = request.repoId();
  }

  if (!!request.hasRepoId()) {
    query["RepoId"] = request.repoId();
  }

  if (!!request.hasRepoInstanceId()) {
    query["RepoInstanceId"] = request.repoInstanceId();
  }

  if (!!request.hasRepoName()) {
    query["RepoName"] = request.repoName();
  }

  if (!!request.hasRepoName()) {
    query["RepoName"] = request.repoName();
  }

  if (!!request.hasRepoNamespace()) {
    query["RepoNamespace"] = request.repoNamespace();
  }

  if (!!request.hasRepoRegionId()) {
    query["RepoRegionId"] = request.repoRegionId();
  }

  if (!!request.hasRuleTag()) {
    query["RuleTag"] = request.ruleTag();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  if (!!request.hasStatusList()) {
    query["StatusList"] = request.statusList();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageVulList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageVulListResponse>();
}

/**
 * @summary Queries the details of vulnerabilities that are detected by using container image scan and the affected images.
 *
 * @description To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](https://help.aliyun.com/document_detail/411723.html) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
 *
 * @param request DescribeImageVulListRequest
 * @return DescribeImageVulListResponse
 */
DescribeImageVulListResponse Client::describeImageVulList(const DescribeImageVulListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageVulListWithOptions(request, runtime);
}

/**
 * @summary Queries the whitelist of image vulnerabilities.
 *
 * @param request DescribeImageVulWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImageVulWhiteListResponse
 */
DescribeImageVulWhiteListResponse Client::describeImageVulWhiteListWithOptions(const DescribeImageVulWhiteListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliasName()) {
    query["AliasName"] = request.aliasName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeImageVulWhiteList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeImageVulWhiteListResponse>();
}

/**
 * @summary Queries the whitelist of image vulnerabilities.
 *
 * @param request DescribeImageVulWhiteListRequest
 * @return DescribeImageVulWhiteListResponse
 */
DescribeImageVulWhiteListResponse Client::describeImageVulWhiteList(const DescribeImageVulWhiteListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeImageVulWhiteListWithOptions(request, runtime);
}

/**
 * @summary Queries the verification codes that are used to manually install the Security Center agent.
 *
 * @param request DescribeInstallCaptchaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstallCaptchaResponse
 */
DescribeInstallCaptchaResponse Client::describeInstallCaptchaWithOptions(const DescribeInstallCaptchaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDeadline()) {
    query["Deadline"] = request.deadline();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeInstallCaptcha"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeInstallCaptchaResponse>();
}

/**
 * @summary Queries the verification codes that are used to manually install the Security Center agent.
 *
 * @param request DescribeInstallCaptchaRequest
 * @return DescribeInstallCaptchaResponse
 */
DescribeInstallCaptchaResponse Client::describeInstallCaptcha(const DescribeInstallCaptchaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeInstallCaptchaWithOptions(request, runtime);
}

/**
 * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
 *
 * @param request DescribeInstallCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstallCodeResponse
 */
DescribeInstallCodeResponse Client::describeInstallCodeWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeInstallCode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeInstallCodeResponse>();
}

/**
 * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
 *
 * @return DescribeInstallCodeResponse
 */
DescribeInstallCodeResponse Client::describeInstallCode() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeInstallCodeWithOptions(runtime);
}

/**
 * @summary Queries the commands that are used to manually install the Security Center Agent.
 *
 * @description You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
 * ### QPS limit
 * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
 *
 * @param request DescribeInstallCodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstallCodesResponse
 */
DescribeInstallCodesResponse Client::describeInstallCodesWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeInstallCodes"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeInstallCodesResponse>();
}

/**
 * @summary Queries the commands that are used to manually install the Security Center Agent.
 *
 * @description You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
 * ### QPS limit
 * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
 *
 * @return DescribeInstallCodesResponse
 */
DescribeInstallCodesResponse Client::describeInstallCodes() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeInstallCodesWithOptions(runtime);
}

/**
 * @summary Queries the information about servers to which a defense rule against brute-force attacks is applied.
 *
 * @param request DescribeInstanceAntiBruteForceRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceAntiBruteForceRulesResponse
 */
DescribeInstanceAntiBruteForceRulesResponse Client::describeInstanceAntiBruteForceRulesWithOptions(const DescribeInstanceAntiBruteForceRulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeInstanceAntiBruteForceRules"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeInstanceAntiBruteForceRulesResponse>();
}

/**
 * @summary Queries the information about servers to which a defense rule against brute-force attacks is applied.
 *
 * @param request DescribeInstanceAntiBruteForceRulesRequest
 * @return DescribeInstanceAntiBruteForceRulesResponse
 */
DescribeInstanceAntiBruteForceRulesResponse Client::describeInstanceAntiBruteForceRules(const DescribeInstanceAntiBruteForceRulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeInstanceAntiBruteForceRulesWithOptions(request, runtime);
}

/**
 * @summary Queries the status of the instance that you restart.
 *
 * @param request DescribeInstanceRebootStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceRebootStatusResponse
 */
DescribeInstanceRebootStatusResponse Client::describeInstanceRebootStatusWithOptions(const DescribeInstanceRebootStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeInstanceRebootStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeInstanceRebootStatusResponse>();
}

/**
 * @summary Queries the status of the instance that you restart.
 *
 * @param request DescribeInstanceRebootStatusRequest
 * @return DescribeInstanceRebootStatusResponse
 */
DescribeInstanceRebootStatusResponse Client::describeInstanceRebootStatus(const DescribeInstanceRebootStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeInstanceRebootStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of assets that are protected by Security Center.
 *
 * @param request DescribeInstanceStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceStatisticsResponse
 */
DescribeInstanceStatisticsResponse Client::describeInstanceStatisticsWithOptions(const DescribeInstanceStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeInstanceStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeInstanceStatisticsResponse>();
}

/**
 * @summary Queries the statistics of assets that are protected by Security Center.
 *
 * @param request DescribeInstanceStatisticsRequest
 * @return DescribeInstanceStatisticsResponse
 */
DescribeInstanceStatisticsResponse Client::describeInstanceStatistics(const DescribeInstanceStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeInstanceStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of vulnerabilities that are detected on a cluster.
 *
 * @param request DescribeInstanceVulStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceVulStatisticsResponse
 */
DescribeInstanceVulStatisticsResponse Client::describeInstanceVulStatisticsWithOptions(const DescribeInstanceVulStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTypes()) {
    query["Types"] = request.types();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeInstanceVulStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeInstanceVulStatisticsResponse>();
}

/**
 * @summary Queries the statistics of vulnerabilities that are detected on a cluster.
 *
 * @param request DescribeInstanceVulStatisticsRequest
 * @return DescribeInstanceVulStatisticsResponse
 */
DescribeInstanceVulStatisticsResponse Client::describeInstanceVulStatistics(const DescribeInstanceVulStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeInstanceVulStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the progress of the last virus scan task.
 *
 * @param request DescribeLatestScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLatestScanTaskResponse
 */
DescribeLatestScanTaskResponse Client::describeLatestScanTaskWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeLatestScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeLatestScanTaskResponse>();
}

/**
 * @summary Queries the progress of the last virus scan task.
 *
 * @return DescribeLatestScanTaskResponse
 */
DescribeLatestScanTaskResponse Client::describeLatestScanTask() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeLatestScanTaskWithOptions(runtime);
}

/**
 * @summary Queries the configurations of the log analysis feature provided by Security Center.
 *
 * @param request DescribeLogMetaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogMetaResponse
 */
DescribeLogMetaResponse Client::describeLogMetaWithOptions(const DescribeLogMetaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeLogMeta"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeLogMetaResponse>();
}

/**
 * @summary Queries the configurations of the log analysis feature provided by Security Center.
 *
 * @param request DescribeLogMetaRequest
 * @return DescribeLogMetaResponse
 */
DescribeLogMetaResponse Client::describeLogMeta(const DescribeLogMetaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeLogMetaWithOptions(request, runtime);
}

/**
 * @summary Queries the status information about the log analysis feature.
 *
 * @param request DescribeLogShipperStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogShipperStatusResponse
 */
DescribeLogShipperStatusResponse Client::describeLogShipperStatusWithOptions(const DescribeLogShipperStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeLogShipperStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeLogShipperStatusResponse>();
}

/**
 * @summary Queries the status information about the log analysis feature.
 *
 * @param request DescribeLogShipperStatusRequest
 * @return DescribeLogShipperStatusResponse
 */
DescribeLogShipperStatusResponse Client::describeLogShipperStatus(const DescribeLogShipperStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeLogShipperStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the configurations that are used to detect unusual logons to your servers.
 *
 * @param request DescribeLoginBaseConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLoginBaseConfigsResponse
 */
DescribeLoginBaseConfigsResponse Client::describeLoginBaseConfigsWithOptions(const DescribeLoginBaseConfigsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeLoginBaseConfigs"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeLoginBaseConfigsResponse>();
}

/**
 * @summary Queries the information about the configurations that are used to detect unusual logons to your servers.
 *
 * @param request DescribeLoginBaseConfigsRequest
 * @return DescribeLoginBaseConfigsResponse
 */
DescribeLoginBaseConfigsResponse Client::describeLoginBaseConfigs(const DescribeLoginBaseConfigsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeLoginBaseConfigsWithOptions(request, runtime);
}

/**
 * @summary Queries the alerting status for unapproved logon IP addresses, unapproved logon time ranges, or unapproved logon accounts.
 *
 * @param request DescribeLoginSwitchConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLoginSwitchConfigsResponse
 */
DescribeLoginSwitchConfigsResponse Client::describeLoginSwitchConfigsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeLoginSwitchConfigs"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeLoginSwitchConfigsResponse>();
}

/**
 * @summary Queries the alerting status for unapproved logon IP addresses, unapproved logon time ranges, or unapproved logon accounts.
 *
 * @return DescribeLoginSwitchConfigsResponse
 */
DescribeLoginSwitchConfigsResponse Client::describeLoginSwitchConfigs() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeLoginSwitchConfigsWithOptions(runtime);
}

/**
 * @summary Queries the purchased log storage capacity.
 *
 * @param request DescribeLogstoreStorageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogstoreStorageResponse
 */
DescribeLogstoreStorageResponse Client::describeLogstoreStorageWithOptions(const DescribeLogstoreStorageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeLogstoreStorage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeLogstoreStorageResponse>();
}

/**
 * @summary Queries the purchased log storage capacity.
 *
 * @param request DescribeLogstoreStorageRequest
 * @return DescribeLogstoreStorageResponse
 */
DescribeLogstoreStorageResponse Client::describeLogstoreStorage(const DescribeLogstoreStorageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeLogstoreStorageWithOptions(request, runtime);
}

/**
 * @summary Queries whether a server can be restarted after the vulnerabilities on the server are fixed. The fixes take effect only after the server is restarted.
 *
 * @param request DescribeMachineCanRebootRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMachineCanRebootResponse
 */
DescribeMachineCanRebootResponse Client::describeMachineCanRebootWithOptions(const DescribeMachineCanRebootRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeMachineCanReboot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeMachineCanRebootResponse>();
}

/**
 * @summary Queries whether a server can be restarted after the vulnerabilities on the server are fixed. The fixes take effect only after the server is restarted.
 *
 * @param request DescribeMachineCanRebootRequest
 * @return DescribeMachineCanRebootResponse
 */
DescribeMachineCanRebootResponse Client::describeMachineCanReboot(const DescribeMachineCanRebootRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeMachineCanRebootWithOptions(request, runtime);
}

/**
 * @summary Queries a list of malicious image sample types.
 *
 * @param request DescribeMatchedMaliciousNamesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMatchedMaliciousNamesResponse
 */
DescribeMatchedMaliciousNamesResponse Client::describeMatchedMaliciousNamesWithOptions(const DescribeMatchedMaliciousNamesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLevels()) {
    query["Levels"] = request.levels();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeMatchedMaliciousNames"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeMatchedMaliciousNamesResponse>();
}

/**
 * @summary Queries a list of malicious image sample types.
 *
 * @param request DescribeMatchedMaliciousNamesRequest
 * @return DescribeMatchedMaliciousNamesResponse
 */
DescribeMatchedMaliciousNamesResponse Client::describeMatchedMaliciousNames(const DescribeMatchedMaliciousNamesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeMatchedMaliciousNamesWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of the asset fingerprint module.
 *
 * @param request DescribeModuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeModuleConfigResponse
 */
DescribeModuleConfigResponse Client::describeModuleConfigWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeModuleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeModuleConfigResponse>();
}

/**
 * @summary Queries the configurations of the asset fingerprint module.
 *
 * @return DescribeModuleConfigResponse
 */
DescribeModuleConfigResponse Client::describeModuleConfig() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeModuleConfigWithOptions(runtime);
}

/**
 * @summary Queries the list of accounts that are added to the multi-account management feature as members.
 *
 * @param request DescribeMonitorAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMonitorAccountsResponse
 */
DescribeMonitorAccountsResponse Client::describeMonitorAccountsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeMonitorAccounts"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeMonitorAccountsResponse>();
}

/**
 * @summary Queries the list of accounts that are added to the multi-account management feature as members.
 *
 * @return DescribeMonitorAccountsResponse
 */
DescribeMonitorAccountsResponse Client::describeMonitorAccounts() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeMonitorAccountsWithOptions(runtime);
}

/**
 * @summary Queries whether slow queries need to be optimized.
 *
 * @param request DescribeNeedAsyncQueryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNeedAsyncQueryResponse
 */
DescribeNeedAsyncQueryResponse Client::describeNeedAsyncQueryWithOptions(const DescribeNeedAsyncQueryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeNeedAsyncQuery"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeNeedAsyncQueryResponse>();
}

/**
 * @summary Queries whether slow queries need to be optimized.
 *
 * @param request DescribeNeedAsyncQueryRequest
 * @return DescribeNeedAsyncQueryResponse
 */
DescribeNeedAsyncQueryResponse Client::describeNeedAsyncQuery(const DescribeNeedAsyncQueryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeNeedAsyncQueryWithOptions(request, runtime);
}

/**
 * @summary Queries notification settings.
 *
 * @param request DescribeNoticeConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNoticeConfigResponse
 */
DescribeNoticeConfigResponse Client::describeNoticeConfigWithOptions(const DescribeNoticeConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeNoticeConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeNoticeConfigResponse>();
}

/**
 * @summary Queries notification settings.
 *
 * @param request DescribeNoticeConfigRequest
 * @return DescribeNoticeConfigResponse
 */
DescribeNoticeConfigResponse Client::describeNoticeConfig(const DescribeNoticeConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeNoticeConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the information about an alert type.
 *
 * @param request DescribeNsasSuspEventTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNsasSuspEventTypeResponse
 */
DescribeNsasSuspEventTypeResponse Client::describeNsasSuspEventTypeWithOptions(const DescribeNsasSuspEventTypeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMultiAccountActionType()) {
    query["MultiAccountActionType"] = request.multiAccountActionType();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasSupportOperateCodeList()) {
    query["SupportOperateCodeList"] = request.supportOperateCodeList();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeNsasSuspEventType"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeNsasSuspEventTypeResponse>();
}

/**
 * @summary Queries the information about an alert type.
 *
 * @param request DescribeNsasSuspEventTypeRequest
 * @return DescribeNsasSuspEventTypeResponse
 */
DescribeNsasSuspEventTypeResponse Client::describeNsasSuspEventType(const DescribeNsasSuspEventTypeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeNsasSuspEventTypeWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the servers whose Security Center agent status is Offline.
 *
 * @param request DescribeOfflineMachinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOfflineMachinesResponse
 */
DescribeOfflineMachinesResponse Client::describeOfflineMachinesWithOptions(const DescribeOfflineMachinesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasOs()) {
    query["Os"] = request.os();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionIdStr()) {
    query["RegionIdStr"] = request.regionIdStr();
  }

  if (!!request.hasRegionNo()) {
    query["RegionNo"] = request.regionNo();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeOfflineMachines"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeOfflineMachinesResponse>();
}

/**
 * @summary Queries the information about the servers whose Security Center agent status is Offline.
 *
 * @param request DescribeOfflineMachinesRequest
 * @return DescribeOfflineMachinesResponse
 */
DescribeOfflineMachinesResponse Client::describeOfflineMachines(const DescribeOfflineMachinesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeOfflineMachinesWithOptions(request, runtime);
}

/**
 * @summary Queries agent tasks.
 *
 * @param request DescribeOnceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOnceTaskResponse
 */
DescribeOnceTaskResponse Client::describeOnceTaskWithOptions(const DescribeOnceTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTimeQuery()) {
    query["EndTimeQuery"] = request.endTimeQuery();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRootTaskId()) {
    query["RootTaskId"] = request.rootTaskId();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasStartTimeQuery()) {
    query["StartTimeQuery"] = request.startTimeQuery();
  }

  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  if (!!request.hasTaskType()) {
    query["TaskType"] = request.taskType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeOnceTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeOnceTaskResponse>();
}

/**
 * @summary Queries agent tasks.
 *
 * @param request DescribeOnceTaskRequest
 * @return DescribeOnceTaskResponse
 */
DescribeOnceTaskResponse Client::describeOnceTask(const DescribeOnceTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeOnceTaskWithOptions(request, runtime);
}

/**
 * @summary Queries the sub-task information of one-time scan task. A sub-task can be an image scan task or an image asset synchronization task.
 *
 * @param request DescribeOnceTaskLeafRecordPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOnceTaskLeafRecordPageResponse
 */
DescribeOnceTaskLeafRecordPageResponse Client::describeOnceTaskLeafRecordPageWithOptions(const DescribeOnceTaskLeafRecordPageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRelateInfo()) {
    query["RelateInfo"] = request.relateInfo();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasStatusList()) {
    query["StatusList"] = request.statusList();
  }

  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  if (!!request.hasTaskType()) {
    query["TaskType"] = request.taskType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeOnceTaskLeafRecordPage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeOnceTaskLeafRecordPageResponse>();
}

/**
 * @summary Queries the sub-task information of one-time scan task. A sub-task can be an image scan task or an image asset synchronization task.
 *
 * @param request DescribeOnceTaskLeafRecordPageRequest
 * @return DescribeOnceTaskLeafRecordPageResponse
 */
DescribeOnceTaskLeafRecordPageResponse Client::describeOnceTaskLeafRecordPage(const DescribeOnceTaskLeafRecordPageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeOnceTaskLeafRecordPageWithOptions(request, runtime);
}

/**
 * @summary Queries statistics on the client plug-in installation status.
 *
 * @param request DescribePluginSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePluginSummaryResponse
 */
DescribePluginSummaryResponse Client::describePluginSummaryWithOptions(const DescribePluginSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPluginName()) {
    query["PluginName"] = request.pluginName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePluginSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePluginSummaryResponse>();
}

/**
 * @summary Queries statistics on the client plug-in installation status.
 *
 * @param request DescribePluginSummaryRequest
 * @return DescribePluginSummaryResponse
 */
DescribePluginSummaryResponse Client::describePluginSummary(const DescribePluginSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePluginSummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
 *
 * @param request DescribePropertyCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyCountResponse
 */
DescribePropertyCountResponse Client::describePropertyCountWithOptions(const DescribePropertyCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyCountResponse>();
}

/**
 * @summary Queries the statistics of asset fingerprints. The assets include processes, ports, software, accounts, middleware, websites, web services, scheduled tasks, startup items, and databases.
 *
 * @param request DescribePropertyCountRequest
 * @return DescribePropertyCountResponse
 */
DescribePropertyCountResponse Client::describePropertyCount(const DescribePropertyCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyCountWithOptions(request, runtime);
}

/**
 * @summary Queries the details of scheduled tasks on the Host page.
 *
 * @param request DescribePropertyCronDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyCronDetailResponse
 */
DescribePropertyCronDetailResponse Client::describePropertyCronDetailWithOptions(const DescribePropertyCronDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasExtend()) {
    query["Extend"] = request.extend();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasUser()) {
    query["User"] = request.user();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyCronDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyCronDetailResponse>();
}

/**
 * @summary Queries the details of scheduled tasks on the Host page.
 *
 * @param request DescribePropertyCronDetailRequest
 * @return DescribePropertyCronDetailResponse
 */
DescribePropertyCronDetailResponse Client::describePropertyCronDetail(const DescribePropertyCronDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyCronDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the scheduled tasks of your assets.
 *
 * @param request DescribePropertyCronItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyCronItemResponse
 */
DescribePropertyCronItemResponse Client::describePropertyCronItemWithOptions(const DescribePropertyCronItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasForceFlush()) {
    query["ForceFlush"] = request.forceFlush();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyCronItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyCronItemResponse>();
}

/**
 * @summary Queries the scheduled tasks of your assets.
 *
 * @param request DescribePropertyCronItemRequest
 * @return DescribePropertyCronItemResponse
 */
DescribePropertyCronItemResponse Client::describePropertyCronItem(const DescribePropertyCronItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyCronItemWithOptions(request, runtime);
}

/**
 * @summary Queries the fingerprints of ports on a specified server.
 *
 * @param request DescribePropertyPortDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyPortDetailResponse
 */
DescribePropertyPortDetailResponse Client::describePropertyPortDetailWithOptions(const DescribePropertyPortDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBindIp()) {
    query["BindIp"] = request.bindIp();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasExtend()) {
    query["Extend"] = request.extend();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPort()) {
    query["Port"] = request.port();
  }

  if (!!request.hasProcName()) {
    query["ProcName"] = request.procName();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyPortDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyPortDetailResponse>();
}

/**
 * @summary Queries the fingerprints of ports on a specified server.
 *
 * @param request DescribePropertyPortDetailRequest
 * @return DescribePropertyPortDetailResponse
 */
DescribePropertyPortDetailResponse Client::describePropertyPortDetail(const DescribePropertyPortDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyPortDetailWithOptions(request, runtime);
}

/**
 * @summary Queries information about all ports.
 *
 * @param request DescribePropertyPortItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyPortItemResponse
 */
DescribePropertyPortItemResponse Client::describePropertyPortItemWithOptions(const DescribePropertyPortItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasForceFlush()) {
    query["ForceFlush"] = request.forceFlush();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPort()) {
    query["Port"] = request.port();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyPortItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyPortItemResponse>();
}

/**
 * @summary Queries information about all ports.
 *
 * @param request DescribePropertyPortItemRequest
 * @return DescribePropertyPortItemResponse
 */
DescribePropertyPortItemResponse Client::describePropertyPortItem(const DescribePropertyPortItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyPortItemWithOptions(request, runtime);
}

/**
 * @summary Queries the fingerprints of processes on a specified server.
 *
 * @param request DescribePropertyProcDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyProcDetailResponse
 */
DescribePropertyProcDetailResponse Client::describePropertyProcDetailWithOptions(const DescribePropertyProcDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCmdline()) {
    query["Cmdline"] = request.cmdline();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasExtend()) {
    query["Extend"] = request.extend();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasProcTimeEnd()) {
    query["ProcTimeEnd"] = request.procTimeEnd();
  }

  if (!!request.hasProcTimeStart()) {
    query["ProcTimeStart"] = request.procTimeStart();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasUser()) {
    query["User"] = request.user();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyProcDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyProcDetailResponse>();
}

/**
 * @summary Queries the fingerprints of processes on a specified server.
 *
 * @param request DescribePropertyProcDetailRequest
 * @return DescribePropertyProcDetailResponse
 */
DescribePropertyProcDetailResponse Client::describePropertyProcDetail(const DescribePropertyProcDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyProcDetailWithOptions(request, runtime);
}

/**
 * @summary Queries information about all processes.
 *
 * @param request DescribePropertyProcItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyProcItemResponse
 */
DescribePropertyProcItemResponse Client::describePropertyProcItemWithOptions(const DescribePropertyProcItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasForceFlush()) {
    query["ForceFlush"] = request.forceFlush();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyProcItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyProcItemResponse>();
}

/**
 * @summary Queries information about all processes.
 *
 * @param request DescribePropertyProcItemRequest
 * @return DescribePropertyProcItemResponse
 */
DescribePropertyProcItemResponse Client::describePropertyProcItem(const DescribePropertyProcItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyProcItemWithOptions(request, runtime);
}

/**
 * @summary Queries middleware fingerprints.
 *
 * @param request DescribePropertyScaDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyScaDetailResponse
 */
DescribePropertyScaDetailResponse Client::describePropertyScaDetailWithOptions(const DescribePropertyScaDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBiz()) {
    query["Biz"] = request.biz();
  }

  if (!!request.hasBizType()) {
    query["BizType"] = request.bizType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPid()) {
    query["Pid"] = request.pid();
  }

  if (!!request.hasPort()) {
    query["Port"] = request.port();
  }

  if (!!request.hasProcessStartedEnd()) {
    query["ProcessStartedEnd"] = request.processStartedEnd();
  }

  if (!!request.hasProcessStartedStart()) {
    query["ProcessStartedStart"] = request.processStartedStart();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasScaName()) {
    query["ScaName"] = request.scaName();
  }

  if (!!request.hasScaNamePattern()) {
    query["ScaNamePattern"] = request.scaNamePattern();
  }

  if (!!request.hasScaVersion()) {
    query["ScaVersion"] = request.scaVersion();
  }

  if (!!request.hasSearchInfo()) {
    query["SearchInfo"] = request.searchInfo();
  }

  if (!!request.hasSearchInfoSub()) {
    query["SearchInfoSub"] = request.searchInfoSub();
  }

  if (!!request.hasSearchItem()) {
    query["SearchItem"] = request.searchItem();
  }

  if (!!request.hasSearchItemSub()) {
    query["SearchItemSub"] = request.searchItemSub();
  }

  if (!!request.hasUser()) {
    query["User"] = request.user();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyScaDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyScaDetailResponse>();
}

/**
 * @summary Queries middleware fingerprints.
 *
 * @param request DescribePropertyScaDetailRequest
 * @return DescribePropertyScaDetailResponse
 */
DescribePropertyScaDetailResponse Client::describePropertyScaDetail(const DescribePropertyScaDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyScaDetailWithOptions(request, runtime);
}

/**
 * @summary Queries middleware fingerprints.
 *
 * @param request DescribePropertyScaItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyScaItemResponse
 */
DescribePropertyScaItemResponse Client::describePropertyScaItemWithOptions(const DescribePropertyScaItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBiz()) {
    query["Biz"] = request.biz();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasForceFlush()) {
    query["ForceFlush"] = request.forceFlush();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSearchInfo()) {
    query["SearchInfo"] = request.searchInfo();
  }

  if (!!request.hasSearchItem()) {
    query["SearchItem"] = request.searchItem();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyScaItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyScaItemResponse>();
}

/**
 * @summary Queries middleware fingerprints.
 *
 * @param request DescribePropertyScaItemRequest
 * @return DescribePropertyScaItemResponse
 */
DescribePropertyScaItemResponse Client::describePropertyScaItem(const DescribePropertyScaItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyScaItemWithOptions(request, runtime);
}

/**
 * @summary Queries the Java processes that are collected by the asset fingerprints feature of Security Center in your assets.
 *
 * @param request DescribePropertyScaProcessDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyScaProcessDetailResponse
 */
DescribePropertyScaProcessDetailResponse Client::describePropertyScaProcessDetailWithOptions(const DescribePropertyScaProcessDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBizType()) {
    query["BizType"] = request.bizType();
  }

  if (!!request.hasCmdline()) {
    query["Cmdline"] = request.cmdline();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPid()) {
    query["Pid"] = request.pid();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyScaProcessDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyScaProcessDetailResponse>();
}

/**
 * @summary Queries the Java processes that are collected by the asset fingerprints feature of Security Center in your assets.
 *
 * @param request DescribePropertyScaProcessDetailRequest
 * @return DescribePropertyScaProcessDetailResponse
 */
DescribePropertyScaProcessDetailResponse Client::describePropertyScaProcessDetail(const DescribePropertyScaProcessDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyScaProcessDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of scheduled tasks of asset fingerprint collection.
 *
 * @param request DescribePropertyScheduleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyScheduleConfigResponse
 */
DescribePropertyScheduleConfigResponse Client::describePropertyScheduleConfigWithOptions(const DescribePropertyScheduleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyScheduleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyScheduleConfigResponse>();
}

/**
 * @summary Queries the configurations of scheduled tasks of asset fingerprint collection.
 *
 * @param request DescribePropertyScheduleConfigRequest
 * @return DescribePropertyScheduleConfigResponse
 */
DescribePropertyScheduleConfigResponse Client::describePropertyScheduleConfig(const DescribePropertyScheduleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyScheduleConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the details of a software asset.
 *
 * @param request DescribePropertySoftwareDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertySoftwareDetailResponse
 */
DescribePropertySoftwareDetailResponse Client::describePropertySoftwareDetailWithOptions(const DescribePropertySoftwareDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasExtend()) {
    query["Extend"] = request.extend();
  }

  if (!!request.hasInstallTimeEnd()) {
    query["InstallTimeEnd"] = request.installTimeEnd();
  }

  if (!!request.hasInstallTimeStart()) {
    query["InstallTimeStart"] = request.installTimeStart();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPath()) {
    query["Path"] = request.path();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSoftwareVersion()) {
    query["SoftwareVersion"] = request.softwareVersion();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertySoftwareDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertySoftwareDetailResponse>();
}

/**
 * @summary Queries the details of a software asset.
 *
 * @param request DescribePropertySoftwareDetailRequest
 * @return DescribePropertySoftwareDetailResponse
 */
DescribePropertySoftwareDetailResponse Client::describePropertySoftwareDetail(const DescribePropertySoftwareDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertySoftwareDetailWithOptions(request, runtime);
}

/**
 * @summary Queries information about all software assets.
 *
 * @param request DescribePropertySoftwareItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertySoftwareItemResponse
 */
DescribePropertySoftwareItemResponse Client::describePropertySoftwareItemWithOptions(const DescribePropertySoftwareItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasForceFlush()) {
    query["ForceFlush"] = request.forceFlush();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertySoftwareItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertySoftwareItemResponse>();
}

/**
 * @summary Queries information about all software assets.
 *
 * @param request DescribePropertySoftwareItemRequest
 * @return DescribePropertySoftwareItemResponse
 */
DescribePropertySoftwareItemResponse Client::describePropertySoftwareItem(const DescribePropertySoftwareItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertySoftwareItemWithOptions(request, runtime);
}

/**
 * @summary Queries middleware types.
 *
 * @param request DescribePropertyTypeScaItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyTypeScaItemResponse
 */
DescribePropertyTypeScaItemResponse Client::describePropertyTypeScaItemWithOptions(const DescribePropertyTypeScaItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyTypeScaItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyTypeScaItemResponse>();
}

/**
 * @summary Queries middleware types.
 *
 * @param request DescribePropertyTypeScaItemRequest
 * @return DescribePropertyTypeScaItemResponse
 */
DescribePropertyTypeScaItemResponse Client::describePropertyTypeScaItem(const DescribePropertyTypeScaItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyTypeScaItemWithOptions(request, runtime);
}

/**
 * @summary Uses the asset fingerprints feature to obtain the statistics on top five most frequently detected ports, processes, software, accounts, or middleware.
 *
 * @description Only users who purchase the Enterprise or Ultimate edition of Security Center can call this operation.
 *
 * @param request DescribePropertyUsageTopRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyUsageTopResponse
 */
DescribePropertyUsageTopResponse Client::describePropertyUsageTopWithOptions(const DescribePropertyUsageTopRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyUsageTop"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyUsageTopResponse>();
}

/**
 * @summary Uses the asset fingerprints feature to obtain the statistics on top five most frequently detected ports, processes, software, accounts, or middleware.
 *
 * @description Only users who purchase the Enterprise or Ultimate edition of Security Center can call this operation.
 *
 * @param request DescribePropertyUsageTopRequest
 * @return DescribePropertyUsageTopResponse
 */
DescribePropertyUsageTopResponse Client::describePropertyUsageTop(const DescribePropertyUsageTopRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyUsageTopWithOptions(request, runtime);
}

/**
 * @summary Queries the asset fingerprints for an account to which a server belongs.
 *
 * @param request DescribePropertyUserDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyUserDetailResponse
 */
DescribePropertyUserDetailResponse Client::describePropertyUserDetailWithOptions(const DescribePropertyUserDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasExtend()) {
    query["Extend"] = request.extend();
  }

  if (!!request.hasIsRoot()) {
    query["IsRoot"] = request.isRoot();
  }

  if (!!request.hasLastLoginTimeEnd()) {
    query["LastLoginTimeEnd"] = request.lastLoginTimeEnd();
  }

  if (!!request.hasLastLoginTimeStart()) {
    query["LastLoginTimeStart"] = request.lastLoginTimeStart();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasUser()) {
    query["User"] = request.user();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyUserDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyUserDetailResponse>();
}

/**
 * @summary Queries the asset fingerprints for an account to which a server belongs.
 *
 * @param request DescribePropertyUserDetailRequest
 * @return DescribePropertyUserDetailResponse
 */
DescribePropertyUserDetailResponse Client::describePropertyUserDetail(const DescribePropertyUserDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyUserDetailWithOptions(request, runtime);
}

/**
 * @summary Queries information about an account.
 *
 * @param request DescribePropertyUserItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePropertyUserItemResponse
 */
DescribePropertyUserItemResponse Client::describePropertyUserItemWithOptions(const DescribePropertyUserItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasForceFlush()) {
    query["ForceFlush"] = request.forceFlush();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasUser()) {
    query["User"] = request.user();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribePropertyUserItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribePropertyUserItemResponse>();
}

/**
 * @summary Queries information about an account.
 *
 * @param request DescribePropertyUserItemRequest
 * @return DescribePropertyUserItemResponse
 */
DescribePropertyUserItemResponse Client::describePropertyUserItem(const DescribePropertyUserItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describePropertyUserItemWithOptions(request, runtime);
}

/**
 * @summary Queries the download information about a quarantined file.
 *
 * @param request DescribeQuaraFileDownloadInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeQuaraFileDownloadInfoResponse
 */
DescribeQuaraFileDownloadInfoResponse Client::describeQuaraFileDownloadInfoWithOptions(const DescribeQuaraFileDownloadInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasQuaraFileId()) {
    query["QuaraFileId"] = request.quaraFileId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeQuaraFileDownloadInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeQuaraFileDownloadInfoResponse>();
}

/**
 * @summary Queries the download information about a quarantined file.
 *
 * @param request DescribeQuaraFileDownloadInfoRequest
 * @return DescribeQuaraFileDownloadInfoResponse
 */
DescribeQuaraFileDownloadInfoResponse Client::describeQuaraFileDownloadInfo(const DescribeQuaraFileDownloadInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeQuaraFileDownloadInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the information about a report export task.
 *
 * @param request DescribeReportExportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeReportExportResponse
 */
DescribeReportExportResponse Client::describeReportExportWithOptions(const DescribeReportExportRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExportId()) {
    query["ExportId"] = request.exportId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeReportExport"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeReportExportResponse>();
}

/**
 * @summary Queries the information about a report export task.
 *
 * @param request DescribeReportExportRequest
 * @return DescribeReportExportResponse
 */
DescribeReportExportResponse Client::describeReportExport(const DescribeReportExportRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeReportExportWithOptions(request, runtime);
}

/**
 * @summary Queries the status of a report recipient by using the security report feature of the System Configuration module in the Security Center console.
 *
 * @param request DescribeReportRecipientStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeReportRecipientStatusResponse
 */
DescribeReportRecipientStatusResponse Client::describeReportRecipientStatusWithOptions(const DescribeReportRecipientStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRecipients()) {
    query["Recipients"] = request.recipients();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeReportRecipientStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeReportRecipientStatusResponse>();
}

/**
 * @summary Queries the status of a report recipient by using the security report feature of the System Configuration module in the Security Center console.
 *
 * @param request DescribeReportRecipientStatusRequest
 * @return DescribeReportRecipientStatusResponse
 */
DescribeReportRecipientStatusResponse Client::describeReportRecipientStatus(const DescribeReportRecipientStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeReportRecipientStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the details about restoration tasks.
 *
 * @description If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
 * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](https://help.aliyun.com/document_detail/164781.html).
 *
 * @param request DescribeRestoreJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRestoreJobsResponse
 */
DescribeRestoreJobsResponse Client::describeRestoreJobsWithOptions(const DescribeRestoreJobsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasMachineRemark()) {
    query["MachineRemark"] = request.machineRemark();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRestoreJobs"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRestoreJobsResponse>();
}

/**
 * @summary Queries the details about restoration tasks.
 *
 * @description If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
 * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](https://help.aliyun.com/document_detail/164781.html).
 *
 * @param request DescribeRestoreJobsRequest
 * @return DescribeRestoreJobsResponse
 */
DescribeRestoreJobsResponse Client::describeRestoreJobs(const DescribeRestoreJobsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRestoreJobsWithOptions(request, runtime);
}

/**
 * @summary Queries restoration tasks.
 *
 * @param request DescribeRestorePlansRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRestorePlansResponse
 */
DescribeRestorePlansResponse Client::describeRestorePlansWithOptions(const DescribeRestorePlansRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasInstanceName()) {
    query["InstanceName"] = request.instanceName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRestorePlans"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRestorePlansResponse>();
}

/**
 * @summary Queries restoration tasks.
 *
 * @param request DescribeRestorePlansRequest
 * @return DescribeRestorePlansResponse
 */
DescribeRestorePlansResponse Client::describeRestorePlans(const DescribeRestorePlansRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRestorePlansWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeRiskCheckItemResult is deprecated
 *
 * @summary Queries the assets that are affected by the risk item detected in configuration assessment based on a specified check item.
 *
 * @description This operation is phased out. You can use the ListCheckInstanceResult operation.
 *
 * @param request DescribeRiskCheckItemResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskCheckItemResultResponse
 */
DescribeRiskCheckItemResultResponse Client::describeRiskCheckItemResultWithOptions(const DescribeRiskCheckItemResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasItemId()) {
    query["ItemId"] = request.itemId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRiskCheckItemResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRiskCheckItemResultResponse>();
}

/**
 * @deprecated OpenAPI DescribeRiskCheckItemResult is deprecated
 *
 * @summary Queries the assets that are affected by the risk item detected in configuration assessment based on a specified check item.
 *
 * @description This operation is phased out. You can use the ListCheckInstanceResult operation.
 *
 * @param request DescribeRiskCheckItemResultRequest
 * @return DescribeRiskCheckItemResultResponse
 */
DescribeRiskCheckItemResultResponse Client::describeRiskCheckItemResult(const DescribeRiskCheckItemResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRiskCheckItemResultWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeRiskCheckResult is deprecated
 *
 * @summary Queries the check results of cloud service configurations by check item type or name.
 *
 * @description This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
 *
 * @param request DescribeRiskCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskCheckResultResponse
 */
DescribeRiskCheckResultResponse Client::describeRiskCheckResultWithOptions(const DescribeRiskCheckResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssetType()) {
    query["AssetType"] = request.assetType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasItemIds()) {
    query["ItemIds"] = request.itemIds();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasQueryFlag()) {
    query["QueryFlag"] = request.queryFlag();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasRiskLevel()) {
    query["RiskLevel"] = request.riskLevel();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRiskCheckResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRiskCheckResultResponse>();
}

/**
 * @deprecated OpenAPI DescribeRiskCheckResult is deprecated
 *
 * @summary Queries the check results of cloud service configurations by check item type or name.
 *
 * @description This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
 *
 * @param request DescribeRiskCheckResultRequest
 * @return DescribeRiskCheckResultResponse
 */
DescribeRiskCheckResultResponse Client::describeRiskCheckResult(const DescribeRiskCheckResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRiskCheckResultWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeRiskCheckSummary is deprecated
 *
 * @summary Queries the summary information about the check results of cloud service configurations. The information includes the number of risk items, the risk rate, the number of affected assets, the check time, and the statistics for each type of check item.
 *
 * @description This operation is phased out. You can use the GetCheckSummary operation.
 *
 * @param request DescribeRiskCheckSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskCheckSummaryResponse
 */
DescribeRiskCheckSummaryResponse Client::describeRiskCheckSummaryWithOptions(const DescribeRiskCheckSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRiskCheckSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRiskCheckSummaryResponse>();
}

/**
 * @deprecated OpenAPI DescribeRiskCheckSummary is deprecated
 *
 * @summary Queries the summary information about the check results of cloud service configurations. The information includes the number of risk items, the risk rate, the number of affected assets, the check time, and the statistics for each type of check item.
 *
 * @description This operation is phased out. You can use the GetCheckSummary operation.
 *
 * @param request DescribeRiskCheckSummaryRequest
 * @return DescribeRiskCheckSummaryResponse
 */
DescribeRiskCheckSummaryResponse Client::describeRiskCheckSummary(const DescribeRiskCheckSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRiskCheckSummaryWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeRiskItemType is deprecated
 *
 * @summary Queries the types of check items in configuration assessment.
 *
 * @description This operation is phased out. You can use the ListCheckStandard operation instead.
 *
 * @param request DescribeRiskItemTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskItemTypeResponse
 */
DescribeRiskItemTypeResponse Client::describeRiskItemTypeWithOptions(const DescribeRiskItemTypeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRiskItemType"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRiskItemTypeResponse>();
}

/**
 * @deprecated OpenAPI DescribeRiskItemType is deprecated
 *
 * @summary Queries the types of check items in configuration assessment.
 *
 * @description This operation is phased out. You can use the ListCheckStandard operation instead.
 *
 * @param request DescribeRiskItemTypeRequest
 * @return DescribeRiskItemTypeResponse
 */
DescribeRiskItemTypeResponse Client::describeRiskItemType(const DescribeRiskItemTypeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRiskItemTypeWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeRiskListCheckResult is deprecated
 *
 * @summary Queries the number of risk items detected in the configuration assessment of one or more cloud services by using the instance IDs of the cloud services.
 *
 * @description This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
 *
 * @param request DescribeRiskListCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskListCheckResultResponse
 */
DescribeRiskListCheckResultResponse Client::describeRiskListCheckResultWithOptions(const DescribeRiskListCheckResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRiskListCheckResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRiskListCheckResultResponse>();
}

/**
 * @deprecated OpenAPI DescribeRiskListCheckResult is deprecated
 *
 * @summary Queries the number of risk items detected in the configuration assessment of one or more cloud services by using the instance IDs of the cloud services.
 *
 * @description This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
 *
 * @param request DescribeRiskListCheckResultRequest
 * @return DescribeRiskListCheckResultResponse
 */
DescribeRiskListCheckResultResponse Client::describeRiskListCheckResult(const DescribeRiskListCheckResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRiskListCheckResultWithOptions(request, runtime);
}

/**
 * @summary Queries baseline types.
 *
 * @param request DescribeRiskTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRiskTypeResponse
 */
DescribeRiskTypeResponse Client::describeRiskTypeWithOptions(const DescribeRiskTypeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRiskType"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRiskTypeResponse>();
}

/**
 * @summary Queries baseline types.
 *
 * @param request DescribeRiskTypeRequest
 * @return DescribeRiskTypeResponse
 */
DescribeRiskTypeResponse Client::describeRiskType(const DescribeRiskTypeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRiskTypeWithOptions(request, runtime);
}

/**
 * @summary Queries the information about baselines based on baseline IDs or names.
 *
 * @param request DescribeRisksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRisksResponse
 */
DescribeRisksResponse Client::describeRisksWithOptions(const DescribeRisksRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLimit()) {
    query["Limit"] = request.limit();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasRiskId()) {
    query["RiskId"] = request.riskId();
  }

  if (!!request.hasRiskName()) {
    query["RiskName"] = request.riskName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeRisks"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeRisksResponse>();
}

/**
 * @summary Queries the information about baselines based on baseline IDs or names.
 *
 * @param request DescribeRisksRequest
 * @return DescribeRisksResponse
 */
DescribeRisksResponse Client::describeRisks(const DescribeRisksRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeRisksWithOptions(request, runtime);
}

/**
 * @summary Queries the servers on which you want to install Cloud Assistant or the CloudMonitor agent.
 *
 * @param request DescribeSasPmAgentListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSasPmAgentListResponse
 */
DescribeSasPmAgentListResponse Client::describeSasPmAgentListWithOptions(const DescribeSasPmAgentListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSasPmAgentList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSasPmAgentListResponse>();
}

/**
 * @summary Queries the servers on which you want to install Cloud Assistant or the CloudMonitor agent.
 *
 * @param request DescribeSasPmAgentListRequest
 * @return DescribeSasPmAgentListResponse
 */
DescribeSasPmAgentListResponse Client::describeSasPmAgentList(const DescribeSasPmAgentListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSasPmAgentListWithOptions(request, runtime);
}

/**
 * @summary Queries the progress of a virus scan task.
 *
 * @param request DescribeScanTaskProgressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScanTaskProgressResponse
 */
DescribeScanTaskProgressResponse Client::describeScanTaskProgressWithOptions(const DescribeScanTaskProgressRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeScanTaskProgress"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeScanTaskProgressResponse>();
}

/**
 * @summary Queries the progress of a virus scan task.
 *
 * @param request DescribeScanTaskProgressRequest
 * @return DescribeScanTaskProgressResponse
 */
DescribeScanTaskProgressResponse Client::describeScanTaskProgress(const DescribeScanTaskProgressRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeScanTaskProgressWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of virus detection tasks.
 *
 * @param request DescribeScanTaskStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScanTaskStatisticsResponse
 */
DescribeScanTaskStatisticsResponse Client::describeScanTaskStatisticsWithOptions(const DescribeScanTaskStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLevels()) {
    query["Levels"] = request.levels();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeScanTaskStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeScanTaskStatisticsResponse>();
}

/**
 * @summary Queries the statistics of virus detection tasks.
 *
 * @param request DescribeScanTaskStatisticsRequest
 * @return DescribeScanTaskStatisticsResponse
 */
DescribeScanTaskStatisticsResponse Client::describeScanTaskStatistics(const DescribeScanTaskStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeScanTaskStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the trends of the scores on the security dashboard.
 *
 * @param request DescribeScreenScoreThreadRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScreenScoreThreadResponse
 */
DescribeScreenScoreThreadResponse Client::describeScreenScoreThreadWithOptions(const DescribeScreenScoreThreadRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeScreenScoreThread"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeScreenScoreThreadResponse>();
}

/**
 * @summary Queries the trends of the scores on the security dashboard.
 *
 * @param request DescribeScreenScoreThreadRequest
 * @return DescribeScreenScoreThreadResponse
 */
DescribeScreenScoreThreadResponse Client::describeScreenScoreThread(const DescribeScreenScoreThreadRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeScreenScoreThreadWithOptions(request, runtime);
}

/**
 * @summary Queries the filter conditions that are used to search for assets.
 *
 * @param request DescribeSearchConditionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSearchConditionResponse
 */
DescribeSearchConditionResponse Client::describeSearchConditionWithOptions(const DescribeSearchConditionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSearchCondition"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSearchConditionResponse>();
}

/**
 * @summary Queries the filter conditions that are used to search for assets.
 *
 * @param request DescribeSearchConditionRequest
 * @return DescribeSearchConditionResponse
 */
DescribeSearchConditionResponse Client::describeSearchCondition(const DescribeSearchConditionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSearchConditionWithOptions(request, runtime);
}

/**
 * @summary Queries suggestions on how to handle the risks that affect the security score.
 *
 * @param request DescribeSecureSuggestionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecureSuggestionResponse
 */
DescribeSecureSuggestionResponse Client::describeSecureSuggestionWithOptions(const DescribeSecureSuggestionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCalType()) {
    query["CalType"] = request.calType();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSecureSuggestion"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSecureSuggestionResponse>();
}

/**
 * @summary Queries suggestions on how to handle the risks that affect the security score.
 *
 * @param request DescribeSecureSuggestionRequest
 * @return DescribeSecureSuggestionResponse
 */
DescribeSecureSuggestionResponse Client::describeSecureSuggestion(const DescribeSecureSuggestionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSecureSuggestionWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI DescribeSecurityCheckScheduleConfig is deprecated
 *
 * @summary Queries the day of a week when custom check tasks are performed and the time range during which the custom check tasks are performed.
 *
 * @description This operation is phased out. You can use the GetCheckConfig operation.
 *
 * @param request DescribeSecurityCheckScheduleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityCheckScheduleConfigResponse
 */
DescribeSecurityCheckScheduleConfigResponse Client::describeSecurityCheckScheduleConfigWithOptions(const DescribeSecurityCheckScheduleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSecurityCheckScheduleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSecurityCheckScheduleConfigResponse>();
}

/**
 * @deprecated OpenAPI DescribeSecurityCheckScheduleConfig is deprecated
 *
 * @summary Queries the day of a week when custom check tasks are performed and the time range during which the custom check tasks are performed.
 *
 * @description This operation is phased out. You can use the GetCheckConfig operation.
 *
 * @param request DescribeSecurityCheckScheduleConfigRequest
 * @return DescribeSecurityCheckScheduleConfigResponse
 */
DescribeSecurityCheckScheduleConfigResponse Client::describeSecurityCheckScheduleConfig(const DescribeSecurityCheckScheduleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSecurityCheckScheduleConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the list of whitelist rules.
 *
 * @param request DescribeSecurityEventMarkMissListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityEventMarkMissListResponse
 */
DescribeSecurityEventMarkMissListResponse Client::describeSecurityEventMarkMissListWithOptions(const DescribeSecurityEventMarkMissListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEventName()) {
    query["EventName"] = request.eventName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSecurityEventMarkMissList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSecurityEventMarkMissListResponse>();
}

/**
 * @summary Queries the list of whitelist rules.
 *
 * @param request DescribeSecurityEventMarkMissListRequest
 * @return DescribeSecurityEventMarkMissListResponse
 */
DescribeSecurityEventMarkMissListResponse Client::describeSecurityEventMarkMissList(const DescribeSecurityEventMarkMissListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSecurityEventMarkMissListWithOptions(request, runtime);
}

/**
 * @summary Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
 *
 * @param request DescribeSecurityEventOperationStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityEventOperationStatusResponse
 */
DescribeSecurityEventOperationStatusResponse Client::describeSecurityEventOperationStatusWithOptions(const DescribeSecurityEventOperationStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityEventIds()) {
    query["SecurityEventIds"] = request.securityEventIds();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSecurityEventOperationStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSecurityEventOperationStatusResponse>();
}

/**
 * @summary Queries the alert events that are triggered by the same IP address rule or of the same alert type as a specific alert event if you want to handle the specific alert event in batch operation mode.
 *
 * @param request DescribeSecurityEventOperationStatusRequest
 * @return DescribeSecurityEventOperationStatusResponse
 */
DescribeSecurityEventOperationStatusResponse Client::describeSecurityEventOperationStatus(const DescribeSecurityEventOperationStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSecurityEventOperationStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the operations that you can perform to handle an alert.
 *
 * @param request DescribeSecurityEventOperationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityEventOperationsResponse
 */
DescribeSecurityEventOperationsResponse Client::describeSecurityEventOperationsWithOptions(const DescribeSecurityEventOperationsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityEventId()) {
    query["SecurityEventId"] = request.securityEventId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSecurityEventOperations"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSecurityEventOperationsResponse>();
}

/**
 * @summary Queries the operations that you can perform to handle an alert.
 *
 * @param request DescribeSecurityEventOperationsRequest
 * @return DescribeSecurityEventOperationsResponse
 */
DescribeSecurityEventOperationsResponse Client::describeSecurityEventOperations(const DescribeSecurityEventOperationsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSecurityEventOperationsWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
 *
 * @param request DescribeSecurityStatInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSecurityStatInfoResponse
 */
DescribeSecurityStatInfoResponse Client::describeSecurityStatInfoWithOptions(const DescribeSecurityStatInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSecurityStatInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSecurityStatInfoResponse>();
}

/**
 * @summary Queries the statistics of each security check item and the daily statistics in the trend chart based on each security check item.
 *
 * @param request DescribeSecurityStatInfoRequest
 * @return DescribeSecurityStatInfoResponse
 */
DescribeSecurityStatInfoResponse Client::describeSecurityStatInfo(const DescribeSecurityStatInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSecurityStatInfoWithOptions(request, runtime);
}

/**
 * @summary Checks whether a service-linked role is created for Security Center.
 *
 * @param request DescribeServiceLinkedRoleStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServiceLinkedRoleStatusResponse
 */
DescribeServiceLinkedRoleStatusResponse Client::describeServiceLinkedRoleStatusWithOptions(const DescribeServiceLinkedRoleStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasServiceLinkedRole()) {
    query["ServiceLinkedRole"] = request.serviceLinkedRole();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeServiceLinkedRoleStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeServiceLinkedRoleStatusResponse>();
}

/**
 * @summary Checks whether a service-linked role is created for Security Center.
 *
 * @param request DescribeServiceLinkedRoleStatusRequest
 * @return DescribeServiceLinkedRoleStatusResponse
 */
DescribeServiceLinkedRoleStatusResponse Client::describeServiceLinkedRoleStatus(const DescribeServiceLinkedRoleStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeServiceLinkedRoleStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the scenarios in which alerts triggered by the same rule or rules of the same type are handled.
 *
 * @param request DescribeSimilarEventScenariosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSimilarEventScenariosResponse
 */
DescribeSimilarEventScenariosResponse Client::describeSimilarEventScenariosWithOptions(const DescribeSimilarEventScenariosRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSecurityEventId()) {
    query["SecurityEventId"] = request.securityEventId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSimilarEventScenarios"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSimilarEventScenariosResponse>();
}

/**
 * @summary Queries the scenarios in which alerts triggered by the same rule or rules of the same type are handled.
 *
 * @param request DescribeSimilarEventScenariosRequest
 * @return DescribeSimilarEventScenariosResponse
 */
DescribeSimilarEventScenariosResponse Client::describeSimilarEventScenarios(const DescribeSimilarEventScenariosRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSimilarEventScenariosWithOptions(request, runtime);
}

/**
 * @summary Queries alert events that are triggered by the same rule or of the same alert type.
 *
 * @param request DescribeSimilarSecurityEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSimilarSecurityEventsResponse
 */
DescribeSimilarSecurityEventsResponse Client::describeSimilarSecurityEventsWithOptions(const DescribeSimilarSecurityEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSimilarSecurityEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSimilarSecurityEventsResponse>();
}

/**
 * @summary Queries alert events that are triggered by the same rule or of the same alert type.
 *
 * @param request DescribeSimilarSecurityEventsRequest
 * @return DescribeSimilarSecurityEventsResponse
 */
DescribeSimilarSecurityEventsResponse Client::describeSimilarSecurityEvents(const DescribeSimilarSecurityEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSimilarSecurityEventsWithOptions(request, runtime);
}

/**
 * @summary Queries the backup snapshots that are created for anti-ransomware.
 *
 * @param request DescribeSnapshotsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSnapshotsResponse
 */
DescribeSnapshotsResponse Client::describeSnapshotsWithOptions(const DescribeSnapshotsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasApiVersion()) {
    query["ApiVersion"] = request.apiVersion();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasIsAliYunEcs()) {
    query["IsAliYunEcs"] = request.isAliYunEcs();
  }

  if (!!request.hasMachineRegion()) {
    query["MachineRegion"] = request.machineRegion();
  }

  if (!!request.hasMachineRemark()) {
    query["MachineRemark"] = request.machineRemark();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStatusList()) {
    query["StatusList"] = request.statusList();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSnapshots"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSnapshotsResponse>();
}

/**
 * @summary Queries the backup snapshots that are created for anti-ransomware.
 *
 * @param request DescribeSnapshotsRequest
 * @return DescribeSnapshotsResponse
 */
DescribeSnapshotsResponse Client::describeSnapshots(const DescribeSnapshotsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSnapshotsWithOptions(request, runtime);
}

/**
 * @summary Query the execution details of a remediation task playbook
 *
 * @description This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request DescribeSoarPlaybookTaskDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarPlaybookTaskDetailResponse
 */
DescribeSoarPlaybookTaskDetailResponse Client::describeSoarPlaybookTaskDetailWithOptions(const DescribeSoarPlaybookTaskDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPlaybookId()) {
    query["PlaybookId"] = request.playbookId();
  }

  if (!!request.hasRecordId()) {
    query["RecordId"] = request.recordId();
  }

  if (!!request.hasRequestUuid()) {
    query["RequestUuid"] = request.requestUuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSoarPlaybookTaskDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSoarPlaybookTaskDetailResponse>();
}

/**
 * @summary Query the execution details of a remediation task playbook
 *
 * @description This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request DescribeSoarPlaybookTaskDetailRequest
 * @return DescribeSoarPlaybookTaskDetailResponse
 */
DescribeSoarPlaybookTaskDetailResponse Client::describeSoarPlaybookTaskDetail(const DescribeSoarPlaybookTaskDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSoarPlaybookTaskDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the policy templates on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategiesResponse
 */
DescribeSoarStrategiesResponse Client::describeSoarStrategiesWithOptions(const DescribeSoarStrategiesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSoarStrategies"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSoarStrategiesResponse>();
}

/**
 * @summary Queries the policy templates on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategiesRequest
 * @return DescribeSoarStrategiesResponse
 */
DescribeSoarStrategiesResponse Client::describeSoarStrategies(const DescribeSoarStrategiesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSoarStrategiesWithOptions(request, runtime);
}

/**
 * @summary Queries the parameters of a policy on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyParamRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategyParamResponse
 */
DescribeSoarStrategyParamResponse Client::describeSoarStrategyParamWithOptions(const DescribeSoarStrategyParamRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSoarStrategyParam"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSoarStrategyParamResponse>();
}

/**
 * @summary Queries the parameters of a policy on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyParamRequest
 * @return DescribeSoarStrategyParamResponse
 */
DescribeSoarStrategyParamResponse Client::describeSoarStrategyParam(const DescribeSoarStrategyParamRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSoarStrategyParamWithOptions(request, runtime);
}

/**
 * @summary Queries the details of a policy task on the Playbook page, including the execution status of the task and the process information of the task.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyTaskDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategyTaskDetailResponse
 */
DescribeSoarStrategyTaskDetailResponse Client::describeSoarStrategyTaskDetailWithOptions(const DescribeSoarStrategyTaskDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasStrategyTaskId()) {
    query["StrategyTaskId"] = request.strategyTaskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSoarStrategyTaskDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSoarStrategyTaskDetailResponse>();
}

/**
 * @summary Queries the details of a policy task on the Playbook page, including the execution status of the task and the process information of the task.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyTaskDetailRequest
 * @return DescribeSoarStrategyTaskDetailResponse
 */
DescribeSoarStrategyTaskDetailResponse Client::describeSoarStrategyTaskDetail(const DescribeSoarStrategyTaskDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSoarStrategyTaskDetailWithOptions(request, runtime);
}

/**
 * @summary Get the input parameters for a specific task
 *
 * @description Only the Enterprise and Flagship editions of Cloud Security Center support this API call, other versions do not support it.
 *
 * @param request DescribeSoarStrategyTaskParamsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategyTaskParamsResponse
 */
DescribeSoarStrategyTaskParamsResponse Client::describeSoarStrategyTaskParamsWithOptions(const DescribeSoarStrategyTaskParamsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSoarStrategyTaskParams"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSoarStrategyTaskParamsResponse>();
}

/**
 * @summary Get the input parameters for a specific task
 *
 * @description Only the Enterprise and Flagship editions of Cloud Security Center support this API call, other versions do not support it.
 *
 * @param request DescribeSoarStrategyTaskParamsRequest
 * @return DescribeSoarStrategyTaskParamsResponse
 */
DescribeSoarStrategyTaskParamsResponse Client::describeSoarStrategyTaskParams(const DescribeSoarStrategyTaskParamsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSoarStrategyTaskParamsWithOptions(request, runtime);
}

/**
 * @summary Get the list of task execution results
 *
 * @description This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request DescribeSoarStrategyTaskResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategyTaskResultResponse
 */
DescribeSoarStrategyTaskResultResponse Client::describeSoarStrategyTaskResultWithOptions(const DescribeSoarStrategyTaskResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSoarStrategyTaskResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSoarStrategyTaskResultResponse>();
}

/**
 * @summary Get the list of task execution results
 *
 * @description This API is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request DescribeSoarStrategyTaskResultRequest
 * @return DescribeSoarStrategyTaskResultResponse
 */
DescribeSoarStrategyTaskResultResponse Client::describeSoarStrategyTaskResult(const DescribeSoarStrategyTaskResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSoarStrategyTaskResultWithOptions(request, runtime);
}

/**
 * @summary Queries a list of policy tasks on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarStrategyTasksResponse
 */
DescribeSoarStrategyTasksResponse Client::describeSoarStrategyTasksWithOptions(const DescribeSoarStrategyTasksRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSoarStrategyTasks"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSoarStrategyTasksResponse>();
}

/**
 * @summary Queries a list of policy tasks on the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarStrategyTasksRequest
 * @return DescribeSoarStrategyTasksResponse
 */
DescribeSoarStrategyTasksResponse Client::describeSoarStrategyTasks(const DescribeSoarStrategyTasksRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSoarStrategyTasksWithOptions(request, runtime);
}

/**
 * @summary Queries a list of policies created on the Playbook page of Security Center.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarSubscribedStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSoarSubscribedStrategyResponse
 */
DescribeSoarSubscribedStrategyResponse Client::describeSoarSubscribedStrategyWithOptions(const DescribeSoarSubscribedStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPageNumber()) {
    query["PageNumber"] = request.pageNumber();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSoarSubscribedStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSoarSubscribedStrategyResponse>();
}

/**
 * @summary Queries a list of policies created on the Playbook page of Security Center.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request DescribeSoarSubscribedStrategyRequest
 * @return DescribeSoarSubscribedStrategyResponse
 */
DescribeSoarSubscribedStrategyResponse Client::describeSoarSubscribedStrategy(const DescribeSoarSubscribedStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSoarSubscribedStrategyWithOptions(request, runtime);
}

/**
 * @summary Queries the details about baseline check policies.
 *
 * @param request DescribeStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStrategyResponse
 */
DescribeStrategyResponse Client::describeStrategyWithOptions(const DescribeStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCustomType()) {
    query["CustomType"] = request.customType();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyIds()) {
    query["StrategyIds"] = request.strategyIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeStrategyResponse>();
}

/**
 * @summary Queries the details about baseline check policies.
 *
 * @param request DescribeStrategyRequest
 * @return DescribeStrategyResponse
 */
DescribeStrategyResponse Client::describeStrategy(const DescribeStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeStrategyWithOptions(request, runtime);
}

/**
 * @summary Queries the information about a baseline check policy.
 *
 * @param request DescribeStrategyDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStrategyDetailResponse
 */
DescribeStrategyDetailResponse Client::describeStrategyDetailWithOptions(const DescribeStrategyDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeStrategyDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeStrategyDetailResponse>();
}

/**
 * @summary Queries the information about a baseline check policy.
 *
 * @param request DescribeStrategyDetailRequest
 * @return DescribeStrategyDetailResponse
 */
DescribeStrategyDetailResponse Client::describeStrategyDetail(const DescribeStrategyDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeStrategyDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the results of the last baseline check by using a specified baseline check policy.
 *
 * @param request DescribeStrategyExecDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStrategyExecDetailResponse
 */
DescribeStrategyExecDetailResponse Client::describeStrategyExecDetailWithOptions(const DescribeStrategyExecDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeStrategyExecDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeStrategyExecDetailResponse>();
}

/**
 * @summary Queries the results of the last baseline check by using a specified baseline check policy.
 *
 * @param request DescribeStrategyExecDetailRequest
 * @return DescribeStrategyExecDetailResponse
 */
DescribeStrategyExecDetailResponse Client::describeStrategyExecDetail(const DescribeStrategyExecDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeStrategyExecDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the assets to which a baseline check policy is applied.
 *
 * @param request DescribeStrategyTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStrategyTargetResponse
 */
DescribeStrategyTargetResponse Client::describeStrategyTargetWithOptions(const DescribeStrategyTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeStrategyTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeStrategyTargetResponse>();
}

/**
 * @summary Queries the information about the assets to which a baseline check policy is applied.
 *
 * @param request DescribeStrategyTargetRequest
 * @return DescribeStrategyTargetResponse
 */
DescribeStrategyTargetResponse Client::describeStrategyTarget(const DescribeStrategyTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeStrategyTargetWithOptions(request, runtime);
}

/**
 * @summary Strict mode supports alarm queries
 *
 * @param request DescribeStrictEventNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStrictEventNameResponse
 */
DescribeStrictEventNameResponse Client::describeStrictEventNameWithOptions(const DescribeStrictEventNameRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeStrictEventName"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeStrictEventNameResponse>();
}

/**
 * @summary Strict mode supports alarm queries
 *
 * @param request DescribeStrictEventNameRequest
 * @return DescribeStrictEventNameResponse
 */
DescribeStrictEventNameResponse Client::describeStrictEventName(const DescribeStrictEventNameRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeStrictEventNameWithOptions(request, runtime);
}

/**
 * @summary Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
 *
 * @param request DescribeSummaryInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSummaryInfoResponse
 */
DescribeSummaryInfoResponse Client::describeSummaryInfoWithOptions(const DescribeSummaryInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSummaryInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSummaryInfoResponse>();
}

/**
 * @summary Queries the security information about your assets. The information includes the security score and the numbers of protected and unprotected assets.
 *
 * @param request DescribeSummaryInfoRequest
 * @return DescribeSummaryInfoResponse
 */
DescribeSummaryInfoResponse Client::describeSummaryInfo(const DescribeSummaryInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSummaryInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the time when a system vulnerability was last detected.
 *
 * @param request DescribeSupervisonInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSupervisonInfoResponse
 */
DescribeSupervisonInfoResponse Client::describeSupervisonInfoWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeSupervisonInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSupervisonInfoResponse>();
}

/**
 * @summary Queries the time when a system vulnerability was last detected.
 *
 * @return DescribeSupervisonInfoResponse
 */
DescribeSupervisonInfoResponse Client::describeSupervisonInfo() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSupervisonInfoWithOptions(runtime);
}

/**
 * @summary Queries the regions in which the anti-ransomware feature is supported.
 *
 * @param request DescribeSupportRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSupportRegionResponse
 */
DescribeSupportRegionResponse Client::describeSupportRegionWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeSupportRegion"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSupportRegionResponse>();
}

/**
 * @summary Queries the regions in which the anti-ransomware feature is supported.
 *
 * @return DescribeSupportRegionResponse
 */
DescribeSupportRegionResponse Client::describeSupportRegion() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSupportRegionWithOptions(runtime);
}

/**
 * @summary Queries the details of an exception. An alert event consists of an alert and exceptions. Each alert event is associated with multiple exceptions.
 *
 * @param request DescribeSuspEventDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspEventDetailResponse
 */
DescribeSuspEventDetailResponse Client::describeSuspEventDetailWithOptions(const DescribeSuspEventDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasSuspiciousEventId()) {
    query["SuspiciousEventId"] = request.suspiciousEventId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSuspEventDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSuspEventDetailResponse>();
}

/**
 * @summary Queries the details of an exception. An alert event consists of an alert and exceptions. Each alert event is associated with multiple exceptions.
 *
 * @param request DescribeSuspEventDetailRequest
 * @return DescribeSuspEventDetailResponse
 */
DescribeSuspEventDetailResponse Client::describeSuspEventDetail(const DescribeSuspEventDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSuspEventDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the information about an export task of exceptions.
 *
 * @param request DescribeSuspEventExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspEventExportInfoResponse
 */
DescribeSuspEventExportInfoResponse Client::describeSuspEventExportInfoWithOptions(const DescribeSuspEventExportInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExportId()) {
    query["ExportId"] = request.exportId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSuspEventExportInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSuspEventExportInfoResponse>();
}

/**
 * @summary Queries the information about an export task of exceptions.
 *
 * @param request DescribeSuspEventExportInfoRequest
 * @return DescribeSuspEventExportInfoResponse
 */
DescribeSuspEventExportInfoResponse Client::describeSuspEventExportInfo(const DescribeSuspEventExportInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSuspEventExportInfoWithOptions(request, runtime);
}

/**
 * @summary Queries quarantined files by page.
 *
 * @param request DescribeSuspEventQuaraFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspEventQuaraFilesResponse
 */
DescribeSuspEventQuaraFilesResponse Client::describeSuspEventQuaraFilesWithOptions(const DescribeSuspEventQuaraFilesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasGroupingId()) {
    query["GroupingId"] = request.groupingId();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasQuaraTag()) {
    query["QuaraTag"] = request.quaraTag();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSuspEventQuaraFiles"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSuspEventQuaraFilesResponse>();
}

/**
 * @summary Queries quarantined files by page.
 *
 * @param request DescribeSuspEventQuaraFilesRequest
 * @return DescribeSuspEventQuaraFilesResponse
 */
DescribeSuspEventQuaraFilesResponse Client::describeSuspEventQuaraFiles(const DescribeSuspEventQuaraFilesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSuspEventQuaraFilesWithOptions(request, runtime);
}

/**
 * @summary Queries the user settings for exceptions.
 *
 * @param request DescribeSuspEventUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspEventUserSettingResponse
 */
DescribeSuspEventUserSettingResponse Client::describeSuspEventUserSettingWithOptions(const DescribeSuspEventUserSettingRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSuspEventUserSetting"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSuspEventUserSettingResponse>();
}

/**
 * @summary Queries the user settings for exceptions.
 *
 * @param request DescribeSuspEventUserSettingRequest
 * @return DescribeSuspEventUserSettingResponse
 */
DescribeSuspEventUserSettingResponse Client::describeSuspEventUserSetting(const DescribeSuspEventUserSettingRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSuspEventUserSettingWithOptions(request, runtime);
}

/**
 * @summary Queries a list of alert events that are generated without aggregation.
 *
 * @param tmpReq DescribeSuspEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspEventsResponse
 */
DescribeSuspEventsResponse Client::describeSuspEventsWithOptions(const DescribeSuspEventsRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  DescribeSuspEventsShrinkRequest request = DescribeSuspEventsShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasSourceAliUids()) {
    request.setSourceAliUidsShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.sourceAliUids(), "SourceAliUids", "simple"));
  }

  json query = {};
  if (!!request.hasAlarmUniqueInfo()) {
    query["AlarmUniqueInfo"] = request.alarmUniqueInfo();
  }

  if (!!request.hasAssetsTypeList()) {
    query["AssetsTypeList"] = request.assetsTypeList();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasEventNames()) {
    query["EventNames"] = request.eventNames();
  }

  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLevels()) {
    query["Levels"] = request.levels();
  }

  if (!!request.hasMultiAccountActionType()) {
    query["MultiAccountActionType"] = request.multiAccountActionType();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOperateErrorCodeList()) {
    query["OperateErrorCodeList"] = request.operateErrorCodeList();
  }

  if (!!request.hasOperateTimeEnd()) {
    query["OperateTimeEnd"] = request.operateTimeEnd();
  }

  if (!!request.hasOperateTimeStart()) {
    query["OperateTimeStart"] = request.operateTimeStart();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasParentEventTypes()) {
    query["ParentEventTypes"] = request.parentEventTypes();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasSortColumn()) {
    query["SortColumn"] = request.sortColumn();
  }

  if (!!request.hasSortType()) {
    query["SortType"] = request.sortType();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasSourceAliUidsShrink()) {
    query["SourceAliUids"] = request.sourceAliUidsShrink();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasStrictMode()) {
    query["StrictMode"] = request.strictMode();
  }

  if (!!request.hasSupportOperateCodeList()) {
    query["SupportOperateCodeList"] = request.supportOperateCodeList();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasTimeEnd()) {
    query["TimeEnd"] = request.timeEnd();
  }

  if (!!request.hasTimeStart()) {
    query["TimeStart"] = request.timeStart();
  }

  if (!!request.hasUniqueInfo()) {
    query["UniqueInfo"] = request.uniqueInfo();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  json body = {};
  if (!!request.hasTacticId()) {
    body["TacticId"] = request.tacticId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "DescribeSuspEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSuspEventsResponse>();
}

/**
 * @summary Queries a list of alert events that are generated without aggregation.
 *
 * @param request DescribeSuspEventsRequest
 * @return DescribeSuspEventsResponse
 */
DescribeSuspEventsResponse Client::describeSuspEvents(const DescribeSuspEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSuspEventsWithOptions(request, runtime);
}

/**
 * @summary Queries the configuration of a specified feature.
 *
 * @param request DescribeSuspiciousOverallConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspiciousOverallConfigResponse
 */
DescribeSuspiciousOverallConfigResponse Client::describeSuspiciousOverallConfigWithOptions(const DescribeSuspiciousOverallConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSuspiciousOverallConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSuspiciousOverallConfigResponse>();
}

/**
 * @summary Queries the configuration of a specified feature.
 *
 * @param request DescribeSuspiciousOverallConfigRequest
 * @return DescribeSuspiciousOverallConfigResponse
 */
DescribeSuspiciousOverallConfigResponse Client::describeSuspiciousOverallConfig(const DescribeSuspiciousOverallConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSuspiciousOverallConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the UUIDs of servers on which proactive defense of a specified type takes effect.
 *
 * @param request DescribeSuspiciousUUIDConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSuspiciousUUIDConfigResponse
 */
DescribeSuspiciousUUIDConfigResponse Client::describeSuspiciousUUIDConfigWithOptions(const DescribeSuspiciousUUIDConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSuspiciousUUIDConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSuspiciousUUIDConfigResponse>();
}

/**
 * @summary Queries the UUIDs of servers on which proactive defense of a specified type takes effect.
 *
 * @param request DescribeSuspiciousUUIDConfigRequest
 * @return DescribeSuspiciousUUIDConfigResponse
 */
DescribeSuspiciousUUIDConfigResponse Client::describeSuspiciousUUIDConfig(const DescribeSuspiciousUUIDConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSuspiciousUUIDConfigWithOptions(request, runtime);
}

/**
 * @summary Queries a list of IDC scan tasks.
 *
 * @param request DescribeSyncAssetTaskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSyncAssetTaskListResponse
 */
DescribeSyncAssetTaskListResponse Client::describeSyncAssetTaskListWithOptions(const DescribeSyncAssetTaskListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasTaskName()) {
    query["TaskName"] = request.taskName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSyncAssetTaskList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSyncAssetTaskListResponse>();
}

/**
 * @summary Queries a list of IDC scan tasks.
 *
 * @param request DescribeSyncAssetTaskListRequest
 * @return DescribeSyncAssetTaskListResponse
 */
DescribeSyncAssetTaskListResponse Client::describeSyncAssetTaskList(const DescribeSyncAssetTaskListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSyncAssetTaskListWithOptions(request, runtime);
}

/**
 * @summary Queries the details of an IDC scan task.
 *
 * @param request DescribeSyncAssetTaskLogDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSyncAssetTaskLogDetailResponse
 */
DescribeSyncAssetTaskLogDetailResponse Client::describeSyncAssetTaskLogDetailWithOptions(const DescribeSyncAssetTaskLogDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRootTaskId()) {
    query["RootTaskId"] = request.rootTaskId();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasTaskName()) {
    query["TaskName"] = request.taskName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeSyncAssetTaskLogDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeSyncAssetTaskLogDetailResponse>();
}

/**
 * @summary Queries the details of an IDC scan task.
 *
 * @param request DescribeSyncAssetTaskLogDetailRequest
 * @return DescribeSyncAssetTaskLogDetailResponse
 */
DescribeSyncAssetTaskLogDetailResponse Client::describeSyncAssetTaskLogDetail(const DescribeSyncAssetTaskLogDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeSyncAssetTaskLogDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the servers on which vulnerability scan is enabled.
 *
 * @param request DescribeTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTargetResponse
 */
DescribeTargetResponse Client::describeTargetWithOptions(const DescribeTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeTargetResponse>();
}

/**
 * @summary Queries the servers on which vulnerability scan is enabled.
 *
 * @param request DescribeTargetRequest
 * @return DescribeTargetResponse
 */
DescribeTargetResponse Client::describeTarget(const DescribeTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeTargetWithOptions(request, runtime);
}

/**
 * @summary Queries the error logs on a task that failed to fix image vulnerabilities.
 *
 * @param request DescribeTaskErrorLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTaskErrorLogResponse
 */
DescribeTaskErrorLogResponse Client::describeTaskErrorLogWithOptions(const DescribeTaskErrorLogRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBuildTaskId()) {
    query["BuildTaskId"] = request.buildTaskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeTaskErrorLog"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeTaskErrorLogResponse>();
}

/**
 * @summary Queries the error logs on a task that failed to fix image vulnerabilities.
 *
 * @param request DescribeTaskErrorLogRequest
 * @return DescribeTaskErrorLogResponse
 */
DescribeTaskErrorLogResponse Client::describeTaskErrorLog(const DescribeTaskErrorLogRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeTaskErrorLogWithOptions(request, runtime);
}

/**
 * @summary Queries event statistics.
 *
 * @param request DescribeTotalStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTotalStatisticsResponse
 */
DescribeTotalStatisticsResponse Client::describeTotalStatisticsWithOptions(const DescribeTotalStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeTotalStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeTotalStatisticsResponse>();
}

/**
 * @summary Queries event statistics.
 *
 * @param request DescribeTotalStatisticsRequest
 * @return DescribeTotalStatisticsResponse
 */
DescribeTotalStatisticsResponse Client::describeTotalStatistics(const DescribeTotalStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeTotalStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the trace information about alerts.
 *
 * @param request DescribeTraceInfoDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTraceInfoDetailResponse
 */
DescribeTraceInfoDetailResponse Client::describeTraceInfoDetailWithOptions(const DescribeTraceInfoDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasIncidentTime()) {
    query["IncidentTime"] = request.incidentTime();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  if (!!request.hasVertexId()) {
    query["VertexId"] = request.vertexId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeTraceInfoDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeTraceInfoDetailResponse>();
}

/**
 * @summary Queries the trace information about alerts.
 *
 * @param request DescribeTraceInfoDetailRequest
 * @return DescribeTraceInfoDetailResponse
 */
DescribeTraceInfoDetailResponse Client::describeTraceInfoDetail(const DescribeTraceInfoDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeTraceInfoDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the details about a trace node.
 *
 * @param request DescribeTraceInfoNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTraceInfoNodeResponse
 */
DescribeTraceInfoNodeResponse Client::describeTraceInfoNodeWithOptions(const DescribeTraceInfoNodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventName()) {
    query["EventName"] = request.eventName();
  }

  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasIncidentTime()) {
    query["IncidentTime"] = request.incidentTime();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  if (!!request.hasVertexId()) {
    query["VertexId"] = request.vertexId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeTraceInfoNode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeTraceInfoNodeResponse>();
}

/**
 * @summary Queries the details about a trace node.
 *
 * @param request DescribeTraceInfoNodeRequest
 * @return DescribeTraceInfoNodeResponse
 */
DescribeTraceInfoNodeResponse Client::describeTraceInfoNode(const DescribeTraceInfoNodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeTraceInfoNodeWithOptions(request, runtime);
}

/**
 * @summary Queries the information about databases for which anti-ransomware policies are created.
 *
 * @param request DescribeUniBackupDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniBackupDatabaseResponse
 */
DescribeUniBackupDatabaseResponse Client::describeUniBackupDatabaseWithOptions(const DescribeUniBackupDatabaseRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDatabaseType()) {
    query["DatabaseType"] = request.databaseType();
  }

  if (!!request.hasInstanceName()) {
    query["InstanceName"] = request.instanceName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasQueryType()) {
    query["QueryType"] = request.queryType();
  }

  if (!!request.hasUniRegionId()) {
    query["UniRegionId"] = request.uniRegionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeUniBackupDatabase"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeUniBackupDatabaseResponse>();
}

/**
 * @summary Queries the information about databases for which anti-ransomware policies are created.
 *
 * @param request DescribeUniBackupDatabaseRequest
 * @return DescribeUniBackupDatabaseResponse
 */
DescribeUniBackupDatabaseResponse Client::describeUniBackupDatabase(const DescribeUniBackupDatabaseRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeUniBackupDatabaseWithOptions(request, runtime);
}

/**
 * @summary Queries the anti-ransomware policies that are created for databases.
 *
 * @param request DescribeUniBackupPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniBackupPoliciesResponse
 */
DescribeUniBackupPoliciesResponse Client::describeUniBackupPoliciesWithOptions(const DescribeUniBackupPoliciesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPolicyName()) {
    query["PolicyName"] = request.policyName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeUniBackupPolicies"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeUniBackupPoliciesResponse>();
}

/**
 * @summary Queries the anti-ransomware policies that are created for databases.
 *
 * @param request DescribeUniBackupPoliciesRequest
 * @return DescribeUniBackupPoliciesResponse
 */
DescribeUniBackupPoliciesResponse Client::describeUniBackupPolicies(const DescribeUniBackupPoliciesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeUniBackupPoliciesWithOptions(request, runtime);
}

/**
 * @summary Queries the details of an anti-ransomware policy for databases.
 *
 * @param request DescribeUniBackupPolicyDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniBackupPolicyDetailResponse
 */
DescribeUniBackupPolicyDetailResponse Client::describeUniBackupPolicyDetailWithOptions(const DescribeUniBackupPolicyDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPolicyId()) {
    query["PolicyId"] = request.policyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeUniBackupPolicyDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeUniBackupPolicyDetailResponse>();
}

/**
 * @summary Queries the details of an anti-ransomware policy for databases.
 *
 * @param request DescribeUniBackupPolicyDetailRequest
 * @return DescribeUniBackupPolicyDetailResponse
 */
DescribeUniBackupPolicyDetailResponse Client::describeUniBackupPolicyDetail(const DescribeUniBackupPolicyDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeUniBackupPolicyDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics on backups based on anti-ransomware policies.
 *
 * @param request DescribeUniBackupStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniBackupStatisticsResponse
 */
DescribeUniBackupStatisticsResponse Client::describeUniBackupStatisticsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeUniBackupStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeUniBackupStatisticsResponse>();
}

/**
 * @summary Queries the statistics on backups based on anti-ransomware policies.
 *
 * @return DescribeUniBackupStatisticsResponse
 */
DescribeUniBackupStatisticsResponse Client::describeUniBackupStatistics() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeUniBackupStatisticsWithOptions(runtime);
}

/**
 * @summary Queries the backup snapshots from which the data of a database can be restored.
 *
 * @param request DescribeUniRecoverableListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniRecoverableListResponse
 */
DescribeUniRecoverableListResponse Client::describeUniRecoverableListWithOptions(const DescribeUniRecoverableListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDatabase()) {
    query["Database"] = request.database();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPolicyId()) {
    query["PolicyId"] = request.policyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeUniRecoverableList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeUniRecoverableListResponse>();
}

/**
 * @summary Queries the backup snapshots from which the data of a database can be restored.
 *
 * @param request DescribeUniRecoverableListRequest
 * @return DescribeUniRecoverableListResponse
 */
DescribeUniRecoverableListResponse Client::describeUniRecoverableList(const DescribeUniRecoverableListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeUniRecoverableListWithOptions(request, runtime);
}

/**
 * @summary Queries the region that is supported by anti-ransomware for databases.
 *
 * @param request DescribeUniSupportRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUniSupportRegionResponse
 */
DescribeUniSupportRegionResponse Client::describeUniSupportRegionWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeUniSupportRegion"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeUniSupportRegionResponse>();
}

/**
 * @summary Queries the region that is supported by anti-ransomware for databases.
 *
 * @return DescribeUniSupportRegionResponse
 */
DescribeUniSupportRegionResponse Client::describeUniSupportRegion() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeUniSupportRegionWithOptions(runtime);
}

/**
 * @summary Queries the information about the servers to which an anti-ransomware policy is applied.
 *
 * @param request DescribeUserBackupMachinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserBackupMachinesResponse
 */
DescribeUserBackupMachinesResponse Client::describeUserBackupMachinesWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeUserBackupMachines"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeUserBackupMachinesResponse>();
}

/**
 * @summary Queries the information about the servers to which an anti-ransomware policy is applied.
 *
 * @return DescribeUserBackupMachinesResponse
 */
DescribeUserBackupMachinesResponse Client::describeUserBackupMachines() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeUserBackupMachinesWithOptions(runtime);
}

/**
 * @summary The source IP address of the request.
 *
 * @param request DescribeUserBaselineAuthorizationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserBaselineAuthorizationResponse
 */
DescribeUserBaselineAuthorizationResponse Client::describeUserBaselineAuthorizationWithOptions(const DescribeUserBaselineAuthorizationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeUserBaselineAuthorization"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeUserBaselineAuthorizationResponse>();
}

/**
 * @summary The source IP address of the request.
 *
 * @param request DescribeUserBaselineAuthorizationRequest
 * @return DescribeUserBaselineAuthorizationResponse
 */
DescribeUserBaselineAuthorizationResponse Client::describeUserBaselineAuthorization(const DescribeUserBaselineAuthorizationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeUserBaselineAuthorizationWithOptions(request, runtime);
}

/**
 * @summary Queries the settings of a custom baseline check policy.
 *
 * @param request DescribeUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserSettingResponse
 */
DescribeUserSettingResponse Client::describeUserSettingWithOptions(const DescribeUserSettingRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeUserSetting"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeUserSettingResponse>();
}

/**
 * @summary Queries the settings of a custom baseline check policy.
 *
 * @param request DescribeUserSettingRequest
 * @return DescribeUserSettingResponse
 */
DescribeUserSettingResponse Client::describeUserSetting(const DescribeUserSettingRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeUserSettingWithOptions(request, runtime);
}

/**
 * @summary Queries a list of assets that support fixing based on vulnerability names.
 *
 * @param request DescribeUuidsByVulNamesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUuidsByVulNamesResponse
 */
DescribeUuidsByVulNamesResponse Client::describeUuidsByVulNamesWithOptions(const DescribeUuidsByVulNamesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasFieldName()) {
    query["FieldName"] = request.fieldName();
  }

  if (!!request.hasFieldValue()) {
    query["FieldValue"] = request.fieldValue();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLevel()) {
    query["Level"] = request.level();
  }

  if (!!request.hasNecessity()) {
    query["Necessity"] = request.necessity();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSearchTags()) {
    query["SearchTags"] = request.searchTags();
  }

  if (!!request.hasStatusList()) {
    query["StatusList"] = request.statusList();
  }

  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasVpcInstanceIds()) {
    query["VpcInstanceIds"] = request.vpcInstanceIds();
  }

  if (!!request.hasVulNames()) {
    query["VulNames"] = request.vulNames();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeUuidsByVulNames"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeUuidsByVulNamesResponse>();
}

/**
 * @summary Queries a list of assets that support fixing based on vulnerability names.
 *
 * @param request DescribeUuidsByVulNamesRequest
 * @return DescribeUuidsByVulNamesResponse
 */
DescribeUuidsByVulNamesResponse Client::describeUuidsByVulNames(const DescribeUuidsByVulNamesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeUuidsByVulNamesWithOptions(request, runtime);
}

/**
 * @summary Queries the service providers whose assets can be added to Security Center.
 *
 * @param request DescribeVendorListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVendorListResponse
 */
DescribeVendorListResponse Client::describeVendorListWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeVendorList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVendorListResponse>();
}

/**
 * @summary Queries the service providers whose assets can be added to Security Center.
 *
 * @return DescribeVendorListResponse
 */
DescribeVendorListResponse Client::describeVendorList() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVendorListWithOptions(runtime);
}

/**
 * @summary Queries the details about the edition of purchased Security Center.
 *
 * @param request DescribeVersionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVersionConfigResponse
 */
DescribeVersionConfigResponse Client::describeVersionConfigWithOptions(const DescribeVersionConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVersionConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVersionConfigResponse>();
}

/**
 * @summary Queries the details about the edition of purchased Security Center.
 *
 * @param request DescribeVersionConfigRequest
 * @return DescribeVersionConfigResponse
 */
DescribeVersionConfigResponse Client::describeVersionConfig(const DescribeVersionConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVersionConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the QR code address of a DingTalk group.
 *
 * @param request DescribeVolDingdingMessageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVolDingdingMessageResponse
 */
DescribeVolDingdingMessageResponse Client::describeVolDingdingMessageWithOptions(const DescribeVolDingdingMessageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVolDingdingMessage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVolDingdingMessageResponse>();
}

/**
 * @summary Queries the QR code address of a DingTalk group.
 *
 * @param request DescribeVolDingdingMessageRequest
 * @return DescribeVolDingdingMessageResponse
 */
DescribeVolDingdingMessageResponse Client::describeVolDingdingMessage(const DescribeVolDingdingMessageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVolDingdingMessageWithOptions(request, runtime);
}

/**
 * @summary Queries the search conditions that can be used to query honeypots.
 *
 * @param request DescribeVpcHoneyPotCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpcHoneyPotCriteriaResponse
 */
DescribeVpcHoneyPotCriteriaResponse Client::describeVpcHoneyPotCriteriaWithOptions(const DescribeVpcHoneyPotCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpcHoneyPotCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpcHoneyPotCriteriaResponse>();
}

/**
 * @summary Queries the search conditions that can be used to query honeypots.
 *
 * @param request DescribeVpcHoneyPotCriteriaRequest
 * @return DescribeVpcHoneyPotCriteriaResponse
 */
DescribeVpcHoneyPotCriteriaResponse Client::describeVpcHoneyPotCriteria(const DescribeVpcHoneyPotCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpcHoneyPotCriteriaWithOptions(request, runtime);
}

/**
 * @summary Queries virtual private clouds (VPCs) on which honeypots are deployed.
 *
 * @description If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
 *
 * @param request DescribeVpcHoneyPotListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpcHoneyPotListResponse
 */
DescribeVpcHoneyPotListResponse Client::describeVpcHoneyPotListWithOptions(const DescribeVpcHoneyPotListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasHoneyPotExistence()) {
    query["HoneyPotExistence"] = request.honeyPotExistence();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  if (!!request.hasVpcName()) {
    query["VpcName"] = request.vpcName();
  }

  if (!!request.hasVpcRegionId()) {
    query["VpcRegionId"] = request.vpcRegionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVpcHoneyPotList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpcHoneyPotListResponse>();
}

/**
 * @summary Queries virtual private clouds (VPCs) on which honeypots are deployed.
 *
 * @description If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
 *
 * @param request DescribeVpcHoneyPotListRequest
 * @return DescribeVpcHoneyPotListResponse
 */
DescribeVpcHoneyPotListResponse Client::describeVpcHoneyPotList(const DescribeVpcHoneyPotListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpcHoneyPotListWithOptions(request, runtime);
}

/**
 * @summary Queries the information about virtual private clouds (VPCs).
 *
 * @param request DescribeVpcListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVpcListResponse
 */
DescribeVpcListResponse Client::describeVpcListWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeVpcList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVpcListResponse>();
}

/**
 * @summary Queries the information about virtual private clouds (VPCs).
 *
 * @return DescribeVpcListResponse
 */
DescribeVpcListResponse Client::describeVpcList() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVpcListWithOptions(runtime);
}

/**
 * @summary Queries the status information about vulnerability scan tasks on a server.
 *
 * @param request DescribeVulCheckTaskStatusDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulCheckTaskStatusDetailResponse
 */
DescribeVulCheckTaskStatusDetailResponse Client::describeVulCheckTaskStatusDetailWithOptions(const DescribeVulCheckTaskStatusDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTaskIds()) {
    query["TaskIds"] = request.taskIds();
  }

  if (!!request.hasTypes()) {
    query["Types"] = request.types();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulCheckTaskStatusDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulCheckTaskStatusDetailResponse>();
}

/**
 * @summary Queries the status information about vulnerability scan tasks on a server.
 *
 * @param request DescribeVulCheckTaskStatusDetailRequest
 * @return DescribeVulCheckTaskStatusDetailResponse
 */
DescribeVulCheckTaskStatusDetailResponse Client::describeVulCheckTaskStatusDetail(const DescribeVulCheckTaskStatusDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulCheckTaskStatusDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of vulnerability management.
 *
 * @param request DescribeVulConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulConfigResponse
 */
DescribeVulConfigResponse Client::describeVulConfigWithOptions(const DescribeVulConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulConfigResponse>();
}

/**
 * @summary Queries the configurations of vulnerability management.
 *
 * @param request DescribeVulConfigRequest
 * @return DescribeVulConfigResponse
 */
DescribeVulConfigResponse Client::describeVulConfig(const DescribeVulConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the vulnerability defense statistics in Security Center.
 *
 * @param request DescribeVulDefendCountStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulDefendCountStatisticsResponse
 */
DescribeVulDefendCountStatisticsResponse Client::describeVulDefendCountStatisticsWithOptions(const DescribeVulDefendCountStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasVulType()) {
    query["VulType"] = request.vulType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulDefendCountStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulDefendCountStatisticsResponse>();
}

/**
 * @summary Queries the vulnerability defense statistics in Security Center.
 *
 * @param request DescribeVulDefendCountStatisticsRequest
 * @return DescribeVulDefendCountStatisticsResponse
 */
DescribeVulDefendCountStatisticsResponse Client::describeVulDefendCountStatistics(const DescribeVulDefendCountStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulDefendCountStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the details about a vulnerability.
 *
 * @param request DescribeVulDetailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulDetailsResponse
 */
DescribeVulDetailsResponse Client::describeVulDetailsWithOptions(const DescribeVulDetailsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliasName()) {
    query["AliasName"] = request.aliasName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulDetails"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulDetailsResponse>();
}

/**
 * @summary Queries the details about a vulnerability.
 *
 * @param request DescribeVulDetailsRequest
 * @return DescribeVulDetailsResponse
 */
DescribeVulDetailsResponse Client::describeVulDetails(const DescribeVulDetailsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulDetailsWithOptions(request, runtime);
}

/**
 * @summary Queries the progress of a task that exports vulnerabilities.
 *
 * @description If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
 *
 * @param request DescribeVulExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulExportInfoResponse
 */
DescribeVulExportInfoResponse Client::describeVulExportInfoWithOptions(const DescribeVulExportInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExportId()) {
    query["ExportId"] = request.exportId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulExportInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulExportInfoResponse>();
}

/**
 * @summary Queries the progress of a task that exports vulnerabilities.
 *
 * @description If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
 *
 * @param request DescribeVulExportInfoRequest
 * @return DescribeVulExportInfoResponse
 */
DescribeVulExportInfoResponse Client::describeVulExportInfo(const DescribeVulExportInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulExportInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of vulnerability fixes.
 *
 * @param request DescribeVulFixStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulFixStatisticsResponse
 */
DescribeVulFixStatisticsResponse Client::describeVulFixStatisticsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeVulFixStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulFixStatisticsResponse>();
}

/**
 * @summary Queries the statistics of vulnerability fixes.
 *
 * @return DescribeVulFixStatisticsResponse
 */
DescribeVulFixStatisticsResponse Client::describeVulFixStatistics() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulFixStatisticsWithOptions(runtime);
}

/**
 * @summary Queries vulnerabilities by type.
 *
 * @param request DescribeVulListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulListResponse
 */
DescribeVulListResponse Client::describeVulListWithOptions(const DescribeVulListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliasName()) {
    query["AliasName"] = request.aliasName();
  }

  if (!!request.hasAttachTypes()) {
    query["AttachTypes"] = request.attachTypes();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasIds()) {
    query["Ids"] = request.ids();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNecessity()) {
    query["Necessity"] = request.necessity();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRaspDefend()) {
    query["RaspDefend"] = request.raspDefend();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasStatusList()) {
    query["StatusList"] = request.statusList();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUseNextToken()) {
    query["UseNextToken"] = request.useNextToken();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  if (!!request.hasVpcInstanceIds()) {
    query["VpcInstanceIds"] = request.vpcInstanceIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulListResponse>();
}

/**
 * @summary Queries vulnerabilities by type.
 *
 * @param request DescribeVulListRequest
 * @return DescribeVulListResponse
 */
DescribeVulListResponse Client::describeVulList(const DescribeVulListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulListWithOptions(request, runtime);
}

/**
 * @summary Queries the vulnerabilities that can be detected.
 *
 * @param request DescribeVulListPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulListPageResponse
 */
DescribeVulListPageResponse Client::describeVulListPageWithOptions(const DescribeVulListPageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasCveId()) {
    query["CveId"] = request.cveId();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRaspDefend()) {
    query["RaspDefend"] = request.raspDefend();
  }

  if (!!request.hasVulNameLike()) {
    query["VulNameLike"] = request.vulNameLike();
  }

  if (!!request.hasVulType()) {
    query["VulType"] = request.vulType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulListPage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulListPageResponse>();
}

/**
 * @summary Queries the vulnerabilities that can be detected.
 *
 * @param request DescribeVulListPageRequest
 * @return DescribeVulListPageResponse
 */
DescribeVulListPageResponse Client::describeVulListPage(const DescribeVulListPageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulListPageWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of vulnerabilities in Security Center.
 *
 * @param request DescribeVulMetaCountStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulMetaCountStatisticsResponse
 */
DescribeVulMetaCountStatisticsResponse Client::describeVulMetaCountStatisticsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeVulMetaCountStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulMetaCountStatisticsResponse>();
}

/**
 * @summary Queries the statistics of vulnerabilities in Security Center.
 *
 * @return DescribeVulMetaCountStatisticsResponse
 */
DescribeVulMetaCountStatisticsResponse Client::describeVulMetaCountStatistics() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulMetaCountStatisticsWithOptions(runtime);
}

/**
 * @summary Queries the statistics of vulnerabilities.
 *
 * @param request DescribeVulNumStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulNumStatisticsResponse
 */
DescribeVulNumStatisticsResponse Client::describeVulNumStatisticsWithOptions(const DescribeVulNumStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulNumStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulNumStatisticsResponse>();
}

/**
 * @summary Queries the statistics of vulnerabilities.
 *
 * @param request DescribeVulNumStatisticsRequest
 * @return DescribeVulNumStatisticsResponse
 */
DescribeVulNumStatisticsResponse Client::describeVulNumStatistics(const DescribeVulNumStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulNumStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of the vulnerability scan feature for a server.
 *
 * @param request DescribeVulTargetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulTargetConfigResponse
 */
DescribeVulTargetConfigResponse Client::describeVulTargetConfigWithOptions(const DescribeVulTargetConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulTargetConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulTargetConfigResponse>();
}

/**
 * @summary Queries the configurations of the vulnerability scan feature for a server.
 *
 * @param request DescribeVulTargetConfigRequest
 * @return DescribeVulTargetConfigResponse
 */
DescribeVulTargetConfigResponse Client::describeVulTargetConfig(const DescribeVulTargetConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulTargetConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of the vulnerability scan feature.
 *
 * @param request DescribeVulTargetStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulTargetStatisticsResponse
 */
DescribeVulTargetStatisticsResponse Client::describeVulTargetStatisticsWithOptions(const DescribeVulTargetStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulTargetStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulTargetStatisticsResponse>();
}

/**
 * @summary Queries the configurations of the vulnerability scan feature.
 *
 * @param request DescribeVulTargetStatisticsRequest
 * @return DescribeVulTargetStatisticsResponse
 */
DescribeVulTargetStatisticsResponse Client::describeVulTargetStatistics(const DescribeVulTargetStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulTargetStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the whitelist of vulnerabilities by page.
 *
 * @param request DescribeVulWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVulWhitelistResponse
 */
DescribeVulWhitelistResponse Client::describeVulWhitelistWithOptions(const DescribeVulWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeVulWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeVulWhitelistResponse>();
}

/**
 * @summary Queries the whitelist of vulnerabilities by page.
 *
 * @param request DescribeVulWhitelistRequest
 * @return DescribeVulWhitelistResponse
 */
DescribeVulWhitelistResponse Client::describeVulWhitelist(const DescribeVulWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeVulWhitelistWithOptions(request, runtime);
}

/**
 * @summary Queries the progress of a export task for a baseline check result.
 *
 * @param request DescribeWarningExportInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWarningExportInfoResponse
 */
DescribeWarningExportInfoResponse Client::describeWarningExportInfoWithOptions(const DescribeWarningExportInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExportId()) {
    query["ExportId"] = request.exportId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWarningExportInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWarningExportInfoResponse>();
}

/**
 * @summary Queries the progress of a export task for a baseline check result.
 *
 * @param request DescribeWarningExportInfoRequest
 * @return DescribeWarningExportInfoResponse
 */
DescribeWarningExportInfoResponse Client::describeWarningExportInfo(const DescribeWarningExportInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWarningExportInfoWithOptions(request, runtime);
}

/**
 * @summary Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
 *
 * @param request DescribeWarningMachinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWarningMachinesResponse
 */
DescribeWarningMachinesResponse Client::describeWarningMachinesWithOptions(const DescribeWarningMachinesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasHaveRisk()) {
    query["HaveRisk"] = request.haveRisk();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMachineName()) {
    query["MachineName"] = request.machineName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskId()) {
    query["RiskId"] = request.riskId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWarningMachines"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWarningMachinesResponse>();
}

/**
 * @summary Queries information about servers on which a baseline check is performed. The information includes the IDs of the servers, the statistics of a risk item, and the status of the risk item.
 *
 * @param request DescribeWarningMachinesRequest
 * @return DescribeWarningMachinesResponse
 */
DescribeWarningMachinesResponse Client::describeWarningMachines(const DescribeWarningMachinesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWarningMachinesWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the servers that have web tamper proofing enabled.
 *
 * @param request DescribeWebLockBindListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockBindListResponse
 */
DescribeWebLockBindListResponse Client::describeWebLockBindListWithOptions(const DescribeWebLockBindListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWebLockBindList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockBindListResponse>();
}

/**
 * @summary Queries the information about the servers that have web tamper proofing enabled.
 *
 * @param request DescribeWebLockBindListRequest
 * @return DescribeWebLockBindListResponse
 */
DescribeWebLockBindListResponse Client::describeWebLockBindList(const DescribeWebLockBindListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockBindListWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of web tamper proofing for a specified server.
 *
 * @param request DescribeWebLockConfigListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockConfigListResponse
 */
DescribeWebLockConfigListResponse Client::describeWebLockConfigListWithOptions(const DescribeWebLockConfigListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWebLockConfigList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockConfigListResponse>();
}

/**
 * @summary Queries the configurations of web tamper proofing for a specified server.
 *
 * @param request DescribeWebLockConfigListRequest
 * @return DescribeWebLockConfigListResponse
 */
DescribeWebLockConfigListResponse Client::describeWebLockConfigList(const DescribeWebLockConfigListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockConfigListWithOptions(request, runtime);
}

/**
 * @summary Queries the types of files that are excluded from web tamper proofing.
 *
 * @param request DescribeWebLockExclusiveFileTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockExclusiveFileTypeResponse
 */
DescribeWebLockExclusiveFileTypeResponse Client::describeWebLockExclusiveFileTypeWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeWebLockExclusiveFileType"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockExclusiveFileTypeResponse>();
}

/**
 * @summary Queries the types of files that are excluded from web tamper proofing.
 *
 * @return DescribeWebLockExclusiveFileTypeResponse
 */
DescribeWebLockExclusiveFileTypeResponse Client::describeWebLockExclusiveFileType() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockExclusiveFileTypeWithOptions(runtime);
}

/**
 * @summary Queries the statistics on changes to the files that are protected by web tamper proofing.
 *
 * @param request DescribeWebLockFileChangeStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockFileChangeStatisticsResponse
 */
DescribeWebLockFileChangeStatisticsResponse Client::describeWebLockFileChangeStatisticsWithOptions(const DescribeWebLockFileChangeStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWebLockFileChangeStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockFileChangeStatisticsResponse>();
}

/**
 * @summary Queries the statistics on changes to the files that are protected by web tamper proofing.
 *
 * @param request DescribeWebLockFileChangeStatisticsRequest
 * @return DescribeWebLockFileChangeStatisticsResponse
 */
DescribeWebLockFileChangeStatisticsResponse Client::describeWebLockFileChangeStatistics(const DescribeWebLockFileChangeStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockFileChangeStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries events on web tamper proofing.
 *
 * @param request DescribeWebLockFileEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockFileEventsResponse
 */
DescribeWebLockFileEventsResponse Client::describeWebLockFileEventsWithOptions(const DescribeWebLockFileEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasProcessName()) {
    query["ProcessName"] = request.processName();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasTsBegin()) {
    query["TsBegin"] = request.tsBegin();
  }

  if (!!request.hasTsEnd()) {
    query["TsEnd"] = request.tsEnd();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWebLockFileEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockFileEventsResponse>();
}

/**
 * @summary Queries events on web tamper proofing.
 *
 * @param request DescribeWebLockFileEventsRequest
 * @return DescribeWebLockFileEventsResponse
 */
DescribeWebLockFileEventsResponse Client::describeWebLockFileEvents(const DescribeWebLockFileEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockFileEventsWithOptions(request, runtime);
}

/**
 * @summary The number of attempts.
 *
 * @param request DescribeWebLockFileTypeSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockFileTypeSummaryResponse
 */
DescribeWebLockFileTypeSummaryResponse Client::describeWebLockFileTypeSummaryWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeWebLockFileTypeSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockFileTypeSummaryResponse>();
}

/**
 * @summary The number of attempts.
 *
 * @return DescribeWebLockFileTypeSummaryResponse
 */
DescribeWebLockFileTypeSummaryResponse Client::describeWebLockFileTypeSummary() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockFileTypeSummaryWithOptions(runtime);
}

/**
 * @summary Queries the types of files that can be protected by web tamper proofing.
 *
 * @param request DescribeWebLockInclusiveFileTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockInclusiveFileTypeResponse
 */
DescribeWebLockInclusiveFileTypeResponse Client::describeWebLockInclusiveFileTypeWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeWebLockInclusiveFileType"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockInclusiveFileTypeResponse>();
}

/**
 * @summary Queries the types of files that can be protected by web tamper proofing.
 *
 * @return DescribeWebLockInclusiveFileTypeResponse
 */
DescribeWebLockInclusiveFileTypeResponse Client::describeWebLockInclusiveFileType() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockInclusiveFileTypeWithOptions(runtime);
}

/**
 * @summary Queries the statistics on processes for web tamper proofing.
 *
 * @param request DescribeWebLockProcessBlockStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockProcessBlockStatisticsResponse
 */
DescribeWebLockProcessBlockStatisticsResponse Client::describeWebLockProcessBlockStatisticsWithOptions(const DescribeWebLockProcessBlockStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWebLockProcessBlockStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockProcessBlockStatisticsResponse>();
}

/**
 * @summary Queries the statistics on processes for web tamper proofing.
 *
 * @param request DescribeWebLockProcessBlockStatisticsRequest
 * @return DescribeWebLockProcessBlockStatisticsResponse
 */
DescribeWebLockProcessBlockStatisticsResponse Client::describeWebLockProcessBlockStatistics(const DescribeWebLockProcessBlockStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockProcessBlockStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the processes for web tamper proofing.
 *
 * @param request DescribeWebLockProcessListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockProcessListResponse
 */
DescribeWebLockProcessListResponse Client::describeWebLockProcessListWithOptions(const DescribeWebLockProcessListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasProcessName()) {
    query["ProcessName"] = request.processName();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWebLockProcessList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockProcessListResponse>();
}

/**
 * @summary Queries the processes for web tamper proofing.
 *
 * @param request DescribeWebLockProcessListRequest
 * @return DescribeWebLockProcessListResponse
 */
DescribeWebLockProcessListResponse Client::describeWebLockProcessList(const DescribeWebLockProcessListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockProcessListWithOptions(request, runtime);
}

/**
 * @summary Queries the status of web tamper proofing.
 *
 * @param request DescribeWebLockStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockStatusResponse
 */
DescribeWebLockStatusResponse Client::describeWebLockStatusWithOptions(const DescribeWebLockStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWebLockStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockStatusResponse>();
}

/**
 * @summary Queries the status of web tamper proofing.
 *
 * @param request DescribeWebLockStatusRequest
 * @return DescribeWebLockStatusResponse
 */
DescribeWebLockStatusResponse Client::describeWebLockStatus(const DescribeWebLockStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the number of times that the files protected by web tamper proofing are changed.
 *
 * @param request DescribeWebLockTotalFileChangeCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebLockTotalFileChangeCountResponse
 */
DescribeWebLockTotalFileChangeCountResponse Client::describeWebLockTotalFileChangeCountWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "DescribeWebLockTotalFileChangeCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebLockTotalFileChangeCountResponse>();
}

/**
 * @summary Queries the number of times that the files protected by web tamper proofing are changed.
 *
 * @return DescribeWebLockTotalFileChangeCountResponse
 */
DescribeWebLockTotalFileChangeCountResponse Client::describeWebLockTotalFileChangeCount() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebLockTotalFileChangeCountWithOptions(runtime);
}

/**
 * @summary Queries the custom web directories that are scanned based on the alerting feature.
 *
 * @param request DescribeWebPathRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebPathResponse
 */
DescribeWebPathResponse Client::describeWebPathWithOptions(const DescribeWebPathRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWebPath"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWebPathResponse>();
}

/**
 * @summary Queries the custom web directories that are scanned based on the alerting feature.
 *
 * @param request DescribeWebPathRequest
 * @return DescribeWebPathResponse
 */
DescribeWebPathResponse Client::describeWebPath(const DescribeWebPathRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWebPathWithOptions(request, runtime);
}

/**
 * @summary Queries the information about servers that can be added or are added to application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListAssetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListAssetResponse
 */
DescribeWhiteListAssetResponse Client::describeWhiteListAssetWithOptions(const DescribeWhiteListAssetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLastMaxId()) {
    query["LastMaxId"] = request.lastMaxId();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWhiteListAsset"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWhiteListAssetResponse>();
}

/**
 * @summary Queries the information about servers that can be added or are added to application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListAssetRequest
 * @return DescribeWhiteListAssetResponse
 */
DescribeWhiteListAssetResponse Client::describeWhiteListAsset(const DescribeWhiteListAssetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWhiteListAssetWithOptions(request, runtime);
}

/**
 * @summary Queries the available quota for the application whitelist feature.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListAuthorizeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListAuthorizeResponse
 */
DescribeWhiteListAuthorizeResponse Client::describeWhiteListAuthorizeWithOptions(const DescribeWhiteListAuthorizeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWhiteListAuthorize"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWhiteListAuthorizeResponse>();
}

/**
 * @summary Queries the available quota for the application whitelist feature.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListAuthorizeRequest
 * @return DescribeWhiteListAuthorizeResponse
 */
DescribeWhiteListAuthorizeResponse Client::describeWhiteListAuthorize(const DescribeWhiteListAuthorizeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWhiteListAuthorizeWithOptions(request, runtime);
}

/**
 * @summary Queries the servers on which an application whitelist policy takes effect.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
 *
 * @param request DescribeWhiteListEffectiveAssetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListEffectiveAssetsResponse
 */
DescribeWhiteListEffectiveAssetsResponse Client::describeWhiteListEffectiveAssetsWithOptions(const DescribeWhiteListEffectiveAssetsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNeedStatistics()) {
    query["NeedStatistics"] = request.needStatistics();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWhiteListEffectiveAssets"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWhiteListEffectiveAssetsResponse>();
}

/**
 * @summary Queries the servers on which an application whitelist policy takes effect.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
 *
 * @param request DescribeWhiteListEffectiveAssetsRequest
 * @return DescribeWhiteListEffectiveAssetsResponse
 */
DescribeWhiteListEffectiveAssetsResponse Client::describeWhiteListEffectiveAssets(const DescribeWhiteListEffectiveAssetsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWhiteListEffectiveAssetsWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the processes that are detected in an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListProcessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListProcessResponse
 */
DescribeWhiteListProcessResponse Client::describeWhiteListProcessWithOptions(const DescribeWhiteListProcessRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDesc()) {
    query["Desc"] = request.desc();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasOrderBy()) {
    query["OrderBy"] = request.orderBy();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasProcessName()) {
    query["ProcessName"] = request.processName();
  }

  if (!!request.hasProcessType()) {
    query["ProcessType"] = request.processType();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWhiteListProcess"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWhiteListProcessResponse>();
}

/**
 * @summary Queries the information about the processes that are detected in an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListProcessRequest
 * @return DescribeWhiteListProcessResponse
 */
DescribeWhiteListProcessResponse Client::describeWhiteListProcess(const DescribeWhiteListProcessRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWhiteListProcessWithOptions(request, runtime);
}

/**
 * @summary Queries a list of application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListStrategyListResponse
 */
DescribeWhiteListStrategyListResponse Client::describeWhiteListStrategyListWithOptions(const DescribeWhiteListStrategyListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyIds()) {
    query["StrategyIds"] = request.strategyIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWhiteListStrategyList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWhiteListStrategyListResponse>();
}

/**
 * @summary Queries a list of application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyListRequest
 * @return DescribeWhiteListStrategyListResponse
 */
DescribeWhiteListStrategyListResponse Client::describeWhiteListStrategyList(const DescribeWhiteListStrategyListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWhiteListStrategyListWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListStrategyStatisticsResponse
 */
DescribeWhiteListStrategyStatisticsResponse Client::describeWhiteListStrategyStatisticsWithOptions(const DescribeWhiteListStrategyStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyIds()) {
    query["StrategyIds"] = request.strategyIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWhiteListStrategyStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWhiteListStrategyStatisticsResponse>();
}

/**
 * @summary Queries the statistics of application whitelist policies.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyStatisticsRequest
 * @return DescribeWhiteListStrategyStatisticsResponse
 */
DescribeWhiteListStrategyStatisticsResponse Client::describeWhiteListStrategyStatistics(const DescribeWhiteListStrategyStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWhiteListStrategyStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the number of the servers on which an application whitelist policy takes effect.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyUuidCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWhiteListStrategyUuidCountResponse
 */
DescribeWhiteListStrategyUuidCountResponse Client::describeWhiteListStrategyUuidCountWithOptions(const DescribeWhiteListStrategyUuidCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DescribeWhiteListStrategyUuidCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DescribeWhiteListStrategyUuidCountResponse>();
}

/**
 * @summary Queries the number of the servers on which an application whitelist policy takes effect.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in-use, you can call this operation.
 *
 * @param request DescribeWhiteListStrategyUuidCountRequest
 * @return DescribeWhiteListStrategyUuidCountResponse
 */
DescribeWhiteListStrategyUuidCountResponse Client::describeWhiteListStrategyUuidCount(const DescribeWhiteListStrategyUuidCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return describeWhiteListStrategyUuidCountWithOptions(request, runtime);
}

/**
 * @summary Tests whether DingTalk notification configurations are valid.
 *
 * @param request DingTalkOnlineTestRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DingTalkOnlineTestResponse
 */
DingTalkOnlineTestResponse Client::dingTalkOnlineTestWithOptions(const DingTalkOnlineTestRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DingTalkOnlineTest"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DingTalkOnlineTestResponse>();
}

/**
 * @summary Tests whether DingTalk notification configurations are valid.
 *
 * @param request DingTalkOnlineTestRequest
 * @return DingTalkOnlineTestResponse
 */
DingTalkOnlineTestResponse Client::dingTalkOnlineTest(const DingTalkOnlineTestRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return dingTalkOnlineTestWithOptions(request, runtime);
}

/**
 * @summary Disables an IP address blocking policy that is in effect.
 *
 * @param request DisableBruteForceRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableBruteForceRecordResponse
 */
DisableBruteForceRecordResponse Client::disableBruteForceRecordWithOptions(const DisableBruteForceRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBlockIp()) {
    query["BlockIp"] = request.blockIp();
  }

  if (!!request.hasBound()) {
    query["Bound"] = request.bound();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasPort()) {
    query["Port"] = request.port();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DisableBruteForceRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DisableBruteForceRecordResponse>();
}

/**
 * @summary Disables an IP address blocking policy that is in effect.
 *
 * @param request DisableBruteForceRecordRequest
 * @return DisableBruteForceRecordResponse
 */
DisableBruteForceRecordResponse Client::disableBruteForceRecord(const DisableBruteForceRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return disableBruteForceRecordWithOptions(request, runtime);
}

/**
 * @summary Disables a custom IP address blocking policy for servers.
 *
 * @param request DisableCustomBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableCustomBlockRecordResponse
 */
DisableCustomBlockRecordResponse Client::disableCustomBlockRecordWithOptions(const DisableCustomBlockRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBlockIp()) {
    query["BlockIp"] = request.blockIp();
  }

  if (!!request.hasBound()) {
    query["Bound"] = request.bound();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "DisableCustomBlockRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<DisableCustomBlockRecordResponse>();
}

/**
 * @summary Disables a custom IP address blocking policy for servers.
 *
 * @param request DisableCustomBlockRecordRequest
 * @return DisableCustomBlockRecordResponse
 */
DisableCustomBlockRecordResponse Client::disableCustomBlockRecord(const DisableCustomBlockRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return disableCustomBlockRecordWithOptions(request, runtime);
}

/**
 * @summary Enables an IP address blocking policy for a specified server.
 *
 * @param request EnableBruteForceRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableBruteForceRecordResponse
 */
EnableBruteForceRecordResponse Client::enableBruteForceRecordWithOptions(const EnableBruteForceRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBlockIp()) {
    query["BlockIp"] = request.blockIp();
  }

  if (!!request.hasBound()) {
    query["Bound"] = request.bound();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasPort()) {
    query["Port"] = request.port();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "EnableBruteForceRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<EnableBruteForceRecordResponse>();
}

/**
 * @summary Enables an IP address blocking policy for a specified server.
 *
 * @param request EnableBruteForceRecordRequest
 * @return EnableBruteForceRecordResponse
 */
EnableBruteForceRecordResponse Client::enableBruteForceRecord(const EnableBruteForceRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return enableBruteForceRecordWithOptions(request, runtime);
}

/**
 * @summary Enables a custom IP address blocking policy.
 *
 * @param request EnableCustomBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableCustomBlockRecordResponse
 */
EnableCustomBlockRecordResponse Client::enableCustomBlockRecordWithOptions(const EnableCustomBlockRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBlockIp()) {
    query["BlockIp"] = request.blockIp();
  }

  if (!!request.hasBound()) {
    query["Bound"] = request.bound();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "EnableCustomBlockRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<EnableCustomBlockRecordResponse>();
}

/**
 * @summary Enables a custom IP address blocking policy.
 *
 * @param request EnableCustomBlockRecordRequest
 * @return EnableCustomBlockRecordResponse
 */
EnableCustomBlockRecordResponse Client::enableCustomBlockRecord(const EnableCustomBlockRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return enableCustomBlockRecordWithOptions(request, runtime);
}

/**
 * @summary Enables a custom rule for an instance.
 *
 * @param request EnableCustomInstanceBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableCustomInstanceBlockRecordResponse
 */
EnableCustomInstanceBlockRecordResponse Client::enableCustomInstanceBlockRecordWithOptions(const EnableCustomInstanceBlockRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBlockIp()) {
    query["BlockIp"] = request.blockIp();
  }

  if (!!request.hasBound()) {
    query["Bound"] = request.bound();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "EnableCustomInstanceBlockRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<EnableCustomInstanceBlockRecordResponse>();
}

/**
 * @summary Enables a custom rule for an instance.
 *
 * @param request EnableCustomInstanceBlockRecordRequest
 * @return EnableCustomInstanceBlockRecordResponse
 */
EnableCustomInstanceBlockRecordResponse Client::enableCustomInstanceBlockRecord(const EnableCustomInstanceBlockRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return enableCustomInstanceBlockRecordWithOptions(request, runtime);
}

/**
 * @summary Enable the multi-account management feature of Security Center.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @param request EnableServiceAccessResourceDirectoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableServiceAccessResourceDirectoryResponse
 */
EnableServiceAccessResourceDirectoryResponse Client::enableServiceAccessResourceDirectoryWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "EnableServiceAccessResourceDirectory"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<EnableServiceAccessResourceDirectoryResponse>();
}

/**
 * @summary Enable the multi-account management feature of Security Center.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @return EnableServiceAccessResourceDirectoryResponse
 */
EnableServiceAccessResourceDirectoryResponse Client::enableServiceAccessResourceDirectory() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return enableServiceAccessResourceDirectoryWithOptions(runtime);
}

/**
 * @summary Performs a baseline check on servers to which a specified baseline check policy is applied.
 *
 * @param request ExecStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecStrategyResponse
 */
ExecStrategyResponse Client::execStrategyWithOptions(const ExecStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExecAction()) {
    query["ExecAction"] = request.execAction();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ExecStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ExecStrategyResponse>();
}

/**
 * @summary Performs a baseline check on servers to which a specified baseline check policy is applied.
 *
 * @param request ExecStrategyRequest
 * @return ExecStrategyResponse
 */
ExecStrategyResponse Client::execStrategy(const ExecStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return execStrategyWithOptions(request, runtime);
}

/**
 * @summary Exports a security report.
 *
 * @param request ExportCustomizeReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportCustomizeReportResponse
 */
ExportCustomizeReportResponse Client::exportCustomizeReportWithOptions(const ExportCustomizeReportRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExportType()) {
    query["ExportType"] = request.exportType();
  }

  if (!!request.hasReportId()) {
    query["ReportId"] = request.reportId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ExportCustomizeReport"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ExportCustomizeReportResponse>();
}

/**
 * @summary Exports a security report.
 *
 * @param request ExportCustomizeReportRequest
 * @return ExportCustomizeReportResponse
 */
ExportCustomizeReportResponse Client::exportCustomizeReport(const ExportCustomizeReportRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return exportCustomizeReportWithOptions(request, runtime);
}

/**
 * @summary Exports the check results on the Host, Cloud Platform Configuration Assessment, Image Security, Attack Awareness, and AK leak detection pages to Excel files.
 *
 * @description You can call the operation to export the following check result lists:
 * *   The list of servers on the Host page.
 * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
 * *   The list of attack analysis data on the Attack Awareness page.
 * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
 *
 * @param request ExportRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportRecordResponse
 */
ExportRecordResponse Client::exportRecordWithOptions(const ExportRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasExportFileType()) {
    query["ExportFileType"] = request.exportFileType();
  }

  if (!!request.hasExportType()) {
    query["ExportType"] = request.exportType();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasParams()) {
    query["Params"] = request.params();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ExportRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ExportRecordResponse>();
}

/**
 * @summary Exports the check results on the Host, Cloud Platform Configuration Assessment, Image Security, Attack Awareness, and AK leak detection pages to Excel files.
 *
 * @description You can call the operation to export the following check result lists:
 * *   The list of servers on the Host page.
 * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
 * *   The list of attack analysis data on the Attack Awareness page.
 * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
 *
 * @param request ExportRecordRequest
 * @return ExportRecordResponse
 */
ExportRecordResponse Client::exportRecord(const ExportRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return exportRecordWithOptions(request, runtime);
}

/**
 * @summary Exports the information about exceptions to a file.
 *
 * @param request ExportSuspEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportSuspEventsResponse
 */
ExportSuspEventsResponse Client::exportSuspEventsWithOptions(const ExportSuspEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssetsTypeList()) {
    query["AssetsTypeList"] = request.assetsTypeList();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLevels()) {
    query["Levels"] = request.levels();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasOperateErrorCodeList()) {
    query["OperateErrorCodeList"] = request.operateErrorCodeList();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasParentEventTypes()) {
    query["ParentEventTypes"] = request.parentEventTypes();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasTimeEnd()) {
    query["TimeEnd"] = request.timeEnd();
  }

  if (!!request.hasTimeStart()) {
    query["TimeStart"] = request.timeStart();
  }

  if (!!request.hasUniqueInfo()) {
    query["UniqueInfo"] = request.uniqueInfo();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ExportSuspEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ExportSuspEventsResponse>();
}

/**
 * @summary Exports the information about exceptions to a file.
 *
 * @param request ExportSuspEventsRequest
 * @return ExportSuspEventsResponse
 */
ExportSuspEventsResponse Client::exportSuspEvents(const ExportSuspEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return exportSuspEventsWithOptions(request, runtime);
}

/**
 * @summary Exports vulnerabilities.
 *
 * @description You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
 * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ExportVulRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportVulResponse
 */
ExportVulResponse Client::exportVulWithOptions(const ExportVulRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliasName()) {
    query["AliasName"] = request.aliasName();
  }

  if (!!request.hasAttachTypes()) {
    query["AttachTypes"] = request.attachTypes();
  }

  if (!!request.hasContainerName()) {
    query["ContainerName"] = request.containerName();
  }

  if (!!request.hasCreateTsEnd()) {
    query["CreateTsEnd"] = request.createTsEnd();
  }

  if (!!request.hasCreateTsStart()) {
    query["CreateTsStart"] = request.createTsStart();
  }

  if (!!request.hasCveId()) {
    query["CveId"] = request.cveId();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasImageName()) {
    query["ImageName"] = request.imageName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNecessity()) {
    query["Necessity"] = request.necessity();
  }

  if (!!request.hasPath()) {
    query["Path"] = request.path();
  }

  if (!!request.hasRaspDefend()) {
    query["RaspDefend"] = request.raspDefend();
  }

  if (!!request.hasSearchTags()) {
    query["SearchTags"] = request.searchTags();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  if (!!request.hasVpcInstanceIds()) {
    query["VpcInstanceIds"] = request.vpcInstanceIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ExportVul"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ExportVulResponse>();
}

/**
 * @summary Exports vulnerabilities.
 *
 * @description You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
 * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ExportVulRequest
 * @return ExportVulResponse
 */
ExportVulResponse Client::exportVul(const ExportVulRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return exportVulWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI ExportWarning is deprecated, please use Sas::2018-12-03::ExportRecord instead.
 *
 * @summary Exports baseline check results.
 *
 * @param request ExportWarningRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportWarningResponse
 */
ExportWarningResponse Client::exportWarningWithOptions(const ExportWarningRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasExportType()) {
    query["ExportType"] = request.exportType();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasIsCleartextPwd()) {
    query["IsCleartextPwd"] = request.isCleartextPwd();
  }

  if (!!request.hasIsSummaryExport()) {
    query["IsSummaryExport"] = request.isSummaryExport();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRiskIds()) {
    query["RiskIds"] = request.riskIds();
  }

  if (!!request.hasRiskLevels()) {
    query["RiskLevels"] = request.riskLevels();
  }

  if (!!request.hasRiskName()) {
    query["RiskName"] = request.riskName();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatusList()) {
    query["StatusList"] = request.statusList();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasSubTypeNames()) {
    query["SubTypeNames"] = request.subTypeNames();
  }

  if (!!request.hasTypeName()) {
    query["TypeName"] = request.typeName();
  }

  if (!!request.hasTypeNames()) {
    query["TypeNames"] = request.typeNames();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ExportWarning"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ExportWarningResponse>();
}

/**
 * @deprecated OpenAPI ExportWarning is deprecated, please use Sas::2018-12-03::ExportRecord instead.
 *
 * @summary Exports baseline check results.
 *
 * @param request ExportWarningRequest
 * @return ExportWarningResponse
 */
ExportWarningResponse Client::exportWarning(const ExportWarningRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return exportWarningWithOptions(request, runtime);
}

/**
 * @summary 容器网络连接
 *
 * @param tmpReq FindContainerNetworkConnectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FindContainerNetworkConnectResponse
 */
FindContainerNetworkConnectResponse Client::findContainerNetworkConnectWithOptions(const FindContainerNetworkConnectRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  FindContainerNetworkConnectShrinkRequest request = FindContainerNetworkConnectShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasDstNode()) {
    request.setDstNodeShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.dstNode(), "DstNode", "json"));
  }

  if (!!tmpReq.hasSrcNode()) {
    request.setSrcNodeShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.srcNode(), "SrcNode", "json"));
  }

  json query = {};
  if (!!request.hasCriteriaType()) {
    query["CriteriaType"] = request.criteriaType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDstNodeShrink()) {
    query["DstNode"] = request.dstNodeShrink();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSrcNodeShrink()) {
    query["SrcNode"] = request.srcNodeShrink();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "FindContainerNetworkConnect"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<FindContainerNetworkConnectResponse>();
}

/**
 * @summary 容器网络连接
 *
 * @param request FindContainerNetworkConnectRequest
 * @return FindContainerNetworkConnectResponse
 */
FindContainerNetworkConnectResponse Client::findContainerNetworkConnect(const FindContainerNetworkConnectRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return findContainerNetworkConnectWithOptions(request, runtime);
}

/**
 * @summary Completes guidance tasks for beginners to earn rewards.
 *
 * @param request FinishGuidTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FinishGuidTaskResponse
 */
FinishGuidTaskResponse Client::finishGuidTaskWithOptions(const FinishGuidTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTaskTypeName()) {
    query["TaskTypeName"] = request.taskTypeName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "FinishGuidTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<FinishGuidTaskResponse>();
}

/**
 * @summary Completes guidance tasks for beginners to earn rewards.
 *
 * @param request FinishGuidTaskRequest
 * @return FinishGuidTaskResponse
 */
FinishGuidTaskResponse Client::finishGuidTask(const FinishGuidTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return finishGuidTaskWithOptions(request, runtime);
}

/**
 * @summary Fixes a baseline risk item.
 *
 * @param request FixCheckWarningsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FixCheckWarningsResponse
 */
FixCheckWarningsResponse Client::fixCheckWarningsWithOptions(const FixCheckWarningsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckParams()) {
    query["CheckParams"] = request.checkParams();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRetentionDays()) {
    query["RetentionDays"] = request.retentionDays();
  }

  if (!!request.hasRiskId()) {
    query["RiskId"] = request.riskId();
  }

  if (!!request.hasSnapshotName()) {
    query["SnapshotName"] = request.snapshotName();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "FixCheckWarnings"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<FixCheckWarningsResponse>();
}

/**
 * @summary Fixes a baseline risk item.
 *
 * @param request FixCheckWarningsRequest
 * @return FixCheckWarningsResponse
 */
FixCheckWarningsResponse Client::fixCheckWarnings(const FixCheckWarningsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return fixCheckWarningsWithOptions(request, runtime);
}

/**
 * @summary Generates a custom dictionary of weak passwords for the baseline check feature.
 *
 * @param request GenerateDynamicDictRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateDynamicDictResponse
 */
GenerateDynamicDictResponse Client::generateDynamicDictWithOptions(const GenerateDynamicDictRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasArgKeywords()) {
    query["ArgKeywords"] = request.argKeywords();
  }

  if (!!request.hasDomains()) {
    query["Domains"] = request.domains();
  }

  if (!!request.hasNames()) {
    query["Names"] = request.names();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GenerateDynamicDict"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GenerateDynamicDictResponse>();
}

/**
 * @summary Generates a custom dictionary of weak passwords for the baseline check feature.
 *
 * @param request GenerateDynamicDictRequest
 * @return GenerateDynamicDictResponse
 */
GenerateDynamicDictResponse Client::generateDynamicDict(const GenerateDynamicDictRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return generateDynamicDictWithOptions(request, runtime);
}

/**
 * @summary Generates a command that is used to add a self-managed Kubernetes cluster.
 *
 * @param request GenerateK8sAccessInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateK8sAccessInfoResponse
 */
GenerateK8sAccessInfoResponse Client::generateK8sAccessInfoWithOptions(const GenerateK8sAccessInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliyunYundunGatewayApiName()) {
    query["AliyunYundunGatewayApiName"] = request.aliyunYundunGatewayApiName();
  }

  if (!!request.hasAliyunYundunGatewayPopName()) {
    query["AliyunYundunGatewayPopName"] = request.aliyunYundunGatewayPopName();
  }

  if (!!request.hasAliyunYundunGatewayProjectName()) {
    query["AliyunYundunGatewayProjectName"] = request.aliyunYundunGatewayProjectName();
  }

  if (!!request.hasAuditLogStore()) {
    query["AuditLogStore"] = request.auditLogStore();
  }

  if (!!request.hasAuditProject()) {
    query["AuditProject"] = request.auditProject();
  }

  if (!!request.hasAuditRegionId()) {
    query["AuditRegionId"] = request.auditRegionId();
  }

  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasCpuArch()) {
    query["CpuArch"] = request.cpuArch();
  }

  if (!!request.hasExpireDate()) {
    query["ExpireDate"] = request.expireDate();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GenerateK8sAccessInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GenerateK8sAccessInfoResponse>();
}

/**
 * @summary Generates a command that is used to add a self-managed Kubernetes cluster.
 *
 * @param request GenerateK8sAccessInfoRequest
 * @return GenerateK8sAccessInfoResponse
 */
GenerateK8sAccessInfoResponse Client::generateK8sAccessInfo(const GenerateK8sAccessInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return generateK8sAccessInfoWithOptions(request, runtime);
}

/**
 * @summary Creates a one-time scan task.
 *
 * @param request GenerateOnceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateOnceTaskResponse
 */
GenerateOnceTaskResponse Client::generateOnceTaskWithOptions(const GenerateOnceTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasParam()) {
    query["Param"] = request.param();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasTaskName()) {
    query["TaskName"] = request.taskName();
  }

  if (!!request.hasTaskType()) {
    query["TaskType"] = request.taskType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GenerateOnceTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GenerateOnceTaskResponse>();
}

/**
 * @summary Creates a one-time scan task.
 *
 * @param request GenerateOnceTaskRequest
 * @return GenerateOnceTaskResponse
 */
GenerateOnceTaskResponse Client::generateOnceTask(const GenerateOnceTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return generateOnceTaskWithOptions(request, runtime);
}

/**
 * @summary Obtains account tags.
 *
 * @param request GetAccountLabelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAccountLabelResponse
 */
GetAccountLabelResponse Client::getAccountLabelWithOptions(const GetAccountLabelRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLabelList()) {
    query["LabelList"] = request.labelList();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAccountLabel"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAccountLabelResponse>();
}

/**
 * @summary Obtains account tags.
 *
 * @param request GetAccountLabelRequest
 * @return GetAccountLabelResponse
 */
GetAccountLabelResponse Client::getAccountLabel(const GetAccountLabelRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAccountLabelWithOptions(request, runtime);
}

/**
 * @summary Queries the details of a defense rule against container escapes.
 *
 * @description Only the Ultimate edition of Security Center supports this operation.
 *
 * @param request GetAegisContainerPluginRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAegisContainerPluginRuleResponse
 */
GetAegisContainerPluginRuleResponse Client::getAegisContainerPluginRuleWithOptions(const GetAegisContainerPluginRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAegisContainerPluginRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAegisContainerPluginRuleResponse>();
}

/**
 * @summary Queries the details of a defense rule against container escapes.
 *
 * @description Only the Ultimate edition of Security Center supports this operation.
 *
 * @param request GetAegisContainerPluginRuleRequest
 * @return GetAegisContainerPluginRuleResponse
 */
GetAegisContainerPluginRuleResponse Client::getAegisContainerPluginRule(const GetAegisContainerPluginRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAegisContainerPluginRuleWithOptions(request, runtime);
}

/**
 * @summary Queries search conditions that can be used to search for container file protection rules.
 *
 * @param request GetAegisContainerPluginRuleCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAegisContainerPluginRuleCriteriaResponse
 */
GetAegisContainerPluginRuleCriteriaResponse Client::getAegisContainerPluginRuleCriteriaWithOptions(const GetAegisContainerPluginRuleCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasValue()) {
    query["Value"] = request.value();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAegisContainerPluginRuleCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAegisContainerPluginRuleCriteriaResponse>();
}

/**
 * @summary Queries search conditions that can be used to search for container file protection rules.
 *
 * @param request GetAegisContainerPluginRuleCriteriaRequest
 * @return GetAegisContainerPluginRuleCriteriaResponse
 */
GetAegisContainerPluginRuleCriteriaResponse Client::getAegisContainerPluginRuleCriteria(const GetAegisContainerPluginRuleCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAegisContainerPluginRuleCriteriaWithOptions(request, runtime);
}

/**
 * @summary Queries the number of agentless detection tasks.
 *
 * @param request GetAgentlessTaskCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAgentlessTaskCountResponse
 */
GetAgentlessTaskCountResponse Client::getAgentlessTaskCountWithOptions(const GetAgentlessTaskCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAgentlessTaskCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAgentlessTaskCountResponse>();
}

/**
 * @summary Queries the number of agentless detection tasks.
 *
 * @param request GetAgentlessTaskCountRequest
 * @return GetAgentlessTaskCountResponse
 */
GetAgentlessTaskCountResponse Client::getAgentlessTaskCount(const GetAgentlessTaskCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAgentlessTaskCountWithOptions(request, runtime);
}

/**
 * @summary Queries the number of servers on which alerts are generated.
 *
 * @param request GetAlarmMachineCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAlarmMachineCountResponse
 */
GetAlarmMachineCountResponse Client::getAlarmMachineCountWithOptions(const GetAlarmMachineCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAlarmMachineCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAlarmMachineCountResponse>();
}

/**
 * @summary Queries the number of servers on which alerts are generated.
 *
 * @param request GetAlarmMachineCountRequest
 * @return GetAlarmMachineCountResponse
 */
GetAlarmMachineCountResponse Client::getAlarmMachineCount(const GetAlarmMachineCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAlarmMachineCountWithOptions(request, runtime);
}

/**
 * @summary Queries the network topology between containerized applications.
 *
 * @param request GetAppNetworkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAppNetworkResponse
 */
GetAppNetworkResponse Client::getAppNetworkWithOptions(const GetAppNetworkRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAppNetwork"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAppNetworkResponse>();
}

/**
 * @summary Queries the network topology between containerized applications.
 *
 * @param request GetAppNetworkRequest
 * @return GetAppNetworkResponse
 */
GetAppNetworkResponse Client::getAppNetwork(const GetAppNetworkRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAppNetworkWithOptions(request, runtime);
}

/**
 * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
 *
 * @param request GetAssetDetailByUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAssetDetailByUuidResponse
 */
GetAssetDetailByUuidResponse Client::getAssetDetailByUuidWithOptions(const GetAssetDetailByUuidRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAssetDetailByUuid"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAssetDetailByUuidResponse>();
}

/**
 * @summary Queries the details of a server and the extended information about the server by using the UUID of the server.
 *
 * @param request GetAssetDetailByUuidRequest
 * @return GetAssetDetailByUuidResponse
 */
GetAssetDetailByUuidResponse Client::getAssetDetailByUuid(const GetAssetDetailByUuidRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAssetDetailByUuidWithOptions(request, runtime);
}

/**
 * @summary Queries asset selection configurations.
 *
 * @param request GetAssetSelectionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAssetSelectionConfigResponse
 */
GetAssetSelectionConfigResponse Client::getAssetSelectionConfigWithOptions(const GetAssetSelectionConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBusinessType()) {
    query["BusinessType"] = request.businessType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAssetSelectionConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAssetSelectionConfigResponse>();
}

/**
 * @summary Queries asset selection configurations.
 *
 * @param request GetAssetSelectionConfigRequest
 * @return GetAssetSelectionConfigResponse
 */
GetAssetSelectionConfigResponse Client::getAssetSelectionConfig(const GetAssetSelectionConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAssetSelectionConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the details about the asset fingerprints of the startup item, kernel module, or website type.
 *
 * @param request GetAssetsPropertyDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAssetsPropertyDetailResponse
 */
GetAssetsPropertyDetailResponse Client::getAssetsPropertyDetailWithOptions(const GetAssetsPropertyDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBiz()) {
    query["Biz"] = request.biz();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasItemName()) {
    query["ItemName"] = request.itemName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSearchCriteriaList()) {
    query["SearchCriteriaList"] = request.searchCriteriaList();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAssetsPropertyDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAssetsPropertyDetailResponse>();
}

/**
 * @summary Queries the details about the asset fingerprints of the startup item, kernel module, or website type.
 *
 * @param request GetAssetsPropertyDetailRequest
 * @return GetAssetsPropertyDetailResponse
 */
GetAssetsPropertyDetailResponse Client::getAssetsPropertyDetail(const GetAssetsPropertyDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAssetsPropertyDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the aggregation information about the asset fingerprints of the startup item, kernel module, or website type.
 *
 * @param request GetAssetsPropertyItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAssetsPropertyItemResponse
 */
GetAssetsPropertyItemResponse Client::getAssetsPropertyItemWithOptions(const GetAssetsPropertyItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBiz()) {
    query["Biz"] = request.biz();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasForceFlush()) {
    query["ForceFlush"] = request.forceFlush();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSearchInfo()) {
    query["SearchInfo"] = request.searchInfo();
  }

  if (!!request.hasSearchItem()) {
    query["SearchItem"] = request.searchItem();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAssetsPropertyItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAssetsPropertyItemResponse>();
}

/**
 * @summary Queries the aggregation information about the asset fingerprints of the startup item, kernel module, or website type.
 *
 * @param request GetAssetsPropertyItemRequest
 * @return GetAssetsPropertyItemResponse
 */
GetAssetsPropertyItemResponse Client::getAssetsPropertyItem(const GetAssetsPropertyItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAssetsPropertyItemWithOptions(request, runtime);
}

/**
 * @summary Query Attack Path Event Details.
 *
 * @param request GetAttackPathEventDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAttackPathEventDetailResponse
 */
GetAttackPathEventDetailResponse Client::getAttackPathEventDetailWithOptions(const GetAttackPathEventDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventId()) {
    query["EventId"] = request.eventId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAttackPathEventDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAttackPathEventDetailResponse>();
}

/**
 * @summary Query Attack Path Event Details.
 *
 * @param request GetAttackPathEventDetailRequest
 * @return GetAttackPathEventDetailResponse
 */
GetAttackPathEventDetailResponse Client::getAttackPathEventDetail(const GetAttackPathEventDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAttackPathEventDetailWithOptions(request, runtime);
}

/**
 * @summary Query Attack Path Event Statistics.
 *
 * @param request GetAttackPathEventStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAttackPathEventStatisticsResponse
 */
GetAttackPathEventStatisticsResponse Client::getAttackPathEventStatisticsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetAttackPathEventStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAttackPathEventStatisticsResponse>();
}

/**
 * @summary Query Attack Path Event Statistics.
 *
 * @return GetAttackPathEventStatisticsResponse
 */
GetAttackPathEventStatisticsResponse Client::getAttackPathEventStatistics() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAttackPathEventStatisticsWithOptions(runtime);
}

/**
 * @summary Query Attack Path Sensitive Assets.
 *
 * @param request GetAttackPathSensitiveAssetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAttackPathSensitiveAssetConfigResponse
 */
GetAttackPathSensitiveAssetConfigResponse Client::getAttackPathSensitiveAssetConfigWithOptions(const GetAttackPathSensitiveAssetConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAttackPathSensitiveAssetConfigId()) {
    query["AttackPathSensitiveAssetConfigId"] = request.attackPathSensitiveAssetConfigId();
  }

  if (!!request.hasConfigType()) {
    query["ConfigType"] = request.configType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAttackPathSensitiveAssetConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAttackPathSensitiveAssetConfigResponse>();
}

/**
 * @summary Query Attack Path Sensitive Assets.
 *
 * @param request GetAttackPathSensitiveAssetConfigRequest
 * @return GetAttackPathSensitiveAssetConfigResponse
 */
GetAttackPathSensitiveAssetConfigResponse Client::getAttackPathSensitiveAssetConfig(const GetAttackPathSensitiveAssetConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAttackPathSensitiveAssetConfigWithOptions(request, runtime);
}

/**
 * @summary Query Attack Path Whitelist Details.
 *
 * @param request GetAttackPathWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAttackPathWhitelistResponse
 */
GetAttackPathWhitelistResponse Client::getAttackPathWhitelistWithOptions(const GetAttackPathWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAttackPathWhitelistId()) {
    query["AttackPathWhitelistId"] = request.attackPathWhitelistId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetAttackPathWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAttackPathWhitelistResponse>();
}

/**
 * @summary Query Attack Path Whitelist Details.
 *
 * @param request GetAttackPathWhitelistRequest
 * @return GetAttackPathWhitelistResponse
 */
GetAttackPathWhitelistResponse Client::getAttackPathWhitelist(const GetAttackPathWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAttackPathWhitelistWithOptions(request, runtime);
}

/**
 * @summary Queries a list of attack types on the Attack Analysis page.
 *
 * @param request GetAttackTypeListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAttackTypeListResponse
 */
GetAttackTypeListResponse Client::getAttackTypeListWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetAttackTypeList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAttackTypeListResponse>();
}

/**
 * @summary Queries a list of attack types on the Attack Analysis page.
 *
 * @return GetAttackTypeListResponse
 */
GetAttackTypeListResponse Client::getAttackTypeList() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAttackTypeListWithOptions(runtime);
}

/**
 * @summary Queries the statistics of asset protection quota.
 *
 * @param request GetAuthSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAuthSummaryResponse
 */
GetAuthSummaryResponse Client::getAuthSummaryWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetAuthSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAuthSummaryResponse>();
}

/**
 * @summary Queries the statistics of asset protection quota.
 *
 * @return GetAuthSummaryResponse
 */
GetAuthSummaryResponse Client::getAuthSummary() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAuthSummaryWithOptions(runtime);
}

/**
 * @summary Queries the statistics about the numbers of assets protected by each edition of Security Center.
 *
 * @param request GetAuthVersionStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAuthVersionStatisticResponse
 */
GetAuthVersionStatisticResponse Client::getAuthVersionStatisticWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetAuthVersionStatistic"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetAuthVersionStatisticResponse>();
}

/**
 * @summary Queries the statistics about the numbers of assets protected by each edition of Security Center.
 *
 * @return GetAuthVersionStatisticResponse
 */
GetAuthVersionStatisticResponse Client::getAuthVersionStatistic() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getAuthVersionStatisticWithOptions(runtime);
}

/**
 * @summary Checks whether the managed anti-ransomware feature can automatically configure an anti-ransomware policy for servers.
 *
 * @param request GetBackupAutoConfigStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBackupAutoConfigStatusResponse
 */
GetBackupAutoConfigStatusResponse Client::getBackupAutoConfigStatusWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetBackupAutoConfigStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetBackupAutoConfigStatusResponse>();
}

/**
 * @summary Checks whether the managed anti-ransomware feature can automatically configure an anti-ransomware policy for servers.
 *
 * @return GetBackupAutoConfigStatusResponse
 */
GetBackupAutoConfigStatusResponse Client::getBackupAutoConfigStatus() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getBackupAutoConfigStatusWithOptions(runtime);
}

/**
 * @summary Queries the anti-ransomware capacity that is used.
 *
 * @param request GetBackupStorageCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBackupStorageCountResponse
 */
GetBackupStorageCountResponse Client::getBackupStorageCountWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetBackupStorageCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetBackupStorageCountResponse>();
}

/**
 * @summary Queries the anti-ransomware capacity that is used.
 *
 * @return GetBackupStorageCountResponse
 */
GetBackupStorageCountResponse Client::getBackupStorageCount() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getBackupStorageCountWithOptions(runtime);
}

/**
 * @summary Queries configurations for scanning image build command risks.
 *
 * @param request GetBuildRiskDefineRuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBuildRiskDefineRuleConfigResponse
 */
GetBuildRiskDefineRuleConfigResponse Client::getBuildRiskDefineRuleConfigWithOptions(const GetBuildRiskDefineRuleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetBuildRiskDefineRuleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetBuildRiskDefineRuleConfigResponse>();
}

/**
 * @summary Queries configurations for scanning image build command risks.
 *
 * @param request GetBuildRiskDefineRuleConfigRequest
 * @return GetBuildRiskDefineRuleConfigResponse
 */
GetBuildRiskDefineRuleConfigResponse Client::getBuildRiskDefineRuleConfig(const GetBuildRiskDefineRuleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getBuildRiskDefineRuleConfigWithOptions(request, runtime);
}

/**
 * @summary Checks whether the current user is qualified for the trial use of Security Center.
 *
 * @param request GetCanTrySasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCanTrySasResponse
 */
GetCanTrySasResponse Client::getCanTrySasWithOptions(const GetCanTrySasRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json body = {};
  if (!!request.hasFromEcs()) {
    body["FromEcs"] = request.fromEcs();
  }

  if (!!request.hasLang()) {
    body["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"body" , Utils::Utils::parseToMap(body)}
  }).get<map<string, json>>());
  Params params = Params(json({
    {"action" , "GetCanTrySas"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCanTrySasResponse>();
}

/**
 * @summary Checks whether the current user is qualified for the trial use of Security Center.
 *
 * @param request GetCanTrySasRequest
 * @return GetCanTrySasResponse
 */
GetCanTrySasResponse Client::getCanTrySas(const GetCanTrySasRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCanTrySasWithOptions(request, runtime);
}

/**
 * @summary Queries the information about an automatic configuration check on cloud services.
 *
 * @param request GetCheckConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckConfigResponse
 */
GetCheckConfigResponse Client::getCheckConfigWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetCheckConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCheckConfigResponse>();
}

/**
 * @summary Queries the information about an automatic configuration check on cloud services.
 *
 * @return GetCheckConfigResponse
 */
GetCheckConfigResponse Client::getCheckConfig() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCheckConfigWithOptions(runtime);
}

/**
 * @summary Queries statistics on the number of risk items in cloud security posture management (CSPM) for cloud services.
 *
 * @param request GetCheckCountStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckCountStatisticResponse
 */
GetCheckCountStatisticResponse Client::getCheckCountStatisticWithOptions(const GetCheckCountStatisticRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStatisticType()) {
    query["StatisticType"] = request.statisticType();
  }

  if (!!request.hasTaskSources()) {
    query["TaskSources"] = request.taskSources();
  }

  if (!!request.hasVendors()) {
    query["Vendors"] = request.vendors();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCheckCountStatistic"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCheckCountStatisticResponse>();
}

/**
 * @summary Queries statistics on the number of risk items in cloud security posture management (CSPM) for cloud services.
 *
 * @param request GetCheckCountStatisticRequest
 * @return GetCheckCountStatisticResponse
 */
GetCheckCountStatisticResponse Client::getCheckCountStatistic(const GetCheckCountStatisticRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCheckCountStatisticWithOptions(request, runtime);
}

/**
 * @summary Queries the details about a check item that is used for configuration assessment.
 *
 * @param request GetCheckDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckDetailResponse
 */
GetCheckDetailResponse Client::getCheckDetailWithOptions(const GetCheckDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCheckDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCheckDetailResponse>();
}

/**
 * @summary Queries the details about a check item that is used for configuration assessment.
 *
 * @param request GetCheckDetailRequest
 * @return GetCheckDetailResponse
 */
GetCheckDetailResponse Client::getCheckDetail(const GetCheckDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCheckDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the progress of a configuration check task on cloud services.
 *
 * @param request GetCheckProcessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckProcessResponse
 */
GetCheckProcessResponse Client::getCheckProcessWithOptions(const GetCheckProcessRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCheckProcess"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCheckProcessResponse>();
}

/**
 * @summary Queries the progress of a configuration check task on cloud services.
 *
 * @param request GetCheckProcessRequest
 * @return GetCheckProcessResponse
 */
GetCheckProcessResponse Client::getCheckProcess(const GetCheckProcessRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCheckProcessWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics on risk scenarios and check items that are used in the risk scenarios, including the statistics on low-risk, medium-risk, and high-risk items by baseline type.
 *
 * @param request GetCheckRiskStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckRiskStatisticsResponse
 */
GetCheckRiskStatisticsResponse Client::getCheckRiskStatisticsWithOptions(const GetCheckRiskStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCheckRiskStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCheckRiskStatisticsResponse>();
}

/**
 * @summary Queries the statistics on risk scenarios and check items that are used in the risk scenarios, including the statistics on low-risk, medium-risk, and high-risk items by baseline type.
 *
 * @param request GetCheckRiskStatisticsRequest
 * @return GetCheckRiskStatisticsResponse
 */
GetCheckRiskStatisticsResponse Client::getCheckRiskStatistics(const GetCheckRiskStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCheckRiskStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the sales information about the configuration assessment feature, including the purchased quota and the consumed quota.
 *
 * @param request GetCheckSaleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckSaleResponse
 */
GetCheckSaleResponse Client::getCheckSaleWithOptions(const GetCheckSaleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCheckSale"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCheckSaleResponse>();
}

/**
 * @summary Queries the sales information about the configuration assessment feature, including the purchased quota and the consumed quota.
 *
 * @param request GetCheckSaleRequest
 * @return GetCheckSaleResponse
 */
GetCheckSaleResponse Client::getCheckSale(const GetCheckSaleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCheckSaleWithOptions(request, runtime);
}

/**
 * @summary Obtains the structure information about check items provided by the configuration assessment feature.
 *
 * @description You must purchase the configuration assessment feature before you can use the feature.
 *
 * @param request GetCheckStructureRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckStructureResponse
 */
GetCheckStructureResponse Client::getCheckStructureWithOptions(const GetCheckStructureRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasTaskSources()) {
    query["TaskSources"] = request.taskSources();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCheckStructure"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCheckStructureResponse>();
}

/**
 * @summary Obtains the structure information about check items provided by the configuration assessment feature.
 *
 * @description You must purchase the configuration assessment feature before you can use the feature.
 *
 * @param request GetCheckStructureRequest
 * @return GetCheckStructureResponse
 */
GetCheckStructureResponse Client::getCheckStructure(const GetCheckStructureRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCheckStructureWithOptions(request, runtime);
}

/**
 * @summary Queries the summary information about the configuration checks on cloud services.
 *
 * @param request GetCheckSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckSummaryResponse
 */
GetCheckSummaryResponse Client::getCheckSummaryWithOptions(const GetCheckSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIsItemStatistic()) {
    query["IsItemStatistic"] = request.isItemStatistic();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasTaskSources()) {
    query["TaskSources"] = request.taskSources();
  }

  if (!!request.hasVendors()) {
    query["Vendors"] = request.vendors();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCheckSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCheckSummaryResponse>();
}

/**
 * @summary Queries the summary information about the configuration checks on cloud services.
 *
 * @param request GetCheckSummaryRequest
 * @return GetCheckSummaryResponse
 */
GetCheckSummaryResponse Client::getCheckSummary(const GetCheckSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCheckSummaryWithOptions(request, runtime);
}

/**
 * @summary Get time trend statistics data
 *
 * @param request GetCheckTimeDimensionStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCheckTimeDimensionStatisticResponse
 */
GetCheckTimeDimensionStatisticResponse Client::getCheckTimeDimensionStatisticWithOptions(const GetCheckTimeDimensionStatisticRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEndTimeStamp()) {
    query["EndTimeStamp"] = request.endTimeStamp();
  }

  if (!!request.hasStartTimeStamp()) {
    query["StartTimeStamp"] = request.startTimeStamp();
  }

  if (!!request.hasStatisticType()) {
    query["StatisticType"] = request.statisticType();
  }

  if (!!request.hasVendors()) {
    query["Vendors"] = request.vendors();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCheckTimeDimensionStatistic"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCheckTimeDimensionStatisticResponse>();
}

/**
 * @summary Get time trend statistics data
 *
 * @param request GetCheckTimeDimensionStatisticRequest
 * @return GetCheckTimeDimensionStatisticResponse
 */
GetCheckTimeDimensionStatisticResponse Client::getCheckTimeDimensionStatistic(const GetCheckTimeDimensionStatisticRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCheckTimeDimensionStatisticWithOptions(request, runtime);
}

/**
 * @summary Queries the installation rate and online rate of the agent.
 *
 * @param request GetClientRatioStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClientRatioStatisticResponse
 */
GetClientRatioStatisticResponse Client::getClientRatioStatisticWithOptions(const GetClientRatioStatisticRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasStatisticTypes()) {
    query["StatisticTypes"] = request.statisticTypes();
  }

  if (!!request.hasTimeEnd()) {
    query["TimeEnd"] = request.timeEnd();
  }

  if (!!request.hasTimeStart()) {
    query["TimeStart"] = request.timeStart();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetClientRatioStatistic"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetClientRatioStatisticResponse>();
}

/**
 * @summary Queries the installation rate and online rate of the agent.
 *
 * @param request GetClientRatioStatisticRequest
 * @return GetClientRatioStatisticResponse
 */
GetClientRatioStatisticResponse Client::getClientRatioStatistic(const GetClientRatioStatisticRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getClientRatioStatisticWithOptions(request, runtime);
}

/**
 * @summary Queries the information about a custom defense rule.
 *
 * @param request GetClientUserDefineRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClientUserDefineRuleResponse
 */
GetClientUserDefineRuleResponse Client::getClientUserDefineRuleWithOptions(const GetClientUserDefineRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetClientUserDefineRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetClientUserDefineRuleResponse>();
}

/**
 * @summary Queries the information about a custom defense rule.
 *
 * @param request GetClientUserDefineRuleRequest
 * @return GetClientUserDefineRuleResponse
 */
GetClientUserDefineRuleResponse Client::getClientUserDefineRule(const GetClientUserDefineRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getClientUserDefineRuleWithOptions(request, runtime);
}

/**
 * @summary Queries the filter conditions that are used to search for cloud assets.
 *
 * @param request GetCloudAssetCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCloudAssetCriteriaResponse
 */
GetCloudAssetCriteriaResponse Client::getCloudAssetCriteriaWithOptions(const GetCloudAssetCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCloudAssetTypes()) {
    query["CloudAssetTypes"] = request.cloudAssetTypes();
  }

  if (!!request.hasValue()) {
    query["Value"] = request.value();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCloudAssetCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCloudAssetCriteriaResponse>();
}

/**
 * @summary Queries the filter conditions that are used to search for cloud assets.
 *
 * @param request GetCloudAssetCriteriaRequest
 * @return GetCloudAssetCriteriaResponse
 */
GetCloudAssetCriteriaResponse Client::getCloudAssetCriteria(const GetCloudAssetCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCloudAssetCriteriaWithOptions(request, runtime);
}

/**
 * @summary Obtains the details of cloud assets.
 *
 * @param request GetCloudAssetDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCloudAssetDetailResponse
 */
GetCloudAssetDetailResponse Client::getCloudAssetDetailWithOptions(const GetCloudAssetDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssetSubType()) {
    query["AssetSubType"] = request.assetSubType();
  }

  if (!!request.hasAssetType()) {
    query["AssetType"] = request.assetType();
  }

  if (!!request.hasCloudAssetInstances()) {
    query["CloudAssetInstances"] = request.cloudAssetInstances();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCloudAssetDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCloudAssetDetailResponse>();
}

/**
 * @summary Obtains the details of cloud assets.
 *
 * @param request GetCloudAssetDetailRequest
 * @return GetCloudAssetDetailResponse
 */
GetCloudAssetDetailResponse Client::getCloudAssetDetail(const GetCloudAssetDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCloudAssetDetailWithOptions(request, runtime);
}

/**
 * @summary The total number of instances that are at risk.
 *
 * @param request GetCloudAssetSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCloudAssetSummaryResponse
 */
GetCloudAssetSummaryResponse Client::getCloudAssetSummaryWithOptions(const GetCloudAssetSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCloudAssetTypes()) {
    query["CloudAssetTypes"] = request.cloudAssetTypes();
  }

  if (!!request.hasVendors()) {
    query["Vendors"] = request.vendors();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCloudAssetSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCloudAssetSummaryResponse>();
}

/**
 * @summary The total number of instances that are at risk.
 *
 * @param request GetCloudAssetSummaryRequest
 * @return GetCloudAssetSummaryResponse
 */
GetCloudAssetSummaryResponse Client::getCloudAssetSummary(const GetCloudAssetSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCloudAssetSummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics on baseline risk items of container clusters.
 *
 * @param request GetClusterCheckItemWarningStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterCheckItemWarningStatisticsResponse
 */
GetClusterCheckItemWarningStatisticsResponse Client::getClusterCheckItemWarningStatisticsWithOptions(const GetClusterCheckItemWarningStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetClusterCheckItemWarningStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetClusterCheckItemWarningStatisticsResponse>();
}

/**
 * @summary Queries the statistics on baseline risk items of container clusters.
 *
 * @param request GetClusterCheckItemWarningStatisticsRequest
 * @return GetClusterCheckItemWarningStatisticsResponse
 */
GetClusterCheckItemWarningStatisticsResponse Client::getClusterCheckItemWarningStatistics(const GetClusterCheckItemWarningStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getClusterCheckItemWarningStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the overall information about cluster defense rules that are configured for the container firewall feature.
 *
 * @param request GetClusterRuleSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterRuleSummaryResponse
 */
GetClusterRuleSummaryResponse Client::getClusterRuleSummaryWithOptions(const GetClusterRuleSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetClusterRuleSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetClusterRuleSummaryResponse>();
}

/**
 * @summary Queries the overall information about cluster defense rules that are configured for the container firewall feature.
 *
 * @param request GetClusterRuleSummaryRequest
 * @return GetClusterRuleSummaryResponse
 */
GetClusterRuleSummaryResponse Client::getClusterRuleSummary(const GetClusterRuleSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getClusterRuleSummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the number of policies in each cluster.
 *
 * @param request GetClusterStrategyCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterStrategyCountResponse
 */
GetClusterStrategyCountResponse Client::getClusterStrategyCountWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetClusterStrategyCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetClusterStrategyCountResponse>();
}

/**
 * @summary Queries the number of policies in each cluster.
 *
 * @return GetClusterStrategyCountResponse
 */
GetClusterStrategyCountResponse Client::getClusterStrategyCount() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getClusterStrategyCountWithOptions(runtime);
}

/**
 * @summary Queries the statistics on alert events that are generated for containers.
 *
 * @param request GetClusterSuspEventStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterSuspEventStatisticsResponse
 */
GetClusterSuspEventStatisticsResponse Client::getClusterSuspEventStatisticsWithOptions(const GetClusterSuspEventStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetClusterSuspEventStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetClusterSuspEventStatisticsResponse>();
}

/**
 * @summary Queries the statistics on alert events that are generated for containers.
 *
 * @param request GetClusterSuspEventStatisticsRequest
 * @return GetClusterSuspEventStatisticsResponse
 */
GetClusterSuspEventStatisticsResponse Client::getClusterSuspEventStatistics(const GetClusterSuspEventStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getClusterSuspEventStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the configuration of a common switch.
 *
 * @param request GetCommonSwitchConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCommonSwitchConfigResponse
 */
GetCommonSwitchConfigResponse Client::getCommonSwitchConfigWithOptions(const GetCommonSwitchConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetCommonSwitchConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCommonSwitchConfigResponse>();
}

/**
 * @summary Queries the configuration of a common switch.
 *
 * @param request GetCommonSwitchConfigRequest
 * @return GetCommonSwitchConfigResponse
 */
GetCommonSwitchConfigResponse Client::getCommonSwitchConfig(const GetCommonSwitchConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCommonSwitchConfigWithOptions(request, runtime);
}

/**
 * @summary Query whether the core function\\"s gray switch is hit
 *
 * @param request GetConsoleFuncGrayStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConsoleFuncGrayStatusResponse
 */
GetConsoleFuncGrayStatusResponse Client::getConsoleFuncGrayStatusWithOptions(const GetConsoleFuncGrayStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCondition()) {
    query["Condition"] = request.condition();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetConsoleFuncGrayStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetConsoleFuncGrayStatusResponse>();
}

/**
 * @summary Query whether the core function\\"s gray switch is hit
 *
 * @param request GetConsoleFuncGrayStatusRequest
 * @return GetConsoleFuncGrayStatusResponse
 */
GetConsoleFuncGrayStatusResponse Client::getConsoleFuncGrayStatus(const GetConsoleFuncGrayStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getConsoleFuncGrayStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the details of a rule for non-image program defense.
 *
 * @param request GetContainerDefenseRuleDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetContainerDefenseRuleDetailResponse
 */
GetContainerDefenseRuleDetailResponse Client::getContainerDefenseRuleDetailWithOptions(const GetContainerDefenseRuleDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetContainerDefenseRuleDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetContainerDefenseRuleDetailResponse>();
}

/**
 * @summary Queries the details of a rule for non-image program defense.
 *
 * @param request GetContainerDefenseRuleDetailRequest
 * @return GetContainerDefenseRuleDetailResponse
 */
GetContainerDefenseRuleDetailResponse Client::getContainerDefenseRuleDetail(const GetContainerDefenseRuleDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getContainerDefenseRuleDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the publish details of the Security Center agent.
 *
 * @param request GetCurrentVersionPublishRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCurrentVersionPublishResponse
 */
GetCurrentVersionPublishResponse Client::getCurrentVersionPublishWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetCurrentVersionPublish"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetCurrentVersionPublishResponse>();
}

/**
 * @summary Queries the publish details of the Security Center agent.
 *
 * @return GetCurrentVersionPublishResponse
 */
GetCurrentVersionPublishResponse Client::getCurrentVersionPublish() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getCurrentVersionPublishWithOptions(runtime);
}

/**
 * @summary Queries the security operations trends of the vulnerabilities, alerts, and baseline risks.
 *
 * @param request GetDataTrendRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataTrendResponse
 */
GetDataTrendResponse Client::getDataTrendWithOptions(const GetDataTrendRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBizTypes()) {
    query["BizTypes"] = request.bizTypes();
  }

  if (!!request.hasEndTimestamp()) {
    query["EndTimestamp"] = request.endTimestamp();
  }

  if (!!request.hasInterval()) {
    query["Interval"] = request.interval();
  }

  if (!!request.hasStartTimestamp()) {
    query["StartTimestamp"] = request.startTimestamp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetDataTrend"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetDataTrendResponse>();
}

/**
 * @summary Queries the security operations trends of the vulnerabilities, alerts, and baseline risks.
 *
 * @param request GetDataTrendRequest
 * @return GetDataTrendResponse
 */
GetDataTrendResponse Client::getDataTrend(const GetDataTrendRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getDataTrendWithOptions(request, runtime);
}

/**
 * @summary Queries the numbers of handled alerts of the precision defense type and the web tamper proofing type.
 *
 * @param request GetDefenceCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDefenceCountResponse
 */
GetDefenceCountResponse Client::getDefenceCountWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetDefenceCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetDefenceCountResponse>();
}

/**
 * @summary Queries the numbers of handled alerts of the precision defense type and the web tamper proofing type.
 *
 * @return GetDefenceCountResponse
 */
GetDefenceCountResponse Client::getDefenceCount() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getDefenceCountWithOptions(runtime);
}

/**
 * @summary Queries the ranking of images in each dimension.
 *
 * @param request GetDockerhubImageRiskRankInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDockerhubImageRiskRankInfoResponse
 */
GetDockerhubImageRiskRankInfoResponse Client::getDockerhubImageRiskRankInfoWithOptions(const GetDockerhubImageRiskRankInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTypes()) {
    query["Types"] = request.types();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetDockerhubImageRiskRankInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetDockerhubImageRiskRankInfoResponse>();
}

/**
 * @summary Queries the ranking of images in each dimension.
 *
 * @param request GetDockerhubImageRiskRankInfoRequest
 * @return GetDockerhubImageRiskRankInfoResponse
 */
GetDockerhubImageRiskRankInfoResponse Client::getDockerhubImageRiskRankInfo(const GetDockerhubImageRiskRankInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getDockerhubImageRiskRankInfoWithOptions(request, runtime);
}

/**
 * @summary Query the statistical counts of images across various dimensions.
 *
 * @param request GetDockerhubImageRiskStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDockerhubImageRiskStatisticResponse
 */
GetDockerhubImageRiskStatisticResponse Client::getDockerhubImageRiskStatisticWithOptions(const GetDockerhubImageRiskStatisticRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTypes()) {
    query["Types"] = request.types();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetDockerhubImageRiskStatistic"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetDockerhubImageRiskStatisticResponse>();
}

/**
 * @summary Query the statistical counts of images across various dimensions.
 *
 * @param request GetDockerhubImageRiskStatisticRequest
 * @return GetDockerhubImageRiskStatisticResponse
 */
GetDockerhubImageRiskStatisticResponse Client::getDockerhubImageRiskStatistic(const GetDockerhubImageRiskStatisticRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getDockerhubImageRiskStatisticWithOptions(request, runtime);
}

/**
 * @summary Obtains the usage information of the malicious file detection SDK.
 *
 * @param request GetFileDetectApiInvokeInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileDetectApiInvokeInfoResponse
 */
GetFileDetectApiInvokeInfoResponse Client::getFileDetectApiInvokeInfoWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetFileDetectApiInvokeInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetFileDetectApiInvokeInfoResponse>();
}

/**
 * @summary Obtains the usage information of the malicious file detection SDK.
 *
 * @return GetFileDetectApiInvokeInfoResponse
 */
GetFileDetectApiInvokeInfoResponse Client::getFileDetectApiInvokeInfo() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getFileDetectApiInvokeInfoWithOptions(runtime);
}

/**
 * @summary Queries the cloud sandbox check results of malicious files.
 *
 * @param request GetFileDetectReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileDetectReportResponse
 */
GetFileDetectReportResponse Client::getFileDetectReportWithOptions(const GetFileDetectReportRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventId()) {
    query["EventId"] = request.eventId();
  }

  if (!!request.hasField()) {
    query["Field"] = request.field();
  }

  if (!!request.hasFileHash()) {
    query["FileHash"] = request.fileHash();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceType()) {
    query["SourceType"] = request.sourceType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetFileDetectReport"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetFileDetectReportResponse>();
}

/**
 * @summary Queries the cloud sandbox check results of malicious files.
 *
 * @param request GetFileDetectReportRequest
 * @return GetFileDetectReportResponse
 */
GetFileDetectReportResponse Client::getFileDetectReport(const GetFileDetectReportRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getFileDetectReportWithOptions(request, runtime);
}

/**
 * @summary Obtains file detection results.
 *
 * @description The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request GetFileDetectResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileDetectResultResponse
 */
GetFileDetectResultResponse Client::getFileDetectResultWithOptions(const GetFileDetectResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHashKeyList()) {
    query["HashKeyList"] = request.hashKeyList();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetFileDetectResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetFileDetectResultResponse>();
}

/**
 * @summary Obtains file detection results.
 *
 * @description The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
 *
 * @param request GetFileDetectResultRequest
 * @return GetFileDetectResultResponse
 */
GetFileDetectResultResponse Client::getFileDetectResult(const GetFileDetectResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getFileDetectResultWithOptions(request, runtime);
}

/**
 * @summary Queries information about the core file monitoring feature, including the number of effective rules and the installation status of the Security Center agent on servers.
 *
 * @param request GetFileProtectDashboardRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileProtectDashboardResponse
 */
GetFileProtectDashboardResponse Client::getFileProtectDashboardWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetFileProtectDashboard"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetFileProtectDashboardResponse>();
}

/**
 * @summary Queries information about the core file monitoring feature, including the number of effective rules and the installation status of the Security Center agent on servers.
 *
 * @return GetFileProtectDashboardResponse
 */
GetFileProtectDashboardResponse Client::getFileProtectDashboard() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getFileProtectDashboardWithOptions(runtime);
}

/**
 * @summary Queries information about core file monitoring events.
 *
 * @param request GetFileProtectEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileProtectEventResponse
 */
GetFileProtectEventResponse Client::getFileProtectEventWithOptions(const GetFileProtectEventRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetFileProtectEvent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetFileProtectEventResponse>();
}

/**
 * @summary Queries information about core file monitoring events.
 *
 * @param request GetFileProtectEventRequest
 * @return GetFileProtectEventResponse
 */
GetFileProtectEventResponse Client::getFileProtectEvent(const GetFileProtectEventRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getFileProtectEventWithOptions(request, runtime);
}

/**
 * @summary Queries the total number of core file monitoring events by filter condition.
 *
 * @param request GetFileProtectEventCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileProtectEventCountResponse
 */
GetFileProtectEventCountResponse Client::getFileProtectEventCountWithOptions(const GetFileProtectEventCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetFileProtectEventCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetFileProtectEventCountResponse>();
}

/**
 * @summary Queries the total number of core file monitoring events by filter condition.
 *
 * @param request GetFileProtectEventCountRequest
 * @return GetFileProtectEventCountResponse
 */
GetFileProtectEventCountResponse Client::getFileProtectEventCount(const GetFileProtectEventCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getFileProtectEventCountWithOptions(request, runtime);
}

/**
 * @summary Queries the information about a core file monitoring rule based on the ID of the rule.
 *
 * @param request GetFileProtectRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileProtectRuleResponse
 */
GetFileProtectRuleResponse Client::getFileProtectRuleWithOptions(const GetFileProtectRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetFileProtectRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetFileProtectRuleResponse>();
}

/**
 * @summary Queries the information about a core file monitoring rule based on the ID of the rule.
 *
 * @param request GetFileProtectRuleRequest
 * @return GetFileProtectRuleResponse
 */
GetFileProtectRuleResponse Client::getFileProtectRule(const GetFileProtectRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getFileProtectRuleWithOptions(request, runtime);
}

/**
 * @summary Queries the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @param request GetFileUploadLimitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileUploadLimitResponse
 */
GetFileUploadLimitResponse Client::getFileUploadLimitWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetFileUploadLimit"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetFileUploadLimitResponse>();
}

/**
 * @summary Queries the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @return GetFileUploadLimitResponse
 */
GetFileUploadLimitResponse Client::getFileUploadLimit() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getFileUploadLimitWithOptions(runtime);
}

/**
 * @summary Get Trial Status
 *
 * @param request GetFunctionTrialStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFunctionTrialStatusResponse
 */
GetFunctionTrialStatusResponse Client::getFunctionTrialStatusWithOptions(const GetFunctionTrialStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFunctionName()) {
    query["FunctionName"] = request.functionName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetFunctionTrialStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetFunctionTrialStatusResponse>();
}

/**
 * @summary Get Trial Status
 *
 * @param request GetFunctionTrialStatusRequest
 * @return GetFunctionTrialStatusResponse
 */
GetFunctionTrialStatusResponse Client::getFunctionTrialStatus(const GetFunctionTrialStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getFunctionTrialStatusWithOptions(request, runtime);
}

/**
 * @summary Obtains the URL that is used to upload a file to a honeypot.
 *
 * @param request GetHoneyPotUploadPolicyInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneyPotUploadPolicyInfoResponse
 */
GetHoneyPotUploadPolicyInfoResponse Client::getHoneyPotUploadPolicyInfoWithOptions(const GetHoneyPotUploadPolicyInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetHoneyPotUploadPolicyInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetHoneyPotUploadPolicyInfoResponse>();
}

/**
 * @summary Obtains the URL that is used to upload a file to a honeypot.
 *
 * @param request GetHoneyPotUploadPolicyInfoRequest
 * @return GetHoneyPotUploadPolicyInfoResponse
 */
GetHoneyPotUploadPolicyInfoResponse Client::getHoneyPotUploadPolicyInfo(const GetHoneyPotUploadPolicyInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getHoneyPotUploadPolicyInfoWithOptions(request, runtime);
}

/**
 * @summary 获取蜜罐攻击统计数据
 *
 * @param request GetHoneypotAttackStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotAttackStatisticsResponse
 */
GetHoneypotAttackStatisticsResponse Client::getHoneypotAttackStatisticsWithOptions(const GetHoneypotAttackStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTimeStamp()) {
    query["EndTimeStamp"] = request.endTimeStamp();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskLevelList()) {
    query["RiskLevelList"] = request.riskLevelList();
  }

  if (!!request.hasSrcIp()) {
    query["SrcIp"] = request.srcIp();
  }

  if (!!request.hasStartTimeStamp()) {
    query["StartTimeStamp"] = request.startTimeStamp();
  }

  if (!!request.hasStatisticsType()) {
    query["StatisticsType"] = request.statisticsType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetHoneypotAttackStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetHoneypotAttackStatisticsResponse>();
}

/**
 * @summary 获取蜜罐攻击统计数据
 *
 * @param request GetHoneypotAttackStatisticsRequest
 * @return GetHoneypotAttackStatisticsResponse
 */
GetHoneypotAttackStatisticsResponse Client::getHoneypotAttackStatistics(const GetHoneypotAttackStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getHoneypotAttackStatisticsWithOptions(request, runtime);
}

/**
 * @summary Obtain attack trend statistics for a single attack source.
 *
 * @param request GetHoneypotEventTrendRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotEventTrendResponse
 */
GetHoneypotEventTrendResponse Client::getHoneypotEventTrendWithOptions(const GetHoneypotEventTrendRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEndTimeStamp()) {
    query["EndTimeStamp"] = request.endTimeStamp();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRiskLevelList()) {
    query["RiskLevelList"] = request.riskLevelList();
  }

  if (!!request.hasSrcIp()) {
    query["SrcIp"] = request.srcIp();
  }

  if (!!request.hasStartTimeStamp()) {
    query["StartTimeStamp"] = request.startTimeStamp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetHoneypotEventTrend"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetHoneypotEventTrendResponse>();
}

/**
 * @summary Obtain attack trend statistics for a single attack source.
 *
 * @param request GetHoneypotEventTrendRequest
 * @return GetHoneypotEventTrendResponse
 */
GetHoneypotEventTrendResponse Client::getHoneypotEventTrend(const GetHoneypotEventTrendRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getHoneypotEventTrendWithOptions(request, runtime);
}

/**
 * @summary Queries the details of a specified management node.
 *
 * @param request GetHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotNodeResponse
 */
GetHoneypotNodeResponse Client::getHoneypotNodeWithOptions(const GetHoneypotNodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetHoneypotNode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetHoneypotNodeResponse>();
}

/**
 * @summary Queries the details of a specified management node.
 *
 * @param request GetHoneypotNodeRequest
 * @return GetHoneypotNodeResponse
 */
GetHoneypotNodeResponse Client::getHoneypotNode(const GetHoneypotNodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getHoneypotNodeWithOptions(request, runtime);
}

/**
 * @summary Queries the monitoring data of management nodes to which the cloud honeypot belongs.
 *
 * @param request GetHoneypotNodeMetricListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotNodeMetricListResponse
 */
GetHoneypotNodeMetricListResponse Client::getHoneypotNodeMetricListWithOptions(const GetHoneypotNodeMetricListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasExpress()) {
    query["Express"] = request.express();
  }

  if (!!request.hasLength()) {
    query["Length"] = request.length();
  }

  if (!!request.hasMetricName()) {
    query["MetricName"] = request.metricName();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  if (!!request.hasPeriod()) {
    query["Period"] = request.period();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetHoneypotNodeMetricList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetHoneypotNodeMetricListResponse>();
}

/**
 * @summary Queries the monitoring data of management nodes to which the cloud honeypot belongs.
 *
 * @param request GetHoneypotNodeMetricListRequest
 * @return GetHoneypotNodeMetricListResponse
 */
GetHoneypotNodeMetricListResponse Client::getHoneypotNodeMetricList(const GetHoneypotNodeMetricListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getHoneypotNodeMetricListWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of a specified honeypot template.
 *
 * @param request GetHoneypotPresetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotPresetResponse
 */
GetHoneypotPresetResponse Client::getHoneypotPresetWithOptions(const GetHoneypotPresetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneypotPresetId()) {
    query["HoneypotPresetId"] = request.honeypotPresetId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetHoneypotPreset"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetHoneypotPresetResponse>();
}

/**
 * @summary Queries the configurations of a specified honeypot template.
 *
 * @param request GetHoneypotPresetRequest
 * @return GetHoneypotPresetResponse
 */
GetHoneypotPresetResponse Client::getHoneypotPreset(const GetHoneypotPresetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getHoneypotPresetWithOptions(request, runtime);
}

/**
 * @summary Queries the details about a specified probe.
 *
 * @param request GetHoneypotProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotProbeResponse
 */
GetHoneypotProbeResponse Client::getHoneypotProbeWithOptions(const GetHoneypotProbeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasProbeId()) {
    query["ProbeId"] = request.probeId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetHoneypotProbe"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetHoneypotProbeResponse>();
}

/**
 * @summary Queries the details about a specified probe.
 *
 * @param request GetHoneypotProbeRequest
 * @return GetHoneypotProbeResponse
 */
GetHoneypotProbeResponse Client::getHoneypotProbe(const GetHoneypotProbeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getHoneypotProbeWithOptions(request, runtime);
}

/**
 * @summary 获取蜜罐使用量的统计数据
 *
 * @param request GetHoneypotStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetHoneypotStatisticsResponse
 */
GetHoneypotStatisticsResponse Client::getHoneypotStatisticsWithOptions(const GetHoneypotStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetHoneypotStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetHoneypotStatisticsResponse>();
}

/**
 * @summary 获取蜜罐使用量的统计数据
 *
 * @param request GetHoneypotStatisticsRequest
 * @return GetHoneypotStatisticsResponse
 */
GetHoneypotStatisticsResponse Client::getHoneypotStatistics(const GetHoneypotStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getHoneypotStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries alert handling rules.
 *
 * @param request GetImageEventOperationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetImageEventOperationResponse
 */
GetImageEventOperationResponse Client::getImageEventOperationWithOptions(const GetImageEventOperationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetImageEventOperation"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetImageEventOperationResponse>();
}

/**
 * @summary Queries alert handling rules.
 *
 * @param request GetImageEventOperationRequest
 * @return GetImageEventOperationResponse
 */
GetImageEventOperationResponse Client::getImageEventOperation(const GetImageEventOperationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getImageEventOperationWithOptions(request, runtime);
}

/**
 * @summary Queries the number of image scans that are performed within the last several days.
 *
 * @param request GetImageScanNumInPeriodRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetImageScanNumInPeriodResponse
 */
GetImageScanNumInPeriodResponse Client::getImageScanNumInPeriodWithOptions(const GetImageScanNumInPeriodRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPastDay()) {
    query["PastDay"] = request.pastDay();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetImageScanNumInPeriod"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetImageScanNumInPeriodResponse>();
}

/**
 * @summary Queries the number of image scans that are performed within the last several days.
 *
 * @param request GetImageScanNumInPeriodRequest
 * @return GetImageScanNumInPeriodResponse
 */
GetImageScanNumInPeriodResponse Client::getImageScanNumInPeriod(const GetImageScanNumInPeriodRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getImageScanNumInPeriodWithOptions(request, runtime);
}

/**
 * @summary Query Asset Installation Code
 *
 * @param request GetInstallCodeForUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstallCodeForUuidResponse
 */
GetInstallCodeForUuidResponse Client::getInstallCodeForUuidWithOptions(const GetInstallCodeForUuidRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetInstallCodeForUuid"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetInstallCodeForUuidResponse>();
}

/**
 * @summary Query Asset Installation Code
 *
 * @param request GetInstallCodeForUuidRequest
 * @return GetInstallCodeForUuidResponse
 */
GetInstallCodeForUuidResponse Client::getInstallCodeForUuid(const GetInstallCodeForUuidRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getInstallCodeForUuidWithOptions(request, runtime);
}

/**
 * @summary Count the number of security events for a single instance
 *
 * @param request GetInstanceAlarmStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceAlarmStatisticsResponse
 */
GetInstanceAlarmStatisticsResponse Client::getInstanceAlarmStatisticsWithOptions(const GetInstanceAlarmStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetInstanceAlarmStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetInstanceAlarmStatisticsResponse>();
}

/**
 * @summary Count the number of security events for a single instance
 *
 * @param request GetInstanceAlarmStatisticsRequest
 * @return GetInstanceAlarmStatisticsResponse
 */
GetInstanceAlarmStatisticsResponse Client::getInstanceAlarmStatistics(const GetInstanceAlarmStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getInstanceAlarmStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the details of a microsegmentation defense rule.
 *
 * @param request GetInterceptionRuleDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInterceptionRuleDetailResponse
 */
GetInterceptionRuleDetailResponse Client::getInterceptionRuleDetailWithOptions(const GetInterceptionRuleDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetInterceptionRuleDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetInterceptionRuleDetailResponse>();
}

/**
 * @summary Queries the details of a microsegmentation defense rule.
 *
 * @param request GetInterceptionRuleDetailRequest
 * @return GetInterceptionRuleDetailResponse
 */
GetInterceptionRuleDetailResponse Client::getInterceptionRuleDetail(const GetInterceptionRuleDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getInterceptionRuleDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics of the container firewall feature.
 *
 * @param request GetInterceptionSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInterceptionSummaryResponse
 */
GetInterceptionSummaryResponse Client::getInterceptionSummaryWithOptions(const GetInterceptionSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetInterceptionSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetInterceptionSummaryResponse>();
}

/**
 * @summary Queries the statistics of the container firewall feature.
 *
 * @param request GetInterceptionSummaryRequest
 * @return GetInterceptionSummaryResponse
 */
GetInterceptionSummaryResponse Client::getInterceptionSummary(const GetInterceptionSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getInterceptionSummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the information about a specified network object that is protected by the container firewall feature.
 *
 * @param request GetInterceptionTargetDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInterceptionTargetDetailResponse
 */
GetInterceptionTargetDetailResponse Client::getInterceptionTargetDetailWithOptions(const GetInterceptionTargetDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTargetId()) {
    query["TargetId"] = request.targetId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetInterceptionTargetDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetInterceptionTargetDetailResponse>();
}

/**
 * @summary Queries the information about a specified network object that is protected by the container firewall feature.
 *
 * @param request GetInterceptionTargetDetailRequest
 * @return GetInterceptionTargetDetailResponse
 */
GetInterceptionTargetDetailResponse Client::getInterceptionTargetDetail(const GetInterceptionTargetDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getInterceptionTargetDetailWithOptions(request, runtime);
}

/**
 * @summary Queries information about the latest scan task to determine whether the task is complete.
 *
 * @param request GetLastOnceTaskInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLastOnceTaskInfoResponse
 */
GetLastOnceTaskInfoResponse Client::getLastOnceTaskInfoWithOptions(const GetLastOnceTaskInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasTaskName()) {
    query["TaskName"] = request.taskName();
  }

  if (!!request.hasTaskType()) {
    query["TaskType"] = request.taskType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetLastOnceTaskInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetLastOnceTaskInfoResponse>();
}

/**
 * @summary Queries information about the latest scan task to determine whether the task is complete.
 *
 * @param request GetLastOnceTaskInfoRequest
 * @return GetLastOnceTaskInfoResponse
 */
GetLastOnceTaskInfoResponse Client::getLastOnceTaskInfo(const GetLastOnceTaskInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getLastOnceTaskInfoWithOptions(request, runtime);
}

/**
 * @summary Obtains the default region for synchronizing assets outside Alibaba Cloud.
 *
 * @param request GetLocalDefaultRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLocalDefaultRegionResponse
 */
GetLocalDefaultRegionResponse Client::getLocalDefaultRegionWithOptions(const GetLocalDefaultRegionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetLocalDefaultRegion"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetLocalDefaultRegionResponse>();
}

/**
 * @summary Obtains the default region for synchronizing assets outside Alibaba Cloud.
 *
 * @param request GetLocalDefaultRegionRequest
 * @return GetLocalDefaultRegionResponse
 */
GetLocalDefaultRegionResponse Client::getLocalDefaultRegion(const GetLocalDefaultRegionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getLocalDefaultRegionWithOptions(request, runtime);
}

/**
 * @summary Queries the status of a data shipping task of a log.
 *
 * @param request GetLogMetaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLogMetaResponse
 */
GetLogMetaResponse Client::getLogMetaWithOptions(const GetLogMetaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLogStore()) {
    query["LogStore"] = request.logStore();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetLogMeta"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetLogMetaResponse>();
}

/**
 * @summary Queries the status of a data shipping task of a log.
 *
 * @param request GetLogMetaRequest
 * @return GetLogMetaResponse
 */
GetLogMetaResponse Client::getLogMeta(const GetLogMetaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getLogMetaWithOptions(request, runtime);
}

/**
 * @summary Queries an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request GetMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMaliciousFileWhitelistConfigResponse
 */
GetMaliciousFileWhitelistConfigResponse Client::getMaliciousFileWhitelistConfigWithOptions(const GetMaliciousFileWhitelistConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigId()) {
    query["ConfigId"] = request.configId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetMaliciousFileWhitelistConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetMaliciousFileWhitelistConfigResponse>();
}

/**
 * @summary Queries an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request GetMaliciousFileWhitelistConfigRequest
 * @return GetMaliciousFileWhitelistConfigResponse
 */
GetMaliciousFileWhitelistConfigResponse Client::getMaliciousFileWhitelistConfig(const GetMaliciousFileWhitelistConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of a module.
 *
 * @param request GetModuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetModuleConfigResponse
 */
GetModuleConfigResponse Client::getModuleConfigWithOptions(const GetModuleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetModuleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetModuleConfigResponse>();
}

/**
 * @summary Queries the configurations of a module.
 *
 * @param request GetModuleConfigRequest
 * @return GetModuleConfigResponse
 */
GetModuleConfigResponse Client::getModuleConfig(const GetModuleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getModuleConfigWithOptions(request, runtime);
}

/**
 * @summary Checks whether the purchased Security Center features are enabled and whether related configurations take effect.
 *
 * @param tmpReq GetModuleConfigStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetModuleConfigStatusResponse
 */
GetModuleConfigStatusResponse Client::getModuleConfigStatusWithOptions(const GetModuleConfigStatusRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  GetModuleConfigStatusShrinkRequest request = GetModuleConfigStatusShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasModuleNames()) {
    request.setModuleNamesShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.moduleNames(), "ModuleNames", "json"));
  }

  json query = {};
  if (!!request.hasModuleNamesShrink()) {
    query["ModuleNames"] = request.moduleNamesShrink();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetModuleConfigStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetModuleConfigStatusResponse>();
}

/**
 * @summary Checks whether the purchased Security Center features are enabled and whether related configurations take effect.
 *
 * @param request GetModuleConfigStatusRequest
 * @return GetModuleConfigStatusResponse
 */
GetModuleConfigStatusResponse Client::getModuleConfigStatus(const GetModuleConfigStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getModuleConfigStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the qualification information about the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
 *
 * @param request GetModuleTrialAuthInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetModuleTrialAuthInfoResponse
 */
GetModuleTrialAuthInfoResponse Client::getModuleTrialAuthInfoWithOptions(const GetModuleTrialAuthInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasModuleCode()) {
    query["ModuleCode"] = request.moduleCode();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetModuleTrialAuthInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetModuleTrialAuthInfoResponse>();
}

/**
 * @summary Queries the qualification information about the trial use of Security Center value-added features, including vulnerability fixing and threat analysis and response.
 *
 * @param request GetModuleTrialAuthInfoRequest
 * @return GetModuleTrialAuthInfoResponse
 */
GetModuleTrialAuthInfoResponse Client::getModuleTrialAuthInfo(const GetModuleTrialAuthInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getModuleTrialAuthInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the details of an alert event that is generated for a malicious object.
 *
 * @param request GetObjectScanEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetObjectScanEventResponse
 */
GetObjectScanEventResponse Client::getObjectScanEventWithOptions(const GetObjectScanEventRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventId()) {
    query["EventId"] = request.eventId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetObjectScanEvent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetObjectScanEventResponse>();
}

/**
 * @summary Queries the details of an alert event that is generated for a malicious object.
 *
 * @param request GetObjectScanEventRequest
 * @return GetObjectScanEventResponse
 */
GetObjectScanEventResponse Client::getObjectScanEvent(const GetObjectScanEventRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getObjectScanEventWithOptions(request, runtime);
}

/**
 * @summary Queries the execution result of a one-time scan task, such as asset fingerprint collection, vulnerability scan, and image security scan.
 *
 * @param request GetOnceTaskResultInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOnceTaskResultInfoResponse
 */
GetOnceTaskResultInfoResponse Client::getOnceTaskResultInfoWithOptions(const GetOnceTaskResultInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  if (!!request.hasTaskName()) {
    query["TaskName"] = request.taskName();
  }

  if (!!request.hasTaskType()) {
    query["TaskType"] = request.taskType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetOnceTaskResultInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetOnceTaskResultInfoResponse>();
}

/**
 * @summary Queries the execution result of a one-time scan task, such as asset fingerprint collection, vulnerability scan, and image security scan.
 *
 * @param request GetOnceTaskResultInfoRequest
 * @return GetOnceTaskResultInfoResponse
 */
GetOnceTaskResultInfoResponse Client::getOnceTaskResultInfo(const GetOnceTaskResultInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getOnceTaskResultInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the baselines that are supported by at-risk image blocking.
 *
 * @param request GetOpaClusterBaseLineListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaClusterBaseLineListResponse
 */
GetOpaClusterBaseLineListResponse Client::getOpaClusterBaseLineListWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetOpaClusterBaseLineList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetOpaClusterBaseLineListResponse>();
}

/**
 * @summary Queries the baselines that are supported by at-risk image blocking.
 *
 * @return GetOpaClusterBaseLineListResponse
 */
GetOpaClusterBaseLineListResponse Client::getOpaClusterBaseLineList() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getOpaClusterBaseLineListWithOptions(runtime);
}

/**
 * @summary 查询集群镜像
 *
 * @param request GetOpaClusterImageListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaClusterImageListResponse
 */
GetOpaClusterImageListResponse Client::getOpaClusterImageListWithOptions(const GetOpaClusterImageListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImageName()) {
    query["ImageName"] = request.imageName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetOpaClusterImageList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetOpaClusterImageListResponse>();
}

/**
 * @summary 查询集群镜像
 *
 * @param request GetOpaClusterImageListRequest
 * @return GetOpaClusterImageListResponse
 */
GetOpaClusterImageListResponse Client::getOpaClusterImageList(const GetOpaClusterImageListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getOpaClusterImageListWithOptions(request, runtime);
}

/**
 * @summary Queries information about the tags that are added to containers based on the feature of proactive defense for containers.
 *
 * @param request GetOpaClusterLabelListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaClusterLabelListResponse
 */
GetOpaClusterLabelListResponse Client::getOpaClusterLabelListWithOptions(const GetOpaClusterLabelListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasTagName()) {
    query["TagName"] = request.tagName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetOpaClusterLabelList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetOpaClusterLabelListResponse>();
}

/**
 * @summary Queries information about the tags that are added to containers based on the feature of proactive defense for containers.
 *
 * @param request GetOpaClusterLabelListRequest
 * @return GetOpaClusterLabelListResponse
 */
GetOpaClusterLabelListResponse Client::getOpaClusterLabelList(const GetOpaClusterLabelListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getOpaClusterLabelListWithOptions(request, runtime);
}

/**
 * @summary Queries information about the namespaces of clusters for which the rules of the at-risk image blocking type are configured in proactive defense for containers.
 *
 * @param request GetOpaClusterNamespaceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaClusterNamespaceListResponse
 */
GetOpaClusterNamespaceListResponse Client::getOpaClusterNamespaceListWithOptions(const GetOpaClusterNamespaceListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasNameSpaceName()) {
    query["NameSpaceName"] = request.nameSpaceName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetOpaClusterNamespaceList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetOpaClusterNamespaceListResponse>();
}

/**
 * @summary Queries information about the namespaces of clusters for which the rules of the at-risk image blocking type are configured in proactive defense for containers.
 *
 * @param request GetOpaClusterNamespaceListRequest
 * @return GetOpaClusterNamespaceListResponse
 */
GetOpaClusterNamespaceListResponse Client::getOpaClusterNamespaceList(const GetOpaClusterNamespaceListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getOpaClusterNamespaceListWithOptions(request, runtime);
}

/**
 * @summary Queries the installation status of the components that are required for clusters protected by proactive defense for containers.
 *
 * @param request GetOpaPluginStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaPluginStatusResponse
 */
GetOpaPluginStatusResponse Client::getOpaPluginStatusWithOptions(const GetOpaPluginStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterIds()) {
    query["ClusterIds"] = request.clusterIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetOpaPluginStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetOpaPluginStatusResponse>();
}

/**
 * @summary Queries the installation status of the components that are required for clusters protected by proactive defense for containers.
 *
 * @param request GetOpaPluginStatusRequest
 * @return GetOpaPluginStatusResponse
 */
GetOpaPluginStatusResponse Client::getOpaPluginStatus(const GetOpaPluginStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getOpaPluginStatusWithOptions(request, runtime);
}

/**
 * @summary Queries the details of the rule that is used to block at-risk images.
 *
 * @param request GetOpaStrategyDetailNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaStrategyDetailNewResponse
 */
GetOpaStrategyDetailNewResponse Client::getOpaStrategyDetailNewWithOptions(const GetOpaStrategyDetailNewRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetOpaStrategyDetailNew"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetOpaStrategyDetailNewResponse>();
}

/**
 * @summary Queries the details of the rule that is used to block at-risk images.
 *
 * @param request GetOpaStrategyDetailNewRequest
 * @return GetOpaStrategyDetailNewResponse
 */
GetOpaStrategyDetailNewResponse Client::getOpaStrategyDetailNew(const GetOpaStrategyDetailNewRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getOpaStrategyDetailNewWithOptions(request, runtime);
}

/**
 * @summary Queries the usage statistics about the templates provided in the feature of proactive defense for containers for rules of the at-risk image blocking type.
 *
 * @param request GetOpaStrategyTemplateSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpaStrategyTemplateSummaryResponse
 */
GetOpaStrategyTemplateSummaryResponse Client::getOpaStrategyTemplateSummaryWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetOpaStrategyTemplateSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetOpaStrategyTemplateSummaryResponse>();
}

/**
 * @summary Queries the usage statistics about the templates provided in the feature of proactive defense for containers for rules of the at-risk image blocking type.
 *
 * @return GetOpaStrategyTemplateSummaryResponse
 */
GetOpaStrategyTemplateSummaryResponse Client::getOpaStrategyTemplateSummary() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getOpaStrategyTemplateSummaryWithOptions(runtime);
}

/**
 * @summary Queries the statistics about an Object Storage Service (OSS) bucket check.
 *
 * @param request GetOssBucketScanStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOssBucketScanStatisticResponse
 */
GetOssBucketScanStatisticResponse Client::getOssBucketScanStatisticWithOptions(const GetOssBucketScanStatisticRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBucketNameList()) {
    query["BucketNameList"] = request.bucketNameList();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetOssBucketScanStatistic"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetOssBucketScanStatisticResponse>();
}

/**
 * @summary Queries the statistics about an Object Storage Service (OSS) bucket check.
 *
 * @param request GetOssBucketScanStatisticRequest
 * @return GetOssBucketScanStatisticResponse
 */
GetOssBucketScanStatisticResponse Client::getOssBucketScanStatistic(const GetOssBucketScanStatisticRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getOssBucketScanStatisticWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of an Object Storage Service (OSS) bucket check policy.
 *
 * @param request GetOssScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOssScanConfigResponse
 */
GetOssScanConfigResponse Client::getOssScanConfigWithOptions(const GetOssScanConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBucketName()) {
    query["BucketName"] = request.bucketName();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetOssScanConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetOssScanConfigResponse>();
}

/**
 * @summary Queries the configurations of an Object Storage Service (OSS) bucket check policy.
 *
 * @param request GetOssScanConfigRequest
 * @return GetOssScanConfigResponse
 */
GetOssScanConfigResponse Client::getOssScanConfig(const GetOssScanConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getOssScanConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations for the collection frequency of asset fingerprints.
 *
 * @param request GetPropertyScheduleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPropertyScheduleConfigResponse
 */
GetPropertyScheduleConfigResponse Client::getPropertyScheduleConfigWithOptions(const GetPropertyScheduleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetPropertyScheduleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetPropertyScheduleConfigResponse>();
}

/**
 * @summary Queries the configurations for the collection frequency of asset fingerprints.
 *
 * @param request GetPropertyScheduleConfigRequest
 * @return GetPropertyScheduleConfigResponse
 */
GetPropertyScheduleConfigResponse Client::getPropertyScheduleConfig(const GetPropertyScheduleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getPropertyScheduleConfigWithOptions(request, runtime);
}

/**
 * @summary Get Publish Time Configuration
 *
 * @param request GetPublishCronRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPublishCronResponse
 */
GetPublishCronResponse Client::getPublishCronWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetPublishCron"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetPublishCronResponse>();
}

/**
 * @summary Get Publish Time Configuration
 *
 * @return GetPublishCronResponse
 */
GetPublishCronResponse Client::getPublishCron() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getPublishCronWithOptions(runtime);
}

/**
 * @summary Queries the organizational structure of a resource directory by using the multi-account management feature.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @param request GetRdTreeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRdTreeResponse
 */
GetRdTreeResponse Client::getRdTreeWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetRdTree"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetRdTreeResponse>();
}

/**
 * @summary Queries the organizational structure of a resource directory by using the multi-account management feature.
 *
 * @description You can call this operation only by using the management account of a resource directory or a delegated administrator account of Security Center.
 *
 * @return GetRdTreeResponse
 */
GetRdTreeResponse Client::getRdTree() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getRdTreeWithOptions(runtime);
}

/**
 * @summary Query Image Scan Period.
 *
 * @param request GetRegistryScanDayNumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRegistryScanDayNumResponse
 */
GetRegistryScanDayNumResponse Client::getRegistryScanDayNumWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetRegistryScanDayNum"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetRegistryScanDayNumResponse>();
}

/**
 * @summary Query Image Scan Period.
 *
 * @return GetRegistryScanDayNumResponse
 */
GetRegistryScanDayNumResponse Client::getRegistryScanDayNum() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getRegistryScanDayNumWithOptions(runtime);
}

/**
 * @summary Queries the numbers of system defense rules and custom defense rules.
 *
 * @param request GetRulesCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRulesCountResponse
 */
GetRulesCountResponse Client::getRulesCountWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetRulesCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetRulesCountResponse>();
}

/**
 * @summary Queries the numbers of system defense rules and custom defense rules.
 *
 * @return GetRulesCountResponse
 */
GetRulesCountResponse Client::getRulesCount() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getRulesCountWithOptions(runtime);
}

/**
 * @summary Get Container File Defense Rule Details.
 *
 * @param request GetSasContainerWebDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSasContainerWebDefenseRuleResponse
 */
GetSasContainerWebDefenseRuleResponse Client::getSasContainerWebDefenseRuleWithOptions(const GetSasContainerWebDefenseRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetSasContainerWebDefenseRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetSasContainerWebDefenseRuleResponse>();
}

/**
 * @summary Get Container File Defense Rule Details.
 *
 * @param request GetSasContainerWebDefenseRuleRequest
 * @return GetSasContainerWebDefenseRuleResponse
 */
GetSasContainerWebDefenseRuleResponse Client::getSasContainerWebDefenseRule(const GetSasContainerWebDefenseRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getSasContainerWebDefenseRuleWithOptions(request, runtime);
}

/**
 * @summary Queries the applications that are specified in a rule for container tamper-proofing.
 *
 * @param request GetSasContainerWebDefenseRuleApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSasContainerWebDefenseRuleApplicationResponse
 */
GetSasContainerWebDefenseRuleApplicationResponse Client::getSasContainerWebDefenseRuleApplicationWithOptions(const GetSasContainerWebDefenseRuleApplicationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetSasContainerWebDefenseRuleApplication"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetSasContainerWebDefenseRuleApplicationResponse>();
}

/**
 * @summary Queries the applications that are specified in a rule for container tamper-proofing.
 *
 * @param request GetSasContainerWebDefenseRuleApplicationRequest
 * @return GetSasContainerWebDefenseRuleApplicationResponse
 */
GetSasContainerWebDefenseRuleApplicationResponse Client::getSasContainerWebDefenseRuleApplication(const GetSasContainerWebDefenseRuleApplicationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getSasContainerWebDefenseRuleApplicationWithOptions(request, runtime);
}

/**
 * @summary Queries search conditions that can be used to search for container file protection rules.
 *
 * @param request GetSasContainerWebDefenseRuleCriteriaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSasContainerWebDefenseRuleCriteriaResponse
 */
GetSasContainerWebDefenseRuleCriteriaResponse Client::getSasContainerWebDefenseRuleCriteriaWithOptions(const GetSasContainerWebDefenseRuleCriteriaRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasValue()) {
    query["Value"] = request.value();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetSasContainerWebDefenseRuleCriteria"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetSasContainerWebDefenseRuleCriteriaResponse>();
}

/**
 * @summary Queries search conditions that can be used to search for container file protection rules.
 *
 * @param request GetSasContainerWebDefenseRuleCriteriaRequest
 * @return GetSasContainerWebDefenseRuleCriteriaResponse
 */
GetSasContainerWebDefenseRuleCriteriaResponse Client::getSasContainerWebDefenseRuleCriteria(const GetSasContainerWebDefenseRuleCriteriaRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getSasContainerWebDefenseRuleCriteriaWithOptions(request, runtime);
}

/**
 * @summary Queries the details of the deduction modules of the security score feature, including custom settings.
 *
 * @param request GetSecurityScoreRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSecurityScoreRuleResponse
 */
GetSecurityScoreRuleResponse Client::getSecurityScoreRuleWithOptions(const GetSecurityScoreRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCalType()) {
    query["CalType"] = request.calType();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetSecurityScoreRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetSecurityScoreRuleResponse>();
}

/**
 * @summary Queries the details of the deduction modules of the security score feature, including custom settings.
 *
 * @param request GetSecurityScoreRuleRequest
 * @return GetSecurityScoreRuleResponse
 */
GetSecurityScoreRuleResponse Client::getSecurityScoreRule(const GetSecurityScoreRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getSecurityScoreRuleWithOptions(request, runtime);
}

/**
 * @summary Queries the check rules of sensitive files.
 *
 * @param request GetSensitiveDefineRuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSensitiveDefineRuleConfigResponse
 */
GetSensitiveDefineRuleConfigResponse Client::getSensitiveDefineRuleConfigWithOptions(const GetSensitiveDefineRuleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetSensitiveDefineRuleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetSensitiveDefineRuleConfigResponse>();
}

/**
 * @summary Queries the check rules of sensitive files.
 *
 * @param request GetSensitiveDefineRuleConfigRequest
 * @return GetSensitiveDefineRuleConfigResponse
 */
GetSensitiveDefineRuleConfigResponse Client::getSensitiveDefineRuleConfig(const GetSensitiveDefineRuleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getSensitiveDefineRuleConfigWithOptions(request, runtime);
}

/**
 * @summary Get Serverless Application Authorization Details
 *
 * @param request GetServerlessAppAuthDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServerlessAppAuthDetailResponse
 */
GetServerlessAppAuthDetailResponse Client::getServerlessAppAuthDetailWithOptions(const GetServerlessAppAuthDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppId()) {
    query["AppId"] = request.appId();
  }

  if (!!request.hasAppRegionId()) {
    query["AppRegionId"] = request.appRegionId();
  }

  if (!!request.hasMachineType()) {
    query["MachineType"] = request.machineType();
  }

  if (!!request.hasVendorType()) {
    query["VendorType"] = request.vendorType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetServerlessAppAuthDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetServerlessAppAuthDetailResponse>();
}

/**
 * @summary Get Serverless Application Authorization Details
 *
 * @param request GetServerlessAppAuthDetailRequest
 * @return GetServerlessAppAuthDetailResponse
 */
GetServerlessAppAuthDetailResponse Client::getServerlessAppAuthDetail(const GetServerlessAppAuthDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getServerlessAppAuthDetailWithOptions(request, runtime);
}

/**
 * @summary Get Serverless Authorization Overview
 *
 * @param request GetServerlessAuthSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServerlessAuthSummaryResponse
 */
GetServerlessAuthSummaryResponse Client::getServerlessAuthSummaryWithOptions(const GetServerlessAuthSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppRegionId()) {
    query["AppRegionId"] = request.appRegionId();
  }

  if (!!request.hasMachineType()) {
    query["MachineType"] = request.machineType();
  }

  if (!!request.hasVendorType()) {
    query["VendorType"] = request.vendorType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetServerlessAuthSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetServerlessAuthSummaryResponse>();
}

/**
 * @summary Get Serverless Authorization Overview
 *
 * @param request GetServerlessAuthSummaryRequest
 * @return GetServerlessAuthSummaryResponse
 */
GetServerlessAuthSummaryResponse Client::getServerlessAuthSummary(const GetServerlessAuthSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getServerlessAuthSummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the service trail that was delivered to ActionTrail.
 *
 * @param request GetServiceTrailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServiceTrailResponse
 */
GetServiceTrailResponse Client::getServiceTrailWithOptions(const GetServiceTrailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetServiceTrail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetServiceTrailResponse>();
}

/**
 * @summary Queries the service trail that was delivered to ActionTrail.
 *
 * @param request GetServiceTrailRequest
 * @return GetServiceTrailResponse
 */
GetServiceTrailResponse Client::getServiceTrail(const GetServiceTrailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getServiceTrailWithOptions(request, runtime);
}

/**
 * @summary Queries the usage details of templates provided in the feature of proactive defense for containers for rules.
 *
 * @param request GetStrategyTemplateDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetStrategyTemplateDetailResponse
 */
GetStrategyTemplateDetailResponse Client::getStrategyTemplateDetailWithOptions(const GetStrategyTemplateDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetStrategyTemplateDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetStrategyTemplateDetailResponse>();
}

/**
 * @summary Queries the usage details of templates provided in the feature of proactive defense for containers for rules.
 *
 * @param request GetStrategyTemplateDetailRequest
 * @return GetStrategyTemplateDetailResponse
 */
GetStrategyTemplateDetailResponse Client::getStrategyTemplateDetail(const GetStrategyTemplateDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getStrategyTemplateDetailWithOptions(request, runtime);
}

/**
 * @summary Get the list of modules supported by authorization.
 *
 * @param request GetSupportedModulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSupportedModulesResponse
 */
GetSupportedModulesResponse Client::getSupportedModulesWithOptions(const GetSupportedModulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetSupportedModules"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetSupportedModulesResponse>();
}

/**
 * @summary Get the list of modules supported by authorization.
 *
 * @param request GetSupportedModulesRequest
 * @return GetSupportedModulesResponse
 */
GetSupportedModulesResponse Client::getSupportedModules(const GetSupportedModulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getSupportedModulesWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics on alerts in one or more asset groups.
 *
 * @param request GetSuspiciousStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSuspiciousStatisticsResponse
 */
GetSuspiciousStatisticsResponse Client::getSuspiciousStatisticsWithOptions(const GetSuspiciousStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGroupIdList()) {
    query["GroupIdList"] = request.groupIdList();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetSuspiciousStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetSuspiciousStatisticsResponse>();
}

/**
 * @summary Queries the statistics on alerts in one or more asset groups.
 *
 * @param request GetSuspiciousStatisticsRequest
 * @return GetSuspiciousStatisticsResponse
 */
GetSuspiciousStatisticsResponse Client::getSuspiciousStatistics(const GetSuspiciousStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getSuspiciousStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries the details of a migration operation. For example, you can query the progress and status of a migration operation after you migrate a server from a region in the Chinese mainland to the Singapore region.
 *
 * @param request GetSwitchRegionDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSwitchRegionDetailResponse
 */
GetSwitchRegionDetailResponse Client::getSwitchRegionDetailWithOptions(const GetSwitchRegionDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetSwitchRegionDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetSwitchRegionDetailResponse>();
}

/**
 * @summary Queries the details of a migration operation. For example, you can query the progress and status of a migration operation after you migrate a server from a region in the Chinese mainland to the Singapore region.
 *
 * @param request GetSwitchRegionDetailRequest
 * @return GetSwitchRegionDetailResponse
 */
GetSwitchRegionDetailResponse Client::getSwitchRegionDetail(const GetSwitchRegionDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getSwitchRegionDetailWithOptions(request, runtime);
}

/**
 * @summary Checks whether you can submit a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
 *
 * @param request GetTenantCheckAvailableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTenantCheckAvailableResponse
 */
GetTenantCheckAvailableResponse Client::getTenantCheckAvailableWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetTenantCheckAvailable"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetTenantCheckAvailableResponse>();
}

/**
 * @summary Checks whether you can submit a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
 *
 * @return GetTenantCheckAvailableResponse
 */
GetTenantCheckAvailableResponse Client::getTenantCheckAvailable() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getTenantCheckAvailableWithOptions(runtime);
}

/**
 * @summary Queries the language settings of log analysis.
 *
 * @param request GetUserLangRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUserLangResponse
 */
GetUserLangResponse Client::getUserLangWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetUserLang"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetUserLangResponse>();
}

/**
 * @summary Queries the language settings of log analysis.
 *
 * @return GetUserLangResponse
 */
GetUserLangResponse Client::getUserLang() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getUserLangWithOptions(runtime);
}

/**
 * @summary Queries the configurations of a periodic virus scan task.
 *
 * @param request GetVirusScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVirusScanConfigResponse
 */
GetVirusScanConfigResponse Client::getVirusScanConfigWithOptions(const GetVirusScanConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTaskType()) {
    query["TaskType"] = request.taskType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetVirusScanConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetVirusScanConfigResponse>();
}

/**
 * @summary Queries the configurations of a periodic virus scan task.
 *
 * @param request GetVirusScanConfigRequest
 * @return GetVirusScanConfigResponse
 */
GetVirusScanConfigResponse Client::getVirusScanConfig(const GetVirusScanConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getVirusScanConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the latest virus scan task.
 *
 * @param request GetVirusScanLatestTaskStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVirusScanLatestTaskStatisticResponse
 */
GetVirusScanLatestTaskStatisticResponse Client::getVirusScanLatestTaskStatisticWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "GetVirusScanLatestTaskStatistic"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetVirusScanLatestTaskStatisticResponse>();
}

/**
 * @summary Queries the information about the latest virus scan task.
 *
 * @return GetVirusScanLatestTaskStatisticResponse
 */
GetVirusScanLatestTaskStatisticResponse Client::getVirusScanLatestTaskStatistic() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getVirusScanLatestTaskStatisticWithOptions(runtime);
}

/**
 * @summary Queries the statistics on vulnerabilities in asset groups.
 *
 * @param request GetVulStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVulStatisticsResponse
 */
GetVulStatisticsResponse Client::getVulStatisticsWithOptions(const GetVulStatisticsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGroupIdList()) {
    query["GroupIdList"] = request.groupIdList();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTypeList()) {
    query["TypeList"] = request.typeList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetVulStatistics"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetVulStatisticsResponse>();
}

/**
 * @summary Queries the statistics on vulnerabilities in asset groups.
 *
 * @param request GetVulStatisticsRequest
 * @return GetVulStatisticsResponse
 */
GetVulStatisticsResponse Client::getVulStatistics(const GetVulStatisticsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getVulStatisticsWithOptions(request, runtime);
}

/**
 * @summary Queries information about a vulnerability whitelist.
 *
 * @param request GetVulWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVulWhitelistResponse
 */
GetVulWhitelistResponse Client::getVulWhitelistWithOptions(const GetVulWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasVulWhitelistId()) {
    query["VulWhitelistId"] = request.vulWhitelistId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GetVulWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GetVulWhitelistResponse>();
}

/**
 * @summary Queries information about a vulnerability whitelist.
 *
 * @param request GetVulWhitelistRequest
 * @return GetVulWhitelistResponse
 */
GetVulWhitelistResponse Client::getVulWhitelist(const GetVulWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return getVulWhitelistWithOptions(request, runtime);
}

/**
 * @summary Authorization for Switching Migration
 *
 * @param request GrantSwitchAgreementRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantSwitchAgreementResponse
 */
GrantSwitchAgreementResponse Client::grantSwitchAgreementWithOptions(const GrantSwitchAgreementRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIsAgree()) {
    query["IsAgree"] = request.isAgree();
  }

  if (!!request.hasIsConfirmed()) {
    query["IsConfirmed"] = request.isConfirmed();
  }

  if (!!request.hasIsImmediate()) {
    query["IsImmediate"] = request.isImmediate();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "GrantSwitchAgreement"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<GrantSwitchAgreementResponse>();
}

/**
 * @summary Authorization for Switching Migration
 *
 * @param request GrantSwitchAgreementRequest
 * @return GrantSwitchAgreementResponse
 */
GrantSwitchAgreementResponse Client::grantSwitchAgreement(const GrantSwitchAgreementRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return grantSwitchAgreementWithOptions(request, runtime);
}

/**
 * @summary Handle Malicious Files
 *
 * @param request HandleMaliciousFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return HandleMaliciousFilesResponse
 */
HandleMaliciousFilesResponse Client::handleMaliciousFilesWithOptions(const HandleMaliciousFilesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFileIdList()) {
    query["FileIdList"] = request.fileIdList();
  }

  if (!!request.hasOperation()) {
    query["Operation"] = request.operation();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "HandleMaliciousFiles"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<HandleMaliciousFilesResponse>();
}

/**
 * @summary Handle Malicious Files
 *
 * @param request HandleMaliciousFilesRequest
 * @return HandleMaliciousFilesResponse
 */
HandleMaliciousFilesResponse Client::handleMaliciousFiles(const HandleMaliciousFilesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return handleMaliciousFilesWithOptions(request, runtime);
}

/**
 * @summary Handles alert events.
 *
 * @param request HandleSecurityEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return HandleSecurityEventsResponse
 */
HandleSecurityEventsResponse Client::handleSecurityEventsWithOptions(const HandleSecurityEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMarkBatch()) {
    query["MarkBatch"] = request.markBatch();
  }

  if (!!request.hasMarkMissParam()) {
    query["MarkMissParam"] = request.markMissParam();
  }

  if (!!request.hasOperationCode()) {
    query["OperationCode"] = request.operationCode();
  }

  if (!!request.hasOperationParams()) {
    query["OperationParams"] = request.operationParams();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasSecurityEventIds()) {
    query["SecurityEventIds"] = request.securityEventIds();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "HandleSecurityEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<HandleSecurityEventsResponse>();
}

/**
 * @summary Handles alert events.
 *
 * @param request HandleSecurityEventsRequest
 * @return HandleSecurityEventsResponse
 */
HandleSecurityEventsResponse Client::handleSecurityEvents(const HandleSecurityEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return handleSecurityEventsWithOptions(request, runtime);
}

/**
 * @summary Handles multiple alert events that are triggered by the same IP address rule or IP address rules of the same type at a time.
 *
 * @param request HandleSimilarSecurityEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return HandleSimilarSecurityEventsResponse
 */
HandleSimilarSecurityEventsResponse Client::handleSimilarSecurityEventsWithOptions(const HandleSimilarSecurityEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMarkMissParam()) {
    query["MarkMissParam"] = request.markMissParam();
  }

  if (!!request.hasOperationCode()) {
    query["OperationCode"] = request.operationCode();
  }

  if (!!request.hasOperationParams()) {
    query["OperationParams"] = request.operationParams();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "HandleSimilarSecurityEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<HandleSimilarSecurityEventsResponse>();
}

/**
 * @summary Handles multiple alert events that are triggered by the same IP address rule or IP address rules of the same type at a time.
 *
 * @param request HandleSimilarSecurityEventsRequest
 * @return HandleSimilarSecurityEventsResponse
 */
HandleSimilarSecurityEventsResponse Client::handleSimilarSecurityEvents(const HandleSimilarSecurityEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return handleSimilarSecurityEventsWithOptions(request, runtime);
}

/**
 * @summary Adds risk items to the whitelist or removes risk items from the whitelist by specifying servers and risk items.
 *
 * @param request IgnoreCheckItemsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return IgnoreCheckItemsResponse
 */
IgnoreCheckItemsResponse Client::ignoreCheckItemsWithOptions(const IgnoreCheckItemsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckAndRiskTypeList()) {
    query["CheckAndRiskTypeList"] = request.checkAndRiskTypeList();
  }

  if (!!request.hasCheckIds()) {
    query["CheckIds"] = request.checkIds();
  }

  if (!!request.hasContainerItems()) {
    query["ContainerItems"] = request.containerItems();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasReason()) {
    query["Reason"] = request.reason();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "IgnoreCheckItems"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<IgnoreCheckItemsResponse>();
}

/**
 * @summary Adds risk items to the whitelist or removes risk items from the whitelist by specifying servers and risk items.
 *
 * @param request IgnoreCheckItemsRequest
 * @return IgnoreCheckItemsResponse
 */
IgnoreCheckItemsResponse Client::ignoreCheckItems(const IgnoreCheckItemsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return ignoreCheckItemsWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI IgnoreHcCheckWarnings is deprecated, please use Sas::2018-12-03::IgnoreCheckItems instead.
 *
 * @summary Ignores multiple baseline risk items at a time or cancels the ignore action that is performed on multiple baseline risk items at a time.
 *
 * @param request IgnoreHcCheckWarningsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return IgnoreHcCheckWarningsResponse
 */
IgnoreHcCheckWarningsResponse Client::ignoreHcCheckWarningsWithOptions(const IgnoreHcCheckWarningsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckIds()) {
    query["CheckIds"] = request.checkIds();
  }

  if (!!request.hasCheckWarningIds()) {
    query["CheckWarningIds"] = request.checkWarningIds();
  }

  if (!!request.hasReason()) {
    query["Reason"] = request.reason();
  }

  if (!!request.hasRiskId()) {
    query["RiskId"] = request.riskId();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "IgnoreHcCheckWarnings"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<IgnoreHcCheckWarningsResponse>();
}

/**
 * @deprecated OpenAPI IgnoreHcCheckWarnings is deprecated, please use Sas::2018-12-03::IgnoreCheckItems instead.
 *
 * @summary Ignores multiple baseline risk items at a time or cancels the ignore action that is performed on multiple baseline risk items at a time.
 *
 * @param request IgnoreHcCheckWarningsRequest
 * @return IgnoreHcCheckWarningsResponse
 */
IgnoreHcCheckWarningsResponse Client::ignoreHcCheckWarnings(const IgnoreHcCheckWarningsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return ignoreHcCheckWarningsWithOptions(request, runtime);
}

/**
 * @summary Adds the result scanned by an IDC probe to the whitelist or ignores the scan result.
 *
 * @param request IgnoreIdcProbeScanResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return IgnoreIdcProbeScanResultResponse
 */
IgnoreIdcProbeScanResultResponse Client::ignoreIdcProbeScanResultWithOptions(const IgnoreIdcProbeScanResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIgnoreAction()) {
    query["IgnoreAction"] = request.ignoreAction();
  }

  if (!!request.hasScanResultIds()) {
    query["ScanResultIds"] = request.scanResultIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "IgnoreIdcProbeScanResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<IgnoreIdcProbeScanResultResponse>();
}

/**
 * @summary Adds the result scanned by an IDC probe to the whitelist or ignores the scan result.
 *
 * @param request IgnoreIdcProbeScanResultRequest
 * @return IgnoreIdcProbeScanResultResponse
 */
IgnoreIdcProbeScanResultResponse Client::ignoreIdcProbeScanResult(const IgnoreIdcProbeScanResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return ignoreIdcProbeScanResultWithOptions(request, runtime);
}

/**
 * @summary Install Aegis client on Lingjun bare metal.
 *
 * @param tmpReq InstallAegisForLingjunRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallAegisForLingjunResponse
 */
InstallAegisForLingjunResponse Client::installAegisForLingjunWithOptions(const InstallAegisForLingjunRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  InstallAegisForLingjunShrinkRequest request = InstallAegisForLingjunShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasUuids()) {
    request.setUuidsShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.uuids(), "Uuids", "json"));
  }

  json query = {};
  if (!!request.hasUuidsShrink()) {
    query["Uuids"] = request.uuidsShrink();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "InstallAegisForLingjun"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<InstallAegisForLingjunResponse>();
}

/**
 * @summary Install Aegis client on Lingjun bare metal.
 *
 * @param request InstallAegisForLingjunRequest
 * @return InstallAegisForLingjunResponse
 */
InstallAegisForLingjunResponse Client::installAegisForLingjun(const InstallAegisForLingjunRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return installAegisForLingjunWithOptions(request, runtime);
}

/**
 * @summary Installs the anti-ransomware agent.
 *
 * @param request InstallBackupClientRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallBackupClientResponse
 */
InstallBackupClientResponse Client::installBackupClientWithOptions(const InstallBackupClientRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPolicyVersion()) {
    query["PolicyVersion"] = request.policyVersion();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "InstallBackupClient"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<InstallBackupClientResponse>();
}

/**
 * @summary Installs the anti-ransomware agent.
 *
 * @param request InstallBackupClientRequest
 * @return InstallBackupClientResponse
 */
InstallBackupClientResponse Client::installBackupClient(const InstallBackupClientRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return installBackupClientWithOptions(request, runtime);
}

/**
 * @summary Installs the CloudMonitor agent on specified servers.
 *
 * @description > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
 *
 * @param request InstallCloudMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallCloudMonitorResponse
 */
InstallCloudMonitorResponse Client::installCloudMonitorWithOptions(const InstallCloudMonitorRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAgentAccessKey()) {
    query["AgentAccessKey"] = request.agentAccessKey();
  }

  if (!!request.hasAgentSecretKey()) {
    query["AgentSecretKey"] = request.agentSecretKey();
  }

  if (!!request.hasArgusVersion()) {
    query["ArgusVersion"] = request.argusVersion();
  }

  if (!!request.hasInstanceIdList()) {
    query["InstanceIdList"] = request.instanceIdList();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "InstallCloudMonitor"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<InstallCloudMonitorResponse>();
}

/**
 * @summary Installs the CloudMonitor agent on specified servers.
 *
 * @description > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
 *
 * @param request InstallCloudMonitorRequest
 * @return InstallCloudMonitorResponse
 */
InstallCloudMonitorResponse Client::installCloudMonitor(const InstallCloudMonitorRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return installCloudMonitorWithOptions(request, runtime);
}

/**
 * @summary Installs the Security Center agent on a proxy server in a hybrid cloud.
 *
 * @param request InstallHybridProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallHybridProxyResponse
 */
InstallHybridProxyResponse Client::installHybridProxyWithOptions(const InstallHybridProxyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasInstallCode()) {
    query["InstallCode"] = request.installCode();
  }

  if (!!request.hasYundunUuids()) {
    query["YundunUuids"] = request.yundunUuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "InstallHybridProxy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<InstallHybridProxyResponse>();
}

/**
 * @summary Installs the Security Center agent on a proxy server in a hybrid cloud.
 *
 * @param request InstallHybridProxyRequest
 * @return InstallHybridProxyResponse
 */
InstallHybridProxyResponse Client::installHybridProxy(const InstallHybridProxyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return installHybridProxyWithOptions(request, runtime);
}

/**
 * @summary Installs the CloudMonitor agent on a server that is not deployed on Alibaba Cloud.
 *
 * @param request InstallPmAgentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallPmAgentResponse
 */
InstallPmAgentResponse Client::installPmAgentWithOptions(const InstallPmAgentRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "InstallPmAgent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<InstallPmAgentResponse>();
}

/**
 * @summary Installs the CloudMonitor agent on a server that is not deployed on Alibaba Cloud.
 *
 * @param request InstallPmAgentRequest
 * @return InstallPmAgentResponse
 */
InstallPmAgentResponse Client::installPmAgent(const InstallPmAgentRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return installPmAgentWithOptions(request, runtime);
}

/**
 * @summary Installs the anti-ransomware agent for databases.
 *
 * @param request InstallUniBackupAgentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallUniBackupAgentResponse
 */
InstallUniBackupAgentResponse Client::installUniBackupAgentWithOptions(const InstallUniBackupAgentRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPolicyId()) {
    query["PolicyId"] = request.policyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "InstallUniBackupAgent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<InstallUniBackupAgentResponse>();
}

/**
 * @summary Installs the anti-ransomware agent for databases.
 *
 * @param request InstallUniBackupAgentRequest
 * @return InstallUniBackupAgentResponse
 */
InstallUniBackupAgentResponse Client::installUniBackupAgent(const InstallUniBackupAgentRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return installUniBackupAgentWithOptions(request, runtime);
}

/**
 * @summary Adds processes to the process whitelist of web tamper proofing.
 *
 * @param request JoinWebLockProcessWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return JoinWebLockProcessWhiteListResponse
 */
JoinWebLockProcessWhiteListResponse Client::joinWebLockProcessWhiteListWithOptions(const JoinWebLockProcessWhiteListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasProcessPaths()) {
    query["ProcessPaths"] = request.processPaths();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "JoinWebLockProcessWhiteList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<JoinWebLockProcessWhiteListResponse>();
}

/**
 * @summary Adds processes to the process whitelist of web tamper proofing.
 *
 * @param request JoinWebLockProcessWhiteListRequest
 * @return JoinWebLockProcessWhiteListResponse
 */
JoinWebLockProcessWhiteListResponse Client::joinWebLockProcessWhiteList(const JoinWebLockProcessWhiteListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return joinWebLockProcessWhiteListWithOptions(request, runtime);
}

/**
 * @summary Queries members in the resource directory that is involved when the multi-account management feature is enabled.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @param request ListAccountsInResourceDirectoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAccountsInResourceDirectoryResponse
 */
ListAccountsInResourceDirectoryResponse Client::listAccountsInResourceDirectoryWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListAccountsInResourceDirectory"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAccountsInResourceDirectoryResponse>();
}

/**
 * @summary Queries members in the resource directory that is involved when the multi-account management feature is enabled.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @return ListAccountsInResourceDirectoryResponse
 */
ListAccountsInResourceDirectoryResponse Client::listAccountsInResourceDirectory() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAccountsInResourceDirectoryWithOptions(runtime);
}

/**
 * @summary Queries defense rules against container escapes.
 *
 * @param request ListAegisContainerPluginRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAegisContainerPluginRuleResponse
 */
ListAegisContainerPluginRuleResponse Client::listAegisContainerPluginRuleWithOptions(const ListAegisContainerPluginRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAegisContainerPluginRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAegisContainerPluginRuleResponse>();
}

/**
 * @summary Queries defense rules against container escapes.
 *
 * @param request ListAegisContainerPluginRuleRequest
 * @return ListAegisContainerPluginRuleResponse
 */
ListAegisContainerPluginRuleResponse Client::listAegisContainerPluginRule(const ListAegisContainerPluginRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAegisContainerPluginRuleWithOptions(request, runtime);
}

/**
 * @summary Query the Aegis client installation result for Lingjun bare metal.
 *
 * @param tmpReq ListAegisForLingjunStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAegisForLingjunStatusResponse
 */
ListAegisForLingjunStatusResponse Client::listAegisForLingjunStatusWithOptions(const ListAegisForLingjunStatusRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  ListAegisForLingjunStatusShrinkRequest request = ListAegisForLingjunStatusShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasUuids()) {
    request.setUuidsShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.uuids(), "Uuids", "json"));
  }

  json query = {};
  if (!!request.hasUuidsShrink()) {
    query["Uuids"] = request.uuidsShrink();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAegisForLingjunStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAegisForLingjunStatusResponse>();
}

/**
 * @summary Query the Aegis client installation result for Lingjun bare metal.
 *
 * @param request ListAegisForLingjunStatusRequest
 * @return ListAegisForLingjunStatusResponse
 */
ListAegisForLingjunStatusResponse Client::listAegisForLingjunStatus(const ListAegisForLingjunStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAegisForLingjunStatusWithOptions(request, runtime);
}

/**
 * @summary Query agentless detection assets.
 *
 * @param request ListAgentlessAssetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessAssetResponse
 */
ListAgentlessAssetResponse Client::listAgentlessAssetWithOptions(const ListAgentlessAssetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDiskType()) {
    query["DiskType"] = request.diskType();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceName()) {
    query["InstanceName"] = request.instanceName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPlatform()) {
    query["Platform"] = request.platform();
  }

  if (!!request.hasScanRegionId()) {
    query["ScanRegionId"] = request.scanRegionId();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAgentlessAsset"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAgentlessAssetResponse>();
}

/**
 * @summary Query agentless detection assets.
 *
 * @param request ListAgentlessAssetRequest
 * @return ListAgentlessAssetResponse
 */
ListAgentlessAssetResponse Client::listAgentlessAsset(const ListAgentlessAssetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAgentlessAssetWithOptions(request, runtime);
}

/**
 * @summary Queries malicious files that are detected by agentless detection tasks.
 *
 * @param request ListAgentlessMaliciousFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessMaliciousFilesResponse
 */
ListAgentlessMaliciousFilesResponse Client::listAgentlessMaliciousFilesWithOptions(const ListAgentlessMaliciousFilesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasEventId()) {
    query["EventId"] = request.eventId();
  }

  if (!!request.hasFuzzyMaliciousName()) {
    query["FuzzyMaliciousName"] = request.fuzzyMaliciousName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLevels()) {
    query["Levels"] = request.levels();
  }

  if (!!request.hasMaliciousMd5()) {
    query["MaliciousMd5"] = request.maliciousMd5();
  }

  if (!!request.hasMaliciousType()) {
    query["MaliciousType"] = request.maliciousType();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAgentlessMaliciousFiles"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAgentlessMaliciousFilesResponse>();
}

/**
 * @summary Queries malicious files that are detected by agentless detection tasks.
 *
 * @param request ListAgentlessMaliciousFilesRequest
 * @return ListAgentlessMaliciousFilesResponse
 */
ListAgentlessMaliciousFilesResponse Client::listAgentlessMaliciousFiles(const ListAgentlessMaliciousFilesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAgentlessMaliciousFilesWithOptions(request, runtime);
}

/**
 * @summary Queries the regions that are supported by the agentless detection feature.
 *
 * @param request ListAgentlessRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessRegionResponse
 */
ListAgentlessRegionResponse Client::listAgentlessRegionWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListAgentlessRegion"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAgentlessRegionResponse>();
}

/**
 * @summary Queries the regions that are supported by the agentless detection feature.
 *
 * @return ListAgentlessRegionResponse
 */
ListAgentlessRegionResponse Client::listAgentlessRegion() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAgentlessRegionWithOptions(runtime);
}

/**
 * @summary Obtains the risks associated with an agentless detection event.
 *
 * @param request ListAgentlessRelateMaliciousRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessRelateMaliciousResponse
 */
ListAgentlessRelateMaliciousResponse Client::listAgentlessRelateMaliciousWithOptions(const ListAgentlessRelateMaliciousRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEventId()) {
    query["EventId"] = request.eventId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasScenario()) {
    query["Scenario"] = request.scenario();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAgentlessRelateMalicious"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAgentlessRelateMaliciousResponse>();
}

/**
 * @summary Obtains the risks associated with an agentless detection event.
 *
 * @param request ListAgentlessRelateMaliciousRequest
 * @return ListAgentlessRelateMaliciousResponse
 */
ListAgentlessRelateMaliciousResponse Client::listAgentlessRelateMalicious(const ListAgentlessRelateMaliciousRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAgentlessRelateMaliciousWithOptions(request, runtime);
}

/**
 * @summary Queries at-risk hosts that are detected by the agentless detection feature.
 *
 * @param request ListAgentlessRiskUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessRiskUuidResponse
 */
ListAgentlessRiskUuidResponse Client::listAgentlessRiskUuidWithOptions(const ListAgentlessRiskUuidRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceName()) {
    query["InstanceName"] = request.instanceName();
  }

  if (!!request.hasInternetIp()) {
    query["InternetIp"] = request.internetIp();
  }

  if (!!request.hasIntranetIp()) {
    query["IntranetIp"] = request.intranetIp();
  }

  if (!!request.hasMachineName()) {
    query["MachineName"] = request.machineName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRisk()) {
    query["Risk"] = request.risk();
  }

  if (!!request.hasTargetName()) {
    query["TargetName"] = request.targetName();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAgentlessRiskUuid"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAgentlessRiskUuidResponse>();
}

/**
 * @summary Queries at-risk hosts that are detected by the agentless detection feature.
 *
 * @param request ListAgentlessRiskUuidRequest
 * @return ListAgentlessRiskUuidResponse
 */
ListAgentlessRiskUuidResponse Client::listAgentlessRiskUuid(const ListAgentlessRiskUuidRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAgentlessRiskUuidWithOptions(request, runtime);
}

/**
 * @summary Queries agentless detection tasks.
 *
 * @param request ListAgentlessTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAgentlessTaskResponse
 */
ListAgentlessTaskResponse Client::listAgentlessTaskWithOptions(const ListAgentlessTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasInternetIp()) {
    query["InternetIp"] = request.internetIp();
  }

  if (!!request.hasIntranetIp()) {
    query["IntranetIp"] = request.intranetIp();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMachineName()) {
    query["MachineName"] = request.machineName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRootTask()) {
    query["RootTask"] = request.rootTask();
  }

  if (!!request.hasRootTaskId()) {
    query["RootTaskId"] = request.rootTaskId();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasTargetName()) {
    query["TargetName"] = request.targetName();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAgentlessTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAgentlessTaskResponse>();
}

/**
 * @summary Queries agentless detection tasks.
 *
 * @param request ListAgentlessTaskRequest
 * @return ListAgentlessTaskResponse
 */
ListAgentlessTaskResponse Client::listAgentlessTask(const ListAgentlessTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAgentlessTaskWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations for cleaning offline hosts whose provider cannot be identified.
 *
 * @param request ListAssetCleanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssetCleanConfigResponse
 */
ListAssetCleanConfigResponse Client::listAssetCleanConfigWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListAssetCleanConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAssetCleanConfigResponse>();
}

/**
 * @summary Queries the configurations for cleaning offline hosts whose provider cannot be identified.
 *
 * @return ListAssetCleanConfigResponse
 */
ListAssetCleanConfigResponse Client::listAssetCleanConfig() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAssetCleanConfigWithOptions(runtime);
}

/**
 * @summary Queries the custom upgrade information about assets.
 *
 * @param request ListAssetInfoPublishRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssetInfoPublishResponse
 */
ListAssetInfoPublishResponse Client::listAssetInfoPublishWithOptions(const ListAssetInfoPublishRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAssetInfoPublish"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAssetInfoPublishResponse>();
}

/**
 * @summary Queries the custom upgrade information about assets.
 *
 * @param request ListAssetInfoPublishRequest
 * @return ListAssetInfoPublishResponse
 */
ListAssetInfoPublishResponse Client::listAssetInfoPublish(const ListAssetInfoPublishRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAssetInfoPublishWithOptions(request, runtime);
}

/**
 * @summary Queries the configurations of asset synchronization.
 *
 * @param request ListAssetRefreshTaskConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssetRefreshTaskConfigResponse
 */
ListAssetRefreshTaskConfigResponse Client::listAssetRefreshTaskConfigWithOptions(const ListAssetRefreshTaskConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRefreshConfigType()) {
    query["RefreshConfigType"] = request.refreshConfigType();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasTargetId()) {
    query["TargetId"] = request.targetId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAssetRefreshTaskConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAssetRefreshTaskConfigResponse>();
}

/**
 * @summary Queries the configurations of asset synchronization.
 *
 * @param request ListAssetRefreshTaskConfigRequest
 * @return ListAssetRefreshTaskConfigResponse
 */
ListAssetRefreshTaskConfigResponse Client::listAssetRefreshTaskConfig(const ListAssetRefreshTaskConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAssetRefreshTaskConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the selected assets.
 *
 * @param request ListAssetSelectionSelectedTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssetSelectionSelectedTargetResponse
 */
ListAssetSelectionSelectedTargetResponse Client::listAssetSelectionSelectedTargetWithOptions(const ListAssetSelectionSelectedTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSelectionKey()) {
    query["SelectionKey"] = request.selectionKey();
  }

  if (!!request.hasTargetList()) {
    query["TargetList"] = request.targetList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAssetSelectionSelectedTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAssetSelectionSelectedTargetResponse>();
}

/**
 * @summary Queries the selected assets.
 *
 * @param request ListAssetSelectionSelectedTargetRequest
 * @return ListAssetSelectionSelectedTargetResponse
 */
ListAssetSelectionSelectedTargetResponse Client::listAssetSelectionSelectedTarget(const ListAssetSelectionSelectedTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAssetSelectionSelectedTargetWithOptions(request, runtime);
}

/**
 * @summary Queries the required asset.
 *
 * @param request ListAssetSelectionTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssetSelectionTargetResponse
 */
ListAssetSelectionTargetResponse Client::listAssetSelectionTargetWithOptions(const ListAssetSelectionTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSelectionKey()) {
    query["SelectionKey"] = request.selectionKey();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAssetSelectionTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAssetSelectionTargetResponse>();
}

/**
 * @summary Queries the required asset.
 *
 * @param request ListAssetSelectionTargetRequest
 * @return ListAssetSelectionTargetResponse
 */
ListAssetSelectionTargetResponse Client::listAssetSelectionTarget(const ListAssetSelectionTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAssetSelectionTargetWithOptions(request, runtime);
}

/**
 * @summary Query Attack Path Events.
 *
 * @param request ListAttackPathEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAttackPathEventResponse
 */
ListAttackPathEventResponse Client::listAttackPathEventWithOptions(const ListAttackPathEventRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAttackPathAssetList()) {
    query["AttackPathAssetList"] = request.attackPathAssetList();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPathNameDesc()) {
    query["PathNameDesc"] = request.pathNameDesc();
  }

  if (!!request.hasPathType()) {
    query["PathType"] = request.pathType();
  }

  if (!!request.hasRiskLevelList()) {
    query["RiskLevelList"] = request.riskLevelList();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAttackPathEvent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAttackPathEventResponse>();
}

/**
 * @summary Query Attack Path Events.
 *
 * @param request ListAttackPathEventRequest
 * @return ListAttackPathEventResponse
 */
ListAttackPathEventResponse Client::listAttackPathEvent(const ListAttackPathEventRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAttackPathEventWithOptions(request, runtime);
}

/**
 * @summary Query Attack Path Whitelist List.
 *
 * @param request ListAttackPathWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAttackPathWhitelistResponse
 */
ListAttackPathWhitelistResponse Client::listAttackPathWhitelistWithOptions(const ListAttackPathWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPathNameDesc()) {
    query["PathNameDesc"] = request.pathNameDesc();
  }

  if (!!request.hasPathType()) {
    query["PathType"] = request.pathType();
  }

  if (!!request.hasWhitelistName()) {
    query["WhitelistName"] = request.whitelistName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAttackPathWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAttackPathWhitelistResponse>();
}

/**
 * @summary Query Attack Path Whitelist List.
 *
 * @param request ListAttackPathWhitelistRequest
 * @return ListAttackPathWhitelistResponse
 */
ListAttackPathWhitelistResponse Client::listAttackPathWhitelist(const ListAttackPathWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAttackPathWhitelistWithOptions(request, runtime);
}

/**
 * @summary Queries asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
 *
 * @param request ListAutoTagRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAutoTagRulesResponse
 */
ListAutoTagRulesResponse Client::listAutoTagRulesWithOptions(const ListAutoTagRulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAutoTagRules"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAutoTagRulesResponse>();
}

/**
 * @summary Queries asset auto-tagging rules that are created by using the feature of asset management rules. You can create rules on the System Configuration > Feature Settings > Multi-cloud Configuration Management > Asset Management Rule page in the Security Center console.
 *
 * @param request ListAutoTagRulesRequest
 * @return ListAutoTagRulesResponse
 */
ListAutoTagRulesResponse Client::listAutoTagRules(const ListAutoTagRulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAutoTagRulesWithOptions(request, runtime);
}

/**
 * @summary Query Attack Path List.
 *
 * @param request ListAvailableAttackPathRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAvailableAttackPathResponse
 */
ListAvailableAttackPathResponse Client::listAvailableAttackPathWithOptions(const ListAvailableAttackPathRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAvailableAttackPath"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAvailableAttackPathResponse>();
}

/**
 * @summary Query Attack Path List.
 *
 * @param request ListAvailableAttackPathRequest
 * @return ListAvailableAttackPathResponse
 */
ListAvailableAttackPathResponse Client::listAvailableAttackPath(const ListAvailableAttackPathRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAvailableAttackPathWithOptions(request, runtime);
}

/**
 * @summary Queries the information about available honeypot templates.
 *
 * @param request ListAvailableHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAvailableHoneypotResponse
 */
ListAvailableHoneypotResponse Client::listAvailableHoneypotWithOptions(const ListAvailableHoneypotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListAvailableHoneypot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListAvailableHoneypotResponse>();
}

/**
 * @summary Queries the information about available honeypot templates.
 *
 * @param request ListAvailableHoneypotRequest
 * @return ListAvailableHoneypotResponse
 */
ListAvailableHoneypotResponse Client::listAvailableHoneypot(const ListAvailableHoneypotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listAvailableHoneypotWithOptions(request, runtime);
}

/**
 * @summary Queries backup records.
 *
 * @param request ListBackupRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListBackupRecordResponse
 */
ListBackupRecordResponse Client::listBackupRecordWithOptions(const ListBackupRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBackupEndTime()) {
    query["BackupEndTime"] = request.backupEndTime();
  }

  if (!!request.hasBackupStartTime()) {
    query["BackupStartTime"] = request.backupStartTime();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasMachineRemark()) {
    query["MachineRemark"] = request.machineRemark();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStatusList()) {
    query["StatusList"] = request.statusList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListBackupRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListBackupRecordResponse>();
}

/**
 * @summary Queries backup records.
 *
 * @param request ListBackupRecordRequest
 * @return ListBackupRecordResponse
 */
ListBackupRecordResponse Client::listBackupRecord(const ListBackupRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listBackupRecordWithOptions(request, runtime);
}

/**
 * @summary Queries the whitelist rules for a baseline check item.
 *
 * @param tmpReq ListBaselineCheckWhiteRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListBaselineCheckWhiteRecordResponse
 */
ListBaselineCheckWhiteRecordResponse Client::listBaselineCheckWhiteRecordWithOptions(const ListBaselineCheckWhiteRecordRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  ListBaselineCheckWhiteRecordShrinkRequest request = ListBaselineCheckWhiteRecordShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasCheckIds()) {
    request.setCheckIdsShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.checkIds(), "CheckIds", "json"));
  }

  if (!!tmpReq.hasRecordIds()) {
    request.setRecordIdsShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.recordIds(), "RecordIds", "json"));
  }

  json query = {};
  if (!!request.hasCheckIdsShrink()) {
    query["CheckIds"] = request.checkIdsShrink();
  }

  if (!!request.hasCheckItemFuzzy()) {
    query["CheckItemFuzzy"] = request.checkItemFuzzy();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRecordIdsShrink()) {
    query["RecordIds"] = request.recordIdsShrink();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListBaselineCheckWhiteRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListBaselineCheckWhiteRecordResponse>();
}

/**
 * @summary Queries the whitelist rules for a baseline check item.
 *
 * @param request ListBaselineCheckWhiteRecordRequest
 * @return ListBaselineCheckWhiteRecordResponse
 */
ListBaselineCheckWhiteRecordResponse Client::listBaselineCheckWhiteRecord(const ListBaselineCheckWhiteRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listBaselineCheckWhiteRecordWithOptions(request, runtime);
}

/**
 * @summary Queries the instances that failed a specified check item of configuration assessment.
 *
 * @param request ListCheckInstanceResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckInstanceResultResponse
 */
ListCheckInstanceResultResponse Client::listCheckInstanceResultWithOptions(const ListCheckInstanceResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasInstanceIdKey()) {
    query["InstanceIdKey"] = request.instanceIdKey();
  }

  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  if (!!request.hasInstanceNameKey()) {
    query["InstanceNameKey"] = request.instanceNameKey();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionIdKey()) {
    query["RegionIdKey"] = request.regionIdKey();
  }

  if (!!request.hasSortTypes()) {
    query["SortTypes"] = request.sortTypes();
  }

  if (!!request.hasStatuses()) {
    query["Statuses"] = request.statuses();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCheckInstanceResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCheckInstanceResultResponse>();
}

/**
 * @summary Queries the instances that failed a specified check item of configuration assessment.
 *
 * @param request ListCheckInstanceResultRequest
 * @return ListCheckInstanceResultResponse
 */
ListCheckInstanceResultResponse Client::listCheckInstanceResult(const ListCheckInstanceResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCheckInstanceResultWithOptions(request, runtime);
}

/**
 * @summary Queries the check items that can be customized.
 *
 * @param request ListCheckItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckItemResponse
 */
ListCheckItemResponse Client::listCheckItemWithOptions(const ListCheckItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasTaskSources()) {
    query["TaskSources"] = request.taskSources();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCheckItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCheckItemResponse>();
}

/**
 * @summary Queries the check items that can be customized.
 *
 * @param request ListCheckItemRequest
 * @return ListCheckItemResponse
 */
ListCheckItemResponse Client::listCheckItem(const ListCheckItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCheckItemWithOptions(request, runtime);
}

/**
 * @summary Queries the servers that are affected by baseline risks.
 *
 * @param request ListCheckItemWarningMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckItemWarningMachineResponse
 */
ListCheckItemWarningMachineResponse Client::listCheckItemWarningMachineWithOptions(const ListCheckItemWarningMachineRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasRiskType()) {
    query["RiskType"] = request.riskType();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCheckItemWarningMachine"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCheckItemWarningMachineResponse>();
}

/**
 * @summary Queries the servers that are affected by baseline risks.
 *
 * @param request ListCheckItemWarningMachineRequest
 * @return ListCheckItemWarningMachineResponse
 */
ListCheckItemWarningMachineResponse Client::listCheckItemWarningMachine(const ListCheckItemWarningMachineRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCheckItemWarningMachineWithOptions(request, runtime);
}

/**
 * @summary Queries the risk statistics of check items by page.
 *
 * @param request ListCheckItemWarningSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckItemWarningSummaryResponse
 */
ListCheckItemWarningSummaryResponse Client::listCheckItemWarningSummaryWithOptions(const ListCheckItemWarningSummaryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckItemFuzzy()) {
    query["CheckItemFuzzy"] = request.checkItemFuzzy();
  }

  if (!!request.hasCheckLevel()) {
    query["CheckLevel"] = request.checkLevel();
  }

  if (!!request.hasCheckType()) {
    query["CheckType"] = request.checkType();
  }

  if (!!request.hasCheckWarningStatus()) {
    query["CheckWarningStatus"] = request.checkWarningStatus();
  }

  if (!!request.hasCheckWarningStatusList()) {
    query["CheckWarningStatusList"] = request.checkWarningStatusList();
  }

  if (!!request.hasContainerFieldName()) {
    query["ContainerFieldName"] = request.containerFieldName();
  }

  if (!!request.hasContainerFieldValue()) {
    query["ContainerFieldValue"] = request.containerFieldValue();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskType()) {
    query["RiskType"] = request.riskType();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCheckItemWarningSummary"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCheckItemWarningSummaryResponse>();
}

/**
 * @summary Queries the risk statistics of check items by page.
 *
 * @param request ListCheckItemWarningSummaryRequest
 * @return ListCheckItemWarningSummaryResponse
 */
ListCheckItemWarningSummaryResponse Client::listCheckItemWarningSummary(const ListCheckItemWarningSummaryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCheckItemWarningSummaryWithOptions(request, runtime);
}

/**
 * @summary Queries the details of the risk items that are detected in the configuration checks on cloud services.
 *
 * @param request ListCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckResultResponse
 */
ListCheckResultResponse Client::listCheckResultWithOptions(const ListCheckResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckIds()) {
    query["CheckIds"] = request.checkIds();
  }

  if (!!request.hasCheckKey()) {
    query["CheckKey"] = request.checkKey();
  }

  if (!!request.hasCheckTypes()) {
    query["CheckTypes"] = request.checkTypes();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasCustomParam()) {
    query["CustomParam"] = request.customParam();
  }

  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  if (!!request.hasInstanceTypes()) {
    query["InstanceTypes"] = request.instanceTypes();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasOperationTypes()) {
    query["OperationTypes"] = request.operationTypes();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRequirementIds()) {
    query["RequirementIds"] = request.requirementIds();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasRiskLevels()) {
    query["RiskLevels"] = request.riskLevels();
  }

  if (!!request.hasSortTypes()) {
    query["SortTypes"] = request.sortTypes();
  }

  if (!!request.hasStandardIds()) {
    query["StandardIds"] = request.standardIds();
  }

  if (!!request.hasStatuses()) {
    query["Statuses"] = request.statuses();
  }

  if (!!request.hasTaskSources()) {
    query["TaskSources"] = request.taskSources();
  }

  if (!!request.hasTypes()) {
    query["Types"] = request.types();
  }

  if (!!request.hasVendors()) {
    query["Vendors"] = request.vendors();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCheckResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCheckResultResponse>();
}

/**
 * @summary Queries the details of the risk items that are detected in the configuration checks on cloud services.
 *
 * @param request ListCheckResultRequest
 * @return ListCheckResultResponse
 */
ListCheckResultResponse Client::listCheckResult(const ListCheckResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCheckResultWithOptions(request, runtime);
}

/**
 * @summary Display cloud product configuration check rules
 *
 * @param request ListCheckRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckRuleResponse
 */
ListCheckRuleResponse Client::listCheckRuleWithOptions(const ListCheckRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCheckRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCheckRuleResponse>();
}

/**
 * @summary Display cloud product configuration check rules
 *
 * @param request ListCheckRuleRequest
 * @return ListCheckRuleResponse
 */
ListCheckRuleResponse Client::listCheckRule(const ListCheckRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCheckRuleWithOptions(request, runtime);
}

/**
 * @summary List all effective machines under the rule
 *
 * @param request ListCheckRuleInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckRuleInstanceResponse
 */
ListCheckRuleInstanceResponse Client::listCheckRuleInstanceWithOptions(const ListCheckRuleInstanceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCheckRuleInstance"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCheckRuleInstanceResponse>();
}

/**
 * @summary List all effective machines under the rule
 *
 * @param request ListCheckRuleInstanceRequest
 * @return ListCheckRuleInstanceResponse
 */
ListCheckRuleInstanceResponse Client::listCheckRuleInstance(const ListCheckRuleInstanceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCheckRuleInstanceWithOptions(request, runtime);
}

/**
 * @summary Queries the standards of configuration checks.
 *
 * @param request ListCheckStandardRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckStandardResponse
 */
ListCheckStandardResponse Client::listCheckStandardWithOptions(const ListCheckStandardRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  if (!!request.hasInstanceSubTypes()) {
    query["InstanceSubTypes"] = request.instanceSubTypes();
  }

  if (!!request.hasInstanceTypes()) {
    query["InstanceTypes"] = request.instanceTypes();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasTaskSources()) {
    query["TaskSources"] = request.taskSources();
  }

  if (!!request.hasVendors()) {
    query["Vendors"] = request.vendors();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCheckStandard"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCheckStandardResponse>();
}

/**
 * @summary Queries the standards of configuration checks.
 *
 * @param request ListCheckStandardRequest
 * @return ListCheckStandardResponse
 */
ListCheckStandardResponse Client::listCheckStandard(const ListCheckStandardRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCheckStandardWithOptions(request, runtime);
}

/**
 * @summary Queries the types of check items that meet the specified conditions based on the ID of a baseline.
 *
 * @param request ListCheckTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCheckTypesResponse
 */
ListCheckTypesResponse Client::listCheckTypesWithOptions(const ListCheckTypesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskId()) {
    query["RiskId"] = request.riskId();
  }

  if (!!request.hasShowChecks()) {
    query["ShowChecks"] = request.showChecks();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCheckTypes"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCheckTypesResponse>();
}

/**
 * @summary Queries the types of check items that meet the specified conditions based on the ID of a baseline.
 *
 * @param request ListCheckTypesRequest
 * @return ListCheckTypesResponse
 */
ListCheckTypesResponse Client::listCheckTypes(const ListCheckTypesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCheckTypesWithOptions(request, runtime);
}

/**
 * @summary Queries the alert settings of assets. By default, the balanced mode is enabled. A detected list of assets can be returned only in strict mode.
 *
 * @param request ListClientAlertModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClientAlertModeResponse
 */
ListClientAlertModeResponse Client::listClientAlertModeWithOptions(const ListClientAlertModeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListClientAlertMode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListClientAlertModeResponse>();
}

/**
 * @summary Queries the alert settings of assets. By default, the balanced mode is enabled. A detected list of assets can be returned only in strict mode.
 *
 * @param request ListClientAlertModeRequest
 * @return ListClientAlertModeResponse
 */
ListClientAlertModeResponse Client::listClientAlertMode(const ListClientAlertModeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listClientAlertModeWithOptions(request, runtime);
}

/**
 * @summary Queries the supported types of custom defense rules.
 *
 * @param request ListClientUserDefineRuleTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClientUserDefineRuleTypesResponse
 */
ListClientUserDefineRuleTypesResponse Client::listClientUserDefineRuleTypesWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListClientUserDefineRuleTypes"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListClientUserDefineRuleTypesResponse>();
}

/**
 * @summary Queries the supported types of custom defense rules.
 *
 * @return ListClientUserDefineRuleTypesResponse
 */
ListClientUserDefineRuleTypesResponse Client::listClientUserDefineRuleTypes() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listClientUserDefineRuleTypesWithOptions(runtime);
}

/**
 * @summary Queries custom defense rules.
 *
 * @param request ListClientUserDefineRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClientUserDefineRulesResponse
 */
ListClientUserDefineRulesResponse Client::listClientUserDefineRulesWithOptions(const ListClientUserDefineRulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListClientUserDefineRules"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListClientUserDefineRulesResponse>();
}

/**
 * @summary Queries custom defense rules.
 *
 * @param request ListClientUserDefineRulesRequest
 * @return ListClientUserDefineRulesResponse
 */
ListClientUserDefineRulesResponse Client::listClientUserDefineRules(const ListClientUserDefineRulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listClientUserDefineRulesWithOptions(request, runtime);
}

/**
 * @summary Queries cloud service assets.
 *
 * @param request ListCloudAssetInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudAssetInstancesResponse
 */
ListCloudAssetInstancesResponse Client::listCloudAssetInstancesWithOptions(const ListCloudAssetInstancesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCloudAssetTypes()) {
    query["CloudAssetTypes"] = request.cloudAssetTypes();
  }

  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLogicalExp()) {
    query["LogicalExp"] = request.logicalExp();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCloudAssetInstances"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCloudAssetInstancesResponse>();
}

/**
 * @summary Queries cloud service assets.
 *
 * @param request ListCloudAssetInstancesRequest
 * @return ListCloudAssetInstancesResponse
 */
ListCloudAssetInstancesResponse Client::listCloudAssetInstances(const ListCloudAssetInstancesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCloudAssetInstancesWithOptions(request, runtime);
}

/**
 * @summary Queries the synchronization region configurations of other clouds on a site.
 *
 * @param request ListCloudVendorRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCloudVendorRegionsResponse
 */
ListCloudVendorRegionsResponse Client::listCloudVendorRegionsWithOptions(const ListCloudVendorRegionsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCloudVendorRegions"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCloudVendorRegionsResponse>();
}

/**
 * @summary Queries the synchronization region configurations of other clouds on a site.
 *
 * @param request ListCloudVendorRegionsRequest
 * @return ListCloudVendorRegionsResponse
 */
ListCloudVendorRegionsResponse Client::listCloudVendorRegions(const ListCloudVendorRegionsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCloudVendorRegionsWithOptions(request, runtime);
}

/**
 * @summary Queries the protection status of the container firewall.
 *
 * @param request ListClusterCnnfStatusDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClusterCnnfStatusDetailResponse
 */
ListClusterCnnfStatusDetailResponse Client::listClusterCnnfStatusDetailWithOptions(const ListClusterCnnfStatusDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterIds()) {
    query["ClusterIds"] = request.clusterIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListClusterCnnfStatusDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListClusterCnnfStatusDetailResponse>();
}

/**
 * @summary Queries the protection status of the container firewall.
 *
 * @param request ListClusterCnnfStatusDetailRequest
 * @return ListClusterCnnfStatusDetailResponse
 */
ListClusterCnnfStatusDetailResponse Client::listClusterCnnfStatusDetail(const ListClusterCnnfStatusDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listClusterCnnfStatusDetailWithOptions(request, runtime);
}

/**
 * @summary Queries the defense rules that are created for a cluster.
 *
 * @param request ListClusterInterceptionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClusterInterceptionConfigResponse
 */
ListClusterInterceptionConfigResponse Client::listClusterInterceptionConfigWithOptions(const ListClusterInterceptionConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterCNNFStatus()) {
    query["ClusterCNNFStatus"] = request.clusterCNNFStatus();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListClusterInterceptionConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListClusterInterceptionConfigResponse>();
}

/**
 * @summary Queries the defense rules that are created for a cluster.
 *
 * @param request ListClusterInterceptionConfigRequest
 * @return ListClusterInterceptionConfigResponse
 */
ListClusterInterceptionConfigResponse Client::listClusterInterceptionConfig(const ListClusterInterceptionConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listClusterInterceptionConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the status of plug-ins on clusters.
 *
 * @param request ListClusterPluginInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClusterPluginInfoResponse
 */
ListClusterPluginInfoResponse Client::listClusterPluginInfoWithOptions(const ListClusterPluginInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterIds()) {
    query["ClusterIds"] = request.clusterIds();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPluginName()) {
    query["PluginName"] = request.pluginName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListClusterPluginInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListClusterPluginInfoResponse>();
}

/**
 * @summary Queries the status of plug-ins on clusters.
 *
 * @param request ListClusterPluginInfoRequest
 * @return ListClusterPluginInfoResponse
 */
ListClusterPluginInfoResponse Client::listClusterPluginInfo(const ListClusterPluginInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listClusterPluginInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the detection results of the files extracted from a package.
 *
 * @description You can call this operation to query the detection results of files only if the files are pushed to the cloud for detection and in the form of packages. You can repeatedly query the detection results of files within 5 hours because the results are retained for 5 hours. For more information about how to push a file to the cloud for detection, see the CreateFileDetect operation. For more information about how to query file detection results, see the GetFileDetectResult operation.
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only hexadecimal MD5 hash values of complete file content are supported. You must calculate the required MD5 hash value before you call this operation.
 * To calculate the hexadecimal MD5 hash value for a file, you can perform the following steps:
 * 1\\. Use the MD5 algorithm to encrypt data and generate a 128-bit hash value. You can use a tool such as MessageDigest for Java and the hashlib module for Python.
 * 2\\. Convert the hash value to a hexadecimal string. You can use a tool such as Codec for Java and the hex() function for Python.
 *
 * @param request ListCompressFileDetectResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCompressFileDetectResultResponse
 */
ListCompressFileDetectResultResponse Client::listCompressFileDetectResultWithOptions(const ListCompressFileDetectResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasHashKey()) {
    query["HashKey"] = request.hashKey();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCompressFileDetectResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCompressFileDetectResultResponse>();
}

/**
 * @summary Queries the detection results of the files extracted from a package.
 *
 * @description You can call this operation to query the detection results of files only if the files are pushed to the cloud for detection and in the form of packages. You can repeatedly query the detection results of files within 5 hours because the results are retained for 5 hours. For more information about how to push a file to the cloud for detection, see the CreateFileDetect operation. For more information about how to query file detection results, see the GetFileDetectResult operation.
 * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only hexadecimal MD5 hash values of complete file content are supported. You must calculate the required MD5 hash value before you call this operation.
 * To calculate the hexadecimal MD5 hash value for a file, you can perform the following steps:
 * 1\\. Use the MD5 algorithm to encrypt data and generate a 128-bit hash value. You can use a tool such as MessageDigest for Java and the hashlib module for Python.
 * 2\\. Convert the hash value to a hexadecimal string. You can use a tool such as Codec for Java and the hex() function for Python.
 *
 * @param request ListCompressFileDetectResultRequest
 * @return ListCompressFileDetectResultResponse
 */
ListCompressFileDetectResultResponse Client::listCompressFileDetectResult(const ListCompressFileDetectResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCompressFileDetectResultWithOptions(request, runtime);
}

/**
 * @summary Queries a list of rules for non-image program defense.
 *
 * @param request ListContainerDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListContainerDefenseRuleResponse
 */
ListContainerDefenseRuleResponse Client::listContainerDefenseRuleWithOptions(const ListContainerDefenseRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConditions()) {
    query["Conditions"] = request.conditions();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasIsDefaultRule()) {
    query["IsDefaultRule"] = request.isDefaultRule();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListContainerDefenseRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListContainerDefenseRuleResponse>();
}

/**
 * @summary Queries a list of rules for non-image program defense.
 *
 * @param request ListContainerDefenseRuleRequest
 * @return ListContainerDefenseRuleResponse
 */
ListContainerDefenseRuleResponse Client::listContainerDefenseRule(const ListContainerDefenseRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listContainerDefenseRuleWithOptions(request, runtime);
}

/**
 * @summary Queries a list of clusters that are included in a rule for non-image program defense.
 *
 * @param request ListContainerDefenseRuleClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListContainerDefenseRuleClustersResponse
 */
ListContainerDefenseRuleClustersResponse Client::listContainerDefenseRuleClustersWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListContainerDefenseRuleClusters"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListContainerDefenseRuleClustersResponse>();
}

/**
 * @summary Queries a list of clusters that are included in a rule for non-image program defense.
 *
 * @return ListContainerDefenseRuleClustersResponse
 */
ListContainerDefenseRuleClustersResponse Client::listContainerDefenseRuleClusters() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listContainerDefenseRuleClustersWithOptions(runtime);
}

/**
 * @summary Queries the IDs and names of rules configured for proactive defense for containers.
 *
 * @param request ListCriteriaStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCriteriaStrategyResponse
 */
ListCriteriaStrategyResponse Client::listCriteriaStrategyWithOptions(const ListCriteriaStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasImageName()) {
    query["ImageName"] = request.imageName();
  }

  if (!!request.hasLabel()) {
    query["Label"] = request.label();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasStrategyName()) {
    query["StrategyName"] = request.strategyName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListCriteriaStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListCriteriaStrategyResponse>();
}

/**
 * @summary Queries the IDs and names of rules configured for proactive defense for containers.
 *
 * @param request ListCriteriaStrategyRequest
 * @return ListCriteriaStrategyResponse
 */
ListCriteriaStrategyResponse Client::listCriteriaStrategy(const ListCriteriaStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listCriteriaStrategyWithOptions(request, runtime);
}

/**
 * @summary Queries the risk overview of official Docker Hub images.
 *
 * @param request ListDockerhubImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDockerhubImageResponse
 */
ListDockerhubImageResponse Client::listDockerhubImageWithOptions(const ListDockerhubImageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasQuery()) {
    query["Query"] = request.query();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListDockerhubImage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListDockerhubImageResponse>();
}

/**
 * @summary Queries the risk overview of official Docker Hub images.
 *
 * @param request ListDockerhubImageRequest
 * @return ListDockerhubImageResponse
 */
ListDockerhubImageResponse Client::listDockerhubImage(const ListDockerhubImageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listDockerhubImageWithOptions(request, runtime);
}

/**
 * @summary Queries core file monitoring rules that meet the specified filter condition.
 *
 * @param request ListFileProtectEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFileProtectEventResponse
 */
ListFileProtectEventResponse Client::listFileProtectEventWithOptions(const ListFileProtectEventRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAlertLevels()) {
    query["AlertLevels"] = request.alertLevels();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  if (!!request.hasInstanceName()) {
    query["InstanceName"] = request.instanceName();
  }

  if (!!request.hasInternetIp()) {
    query["InternetIp"] = request.internetIp();
  }

  if (!!request.hasIntranetIp()) {
    query["IntranetIp"] = request.intranetIp();
  }

  if (!!request.hasOperation()) {
    query["Operation"] = request.operation();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListFileProtectEvent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListFileProtectEventResponse>();
}

/**
 * @summary Queries core file monitoring rules that meet the specified filter condition.
 *
 * @param request ListFileProtectEventRequest
 * @return ListFileProtectEventResponse
 */
ListFileProtectEventResponse Client::listFileProtectEvent(const ListFileProtectEventRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listFileProtectEventWithOptions(request, runtime);
}

/**
 * @summary Queries information about the Security Center agent installed on servers on which core file monitoring rules take effect. The information includes the installation status of the Security Center agent and whether the core file monitoring feature is supported.
 *
 * @param request ListFileProtectPluginStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFileProtectPluginStatusResponse
 */
ListFileProtectPluginStatusResponse Client::listFileProtectPluginStatusWithOptions(const ListFileProtectPluginStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSwitchId()) {
    query["SwitchId"] = request.switchId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListFileProtectPluginStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListFileProtectPluginStatusResponse>();
}

/**
 * @summary Queries information about the Security Center agent installed on servers on which core file monitoring rules take effect. The information includes the installation status of the Security Center agent and whether the core file monitoring feature is supported.
 *
 * @param request ListFileProtectPluginStatusRequest
 * @return ListFileProtectPluginStatusResponse
 */
ListFileProtectPluginStatusResponse Client::listFileProtectPluginStatus(const ListFileProtectPluginStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listFileProtectPluginStatusWithOptions(request, runtime);
}

/**
 * @summary Queries core file monitoring rules.
 *
 * @param request ListFileProtectRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFileProtectRuleResponse
 */
ListFileProtectRuleResponse Client::listFileProtectRuleWithOptions(const ListFileProtectRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAlertLevel()) {
    query["AlertLevel"] = request.alertLevel();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPlatform()) {
    query["Platform"] = request.platform();
  }

  if (!!request.hasRuleAction()) {
    query["RuleAction"] = request.ruleAction();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListFileProtectRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListFileProtectRuleResponse>();
}

/**
 * @summary Queries core file monitoring rules.
 *
 * @param request ListFileProtectRuleRequest
 * @return ListFileProtectRuleResponse
 */
ListFileProtectRuleResponse Client::listFileProtectRule(const ListFileProtectRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listFileProtectRuleWithOptions(request, runtime);
}

/**
 * @summary Queries the server groups.
 *
 * @param request ListGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGroupsResponse
 */
ListGroupsResponse Client::listGroupsWithOptions(const ListGroupsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNextToken()) {
    query["NextToken"] = request.nextToken();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasUseNextToken()) {
    query["UseNextToken"] = request.useNextToken();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListGroups"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListGroupsResponse>();
}

/**
 * @summary Queries the server groups.
 *
 * @param request ListGroupsRequest
 * @return ListGroupsResponse
 */
ListGroupsResponse Client::listGroups(const ListGroupsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listGroupsWithOptions(request, runtime);
}

/**
 * @summary Queries the information about honeypots.
 *
 * @param request ListHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotResponse
 */
ListHoneypotResponse Client::listHoneypotWithOptions(const ListHoneypotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasHoneypotIds()) {
    query["HoneypotIds"] = request.honeypotIds();
  }

  if (!!request.hasHoneypotName()) {
    query["HoneypotName"] = request.honeypotName();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  if (!!request.hasNodeName()) {
    query["NodeName"] = request.nodeName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListHoneypot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListHoneypotResponse>();
}

/**
 * @summary Queries the information about honeypots.
 *
 * @param request ListHoneypotRequest
 * @return ListHoneypotResponse
 */
ListHoneypotResponse Client::listHoneypot(const ListHoneypotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listHoneypotWithOptions(request, runtime);
}

/**
 * @summary Queries the information about alert events that are generated.
 *
 * @param request ListHoneypotAlarmEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotAlarmEventsResponse
 */
ListHoneypotAlarmEventsResponse Client::listHoneypotAlarmEventsWithOptions(const ListHoneypotAlarmEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListHoneypotAlarmEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListHoneypotAlarmEventsResponse>();
}

/**
 * @summary Queries the information about alert events that are generated.
 *
 * @param request ListHoneypotAlarmEventsRequest
 * @return ListHoneypotAlarmEventsResponse
 */
ListHoneypotAlarmEventsResponse Client::listHoneypotAlarmEvents(const ListHoneypotAlarmEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listHoneypotAlarmEventsWithOptions(request, runtime);
}

/**
 * @summary Queries the attacker profile based on the source IP address of the attack.
 *
 * @param request ListHoneypotAttackerPortraitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotAttackerPortraitResponse
 */
ListHoneypotAttackerPortraitResponse Client::listHoneypotAttackerPortraitWithOptions(const ListHoneypotAttackerPortraitRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTimeStamp()) {
    query["EndTimeStamp"] = request.endTimeStamp();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSrcIp()) {
    query["SrcIp"] = request.srcIp();
  }

  if (!!request.hasStartTimeStamp()) {
    query["StartTimeStamp"] = request.startTimeStamp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListHoneypotAttackerPortrait"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListHoneypotAttackerPortraitResponse>();
}

/**
 * @summary Queries the attacker profile based on the source IP address of the attack.
 *
 * @param request ListHoneypotAttackerPortraitRequest
 * @return ListHoneypotAttackerPortraitResponse
 */
ListHoneypotAttackerPortraitResponse Client::listHoneypotAttackerPortrait(const ListHoneypotAttackerPortraitRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listHoneypotAttackerPortraitWithOptions(request, runtime);
}

/**
 * @summary Queries the attack source IP addresses that are used to attack a honeypot.
 *
 * @param request ListHoneypotAttackerSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotAttackerSourceResponse
 */
ListHoneypotAttackerSourceResponse Client::listHoneypotAttackerSourceWithOptions(const ListHoneypotAttackerSourceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTimeStamp()) {
    query["EndTimeStamp"] = request.endTimeStamp();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRiskLevelList()) {
    query["RiskLevelList"] = request.riskLevelList();
  }

  if (!!request.hasSrcIp()) {
    query["SrcIp"] = request.srcIp();
  }

  if (!!request.hasStartTimeStamp()) {
    query["StartTimeStamp"] = request.startTimeStamp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListHoneypotAttackerSource"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListHoneypotAttackerSourceResponse>();
}

/**
 * @summary Queries the attack source IP addresses that are used to attack a honeypot.
 *
 * @param request ListHoneypotAttackerSourceRequest
 * @return ListHoneypotAttackerSourceResponse
 */
ListHoneypotAttackerSourceResponse Client::listHoneypotAttackerSource(const ListHoneypotAttackerSourceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listHoneypotAttackerSourceWithOptions(request, runtime);
}

/**
 * @summary Queries the details of an intrusion event in a honeypot.
 *
 * @param request ListHoneypotEventFlowsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotEventFlowsResponse
 */
ListHoneypotEventFlowsResponse Client::listHoneypotEventFlowsWithOptions(const ListHoneypotEventFlowsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDealed()) {
    query["Dealed"] = request.dealed();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRequestId()) {
    query["RequestId"] = request.requestId();
  }

  if (!!request.hasSecurityEventId()) {
    query["SecurityEventId"] = request.securityEventId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListHoneypotEventFlows"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListHoneypotEventFlowsResponse>();
}

/**
 * @summary Queries the details of an intrusion event in a honeypot.
 *
 * @param request ListHoneypotEventFlowsRequest
 * @return ListHoneypotEventFlowsResponse
 */
ListHoneypotEventFlowsResponse Client::listHoneypotEventFlows(const ListHoneypotEventFlowsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listHoneypotEventFlowsWithOptions(request, runtime);
}

/**
 * @summary Queries the intrusion events detected by honeypots.
 *
 * @param request ListHoneypotEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotEventsResponse
 */
ListHoneypotEventsResponse Client::listHoneypotEventsWithOptions(const ListHoneypotEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListHoneypotEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListHoneypotEventsResponse>();
}

/**
 * @summary Queries the intrusion events detected by honeypots.
 *
 * @param request ListHoneypotEventsRequest
 * @return ListHoneypotEventsResponse
 */
ListHoneypotEventsResponse Client::listHoneypotEvents(const ListHoneypotEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listHoneypotEventsWithOptions(request, runtime);
}

/**
 * @summary Queries the information about management nodes.
 *
 * @param request ListHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotNodeResponse
 */
ListHoneypotNodeResponse Client::listHoneypotNodeWithOptions(const ListHoneypotNodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  if (!!request.hasNodeName()) {
    query["NodeName"] = request.nodeName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListHoneypotNode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListHoneypotNodeResponse>();
}

/**
 * @summary Queries the information about management nodes.
 *
 * @param request ListHoneypotNodeRequest
 * @return ListHoneypotNodeResponse
 */
ListHoneypotNodeResponse Client::listHoneypotNode(const ListHoneypotNodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listHoneypotNodeWithOptions(request, runtime);
}

/**
 * @summary Queries honeypot templates.
 *
 * @param request ListHoneypotPresetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotPresetResponse
 */
ListHoneypotPresetResponse Client::listHoneypotPresetWithOptions(const ListHoneypotPresetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasHoneypotImageName()) {
    query["HoneypotImageName"] = request.honeypotImageName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  if (!!request.hasNodeName()) {
    query["NodeName"] = request.nodeName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPresetName()) {
    query["PresetName"] = request.presetName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListHoneypotPreset"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListHoneypotPresetResponse>();
}

/**
 * @summary Queries honeypot templates.
 *
 * @param request ListHoneypotPresetRequest
 * @return ListHoneypotPresetResponse
 */
ListHoneypotPresetResponse Client::listHoneypotPreset(const ListHoneypotPresetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listHoneypotPresetWithOptions(request, runtime);
}

/**
 * @summary Queries probes.
 *
 * @param request ListHoneypotProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotProbeResponse
 */
ListHoneypotProbeResponse Client::listHoneypotProbeWithOptions(const ListHoneypotProbeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasDisplayName()) {
    query["DisplayName"] = request.displayName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasProbeStatus()) {
    query["ProbeStatus"] = request.probeStatus();
  }

  if (!!request.hasProbeType()) {
    query["ProbeType"] = request.probeType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListHoneypotProbe"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListHoneypotProbeResponse>();
}

/**
 * @summary Queries probes.
 *
 * @param request ListHoneypotProbeRequest
 * @return ListHoneypotProbeResponse
 */
ListHoneypotProbeResponse Client::listHoneypotProbe(const ListHoneypotProbeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listHoneypotProbeWithOptions(request, runtime);
}

/**
 * @summary 查询已安装的探针
 *
 * @param request ListHoneypotProbeUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListHoneypotProbeUuidResponse
 */
ListHoneypotProbeUuidResponse Client::listHoneypotProbeUuidWithOptions(const ListHoneypotProbeUuidRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasControlNodeId()) {
    query["ControlNodeId"] = request.controlNodeId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasProbeType()) {
    query["ProbeType"] = request.probeType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListHoneypotProbeUuid"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListHoneypotProbeUuidResponse>();
}

/**
 * @summary 查询已安装的探针
 *
 * @param request ListHoneypotProbeUuidRequest
 * @return ListHoneypotProbeUuidResponse
 */
ListHoneypotProbeUuidResponse Client::listHoneypotProbeUuid(const ListHoneypotProbeUuidRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listHoneypotProbeUuidWithOptions(request, runtime);
}

/**
 * @summary Queries the types of risky image build commands.
 *
 * @param request ListImageBuildRiskItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImageBuildRiskItemResponse
 */
ListImageBuildRiskItemResponse Client::listImageBuildRiskItemWithOptions(const ListImageBuildRiskItemRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListImageBuildRiskItem"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListImageBuildRiskItemResponse>();
}

/**
 * @summary Queries the types of risky image build commands.
 *
 * @param request ListImageBuildRiskItemRequest
 * @return ListImageBuildRiskItemResponse
 */
ListImageBuildRiskItemResponse Client::listImageBuildRiskItem(const ListImageBuildRiskItemRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listImageBuildRiskItemWithOptions(request, runtime);
}

/**
 * @summary Query Image Registry Extended Information.
 *
 * @param request ListImageRegistryExtraRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImageRegistryExtraResponse
 */
ListImageRegistryExtraResponse Client::listImageRegistryExtraWithOptions(const ListImageRegistryExtraRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRegistryId()) {
    query["RegistryId"] = request.registryId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListImageRegistryExtra"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListImageRegistryExtraResponse>();
}

/**
 * @summary Query Image Registry Extended Information.
 *
 * @param request ListImageRegistryExtraRequest
 * @return ListImageRegistryExtraResponse
 */
ListImageRegistryExtraResponse Client::listImageRegistryExtra(const ListImageRegistryExtraRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listImageRegistryExtraWithOptions(request, runtime);
}

/**
 * @summary The region ID of the image.
 *
 * @param request ListImageRegistryRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImageRegistryRegionResponse
 */
ListImageRegistryRegionResponse Client::listImageRegistryRegionWithOptions(const ListImageRegistryRegionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListImageRegistryRegion"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListImageRegistryRegionResponse>();
}

/**
 * @summary The region ID of the image.
 *
 * @param request ListImageRegistryRegionRequest
 * @return ListImageRegistryRegionResponse
 */
ListImageRegistryRegionResponse Client::listImageRegistryRegion(const ListImageRegistryRegionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listImageRegistryRegionWithOptions(request, runtime);
}

/**
 * @summary Queries security information about a container image.
 *
 * @param request ListImageRiskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListImageRiskResponse
 */
ListImageRiskResponse Client::listImageRiskWithOptions(const ListImageRiskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppName()) {
    query["AppName"] = request.appName();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImageName()) {
    query["ImageName"] = request.imageName();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListImageRisk"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListImageRiskResponse>();
}

/**
 * @summary Queries security information about a container image.
 *
 * @param request ListImageRiskRequest
 * @return ListImageRiskResponse
 */
ListImageRiskResponse Client::listImageRisk(const ListImageRiskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listImageRiskWithOptions(request, runtime);
}

/**
 * @summary Queries the asset types and asset subtypes for configuration assessment.
 *
 * @param request ListInstanceCatalogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceCatalogResponse
 */
ListInstanceCatalogResponse Client::listInstanceCatalogWithOptions(const ListInstanceCatalogRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasOnlyCustom()) {
    query["OnlyCustom"] = request.onlyCustom();
  }

  if (!!request.hasRegionId()) {
    query["RegionId"] = request.regionId();
  }

  if (!!request.hasRequirementIds()) {
    query["RequirementIds"] = request.requirementIds();
  }

  if (!!request.hasStandardIds()) {
    query["StandardIds"] = request.standardIds();
  }

  if (!!request.hasTaskSources()) {
    query["TaskSources"] = request.taskSources();
  }

  if (!!request.hasTypes()) {
    query["Types"] = request.types();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListInstanceCatalog"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListInstanceCatalogResponse>();
}

/**
 * @summary Queries the asset types and asset subtypes for configuration assessment.
 *
 * @param request ListInstanceCatalogRequest
 * @return ListInstanceCatalogResponse
 */
ListInstanceCatalogResponse Client::listInstanceCatalog(const ListInstanceCatalogRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listInstanceCatalogWithOptions(request, runtime);
}

/**
 * @summary Queries the risk levels of instances.
 *
 * @param request ListInstanceRiskLevelsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceRiskLevelsResponse
 */
ListInstanceRiskLevelsResponse Client::listInstanceRiskLevelsWithOptions(const ListInstanceRiskLevelsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceList()) {
    query["InstanceList"] = request.instanceList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListInstanceRiskLevels"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListInstanceRiskLevelsResponse>();
}

/**
 * @summary Queries the risk levels of instances.
 *
 * @param request ListInstanceRiskLevelsRequest
 * @return ListInstanceRiskLevelsResponse
 */
ListInstanceRiskLevelsResponse Client::listInstanceRiskLevels(const ListInstanceRiskLevelsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listInstanceRiskLevelsWithOptions(request, runtime);
}

/**
 * @summary Queries the statistics about risks in instances.
 *
 * @param request ListInstanceRiskNumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceRiskNumResponse
 */
ListInstanceRiskNumResponse Client::listInstanceRiskNumWithOptions(const ListInstanceRiskNumRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceList()) {
    query["InstanceList"] = request.instanceList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListInstanceRiskNum"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListInstanceRiskNumResponse>();
}

/**
 * @summary Queries the statistics about risks in instances.
 *
 * @param request ListInstanceRiskNumRequest
 * @return ListInstanceRiskNumResponse
 */
ListInstanceRiskNumResponse Client::listInstanceRiskNum(const ListInstanceRiskNumRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listInstanceRiskNumWithOptions(request, runtime);
}

/**
 * @summary Queries the alerts generated by defense rules.
 *
 * @param request ListInterceptionHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterceptionHistoryResponse
 */
ListInterceptionHistoryResponse Client::listInterceptionHistoryWithOptions(const ListInterceptionHistoryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasHistoryName()) {
    query["HistoryName"] = request.historyName();
  }

  if (!!request.hasInterceptionTypes()) {
    query["InterceptionTypes"] = request.interceptionTypes();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListInterceptionHistory"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListInterceptionHistoryResponse>();
}

/**
 * @summary Queries the alerts generated by defense rules.
 *
 * @param request ListInterceptionHistoryRequest
 * @return ListInterceptionHistoryResponse
 */
ListInterceptionHistoryResponse Client::listInterceptionHistory(const ListInterceptionHistoryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listInterceptionHistoryWithOptions(request, runtime);
}

/**
 * @summary Queries defense rules that are configured for the container firewall feature.
 *
 * @param request ListInterceptionRulePageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterceptionRulePageResponse
 */
ListInterceptionRulePageResponse Client::listInterceptionRulePageWithOptions(const ListInterceptionRulePageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCriteriaType()) {
    query["CriteriaType"] = request.criteriaType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListInterceptionRulePage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListInterceptionRulePageResponse>();
}

/**
 * @summary Queries defense rules that are configured for the container firewall feature.
 *
 * @param request ListInterceptionRulePageRequest
 * @return ListInterceptionRulePageResponse
 */
ListInterceptionRulePageResponse Client::listInterceptionRulePage(const ListInterceptionRulePageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listInterceptionRulePageWithOptions(request, runtime);
}

/**
 * @summary Queries the network objects that are protected by the container firewall feature.
 *
 * @param request ListInterceptionTargetPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInterceptionTargetPageResponse
 */
ListInterceptionTargetPageResponse Client::listInterceptionTargetPageWithOptions(const ListInterceptionTargetPageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppName()) {
    query["AppName"] = request.appName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImageList()) {
    query["ImageList"] = request.imageList();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasTagList()) {
    query["TagList"] = request.tagList();
  }

  if (!!request.hasTargetName()) {
    query["TargetName"] = request.targetName();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListInterceptionTargetPage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListInterceptionTargetPageResponse>();
}

/**
 * @summary Queries the network objects that are protected by the container firewall feature.
 *
 * @param request ListInterceptionTargetPageRequest
 * @return ListInterceptionTargetPageResponse
 */
ListInterceptionTargetPageResponse Client::listInterceptionTargetPage(const ListInterceptionTargetPageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listInterceptionTargetPageWithOptions(request, runtime);
}

/**
 * @summary Queries the information about Kubernetes clusters that are added to Security Center.
 *
 * @description You can use this operation to query the access information about Kubernetes clusters.
 *
 * @param request ListK8sAccessInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListK8sAccessInfoResponse
 */
ListK8sAccessInfoResponse Client::listK8sAccessInfoWithOptions(const ListK8sAccessInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliyunYundunGatewayApiName()) {
    query["AliyunYundunGatewayApiName"] = request.aliyunYundunGatewayApiName();
  }

  if (!!request.hasAliyunYundunGatewayPopName()) {
    query["AliyunYundunGatewayPopName"] = request.aliyunYundunGatewayPopName();
  }

  if (!!request.hasAliyunYundunGatewayProjectName()) {
    query["AliyunYundunGatewayProjectName"] = request.aliyunYundunGatewayProjectName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListK8sAccessInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListK8sAccessInfoResponse>();
}

/**
 * @summary Queries the information about Kubernetes clusters that are added to Security Center.
 *
 * @description You can use this operation to query the access information about Kubernetes clusters.
 *
 * @param request ListK8sAccessInfoRequest
 * @return ListK8sAccessInfoResponse
 */
ListK8sAccessInfoResponse Client::listK8sAccessInfo(const ListK8sAccessInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listK8sAccessInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the regions supported by the log delivery feature that uses the pay-as-you-go billing method.
 *
 * @param request ListLogShipperRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLogShipperRegionsResponse
 */
ListLogShipperRegionsResponse Client::listLogShipperRegionsWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListLogShipperRegions"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListLogShipperRegionsResponse>();
}

/**
 * @summary Queries the regions supported by the log delivery feature that uses the pay-as-you-go billing method.
 *
 * @return ListLogShipperRegionsResponse
 */
ListLogShipperRegionsResponse Client::listLogShipperRegions() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listLogShipperRegionsWithOptions(runtime);
}

/**
 * @summary Paginate to query the application list.
 *
 * @param request ListMachineAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMachineAppsResponse
 */
ListMachineAppsResponse Client::listMachineAppsWithOptions(const ListMachineAppsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppId()) {
    query["AppId"] = request.appId();
  }

  if (!!request.hasAppName()) {
    query["AppName"] = request.appName();
  }

  if (!!request.hasAppRegionId()) {
    query["AppRegionId"] = request.appRegionId();
  }

  if (!!request.hasAuthVersion()) {
    query["AuthVersion"] = request.authVersion();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceDirectoryUid()) {
    query["ResourceDirectoryUid"] = request.resourceDirectoryUid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListMachineApps"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListMachineAppsResponse>();
}

/**
 * @summary Paginate to query the application list.
 *
 * @param request ListMachineAppsRequest
 * @return ListMachineAppsResponse
 */
ListMachineAppsResponse Client::listMachineApps(const ListMachineAppsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listMachineAppsWithOptions(request, runtime);
}

/**
 * @summary Queries the alert whitelist rules of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request ListMaliciousFileWhitelistConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMaliciousFileWhitelistConfigsResponse
 */
ListMaliciousFileWhitelistConfigsResponse Client::listMaliciousFileWhitelistConfigsWithOptions(const ListMaliciousFileWhitelistConfigsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEventName()) {
    query["EventName"] = request.eventName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListMaliciousFileWhitelistConfigs"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListMaliciousFileWhitelistConfigsResponse>();
}

/**
 * @summary Queries the alert whitelist rules of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request ListMaliciousFileWhitelistConfigsRequest
 * @return ListMaliciousFileWhitelistConfigsResponse
 */
ListMaliciousFileWhitelistConfigsResponse Client::listMaliciousFileWhitelistConfigs(const ListMaliciousFileWhitelistConfigsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listMaliciousFileWhitelistConfigsWithOptions(request, runtime);
}

/**
 * @summary Queries alerts that are generated for malicious files.
 *
 * @param request ListObjectScanEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListObjectScanEventResponse
 */
ListObjectScanEventResponse Client::listObjectScanEventWithOptions(const ListObjectScanEventRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBucketName()) {
    query["BucketName"] = request.bucketName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEventName()) {
    query["EventName"] = request.eventName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMd5()) {
    query["Md5"] = request.md5();
  }

  if (!!request.hasOssKey()) {
    query["OssKey"] = request.ossKey();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasParentEventId()) {
    query["ParentEventId"] = request.parentEventId();
  }

  if (!!request.hasRiskLevel()) {
    query["RiskLevel"] = request.riskLevel();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasTimeEnd()) {
    query["TimeEnd"] = request.timeEnd();
  }

  if (!!request.hasTimeStart()) {
    query["TimeStart"] = request.timeStart();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListObjectScanEvent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListObjectScanEventResponse>();
}

/**
 * @summary Queries alerts that are generated for malicious files.
 *
 * @param request ListObjectScanEventRequest
 * @return ListObjectScanEventResponse
 */
ListObjectScanEventResponse Client::listObjectScanEvent(const ListObjectScanEventRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listObjectScanEventWithOptions(request, runtime);
}

/**
 * @summary Queries at-risk image blocking rules.
 *
 * @param request ListOpaClusterStrategyNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOpaClusterStrategyNewResponse
 */
ListOpaClusterStrategyNewResponse Client::listOpaClusterStrategyNewWithOptions(const ListOpaClusterStrategyNewRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasImageName()) {
    query["ImageName"] = request.imageName();
  }

  if (!!request.hasLabel()) {
    query["Label"] = request.label();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStrategyName()) {
    query["StrategyName"] = request.strategyName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListOpaClusterStrategyNew"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListOpaClusterStrategyNewResponse>();
}

/**
 * @summary Queries at-risk image blocking rules.
 *
 * @param request ListOpaClusterStrategyNewRequest
 * @return ListOpaClusterStrategyNewResponse
 */
ListOpaClusterStrategyNewResponse Client::listOpaClusterStrategyNew(const ListOpaClusterStrategyNewRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listOpaClusterStrategyNewWithOptions(request, runtime);
}

/**
 * @summary Query the list of instance results under the operation check item
 *
 * @description This interface is only available to users who have purchased the cloud platform configuration check authorization or enabled the pay-as-you-go service for cloud platform configuration checks.
 *
 * @param request ListOperationCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOperationCheckResponse
 */
ListOperationCheckResponse Client::listOperationCheckWithOptions(const ListOperationCheckRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListOperationCheck"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListOperationCheckResponse>();
}

/**
 * @summary Query the list of instance results under the operation check item
 *
 * @description This interface is only available to users who have purchased the cloud platform configuration check authorization or enabled the pay-as-you-go service for cloud platform configuration checks.
 *
 * @param request ListOperationCheckRequest
 * @return ListOperationCheckResponse
 */
ListOperationCheckResponse Client::listOperationCheck(const ListOperationCheckRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listOperationCheckWithOptions(request, runtime);
}

/**
 * @summary Queries a list of operation tasks.
 *
 * @description You can query only operation tasks.
 *
 * @param request ListOperationProcessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOperationProcessResponse
 */
ListOperationProcessResponse Client::listOperationProcessWithOptions(const ListOperationProcessRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasStatusCodes()) {
    query["StatusCodes"] = request.statusCodes();
  }

  if (!!request.hasTaskIds()) {
    query["TaskIds"] = request.taskIds();
  }

  if (!!request.hasTaskSources()) {
    query["TaskSources"] = request.taskSources();
  }

  if (!!request.hasTaskTypes()) {
    query["TaskTypes"] = request.taskTypes();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListOperationProcess"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListOperationProcessResponse>();
}

/**
 * @summary Queries a list of operation tasks.
 *
 * @description You can query only operation tasks.
 *
 * @param request ListOperationProcessRequest
 * @return ListOperationProcessResponse
 */
ListOperationProcessResponse Client::listOperationProcess(const ListOperationProcessRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listOperationProcessWithOptions(request, runtime);
}

/**
 * @summary Query operation task sub-task list.
 *
 * @description You can query only operation subtasks.
 *
 * @param request ListOperationProcessDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOperationProcessDetailResponse
 */
ListOperationProcessDetailResponse Client::listOperationProcessDetailWithOptions(const ListOperationProcessDetailRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasStatusCodes()) {
    query["StatusCodes"] = request.statusCodes();
  }

  if (!!request.hasTaskIds()) {
    query["TaskIds"] = request.taskIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListOperationProcessDetail"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListOperationProcessDetailResponse>();
}

/**
 * @summary Query operation task sub-task list.
 *
 * @description You can query only operation subtasks.
 *
 * @param request ListOperationProcessDetailRequest
 * @return ListOperationProcessDetailResponse
 */
ListOperationProcessDetailResponse Client::listOperationProcessDetail(const ListOperationProcessDetailRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listOperationProcessDetailWithOptions(request, runtime);
}

/**
 * @summary Display the list of cloud product configuration check, repair, and rollback tasks
 *
 * @param request ListOperationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOperationTaskResponse
 */
ListOperationTaskResponse Client::listOperationTaskWithOptions(const ListOperationTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListOperationTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListOperationTaskResponse>();
}

/**
 * @summary Display the list of cloud product configuration check, repair, and rollback tasks
 *
 * @param request ListOperationTaskRequest
 * @return ListOperationTaskResponse
 */
ListOperationTaskResponse Client::listOperationTask(const ListOperationTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listOperationTaskWithOptions(request, runtime);
}

/**
 * @summary Queries Object Storage Service (OSS) buckets.
 *
 * @param request ListOssBucketRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOssBucketResponse
 */
ListOssBucketResponse Client::listOssBucketWithOptions(const ListOssBucketRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBucketName()) {
    query["BucketName"] = request.bucketName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListOssBucket"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListOssBucketResponse>();
}

/**
 * @summary Queries Object Storage Service (OSS) buckets.
 *
 * @param request ListOssBucketRequest
 * @return ListOssBucketResponse
 */
ListOssBucketResponse Client::listOssBucket(const ListOssBucketRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listOssBucketWithOptions(request, runtime);
}

/**
 * @summary Queries the risk information of an Object Storage Service (OSS) bucket.
 *
 * @param request ListOssBucketScanInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOssBucketScanInfoResponse
 */
ListOssBucketScanInfoResponse Client::listOssBucketScanInfoWithOptions(const ListOssBucketScanInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBucketName()) {
    query["BucketName"] = request.bucketName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasFuzzBucketName()) {
    query["FuzzBucketName"] = request.fuzzBucketName();
  }

  if (!!request.hasHasRisk()) {
    query["HasRisk"] = request.hasRisk();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListOssBucketScanInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListOssBucketScanInfoResponse>();
}

/**
 * @summary Queries the risk information of an Object Storage Service (OSS) bucket.
 *
 * @param request ListOssBucketScanInfoRequest
 * @return ListOssBucketScanInfoResponse
 */
ListOssBucketScanInfoResponse Client::listOssBucketScanInfo(const ListOssBucketScanInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listOssBucketScanInfoWithOptions(request, runtime);
}

/**
 * @summary Queries the configuration of an Object Storage Service (OSS) file detection policy.
 *
 * @param request ListOssScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOssScanConfigResponse
 */
ListOssScanConfigResponse Client::listOssScanConfigWithOptions(const ListOssScanConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListOssScanConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListOssScanConfigResponse>();
}

/**
 * @summary Queries the configuration of an Object Storage Service (OSS) file detection policy.
 *
 * @param request ListOssScanConfigRequest
 * @return ListOssScanConfigResponse
 */
ListOssScanConfigResponse Client::listOssScanConfig(const ListOssScanConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listOssScanConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the information about plug-ins on a server.
 *
 * @param tmpReq ListPluginForUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPluginForUuidResponse
 */
ListPluginForUuidResponse Client::listPluginForUuidWithOptions(const ListPluginForUuidRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  ListPluginForUuidShrinkRequest request = ListPluginForUuidShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasTypes()) {
    request.setTypesShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.types(), "Types", "simple"));
  }

  json query = {};
  if (!!request.hasTypesShrink()) {
    query["Types"] = request.typesShrink();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListPluginForUuid"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListPluginForUuidResponse>();
}

/**
 * @summary Queries the information about plug-ins on a server.
 *
 * @param request ListPluginForUuidRequest
 * @return ListPluginForUuidResponse
 */
ListPluginForUuidResponse Client::listPluginForUuid(const ListPluginForUuidRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listPluginForUuidWithOptions(request, runtime);
}

/**
 * @summary Queries the security risks of a pod.
 *
 * @param request ListPodRiskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPodRiskResponse
 */
ListPodRiskResponse Client::listPodRiskWithOptions(const ListPodRiskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppName()) {
    query["AppName"] = request.appName();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPodName()) {
    query["PodName"] = request.podName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListPodRisk"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListPodRiskResponse>();
}

/**
 * @summary Queries the security risks of a pod.
 *
 * @param request ListPodRiskRequest
 * @return ListPodRiskResponse
 */
ListPodRiskResponse Client::listPodRisk(const ListPodRiskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listPodRiskWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the self-managed Kubernetes clusters that are added to Security Center.
 *
 * @param request ListPrivateK8sRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrivateK8sResponse
 */
ListPrivateK8sResponse Client::listPrivateK8sWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListPrivateK8s"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListPrivateK8sResponse>();
}

/**
 * @summary Queries the information about the self-managed Kubernetes clusters that are added to Security Center.
 *
 * @return ListPrivateK8sResponse
 */
ListPrivateK8sResponse Client::listPrivateK8s() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listPrivateK8sWithOptions(runtime);
}

/**
 * @summary Queries image repositories.
 *
 * @param request ListPrivateRegistryListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrivateRegistryListResponse
 */
ListPrivateRegistryListResponse Client::listPrivateRegistryListWithOptions(const ListPrivateRegistryListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRegistryType()) {
    query["RegistryType"] = request.registryType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListPrivateRegistryList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListPrivateRegistryListResponse>();
}

/**
 * @summary Queries image repositories.
 *
 * @param request ListPrivateRegistryListRequest
 * @return ListPrivateRegistryListResponse
 */
ListPrivateRegistryListResponse Client::listPrivateRegistryList(const ListPrivateRegistryListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listPrivateRegistryListWithOptions(request, runtime);
}

/**
 * @summary Queries the number of image repositories of each type.
 *
 * @param request ListPrivateRegistryTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPrivateRegistryTypeResponse
 */
ListPrivateRegistryTypeResponse Client::listPrivateRegistryTypeWithOptions(const ListPrivateRegistryTypeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListPrivateRegistryType"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListPrivateRegistryTypeResponse>();
}

/**
 * @summary Queries the number of image repositories of each type.
 *
 * @param request ListPrivateRegistryTypeRequest
 * @return ListPrivateRegistryTypeResponse
 */
ListPrivateRegistryTypeResponse Client::listPrivateRegistryType(const ListPrivateRegistryTypeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listPrivateRegistryTypeWithOptions(request, runtime);
}

/**
 * @summary Query the details of a release batch for upgrade.
 *
 * @param request ListPublishBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPublishBatchResponse
 */
ListPublishBatchResponse Client::listPublishBatchWithOptions(const ListPublishBatchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBatchName()) {
    query["BatchName"] = request.batchName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasUpgradeVersion()) {
    query["UpgradeVersion"] = request.upgradeVersion();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListPublishBatch"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListPublishBatchResponse>();
}

/**
 * @summary Query the details of a release batch for upgrade.
 *
 * @param request ListPublishBatchRequest
 * @return ListPublishBatchResponse
 */
ListPublishBatchResponse Client::listPublishBatch(const ListPublishBatchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listPublishBatchWithOptions(request, runtime);
}

/**
 * @summary Queries the automatic management policies of members that are added to Security Center for multi-account management. The members in the automatic control management directory are automatically added to the member list of Security Center.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @param request ListRdDefaultSyncListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRdDefaultSyncListResponse
 */
ListRdDefaultSyncListResponse Client::listRdDefaultSyncListWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListRdDefaultSyncList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListRdDefaultSyncListResponse>();
}

/**
 * @summary Queries the automatic management policies of members that are added to Security Center for multi-account management. The members in the automatic control management directory are automatically added to the member list of Security Center.
 *
 * @description You must use the management account of your resource directory or a delegated administrator account of Security Center to call this operation.
 *
 * @return ListRdDefaultSyncListResponse
 */
ListRdDefaultSyncListResponse Client::listRdDefaultSyncList() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listRdDefaultSyncListWithOptions(runtime);
}

/**
 * @summary Queries the network objects based on which a specified cluster is protected.
 *
 * @param request ListRuleTargetAllRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRuleTargetAllResponse
 */
ListRuleTargetAllResponse Client::listRuleTargetAllWithOptions(const ListRuleTargetAllRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListRuleTargetAll"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListRuleTargetAllResponse>();
}

/**
 * @summary Queries the network objects based on which a specified cluster is protected.
 *
 * @param request ListRuleTargetAllRequest
 * @return ListRuleTargetAllResponse
 */
ListRuleTargetAllResponse Client::listRuleTargetAll(const ListRuleTargetAllRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listRuleTargetAllWithOptions(request, runtime);
}

/**
 * @summary Queries rules for container tamper-proofing.
 *
 * @param request ListSasContainerWebDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSasContainerWebDefenseRuleResponse
 */
ListSasContainerWebDefenseRuleResponse Client::listSasContainerWebDefenseRuleWithOptions(const ListSasContainerWebDefenseRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLogicalExp()) {
    query["LogicalExp"] = request.logicalExp();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListSasContainerWebDefenseRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListSasContainerWebDefenseRuleResponse>();
}

/**
 * @summary Queries rules for container tamper-proofing.
 *
 * @param request ListSasContainerWebDefenseRuleRequest
 * @return ListSasContainerWebDefenseRuleResponse
 */
ListSasContainerWebDefenseRuleResponse Client::listSasContainerWebDefenseRule(const ListSasContainerWebDefenseRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listSasContainerWebDefenseRuleWithOptions(request, runtime);
}

/**
 * @summary Query the list of supported cloud products for attacks.
 *
 * @param request ListSupportAttackPathAssetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSupportAttackPathAssetResponse
 */
ListSupportAttackPathAssetResponse Client::listSupportAttackPathAssetWithOptions(const ListSupportAttackPathAssetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasNodeType()) {
    query["NodeType"] = request.nodeType();
  }

  if (!!request.hasPathName()) {
    query["PathName"] = request.pathName();
  }

  if (!!request.hasPathType()) {
    query["PathType"] = request.pathType();
  }

  if (!!request.hasSupportType()) {
    query["SupportType"] = request.supportType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListSupportAttackPathAsset"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListSupportAttackPathAssetResponse>();
}

/**
 * @summary Query the list of supported cloud products for attacks.
 *
 * @param request ListSupportAttackPathAssetRequest
 * @return ListSupportAttackPathAssetResponse
 */
ListSupportAttackPathAssetResponse Client::listSupportAttackPathAsset(const ListSupportAttackPathAssetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listSupportAttackPathAssetWithOptions(request, runtime);
}

/**
 * @summary Queries supported file suffixes.
 *
 * @param request ListSupportObjectSuffixRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSupportObjectSuffixResponse
 */
ListSupportObjectSuffixResponse Client::listSupportObjectSuffixWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListSupportObjectSuffix"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListSupportObjectSuffixResponse>();
}

/**
 * @summary Queries supported file suffixes.
 *
 * @return ListSupportObjectSuffixResponse
 */
ListSupportObjectSuffixResponse Client::listSupportObjectSuffix() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listSupportObjectSuffixWithOptions(runtime);
}

/**
 * @summary Queries the details about the aggregation types of system defense rules.
 *
 * @param request ListSystemAggregationRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSystemAggregationRulesResponse
 */
ListSystemAggregationRulesResponse Client::listSystemAggregationRulesWithOptions(const ListSystemAggregationRulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListSystemAggregationRules"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListSystemAggregationRulesResponse>();
}

/**
 * @summary Queries the details about the aggregation types of system defense rules.
 *
 * @param request ListSystemAggregationRulesRequest
 * @return ListSystemAggregationRulesResponse
 */
ListSystemAggregationRulesResponse Client::listSystemAggregationRules(const ListSystemAggregationRulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listSystemAggregationRulesWithOptions(request, runtime);
}

/**
 * @summary Queries the types of system rules.
 *
 * @param request ListSystemClientRuleTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSystemClientRuleTypesResponse
 */
ListSystemClientRuleTypesResponse Client::listSystemClientRuleTypesWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "ListSystemClientRuleTypes"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListSystemClientRuleTypesResponse>();
}

/**
 * @summary Queries the types of system rules.
 *
 * @return ListSystemClientRuleTypesResponse
 */
ListSystemClientRuleTypesResponse Client::listSystemClientRuleTypes() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listSystemClientRuleTypesWithOptions(runtime);
}

/**
 * @summary Queries system defense rules.
 *
 * @param request ListSystemClientRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSystemClientRulesResponse
 */
ListSystemClientRulesResponse Client::listSystemClientRulesWithOptions(const ListSystemClientRulesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAggregationIds()) {
    query["AggregationIds"] = request.aggregationIds();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasIsContainer()) {
    query["IsContainer"] = request.isContainer();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasRuleTypes()) {
    query["RuleTypes"] = request.ruleTypes();
  }

  if (!!request.hasSystemType()) {
    query["SystemType"] = request.systemType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListSystemClientRules"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListSystemClientRulesResponse>();
}

/**
 * @summary Queries system defense rules.
 *
 * @param request ListSystemClientRulesRequest
 * @return ListSystemClientRulesResponse
 */
ListSystemClientRulesResponse Client::listSystemClientRules(const ListSystemClientRulesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listSystemClientRulesWithOptions(request, runtime);
}

/**
 * @summary Queries the aggregation types of system defense rules.
 *
 * @param request ListSystemRuleAggregationTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSystemRuleAggregationTypesResponse
 */
ListSystemRuleAggregationTypesResponse Client::listSystemRuleAggregationTypesWithOptions(const ListSystemRuleAggregationTypesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  map<string, string> query = Utils::Utils::query(request.toMap());
  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListSystemRuleAggregationTypes"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "GET"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListSystemRuleAggregationTypesResponse>();
}

/**
 * @summary Queries the aggregation types of system defense rules.
 *
 * @param request ListSystemRuleAggregationTypesRequest
 * @return ListSystemRuleAggregationTypesResponse
 */
ListSystemRuleAggregationTypesResponse Client::listSystemRuleAggregationTypes(const ListSystemRuleAggregationTypesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listSystemRuleAggregationTypesWithOptions(request, runtime);
}

/**
 * @summary Query Targets by Batch
 *
 * @param request ListTargetByBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTargetByBatchResponse
 */
ListTargetByBatchResponse Client::listTargetByBatchWithOptions(const ListTargetByBatchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBatchId()) {
    query["BatchId"] = request.batchId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasOperationBase()) {
    query["OperationBase"] = request.operationBase();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListTargetByBatch"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListTargetByBatchResponse>();
}

/**
 * @summary Query Targets by Batch
 *
 * @param request ListTargetByBatchRequest
 * @return ListTargetByBatchResponse
 */
ListTargetByBatchResponse Client::listTargetByBatch(const ListTargetByBatchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listTargetByBatchWithOptions(request, runtime);
}

/**
 * @summary Queries tasks that are not complete by task type.
 *
 * @param request ListUnfinishedOnceTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUnfinishedOnceTaskResponse
 */
ListUnfinishedOnceTaskResponse Client::listUnfinishedOnceTaskWithOptions(const ListUnfinishedOnceTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasTaskType()) {
    query["TaskType"] = request.taskType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListUnfinishedOnceTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListUnfinishedOnceTaskResponse>();
}

/**
 * @summary Queries tasks that are not complete by task type.
 *
 * @param request ListUnfinishedOnceTaskRequest
 * @return ListUnfinishedOnceTaskResponse
 */
ListUnfinishedOnceTaskResponse Client::listUnfinishedOnceTask(const ListUnfinishedOnceTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listUnfinishedOnceTaskWithOptions(request, runtime);
}

/**
 * @summary Queries the information about the servers whose Security Center agent is not installed.
 *
 * @param request ListUninstallAegisMachinesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUninstallAegisMachinesResponse
 */
ListUninstallAegisMachinesResponse Client::listUninstallAegisMachinesWithOptions(const ListUninstallAegisMachinesRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasOs()) {
    query["Os"] = request.os();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegionIdStr()) {
    query["RegionIdStr"] = request.regionIdStr();
  }

  if (!!request.hasRegionNo()) {
    query["RegionNo"] = request.regionNo();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListUninstallAegisMachines"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListUninstallAegisMachinesResponse>();
}

/**
 * @summary Queries the information about the servers whose Security Center agent is not installed.
 *
 * @param request ListUninstallAegisMachinesRequest
 * @return ListUninstallAegisMachinesResponse
 */
ListUninstallAegisMachinesResponse Client::listUninstallAegisMachines(const ListUninstallAegisMachinesRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listUninstallAegisMachinesWithOptions(request, runtime);
}

/**
 * @summary Get VPC Data
 *
 * @param request ListUserVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserVpcResponse
 */
ListUserVpcResponse Client::listUserVpcWithOptions(const ListUserVpcRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasK8sRegionId()) {
    query["K8sRegionId"] = request.k8sRegionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListUserVpc"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListUserVpcResponse>();
}

/**
 * @summary Get VPC Data
 *
 * @param request ListUserVpcRequest
 * @return ListUserVpcResponse
 */
ListUserVpcResponse Client::listUserVpc(const ListUserVpcRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listUserVpcWithOptions(request, runtime);
}

/**
 * @summary Query the list of instance UUIDs based on the application ID.
 *
 * @param request ListUuidsByAppIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUuidsByAppIdResponse
 */
ListUuidsByAppIdResponse Client::listUuidsByAppIdWithOptions(const ListUuidsByAppIdRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppId()) {
    query["AppId"] = request.appId();
  }

  if (!!request.hasAppRegionId()) {
    query["AppRegionId"] = request.appRegionId();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasResourceDirectoryUid()) {
    query["ResourceDirectoryUid"] = request.resourceDirectoryUid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListUuidsByAppId"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListUuidsByAppIdResponse>();
}

/**
 * @summary Query the list of instance UUIDs based on the application ID.
 *
 * @param request ListUuidsByAppIdRequest
 * @return ListUuidsByAppIdResponse
 */
ListUuidsByAppIdResponse Client::listUuidsByAppId(const ListUuidsByAppIdRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listUuidsByAppIdWithOptions(request, runtime);
}

/**
 * @summary Queries protected assets by using the paths to specific web directories.
 *
 * @param request ListUuidsByWebPathRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUuidsByWebPathResponse
 */
ListUuidsByWebPathResponse Client::listUuidsByWebPathWithOptions(const ListUuidsByWebPathRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasWebPath()) {
    query["WebPath"] = request.webPath();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListUuidsByWebPath"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListUuidsByWebPathResponse>();
}

/**
 * @summary Queries protected assets by using the paths to specific web directories.
 *
 * @param request ListUuidsByWebPathRequest
 * @return ListUuidsByWebPathResponse
 */
ListUuidsByWebPathResponse Client::listUuidsByWebPath(const ListUuidsByWebPathRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listUuidsByWebPathWithOptions(request, runtime);
}

/**
 * @summary Queries servers on which virus detection and removal tasks are performed.
 *
 * @param request ListVirusScanMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVirusScanMachineResponse
 */
ListVirusScanMachineResponse Client::listVirusScanMachineWithOptions(const ListVirusScanMachineRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVirusScanMachine"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVirusScanMachineResponse>();
}

/**
 * @summary Queries servers on which virus detection and removal tasks are performed.
 *
 * @param request ListVirusScanMachineRequest
 * @return ListVirusScanMachineResponse
 */
ListVirusScanMachineResponse Client::listVirusScanMachine(const ListVirusScanMachineRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVirusScanMachineWithOptions(request, runtime);
}

/**
 * @summary Queries the alert events that are generated for viruses detected on a server.
 *
 * @param request ListVirusScanMachineEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVirusScanMachineEventResponse
 */
ListVirusScanMachineEventResponse Client::listVirusScanMachineEventWithOptions(const ListVirusScanMachineEventRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasOperateTaskId()) {
    query["OperateTaskId"] = request.operateTaskId();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVirusScanMachineEvent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVirusScanMachineEventResponse>();
}

/**
 * @summary Queries the alert events that are generated for viruses detected on a server.
 *
 * @param request ListVirusScanMachineEventRequest
 * @return ListVirusScanMachineEventResponse
 */
ListVirusScanMachineEventResponse Client::listVirusScanMachineEvent(const ListVirusScanMachineEventRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVirusScanMachineEventWithOptions(request, runtime);
}

/**
 * @summary Queries virus scan tasks based on conditions such as the task type, task status, and server information.
 *
 * @param request ListVirusScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVirusScanTaskResponse
 */
ListVirusScanTaskResponse Client::listVirusScanTaskWithOptions(const ListVirusScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasInternetIp()) {
    query["InternetIp"] = request.internetIp();
  }

  if (!!request.hasIntranetIp()) {
    query["IntranetIp"] = request.intranetIp();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMachineName()) {
    query["MachineName"] = request.machineName();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasRootTask()) {
    query["RootTask"] = request.rootTask();
  }

  if (!!request.hasRootTaskId()) {
    query["RootTaskId"] = request.rootTaskId();
  }

  if (!!request.hasScanType()) {
    query["ScanType"] = request.scanType();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasStatusList()) {
    query["StatusList"] = request.statusList();
  }

  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVirusScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVirusScanTaskResponse>();
}

/**
 * @summary Queries virus scan tasks based on conditions such as the task type, task status, and server information.
 *
 * @param request ListVirusScanTaskRequest
 * @return ListVirusScanTaskResponse
 */
ListVirusScanTaskResponse Client::listVirusScanTask(const ListVirusScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVirusScanTaskWithOptions(request, runtime);
}

/**
 * @summary Queries the existing configurations of vulnerabilities that can be automatically fixed.
 *
 * @param request ListVulAutoRepairConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVulAutoRepairConfigResponse
 */
ListVulAutoRepairConfigResponse Client::listVulAutoRepairConfigWithOptions(const ListVulAutoRepairConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAliasName()) {
    query["AliasName"] = request.aliasName();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVulAutoRepairConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVulAutoRepairConfigResponse>();
}

/**
 * @summary Queries the existing configurations of vulnerabilities that can be automatically fixed.
 *
 * @param request ListVulAutoRepairConfigRequest
 * @return ListVulAutoRepairConfigResponse
 */
ListVulAutoRepairConfigResponse Client::listVulAutoRepairConfig(const ListVulAutoRepairConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVulAutoRepairConfigWithOptions(request, runtime);
}

/**
 * @summary Queries the global configurations of vulnerability detection.
 *
 * @param request ListVulGlobalConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVulGlobalConfigResponse
 */
ListVulGlobalConfigResponse Client::listVulGlobalConfigWithOptions(const ListVulGlobalConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigKey()) {
    query["ConfigKey"] = request.configKey();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ListVulGlobalConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ListVulGlobalConfigResponse>();
}

/**
 * @summary Queries the global configurations of vulnerability detection.
 *
 * @param request ListVulGlobalConfigRequest
 * @return ListVulGlobalConfigResponse
 */
ListVulGlobalConfigResponse Client::listVulGlobalConfig(const ListVulGlobalConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return listVulGlobalConfigWithOptions(request, runtime);
}

/**
 * @summary Marks members for multi-account management. You can call this operation to mark selected members as followed. In the Security Center console, the drop-down list above the left-side navigation pane displays the followed members.
 *
 * @param request MarkMonitorAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MarkMonitorAccountsResponse
 */
MarkMonitorAccountsResponse Client::markMonitorAccountsWithOptions(const MarkMonitorAccountsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAccountIds()) {
    query["AccountIds"] = request.accountIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "MarkMonitorAccounts"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<MarkMonitorAccountsResponse>();
}

/**
 * @summary Marks members for multi-account management. You can call this operation to mark selected members as followed. In the Security Center console, the drop-down list above the left-side navigation pane displays the followed members.
 *
 * @param request MarkMonitorAccountsRequest
 * @return MarkMonitorAccountsResponse
 */
MarkMonitorAccountsResponse Client::markMonitorAccounts(const MarkMonitorAccountsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return markMonitorAccountsWithOptions(request, runtime);
}

/**
 * @summary Handles AccessKey pair leaks.
 *
 * @param request ModifyAccessKeyLeakDealRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccessKeyLeakDealResponse
 */
ModifyAccessKeyLeakDealResponse Client::modifyAccessKeyLeakDealWithOptions(const ModifyAccessKeyLeakDealRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasIdList()) {
    query["IdList"] = request.idList();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyAccessKeyLeakDeal"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyAccessKeyLeakDealResponse>();
}

/**
 * @summary Handles AccessKey pair leaks.
 *
 * @param request ModifyAccessKeyLeakDealRequest
 * @return ModifyAccessKeyLeakDealResponse
 */
ModifyAccessKeyLeakDealResponse Client::modifyAccessKeyLeakDeal(const ModifyAccessKeyLeakDealRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyAccessKeyLeakDealWithOptions(request, runtime);
}

/**
 * @summary Modifies a defense rule against brute-force attacks.
 *
 * @param tmpReq ModifyAntiBruteForceRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAntiBruteForceRuleResponse
 */
ModifyAntiBruteForceRuleResponse Client::modifyAntiBruteForceRuleWithOptions(const ModifyAntiBruteForceRuleRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  ModifyAntiBruteForceRuleShrinkRequest request = ModifyAntiBruteForceRuleShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasProtocolType()) {
    request.setProtocolTypeShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.protocolType(), "ProtocolType", "json"));
  }

  json query = {};
  if (!!request.hasDefaultRule()) {
    query["DefaultRule"] = request.defaultRule();
  }

  if (!!request.hasFailCount()) {
    query["FailCount"] = request.failCount();
  }

  if (!!request.hasForbiddenTime()) {
    query["ForbiddenTime"] = request.forbiddenTime();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasProtocolTypeShrink()) {
    query["ProtocolType"] = request.protocolTypeShrink();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasSpan()) {
    query["Span"] = request.span();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyAntiBruteForceRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyAntiBruteForceRuleResponse>();
}

/**
 * @summary Modifies a defense rule against brute-force attacks.
 *
 * @param request ModifyAntiBruteForceRuleRequest
 * @return ModifyAntiBruteForceRuleResponse
 */
ModifyAntiBruteForceRuleResponse Client::modifyAntiBruteForceRule(const ModifyAntiBruteForceRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyAntiBruteForceRuleWithOptions(request, runtime);
}

/**
 * @summary Configures a scan cycle for application vulnerabilities.
 *
 * @param request ModifyAppVulScanCycleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAppVulScanCycleResponse
 */
ModifyAppVulScanCycleResponse Client::modifyAppVulScanCycleWithOptions(const ModifyAppVulScanCycleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCycle()) {
    query["Cycle"] = request.cycle();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyAppVulScanCycle"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyAppVulScanCycleResponse>();
}

/**
 * @summary Configures a scan cycle for application vulnerabilities.
 *
 * @param request ModifyAppVulScanCycleRequest
 * @return ModifyAppVulScanCycleResponse
 */
ModifyAppVulScanCycleResponse Client::modifyAppVulScanCycle(const ModifyAppVulScanCycleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyAppVulScanCycleWithOptions(request, runtime);
}

/**
 * @summary Modifies the configurations for cleaning offline hosts whose provider cannot be identified.
 *
 * @param request ModifyAssetCleanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAssetCleanConfigResponse
 */
ModifyAssetCleanConfigResponse Client::modifyAssetCleanConfigWithOptions(const ModifyAssetCleanConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssetCleanConfigs()) {
    query["AssetCleanConfigs"] = request.assetCleanConfigs();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyAssetCleanConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyAssetCleanConfigResponse>();
}

/**
 * @summary Modifies the configurations for cleaning offline hosts whose provider cannot be identified.
 *
 * @param request ModifyAssetCleanConfigRequest
 * @return ModifyAssetCleanConfigResponse
 */
ModifyAssetCleanConfigResponse Client::modifyAssetCleanConfig(const ModifyAssetCleanConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyAssetCleanConfigWithOptions(request, runtime);
}

/**
 * @summary Changes the server group to which specified servers belong.
 *
 * @description You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
 * ### Limits
 * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyAssetGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAssetGroupResponse
 */
ModifyAssetGroupResponse Client::modifyAssetGroupWithOptions(const ModifyAssetGroupRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGroupId()) {
    query["GroupId"] = request.groupId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyAssetGroup"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyAssetGroupResponse>();
}

/**
 * @summary Changes the server group to which specified servers belong.
 *
 * @description You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
 * ### Limits
 * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyAssetGroupRequest
 * @return ModifyAssetGroupResponse
 */
ModifyAssetGroupResponse Client::modifyAssetGroup(const ModifyAssetGroupRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyAssetGroupWithOptions(request, runtime);
}

/**
 * @summary Modifies the importance of an asset.
 *
 * @param request ModifyAssetImportantRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAssetImportantResponse
 */
ModifyAssetImportantResponse Client::modifyAssetImportantWithOptions(const ModifyAssetImportantRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasImportantCode()) {
    query["ImportantCode"] = request.importantCode();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyAssetImportant"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyAssetImportantResponse>();
}

/**
 * @summary Modifies the importance of an asset.
 *
 * @param request ModifyAssetImportantRequest
 * @return ModifyAssetImportantResponse
 */
ModifyAssetImportantResponse Client::modifyAssetImportant(const ModifyAssetImportantRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyAssetImportantWithOptions(request, runtime);
}

/**
 * @summary Modifies the information about a witness that is created by using the container signature feature.
 *
 * @param request ModifyAttestorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAttestorResponse
 */
ModifyAttestorResponse Client::modifyAttestorWithOptions(const ModifyAttestorRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasKeyId()) {
    query["KeyId"] = request.keyId();
  }

  if (!!request.hasKeyRegionId()) {
    query["KeyRegionId"] = request.keyRegionId();
  }

  if (!!request.hasKeyVersionId()) {
    query["KeyVersionId"] = request.keyVersionId();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyAttestor"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyAttestorResponse>();
}

/**
 * @summary Modifies the information about a witness that is created by using the container signature feature.
 *
 * @param request ModifyAttestorRequest
 * @return ModifyAttestorResponse
 */
ModifyAttestorResponse Client::modifyAttestor(const ModifyAttestorRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyAttestorWithOptions(request, runtime);
}

/**
 * @summary Specifies the number of days after which a detected vulnerability is automatically deleted.
 *
 * @param request ModifyAutoDelConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAutoDelConfigResponse
 */
ModifyAutoDelConfigResponse Client::modifyAutoDelConfigWithOptions(const ModifyAutoDelConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDays()) {
    query["Days"] = request.days();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyAutoDelConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyAutoDelConfigResponse>();
}

/**
 * @summary Specifies the number of days after which a detected vulnerability is automatically deleted.
 *
 * @param request ModifyAutoDelConfigRequest
 * @return ModifyAutoDelConfigResponse
 */
ModifyAutoDelConfigResponse Client::modifyAutoDelConfig(const ModifyAutoDelConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyAutoDelConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies an anti-ransomware policy.
 *
 * @param tmpReq ModifyBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBackupPolicyResponse
 */
ModifyBackupPolicyResponse Client::modifyBackupPolicyWithOptions(const ModifyBackupPolicyRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  ModifyBackupPolicyShrinkRequest request = ModifyBackupPolicyShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasPolicy()) {
    request.setPolicyShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.policy(), "Policy", "json"));
  }

  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPolicyShrink()) {
    query["Policy"] = request.policyShrink();
  }

  if (!!request.hasPolicyRegionId()) {
    query["PolicyRegionId"] = request.policyRegionId();
  }

  if (!!request.hasPolicyVersion()) {
    query["PolicyVersion"] = request.policyVersion();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyBackupPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyBackupPolicyResponse>();
}

/**
 * @summary Modifies an anti-ransomware policy.
 *
 * @param request ModifyBackupPolicyRequest
 * @return ModifyBackupPolicyResponse
 */
ModifyBackupPolicyResponse Client::modifyBackupPolicy(const ModifyBackupPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyBackupPolicyWithOptions(request, runtime);
}

/**
 * @summary Enables or disables an anti-ransomware policy.
 *
 * @param request ModifyBackupPolicyStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBackupPolicyStatusResponse
 */
ModifyBackupPolicyStatusResponse Client::modifyBackupPolicyStatusWithOptions(const ModifyBackupPolicyStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasPolicyVersion()) {
    query["PolicyVersion"] = request.policyVersion();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyBackupPolicyStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyBackupPolicyStatusResponse>();
}

/**
 * @summary Enables or disables an anti-ransomware policy.
 *
 * @param request ModifyBackupPolicyStatusRequest
 * @return ModifyBackupPolicyStatusResponse
 */
ModifyBackupPolicyStatusResponse Client::modifyBackupPolicyStatus(const ModifyBackupPolicyStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyBackupPolicyStatusWithOptions(request, runtime);
}

/**
 * @summary Modify Container Image Signature Security Policy.
 *
 * @param request ModifyBinarySecurityPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBinarySecurityPolicyResponse
 */
ModifyBinarySecurityPolicyResponse Client::modifyBinarySecurityPolicyWithOptions(const ModifyBinarySecurityPolicyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusters()) {
    query["Clusters"] = request.clusters();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasPolicy()) {
    query["Policy"] = request.policy();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyBinarySecurityPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyBinarySecurityPolicyResponse>();
}

/**
 * @summary Modify Container Image Signature Security Policy.
 *
 * @param request ModifyBinarySecurityPolicyRequest
 * @return ModifyBinarySecurityPolicyResponse
 */
ModifyBinarySecurityPolicyResponse Client::modifyBinarySecurityPolicy(const ModifyBinarySecurityPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyBinarySecurityPolicyWithOptions(request, runtime);
}

/**
 * @summary Modify the rule settings for cloud product configuration checks
 *
 * @param request ModifyCheckRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCheckRuleResponse
 */
ModifyCheckRuleResponse Client::modifyCheckRuleWithOptions(const ModifyCheckRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAddInstanceList()) {
    query["AddInstanceList"] = request.addInstanceList();
  }

  if (!!request.hasDeleteInstanceList()) {
    query["DeleteInstanceList"] = request.deleteInstanceList();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  if (!!request.hasScopeType()) {
    query["ScopeType"] = request.scopeType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyCheckRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyCheckRuleResponse>();
}

/**
 * @summary Modify the rule settings for cloud product configuration checks
 *
 * @param request ModifyCheckRuleRequest
 * @return ModifyCheckRuleResponse
 */
ModifyCheckRuleResponse Client::modifyCheckRule(const ModifyCheckRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyCheckRuleWithOptions(request, runtime);
}

/**
 * @summary Deletes all logs that occupy your log storage.
 *
 * @description Deleted logs cannot be restored. Before you call this operation to delete all logs and free up log storage, we recommend that you export and save your logs to your computer.
 *
 * @param request ModifyClearLogstoreStorageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClearLogstoreStorageResponse
 */
ModifyClearLogstoreStorageResponse Client::modifyClearLogstoreStorageWithOptions(const ModifyClearLogstoreStorageRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasUserLogStore()) {
    query["UserLogStore"] = request.userLogStore();
  }

  if (!!request.hasUserProject()) {
    query["UserProject"] = request.userProject();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyClearLogstoreStorage"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyClearLogstoreStorageResponse>();
}

/**
 * @summary Deletes all logs that occupy your log storage.
 *
 * @description Deleted logs cannot be restored. Before you call this operation to delete all logs and free up log storage, we recommend that you export and save your logs to your computer.
 *
 * @param request ModifyClearLogstoreStorageRequest
 * @return ModifyClearLogstoreStorageResponse
 */
ModifyClearLogstoreStorageResponse Client::modifyClearLogstoreStorage(const ModifyClearLogstoreStorageRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyClearLogstoreStorageWithOptions(request, runtime);
}

/**
 * @summary Modifies the resource configurations of the Security Center agent.
 *
 * @param request ModifyClientConfSetupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClientConfSetupResponse
 */
ModifyClientConfSetupResponse Client::modifyClientConfSetupWithOptions(const ModifyClientConfSetupRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStrategyConfig()) {
    query["StrategyConfig"] = request.strategyConfig();
  }

  if (!!request.hasStrategyTag()) {
    query["StrategyTag"] = request.strategyTag();
  }

  if (!!request.hasStrategyTagValue()) {
    query["StrategyTagValue"] = request.strategyTagValue();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyClientConfSetup"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyClientConfSetupResponse>();
}

/**
 * @summary Modifies the resource configurations of the Security Center agent.
 *
 * @param request ModifyClientConfSetupRequest
 * @return ModifyClientConfSetupResponse
 */
ModifyClientConfSetupResponse Client::modifyClientConfSetup(const ModifyClientConfSetupRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyClientConfSetupWithOptions(request, runtime);
}

/**
 * @summary Modifies an agent configuration policy.
 *
 * @param request ModifyClientConfStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClientConfStrategyResponse
 */
ModifyClientConfStrategyResponse Client::modifyClientConfStrategyWithOptions(const ModifyClientConfStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTag()) {
    query["Tag"] = request.tag();
  }

  if (!!request.hasTagExt()) {
    query["TagExt"] = request.tagExt();
  }

  if (!!request.hasTagValue()) {
    query["TagValue"] = request.tagValue();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyClientConfStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyClientConfStrategyResponse>();
}

/**
 * @summary Modifies an agent configuration policy.
 *
 * @param request ModifyClientConfStrategyRequest
 * @return ModifyClientConfStrategyResponse
 */
ModifyClientConfStrategyResponse Client::modifyClientConfStrategy(const ModifyClientConfStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyClientConfStrategyWithOptions(request, runtime);
}

/**
 * @summary Modifies a custom defense rule.
 *
 * @param request ModifyClientUserDefineRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClientUserDefineRuleResponse
 */
ModifyClientUserDefineRuleResponse Client::modifyClientUserDefineRuleWithOptions(const ModifyClientUserDefineRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasActionType()) {
    query["ActionType"] = request.actionType();
  }

  if (!!request.hasCmdline()) {
    query["Cmdline"] = request.cmdline();
  }

  if (!!request.hasDomain()) {
    query["Domain"] = request.domain();
  }

  if (!!request.hasFilePath()) {
    query["FilePath"] = request.filePath();
  }

  if (!!request.hasIP()) {
    query["IP"] = request.IP();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasMd5List()) {
    query["Md5List"] = request.md5List();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasNewFilePath()) {
    query["NewFilePath"] = request.newFilePath();
  }

  if (!!request.hasParentCmdline()) {
    query["ParentCmdline"] = request.parentCmdline();
  }

  if (!!request.hasParentProcPath()) {
    query["ParentProcPath"] = request.parentProcPath();
  }

  if (!!request.hasPlatform()) {
    query["Platform"] = request.platform();
  }

  if (!!request.hasPort()) {
    query["Port"] = request.port();
  }

  if (!!request.hasPortStr()) {
    query["PortStr"] = request.portStr();
  }

  if (!!request.hasProcPath()) {
    query["ProcPath"] = request.procPath();
  }

  if (!!request.hasRegistryContent()) {
    query["RegistryContent"] = request.registryContent();
  }

  if (!!request.hasRegistryKey()) {
    query["RegistryKey"] = request.registryKey();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyClientUserDefineRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyClientUserDefineRuleResponse>();
}

/**
 * @summary Modifies a custom defense rule.
 *
 * @param request ModifyClientUserDefineRuleRequest
 * @return ModifyClientUserDefineRuleResponse
 */
ModifyClientUserDefineRuleResponse Client::modifyClientUserDefineRule(const ModifyClientUserDefineRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyClientUserDefineRuleWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of the AccessKey pair for a third-party account.
 *
 * @param request ModifyCloudVendorAccountAKRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCloudVendorAccountAKResponse
 */
ModifyCloudVendorAccountAKResponse Client::modifyCloudVendorAccountAKWithOptions(const ModifyCloudVendorAccountAKRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAuthIds()) {
    query["AuthIds"] = request.authIds();
  }

  if (!!request.hasAuthModules()) {
    query["AuthModules"] = request.authModules();
  }

  if (!!request.hasCtdrCloudUserId()) {
    query["CtdrCloudUserId"] = request.ctdrCloudUserId();
  }

  if (!!request.hasDomain()) {
    query["Domain"] = request.domain();
  }

  if (!!request.hasExtendInfo()) {
    query["ExtendInfo"] = request.extendInfo();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasRegions()) {
    query["Regions"] = request.regions();
  }

  if (!!request.hasSecretId()) {
    query["SecretId"] = request.secretId();
  }

  if (!!request.hasSecretKey()) {
    query["SecretKey"] = request.secretKey();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasSubscriptionIds()) {
    query["SubscriptionIds"] = request.subscriptionIds();
  }

  if (!!request.hasTenantId()) {
    query["TenantId"] = request.tenantId();
  }

  if (!!request.hasVendorAuthAlias()) {
    query["VendorAuthAlias"] = request.vendorAuthAlias();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyCloudVendorAccountAK"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyCloudVendorAccountAKResponse>();
}

/**
 * @summary Modifies the configuration of the AccessKey pair for a third-party account.
 *
 * @param request ModifyCloudVendorAccountAKRequest
 * @return ModifyCloudVendorAccountAKResponse
 */
ModifyCloudVendorAccountAKResponse Client::modifyCloudVendorAccountAK(const ModifyCloudVendorAccountAKRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyCloudVendorAccountAKWithOptions(request, runtime);
}

/**
 * @summary Modify the Trail configuration information for the AK
 *
 * @param request ModifyCloudVendorTrialConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCloudVendorTrialConfigResponse
 */
ModifyCloudVendorTrialConfigResponse Client::modifyCloudVendorTrialConfigWithOptions(const ModifyCloudVendorTrialConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAuthId()) {
    query["AuthId"] = request.authId();
  }

  if (!!request.hasAuthInfo()) {
    query["AuthInfo"] = request.authInfo();
  }

  if (!!request.hasDeleteTrail()) {
    query["DeleteTrail"] = request.deleteTrail();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyCloudVendorTrialConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyCloudVendorTrialConfigResponse>();
}

/**
 * @summary Modify the Trail configuration information for the AK
 *
 * @param request ModifyCloudVendorTrialConfigRequest
 * @return ModifyCloudVendorTrialConfigResponse
 */
ModifyCloudVendorTrialConfigResponse Client::modifyCloudVendorTrialConfig(const ModifyCloudVendorTrialConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyCloudVendorTrialConfigWithOptions(request, runtime);
}

/**
 * @summary Fixes the blocking status of clusters whose status is Normal to be confirmed.
 *
 * @param request ModifyClusterCnnfStatusUserConfirmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyClusterCnnfStatusUserConfirmResponse
 */
ModifyClusterCnnfStatusUserConfirmResponse Client::modifyClusterCnnfStatusUserConfirmWithOptions(const ModifyClusterCnnfStatusUserConfirmRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterIds()) {
    query["ClusterIds"] = request.clusterIds();
  }

  if (!!request.hasUserConfirm()) {
    query["UserConfirm"] = request.userConfirm();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyClusterCnnfStatusUserConfirm"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyClusterCnnfStatusUserConfirmResponse>();
}

/**
 * @summary Fixes the blocking status of clusters whose status is Normal to be confirmed.
 *
 * @param request ModifyClusterCnnfStatusUserConfirmRequest
 * @return ModifyClusterCnnfStatusUserConfirmResponse
 */
ModifyClusterCnnfStatusUserConfirmResponse Client::modifyClusterCnnfStatusUserConfirm(const ModifyClusterCnnfStatusUserConfirmRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyClusterCnnfStatusUserConfirmWithOptions(request, runtime);
}

/**
 * @summary Modifies the priority to fix vulnerabilities.
 *
 * @param request ModifyConcernNecessityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyConcernNecessityResponse
 */
ModifyConcernNecessityResponse Client::modifyConcernNecessityWithOptions(const ModifyConcernNecessityRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConcernNecessity()) {
    query["ConcernNecessity"] = request.concernNecessity();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyConcernNecessity"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyConcernNecessityResponse>();
}

/**
 * @summary Modifies the priority to fix vulnerabilities.
 *
 * @param request ModifyConcernNecessityRequest
 * @return ModifyConcernNecessityResponse
 */
ModifyConcernNecessityResponse Client::modifyConcernNecessity(const ModifyConcernNecessityRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyConcernNecessityWithOptions(request, runtime);
}

/**
 * @summary Modifies a rule for non-image program defense.
 *
 * @param tmpReq ModifyContainerDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyContainerDefenseRuleResponse
 */
ModifyContainerDefenseRuleResponse Client::modifyContainerDefenseRuleWithOptions(const ModifyContainerDefenseRuleRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  ModifyContainerDefenseRuleShrinkRequest request = ModifyContainerDefenseRuleShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasWhitelist()) {
    request.setWhitelistShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.whitelist(), "Whitelist", "json"));
  }

  json query = {};
  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasRuleAction()) {
    query["RuleAction"] = request.ruleAction();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasRuleSwitch()) {
    query["RuleSwitch"] = request.ruleSwitch();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  if (!!request.hasScope()) {
    query["Scope"] = request.scope();
  }

  if (!!request.hasWhitelistShrink()) {
    query["Whitelist"] = request.whitelistShrink();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyContainerDefenseRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyContainerDefenseRuleResponse>();
}

/**
 * @summary Modifies a rule for non-image program defense.
 *
 * @param request ModifyContainerDefenseRuleRequest
 * @return ModifyContainerDefenseRuleResponse
 */
ModifyContainerDefenseRuleResponse Client::modifyContainerDefenseRule(const ModifyContainerDefenseRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyContainerDefenseRuleWithOptions(request, runtime);
}

/**
 * @summary Changes the status of non-image program defense rules.
 *
 * @param request ModifyContainerDefenseRuleSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyContainerDefenseRuleSwitchResponse
 */
ModifyContainerDefenseRuleSwitchResponse Client::modifyContainerDefenseRuleSwitchWithOptions(const ModifyContainerDefenseRuleSwitchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRuleIds()) {
    query["RuleIds"] = request.ruleIds();
  }

  if (!!request.hasRuleSwitch()) {
    query["RuleSwitch"] = request.ruleSwitch();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyContainerDefenseRuleSwitch"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyContainerDefenseRuleSwitchResponse>();
}

/**
 * @summary Changes the status of non-image program defense rules.
 *
 * @param request ModifyContainerDefenseRuleSwitchRequest
 * @return ModifyContainerDefenseRuleSwitchResponse
 */
ModifyContainerDefenseRuleSwitchResponse Client::modifyContainerDefenseRuleSwitch(const ModifyContainerDefenseRuleSwitchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyContainerDefenseRuleSwitchWithOptions(request, runtime);
}

/**
 * @summary Modifies the defense rule against container escapes.
 *
 * @param request ModifyContainerPluginRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyContainerPluginRuleResponse
 */
ModifyContainerPluginRuleResponse Client::modifyContainerPluginRuleWithOptions(const ModifyContainerPluginRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMode()) {
    query["Mode"] = request.mode();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasRuleType()) {
    query["RuleType"] = request.ruleType();
  }

  if (!!request.hasSelectedPolicy()) {
    query["SelectedPolicy"] = request.selectedPolicy();
  }

  if (!!request.hasWhiteImages()) {
    query["WhiteImages"] = request.whiteImages();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyContainerPluginRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyContainerPluginRuleResponse>();
}

/**
 * @summary Modifies the defense rule against container escapes.
 *
 * @param request ModifyContainerPluginRuleRequest
 * @return ModifyContainerPluginRuleResponse
 */
ModifyContainerPluginRuleResponse Client::modifyContainerPluginRule(const ModifyContainerPluginRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyContainerPluginRuleWithOptions(request, runtime);
}

/**
 * @summary Modifies the configurations of vulnerability scan for a running container.
 *
 * @param request ModifyContainerScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyContainerScanConfigResponse
 */
ModifyContainerScanConfigResponse Client::modifyContainerScanConfigWithOptions(const ModifyContainerScanConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppNames()) {
    query["AppNames"] = request.appNames();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyContainerScanConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyContainerScanConfigResponse>();
}

/**
 * @summary Modifies the configurations of vulnerability scan for a running container.
 *
 * @param request ModifyContainerScanConfigRequest
 * @return ModifyContainerScanConfigResponse
 */
ModifyContainerScanConfigResponse Client::modifyContainerScanConfig(const ModifyContainerScanConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyContainerScanConfigWithOptions(request, runtime);
}

/**
 * @summary Adds vulnerabilities to the whitelist. After you add the vulnerabilities to the whitelist, Security Center no longer generates alerts for the vulnerabilities.
 *
 * @param request ModifyCreateVulWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCreateVulWhitelistResponse
 */
ModifyCreateVulWhitelistResponse Client::modifyCreateVulWhitelistWithOptions(const ModifyCreateVulWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasReason()) {
    query["Reason"] = request.reason();
  }

  if (!!request.hasTargetInfo()) {
    query["TargetInfo"] = request.targetInfo();
  }

  if (!!request.hasWhitelist()) {
    query["Whitelist"] = request.whitelist();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyCreateVulWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyCreateVulWhitelistResponse>();
}

/**
 * @summary Adds vulnerabilities to the whitelist. After you add the vulnerabilities to the whitelist, Security Center no longer generates alerts for the vulnerabilities.
 *
 * @param request ModifyCreateVulWhitelistRequest
 * @return ModifyCreateVulWhitelistResponse
 */
ModifyCreateVulWhitelistResponse Client::modifyCreateVulWhitelist(const ModifyCreateVulWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyCreateVulWhitelistWithOptions(request, runtime);
}

/**
 * @summary Modifies a custom IP address blocking policy.
 *
 * @param request ModifyCustomBlockRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCustomBlockRecordResponse
 */
ModifyCustomBlockRecordResponse Client::modifyCustomBlockRecordWithOptions(const ModifyCustomBlockRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBlockIp()) {
    query["BlockIp"] = request.blockIp();
  }

  if (!!request.hasBound()) {
    query["Bound"] = request.bound();
  }

  if (!!request.hasExpireTime()) {
    query["ExpireTime"] = request.expireTime();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyCustomBlockRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyCustomBlockRecordResponse>();
}

/**
 * @summary Modifies a custom IP address blocking policy.
 *
 * @param request ModifyCustomBlockRecordRequest
 * @return ModifyCustomBlockRecordResponse
 */
ModifyCustomBlockRecordResponse Client::modifyCustomBlockRecord(const ModifyCustomBlockRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyCustomBlockRecordWithOptions(request, runtime);
}

/**
 * @summary Modifies the execution cycle of periodic tasks, including image scan, urgent vulnerability scan, and virus detection tasks.
 *
 * @param request ModifyCycleTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCycleTaskResponse
 */
ModifyCycleTaskResponse Client::modifyCycleTaskWithOptions(const ModifyCycleTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigId()) {
    query["ConfigId"] = request.configId();
  }

  if (!!request.hasEnable()) {
    query["Enable"] = request.enable();
  }

  if (!!request.hasFirstDateStr()) {
    query["FirstDateStr"] = request.firstDateStr();
  }

  if (!!request.hasIntervalPeriod()) {
    query["IntervalPeriod"] = request.intervalPeriod();
  }

  if (!!request.hasParam()) {
    query["Param"] = request.param();
  }

  if (!!request.hasPeriodUnit()) {
    query["PeriodUnit"] = request.periodUnit();
  }

  if (!!request.hasTargetEndTime()) {
    query["TargetEndTime"] = request.targetEndTime();
  }

  if (!!request.hasTargetStartTime()) {
    query["TargetStartTime"] = request.targetStartTime();
  }

  if (!!request.hasTaskName()) {
    query["TaskName"] = request.taskName();
  }

  if (!!request.hasTaskType()) {
    query["TaskType"] = request.taskType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyCycleTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyCycleTaskResponse>();
}

/**
 * @summary Modifies the execution cycle of periodic tasks, including image scan, urgent vulnerability scan, and virus detection tasks.
 *
 * @param request ModifyCycleTaskRequest
 * @return ModifyCycleTaskResponse
 */
ModifyCycleTaskResponse Client::modifyCycleTask(const ModifyCycleTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyCycleTaskWithOptions(request, runtime);
}

/**
 * @summary Changes the notification status of a DingTalk chatbot.
 *
 * @description You can call this operation only if you use Security Center Enterprise.
 *
 * @param request ModifyDingTalkStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDingTalkStatusResponse
 */
ModifyDingTalkStatusResponse Client::modifyDingTalkStatusWithOptions(const ModifyDingTalkStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIds()) {
    query["Ids"] = request.ids();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyDingTalkStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyDingTalkStatusResponse>();
}

/**
 * @summary Changes the notification status of a DingTalk chatbot.
 *
 * @description You can call this operation only if you use Security Center Enterprise.
 *
 * @param request ModifyDingTalkStatusRequest
 * @return ModifyDingTalkStatusResponse
 */
ModifyDingTalkStatusResponse Client::modifyDingTalkStatus(const ModifyDingTalkStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyDingTalkStatusWithOptions(request, runtime);
}

/**
 * @summary Runs a scan task for urgent vulnerabilities.
 *
 * @param request ModifyEmgVulSubmitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyEmgVulSubmitResponse
 */
ModifyEmgVulSubmitResponse Client::modifyEmgVulSubmitWithOptions(const ModifyEmgVulSubmitRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasUserAgreement()) {
    query["UserAgreement"] = request.userAgreement();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyEmgVulSubmit"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyEmgVulSubmitResponse>();
}

/**
 * @summary Runs a scan task for urgent vulnerabilities.
 *
 * @param request ModifyEmgVulSubmitRequest
 * @return ModifyEmgVulSubmitResponse
 */
ModifyEmgVulSubmitResponse Client::modifyEmgVulSubmit(const ModifyEmgVulSubmitRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyEmgVulSubmitWithOptions(request, runtime);
}

/**
 * @summary Changes the name of a server group.
 *
 * @param request ModifyGroupPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyGroupPropertyResponse
 */
ModifyGroupPropertyResponse Client::modifyGroupPropertyWithOptions(const ModifyGroupPropertyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasData()) {
    query["Data"] = request.data();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyGroupProperty"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyGroupPropertyResponse>();
}

/**
 * @summary Changes the name of a server group.
 *
 * @param request ModifyGroupPropertyRequest
 * @return ModifyGroupPropertyResponse
 */
ModifyGroupPropertyResponse Client::modifyGroupProperty(const ModifyGroupPropertyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyGroupPropertyWithOptions(request, runtime);
}

/**
 * @summary 修改代理集群
 *
 * @param request ModifyHybridProxyClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHybridProxyClusterResponse
 */
ModifyHybridProxyClusterResponse Client::modifyHybridProxyClusterWithOptions(const ModifyHybridProxyClusterRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyHybridProxyCluster"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyHybridProxyClusterResponse>();
}

/**
 * @summary 修改代理集群
 *
 * @param request ModifyHybridProxyClusterRequest
 * @return ModifyHybridProxyClusterResponse
 */
ModifyHybridProxyClusterResponse Client::modifyHybridProxyCluster(const ModifyHybridProxyClusterRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyHybridProxyClusterWithOptions(request, runtime);
}

/**
 * @summary 修改代理策略
 *
 * @param request ModifyHybridProxyPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHybridProxyPolicyResponse
 */
ModifyHybridProxyPolicyResponse Client::modifyHybridProxyPolicyWithOptions(const ModifyHybridProxyPolicyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasPolicyInfo()) {
    query["PolicyInfo"] = request.policyInfo();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyHybridProxyPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyHybridProxyPolicyResponse>();
}

/**
 * @summary 修改代理策略
 *
 * @param request ModifyHybridProxyPolicyRequest
 * @return ModifyHybridProxyPolicyResponse
 */
ModifyHybridProxyPolicyResponse Client::modifyHybridProxyPolicy(const ModifyHybridProxyPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyHybridProxyPolicyWithOptions(request, runtime);
}

/**
 * @summary Modifies the configurations of an IDC probe.
 *
 * @param request ModifyIdcProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyIdcProbeResponse
 */
ModifyIdcProbeResponse Client::modifyIdcProbeWithOptions(const ModifyIdcProbeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasIdcName()) {
    query["IdcName"] = request.idcName();
  }

  if (!!request.hasIdcRegion()) {
    query["IdcRegion"] = request.idcRegion();
  }

  if (!!request.hasIntervalPeriod()) {
    query["IntervalPeriod"] = request.intervalPeriod();
  }

  if (!!request.hasIpSegments()) {
    query["IpSegments"] = request.ipSegments();
  }

  if (!!request.hasLinuxPort()) {
    query["LinuxPort"] = request.linuxPort();
  }

  if (!!request.hasPeriodUnit()) {
    query["PeriodUnit"] = request.periodUnit();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  if (!!request.hasWinPort()) {
    query["WinPort"] = request.winPort();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyIdcProbe"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyIdcProbeResponse>();
}

/**
 * @summary Modifies the configurations of an IDC probe.
 *
 * @param request ModifyIdcProbeRequest
 * @return ModifyIdcProbeResponse
 */
ModifyIdcProbeResponse Client::modifyIdcProbe(const ModifyIdcProbeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyIdcProbeWithOptions(request, runtime);
}

/**
 * @summary Modifies the configurations of a scheduled image fix.
 *
 * @param request ModifyImageFixCycleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyImageFixCycleConfigResponse
 */
ModifyImageFixCycleConfigResponse Client::modifyImageFixCycleConfigWithOptions(const ModifyImageFixCycleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json body = {};
  if (!!request.hasImageFixCycle()) {
    body["ImageFixCycle"] = request.imageFixCycle();
  }

  if (!!request.hasImageFixSwitch()) {
    body["ImageFixSwitch"] = request.imageFixSwitch();
  }

  if (!!request.hasImageFixTarget()) {
    body["ImageFixTarget"] = request.imageFixTarget();
  }

  if (!!request.hasImageTimeRange()) {
    body["ImageTimeRange"] = request.imageTimeRange();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"body" , Utils::Utils::parseToMap(body)}
  }).get<map<string, json>>());
  Params params = Params(json({
    {"action" , "ModifyImageFixCycleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyImageFixCycleConfigResponse>();
}

/**
 * @summary Modifies the configurations of a scheduled image fix.
 *
 * @param request ModifyImageFixCycleConfigRequest
 * @return ModifyImageFixCycleConfigResponse
 */
ModifyImageFixCycleConfigResponse Client::modifyImageFixCycleConfig(const ModifyImageFixCycleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyImageFixCycleConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies the transfer time of an image repository.
 *
 * @param request ModifyImageRegistryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyImageRegistryResponse
 */
ModifyImageRegistryResponse Client::modifyImageRegistryWithOptions(const ModifyImageRegistryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json body = {};
  if (!!request.hasId()) {
    body["Id"] = request.id();
  }

  if (!!request.hasPassword()) {
    body["Password"] = request.password();
  }

  if (!!request.hasTransPerHour()) {
    body["TransPerHour"] = request.transPerHour();
  }

  if (!!request.hasUserName()) {
    body["UserName"] = request.userName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"body" , Utils::Utils::parseToMap(body)}
  }).get<map<string, json>>());
  Params params = Params(json({
    {"action" , "ModifyImageRegistry"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyImageRegistryResponse>();
}

/**
 * @summary Modifies the transfer time of an image repository.
 *
 * @param request ModifyImageRegistryRequest
 * @return ModifyImageRegistryResponse
 */
ModifyImageRegistryResponse Client::modifyImageRegistry(const ModifyImageRegistryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyImageRegistryWithOptions(request, runtime);
}

/**
 * @summary Modifies the defense rule against brute-force attacks that is applied to a specified server.
 *
 * @param request ModifyInstanceAntiBruteForceRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInstanceAntiBruteForceRuleResponse
 */
ModifyInstanceAntiBruteForceRuleResponse Client::modifyInstanceAntiBruteForceRuleWithOptions(const ModifyInstanceAntiBruteForceRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasNewRuleId()) {
    query["NewRuleId"] = request.newRuleId();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyInstanceAntiBruteForceRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyInstanceAntiBruteForceRuleResponse>();
}

/**
 * @summary Modifies the defense rule against brute-force attacks that is applied to a specified server.
 *
 * @param request ModifyInstanceAntiBruteForceRuleRequest
 * @return ModifyInstanceAntiBruteForceRuleResponse
 */
ModifyInstanceAntiBruteForceRuleResponse Client::modifyInstanceAntiBruteForceRule(const ModifyInstanceAntiBruteForceRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyInstanceAntiBruteForceRuleWithOptions(request, runtime);
}

/**
 * @summary Modifies a proactive defense rule for containers.
 *
 * @param tmpReq ModifyInterceptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInterceptionRuleResponse
 */
ModifyInterceptionRuleResponse Client::modifyInterceptionRuleWithOptions(const ModifyInterceptionRuleRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  ModifyInterceptionRuleShrinkRequest request = ModifyInterceptionRuleShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasDstTarget()) {
    request.setDstTargetShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.dstTarget(), "DstTarget", "json"));
  }

  if (!!tmpReq.hasSrcTarget()) {
    request.setSrcTargetShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.srcTarget(), "SrcTarget", "json"));
  }

  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasDstTargetShrink()) {
    query["DstTarget"] = request.dstTargetShrink();
  }

  if (!!request.hasInterceptType()) {
    query["InterceptType"] = request.interceptType();
  }

  if (!!request.hasOrderIndex()) {
    query["OrderIndex"] = request.orderIndex();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasRuleSwitch()) {
    query["RuleSwitch"] = request.ruleSwitch();
  }

  if (!!request.hasSrcTargetShrink()) {
    query["SrcTarget"] = request.srcTargetShrink();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyInterceptionRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyInterceptionRuleResponse>();
}

/**
 * @summary Modifies a proactive defense rule for containers.
 *
 * @param request ModifyInterceptionRuleRequest
 * @return ModifyInterceptionRuleResponse
 */
ModifyInterceptionRuleResponse Client::modifyInterceptionRule(const ModifyInterceptionRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyInterceptionRuleWithOptions(request, runtime);
}

/**
 * @summary Enables or disables a proactive defense rule for containers.
 *
 * @param request ModifyInterceptionRuleSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInterceptionRuleSwitchResponse
 */
ModifyInterceptionRuleSwitchResponse Client::modifyInterceptionRuleSwitchWithOptions(const ModifyInterceptionRuleSwitchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasRuleIds()) {
    query["RuleIds"] = request.ruleIds();
  }

  if (!!request.hasRuleSwitch()) {
    query["RuleSwitch"] = request.ruleSwitch();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyInterceptionRuleSwitch"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyInterceptionRuleSwitchResponse>();
}

/**
 * @summary Enables or disables a proactive defense rule for containers.
 *
 * @param request ModifyInterceptionRuleSwitchRequest
 * @return ModifyInterceptionRuleSwitchResponse
 */
ModifyInterceptionRuleSwitchResponse Client::modifyInterceptionRuleSwitch(const ModifyInterceptionRuleSwitchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyInterceptionRuleSwitchWithOptions(request, runtime);
}

/**
 * @summary Modifies the information about a network object of the container firewall feature.
 *
 * @param request ModifyInterceptionTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInterceptionTargetResponse
 */
ModifyInterceptionTargetResponse Client::modifyInterceptionTargetWithOptions(const ModifyInterceptionTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppName()) {
    query["AppName"] = request.appName();
  }

  if (!!request.hasImageList()) {
    query["ImageList"] = request.imageList();
  }

  if (!!request.hasNamespace()) {
    query["Namespace"] = request._namespace();
  }

  if (!!request.hasTagList()) {
    query["TagList"] = request.tagList();
  }

  if (!!request.hasTargetId()) {
    query["TargetId"] = request.targetId();
  }

  if (!!request.hasTargetName()) {
    query["TargetName"] = request.targetName();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyInterceptionTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyInterceptionTargetResponse>();
}

/**
 * @summary Modifies the information about a network object of the container firewall feature.
 *
 * @param request ModifyInterceptionTargetRequest
 * @return ModifyInterceptionTargetResponse
 */
ModifyInterceptionTargetResponse Client::modifyInterceptionTarget(const ModifyInterceptionTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyInterceptionTargetWithOptions(request, runtime);
}

/**
 * @summary Enables or disables the log analysis feature.
 *
 * @param request ModifyLogMetaStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLogMetaStatusResponse
 */
ModifyLogMetaStatusResponse Client::modifyLogMetaStatusWithOptions(const ModifyLogMetaStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLogStore()) {
    query["LogStore"] = request.logStore();
  }

  if (!!request.hasProject()) {
    query["Project"] = request.project();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyLogMetaStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyLogMetaStatusResponse>();
}

/**
 * @summary Enables or disables the log analysis feature.
 *
 * @param request ModifyLogMetaStatusRequest
 * @return ModifyLogMetaStatusResponse
 */
ModifyLogMetaStatusResponse Client::modifyLogMetaStatus(const ModifyLogMetaStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyLogMetaStatusWithOptions(request, runtime);
}

/**
 * @summary Modifies the logon configuration for a specified asset.
 *
 * @param request ModifyLoginBaseConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLoginBaseConfigResponse
 */
ModifyLoginBaseConfigResponse Client::modifyLoginBaseConfigWithOptions(const ModifyLoginBaseConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyLoginBaseConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyLoginBaseConfigResponse>();
}

/**
 * @summary Modifies the logon configuration for a specified asset.
 *
 * @param request ModifyLoginBaseConfigRequest
 * @return ModifyLoginBaseConfigResponse
 */
ModifyLoginBaseConfigResponse Client::modifyLoginBaseConfig(const ModifyLoginBaseConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyLoginBaseConfigWithOptions(request, runtime);
}

/**
 * @summary Enables or disables the logon security settings for an asset.
 *
 * @param request ModifyLoginSwitchConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLoginSwitchConfigResponse
 */
ModifyLoginSwitchConfigResponse Client::modifyLoginSwitchConfigWithOptions(const ModifyLoginSwitchConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasItem()) {
    query["Item"] = request.item();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyLoginSwitchConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyLoginSwitchConfigResponse>();
}

/**
 * @summary Enables or disables the logon security settings for an asset.
 *
 * @param request ModifyLoginSwitchConfigRequest
 * @return ModifyLoginSwitchConfigResponse
 */
ModifyLoginSwitchConfigResponse Client::modifyLoginSwitchConfig(const ModifyLoginSwitchConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyLoginSwitchConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies notification settings.
 *
 * @param request ModifyNoticeConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNoticeConfigResponse
 */
ModifyNoticeConfigResponse Client::modifyNoticeConfigWithOptions(const ModifyNoticeConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasProject()) {
    query["Project"] = request.project();
  }

  if (!!request.hasRoute()) {
    query["Route"] = request.route();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTimeLimit()) {
    query["TimeLimit"] = request.timeLimit();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyNoticeConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyNoticeConfigResponse>();
}

/**
 * @summary Modifies notification settings.
 *
 * @param request ModifyNoticeConfigRequest
 * @return ModifyNoticeConfigResponse
 */
ModifyNoticeConfigResponse Client::modifyNoticeConfig(const ModifyNoticeConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyNoticeConfigWithOptions(request, runtime);
}

/**
 * @summary Activates Simple Log Service.
 *
 * @description **Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
 *
 * @param request ModifyOpenLogShipperRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyOpenLogShipperResponse
 */
ModifyOpenLogShipperResponse Client::modifyOpenLogShipperWithOptions(const ModifyOpenLogShipperRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasResourceDirectoryAccountId()) {
    query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyOpenLogShipper"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyOpenLogShipperResponse>();
}

/**
 * @summary Activates Simple Log Service.
 *
 * @description **Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
 *
 * @param request ModifyOpenLogShipperRequest
 * @return ModifyOpenLogShipperResponse
 */
ModifyOpenLogShipperResponse Client::modifyOpenLogShipper(const ModifyOpenLogShipperRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyOpenLogShipperWithOptions(request, runtime);
}

/**
 * @summary Handles detected vulnerabilities. You can fix, check, or ignore the vulnerabilities.
 *
 * @param request ModifyOperateVulRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyOperateVulResponse
 */
ModifyOperateVulResponse Client::modifyOperateVulWithOptions(const ModifyOperateVulRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasInfo()) {
    query["Info"] = request.info();
  }

  if (!!request.hasOperateType()) {
    query["OperateType"] = request.operateType();
  }

  if (!!request.hasReason()) {
    query["Reason"] = request.reason();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyOperateVul"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyOperateVulResponse>();
}

/**
 * @summary Handles detected vulnerabilities. You can fix, check, or ignore the vulnerabilities.
 *
 * @param request ModifyOperateVulRequest
 * @return ModifyOperateVulResponse
 */
ModifyOperateVulResponse Client::modifyOperateVul(const ModifyOperateVulRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyOperateVulWithOptions(request, runtime);
}

/**
 * @summary Modifies the switch settings of pay-as-you-go modules.
 *
 * @param request ModifyPostPayModuleSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPostPayModuleSwitchResponse
 */
ModifyPostPayModuleSwitchResponse Client::modifyPostPayModuleSwitchWithOptions(const ModifyPostPayModuleSwitchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPostPayInstanceId()) {
    query["PostPayInstanceId"] = request.postPayInstanceId();
  }

  if (!!request.hasPostPayModuleSwitch()) {
    query["PostPayModuleSwitch"] = request.postPayModuleSwitch();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyPostPayModuleSwitch"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyPostPayModuleSwitchResponse>();
}

/**
 * @summary Modifies the switch settings of pay-as-you-go modules.
 *
 * @param request ModifyPostPayModuleSwitchRequest
 * @return ModifyPostPayModuleSwitchResponse
 */
ModifyPostPayModuleSwitchResponse Client::modifyPostPayModuleSwitch(const ModifyPostPayModuleSwitchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyPostPayModuleSwitchWithOptions(request, runtime);
}

/**
 * @summary Adds a process to or removes a process from the whitelist by using the application whitelist feature.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request ModifyProcessWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyProcessWhiteListResponse
 */
ModifyProcessWhiteListResponse Client::modifyProcessWhiteListWithOptions(const ModifyProcessWhiteListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMd5s()) {
    query["Md5s"] = request.md5s();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyProcessWhiteList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyProcessWhiteListResponse>();
}

/**
 * @summary Adds a process to or removes a process from the whitelist by using the application whitelist feature.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request ModifyProcessWhiteListRequest
 * @return ModifyProcessWhiteListResponse
 */
ModifyProcessWhiteListResponse Client::modifyProcessWhiteList(const ModifyProcessWhiteListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyProcessWhiteListWithOptions(request, runtime);
}

/**
 * @summary Modifies the collection frequency of asset fingerprints for an automatic periodic collection task.
 *
 * @param request ModifyPropertyScheduleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPropertyScheduleConfigResponse
 */
ModifyPropertyScheduleConfigResponse Client::modifyPropertyScheduleConfigWithOptions(const ModifyPropertyScheduleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasScheduleTime()) {
    query["ScheduleTime"] = request.scheduleTime();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyPropertyScheduleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyPropertyScheduleConfigResponse>();
}

/**
 * @summary Modifies the collection frequency of asset fingerprints for an automatic periodic collection task.
 *
 * @param request ModifyPropertyScheduleConfigRequest
 * @return ModifyPropertyScheduleConfigResponse
 */
ModifyPropertyScheduleConfigResponse Client::modifyPropertyScheduleConfig(const ModifyPropertyScheduleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyPropertyScheduleConfigWithOptions(request, runtime);
}

/**
 * @summary Performs security check tasks on servers with a few clicks.
 *
 * @param request ModifyPushAllTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPushAllTaskResponse
 */
ModifyPushAllTaskResponse Client::modifyPushAllTaskWithOptions(const ModifyPushAllTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTasks()) {
    query["Tasks"] = request.tasks();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyPushAllTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyPushAllTaskResponse>();
}

/**
 * @summary Performs security check tasks on servers with a few clicks.
 *
 * @param request ModifyPushAllTaskRequest
 * @return ModifyPushAllTaskResponse
 */
ModifyPushAllTaskResponse Client::modifyPushAllTask(const ModifyPushAllTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyPushAllTaskWithOptions(request, runtime);
}

/**
 * @summary Refreshes the list of processes that are associated with a Linux software vulnerability.
 *
 * @param request ModifyRefreshProcessInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRefreshProcessInfoResponse
 */
ModifyRefreshProcessInfoResponse Client::modifyRefreshProcessInfoWithOptions(const ModifyRefreshProcessInfoRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyRefreshProcessInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyRefreshProcessInfoResponse>();
}

/**
 * @summary Refreshes the list of processes that are associated with a Linux software vulnerability.
 *
 * @param request ModifyRefreshProcessInfoRequest
 * @return ModifyRefreshProcessInfoResponse
 */
ModifyRefreshProcessInfoResponse Client::modifyRefreshProcessInfo(const ModifyRefreshProcessInfoRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyRefreshProcessInfoWithOptions(request, runtime);
}

/**
 * @summary Modifies a rule for container tamper-proofing.
 *
 * @param request ModifySasContainerWebDefenseRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySasContainerWebDefenseRuleResponse
 */
ModifySasContainerWebDefenseRuleResponse Client::modifySasContainerWebDefenseRuleWithOptions(const ModifySasContainerWebDefenseRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPathConfDTOList()) {
    query["PathConfDTOList"] = request.pathConfDTOList();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifySasContainerWebDefenseRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifySasContainerWebDefenseRuleResponse>();
}

/**
 * @summary Modifies a rule for container tamper-proofing.
 *
 * @param request ModifySasContainerWebDefenseRuleRequest
 * @return ModifySasContainerWebDefenseRuleResponse
 */
ModifySasContainerWebDefenseRuleResponse Client::modifySasContainerWebDefenseRule(const ModifySasContainerWebDefenseRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifySasContainerWebDefenseRuleWithOptions(request, runtime);
}

/**
 * @summary Modifies common filter conditions to search for assets.
 *
 * @param request ModifySearchConditionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySearchConditionResponse
 */
ModifySearchConditionResponse Client::modifySearchConditionWithOptions(const ModifySearchConditionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFilterConditions()) {
    query["FilterConditions"] = request.filterConditions();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifySearchCondition"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifySearchConditionResponse>();
}

/**
 * @summary Modifies common filter conditions to search for assets.
 *
 * @param request ModifySearchConditionRequest
 * @return ModifySearchConditionResponse
 */
ModifySearchConditionResponse Client::modifySearchCondition(const ModifySearchConditionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifySearchConditionWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI ModifySecurityCheckScheduleConfig is deprecated, please use Sas::2018-12-03::ChangeCheckConfig instead.
 *
 * @summary Specifies the time when an automatic configuration check is performed on cloud services.
 *
 * @description This operation is phased out. You can use the ChangeCheckConfig operation.
 *
 * @param request ModifySecurityCheckScheduleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySecurityCheckScheduleConfigResponse
 */
ModifySecurityCheckScheduleConfigResponse Client::modifySecurityCheckScheduleConfigWithOptions(const ModifySecurityCheckScheduleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDaysOfWeek()) {
    query["DaysOfWeek"] = request.daysOfWeek();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifySecurityCheckScheduleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifySecurityCheckScheduleConfigResponse>();
}

/**
 * @deprecated OpenAPI ModifySecurityCheckScheduleConfig is deprecated, please use Sas::2018-12-03::ChangeCheckConfig instead.
 *
 * @summary Specifies the time when an automatic configuration check is performed on cloud services.
 *
 * @description This operation is phased out. You can use the ChangeCheckConfig operation.
 *
 * @param request ModifySecurityCheckScheduleConfigRequest
 * @return ModifySecurityCheckScheduleConfigResponse
 */
ModifySecurityCheckScheduleConfigResponse Client::modifySecurityCheckScheduleConfig(const ModifySecurityCheckScheduleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifySecurityCheckScheduleConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies the alert handling rule for alerts that are added to the whitelist by asset.
 *
 * @param request ModifySecurityEventMarkMissIndividuallyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySecurityEventMarkMissIndividuallyResponse
 */
ModifySecurityEventMarkMissIndividuallyResponse Client::modifySecurityEventMarkMissIndividuallyWithOptions(const ModifySecurityEventMarkMissIndividuallyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  json body = {};
  if (!!request.hasDeleteMarkMissParam()) {
    body["DeleteMarkMissParam"] = request.deleteMarkMissParam();
  }

  if (!!request.hasFrom()) {
    body["From"] = request.from();
  }

  if (!!request.hasInsertMarkMissParam()) {
    body["InsertMarkMissParam"] = request.insertMarkMissParam();
  }

  if (!!request.hasLang()) {
    body["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "ModifySecurityEventMarkMissIndividually"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifySecurityEventMarkMissIndividuallyResponse>();
}

/**
 * @summary Modifies the alert handling rule for alerts that are added to the whitelist by asset.
 *
 * @param request ModifySecurityEventMarkMissIndividuallyRequest
 * @return ModifySecurityEventMarkMissIndividuallyResponse
 */
ModifySecurityEventMarkMissIndividuallyResponse Client::modifySecurityEventMarkMissIndividually(const ModifySecurityEventMarkMissIndividuallyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifySecurityEventMarkMissIndividuallyWithOptions(request, runtime);
}

/**
 * @summary Manage Serverless Asset Authorization
 *
 * @param request ModifyServerlessAuthToMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyServerlessAuthToMachineResponse
 */
ModifyServerlessAuthToMachineResponse Client::modifyServerlessAuthToMachineWithOptions(const ModifyServerlessAuthToMachineRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAppCriteria()) {
    query["AppCriteria"] = request.appCriteria();
  }

  if (!!request.hasAuthItem()) {
    query["AuthItem"] = request.authItem();
  }

  if (!!request.hasAutoBind()) {
    query["AutoBind"] = request.autoBind();
  }

  if (!!request.hasBindAll()) {
    query["BindAll"] = request.bindAll();
  }

  if (!!request.hasBindAppList()) {
    query["BindAppList"] = request.bindAppList();
  }

  if (!!request.hasBindAssetType()) {
    query["BindAssetType"] = request.bindAssetType();
  }

  if (!!request.hasBindUuidList()) {
    query["BindUuidList"] = request.bindUuidList();
  }

  if (!!request.hasCriteria()) {
    query["Criteria"] = request.criteria();
  }

  if (!!request.hasLogicalExp()) {
    query["LogicalExp"] = request.logicalExp();
  }

  if (!!request.hasNtmVersion()) {
    query["NtmVersion"] = request.ntmVersion();
  }

  if (!!request.hasPreBind()) {
    query["PreBind"] = request.preBind();
  }

  if (!!request.hasPreBindOrderId()) {
    query["PreBindOrderId"] = request.preBindOrderId();
  }

  if (!!request.hasResourceDirectoryUid()) {
    query["ResourceDirectoryUid"] = request.resourceDirectoryUid();
  }

  if (!!request.hasUnBindAppList()) {
    query["UnBindAppList"] = request.unBindAppList();
  }

  if (!!request.hasUnBindUuidList()) {
    query["UnBindUuidList"] = request.unBindUuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyServerlessAuthToMachine"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyServerlessAuthToMachineResponse>();
}

/**
 * @summary Manage Serverless Asset Authorization
 *
 * @param request ModifyServerlessAuthToMachineRequest
 * @return ModifyServerlessAuthToMachineResponse
 */
ModifyServerlessAuthToMachineResponse Client::modifyServerlessAuthToMachine(const ModifyServerlessAuthToMachineRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyServerlessAuthToMachineWithOptions(request, runtime);
}

/**
 * @summary Creates or deletes a policy template on the My Policies tab of the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request ModifySoarStrategySubscribeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySoarStrategySubscribeResponse
 */
ModifySoarStrategySubscribeResponse Client::modifySoarStrategySubscribeWithOptions(const ModifySoarStrategySubscribeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasSubscribeStatus()) {
    query["SubscribeStatus"] = request.subscribeStatus();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifySoarStrategySubscribe"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifySoarStrategySubscribeResponse>();
}

/**
 * @summary Creates or deletes a policy template on the My Policies tab of the Playbook page.
 *
 * @description Only the Enterprise and Ultimate editions of Security Center support this API operation.
 *
 * @param request ModifySoarStrategySubscribeRequest
 * @return ModifySoarStrategySubscribeResponse
 */
ModifySoarStrategySubscribeResponse Client::modifySoarStrategySubscribe(const ModifySoarStrategySubscribeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifySoarStrategySubscribeWithOptions(request, runtime);
}

/**
 * @summary Enables the quick scan feature. You can also enable the feature on the Vulnerabilities page of the Security Center console.
 *
 * @param request ModifyStartVulScanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyStartVulScanResponse
 */
ModifyStartVulScanResponse Client::modifyStartVulScanWithOptions(const ModifyStartVulScanRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTypes()) {
    query["Types"] = request.types();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyStartVulScan"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyStartVulScanResponse>();
}

/**
 * @summary Enables the quick scan feature. You can also enable the feature on the Vulnerabilities page of the Security Center console.
 *
 * @param request ModifyStartVulScanRequest
 * @return ModifyStartVulScanResponse
 */
ModifyStartVulScanResponse Client::modifyStartVulScan(const ModifyStartVulScanRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyStartVulScanWithOptions(request, runtime);
}

/**
 * @summary Modifies a baseline check policy.
 *
 * @param request ModifyStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyStrategyResponse
 */
ModifyStrategyResponse Client::modifyStrategyWithOptions(const ModifyStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCustomType()) {
    query["CustomType"] = request.customType();
  }

  if (!!request.hasCycleDays()) {
    query["CycleDays"] = request.cycleDays();
  }

  if (!!request.hasCycleStartTime()) {
    query["CycleStartTime"] = request.cycleStartTime();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasRiskCustomParams()) {
    query["RiskCustomParams"] = request.riskCustomParams();
  }

  if (!!request.hasRiskSubTypeName()) {
    query["RiskSubTypeName"] = request.riskSubTypeName();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyStrategyResponse>();
}

/**
 * @summary Modifies a baseline check policy.
 *
 * @param request ModifyStrategyRequest
 * @return ModifyStrategyResponse
 */
ModifyStrategyResponse Client::modifyStrategy(const ModifyStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyStrategyWithOptions(request, runtime);
}

/**
 * @summary Modifies the servers to which a baseline check policy is applied.
 *
 * @param request ModifyStrategyTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyStrategyTargetResponse
 */
ModifyStrategyTargetResponse Client::modifyStrategyTargetWithOptions(const ModifyStrategyTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyStrategyTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyStrategyTargetResponse>();
}

/**
 * @summary Modifies the servers to which a baseline check policy is applied.
 *
 * @param request ModifyStrategyTargetRequest
 * @return ModifyStrategyTargetResponse
 */
ModifyStrategyTargetResponse Client::modifyStrategyTarget(const ModifyStrategyTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyStrategyTargetWithOptions(request, runtime);
}

/**
 * @summary Modifies the names of the tags that are added to assets, or modifies the tags for assets.
 *
 * @param request ModifyTagWithUuidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyTagWithUuidResponse
 */
ModifyTagWithUuidResponse Client::modifyTagWithUuidWithOptions(const ModifyTagWithUuidRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMachineTypes()) {
    query["MachineTypes"] = request.machineTypes();
  }

  if (!!request.hasTagId()) {
    query["TagId"] = request.tagId();
  }

  if (!!request.hasTagList()) {
    query["TagList"] = request.tagList();
  }

  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyTagWithUuid"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyTagWithUuidResponse>();
}

/**
 * @summary Modifies the names of the tags that are added to assets, or modifies the tags for assets.
 *
 * @param request ModifyTagWithUuidRequest
 * @return ModifyTagWithUuidResponse
 */
ModifyTagWithUuidResponse Client::modifyTagWithUuid(const ModifyTagWithUuidRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyTagWithUuidWithOptions(request, runtime);
}

/**
 * @summary Modifies an anti-ransomware policy for databases.
 *
 * @param tmpReq ModifyUniBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyUniBackupPolicyResponse
 */
ModifyUniBackupPolicyResponse Client::modifyUniBackupPolicyWithOptions(const ModifyUniBackupPolicyRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  ModifyUniBackupPolicyShrinkRequest request = ModifyUniBackupPolicyShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasFullPlan()) {
    request.setFullPlanShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.fullPlan(), "FullPlan", "json"));
  }

  if (!!tmpReq.hasIncPlan()) {
    request.setIncPlanShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.incPlan(), "IncPlan", "json"));
  }

  json query = {};
  if (!!request.hasAccountName()) {
    query["AccountName"] = request.accountName();
  }

  if (!!request.hasAccountPassword()) {
    query["AccountPassword"] = request.accountPassword();
  }

  if (!!request.hasFullPlanShrink()) {
    query["FullPlan"] = request.fullPlanShrink();
  }

  if (!!request.hasIncPlanShrink()) {
    query["IncPlan"] = request.incPlanShrink();
  }

  if (!!request.hasPolicyId()) {
    query["PolicyId"] = request.policyId();
  }

  if (!!request.hasPolicyName()) {
    query["PolicyName"] = request.policyName();
  }

  if (!!request.hasPolicyStatus()) {
    query["PolicyStatus"] = request.policyStatus();
  }

  if (!!request.hasRetention()) {
    query["Retention"] = request.retention();
  }

  if (!!request.hasSpeedLimiter()) {
    query["SpeedLimiter"] = request.speedLimiter();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyUniBackupPolicy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyUniBackupPolicyResponse>();
}

/**
 * @summary Modifies an anti-ransomware policy for databases.
 *
 * @param request ModifyUniBackupPolicyRequest
 * @return ModifyUniBackupPolicyResponse
 */
ModifyUniBackupPolicyResponse Client::modifyUniBackupPolicy(const ModifyUniBackupPolicyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyUniBackupPolicyWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI ModifyVpcHoneyPot is deprecated
 *
 * @summary Enables or disables a honeypot.
 *
 * @param request ModifyVpcHoneyPotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVpcHoneyPotResponse
 */
ModifyVpcHoneyPotResponse Client::modifyVpcHoneyPotWithOptions(const ModifyVpcHoneyPotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneyPotAction()) {
    query["HoneyPotAction"] = request.honeyPotAction();
  }

  if (!!request.hasVpcId()) {
    query["VpcId"] = request.vpcId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVpcHoneyPot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVpcHoneyPotResponse>();
}

/**
 * @deprecated OpenAPI ModifyVpcHoneyPot is deprecated
 *
 * @summary Enables or disables a honeypot.
 *
 * @param request ModifyVpcHoneyPotRequest
 * @return ModifyVpcHoneyPotResponse
 */
ModifyVpcHoneyPotResponse Client::modifyVpcHoneyPot(const ModifyVpcHoneyPotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVpcHoneyPotWithOptions(request, runtime);
}

/**
 * @summary Modifies the configurations of the vulnerability scan feature.
 *
 * @param request ModifyVulConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVulConfigResponse
 */
ModifyVulConfigResponse Client::modifyVulConfigWithOptions(const ModifyVulConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVulConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVulConfigResponse>();
}

/**
 * @summary Modifies the configurations of the vulnerability scan feature.
 *
 * @param request ModifyVulConfigRequest
 * @return ModifyVulConfigResponse
 */
ModifyVulConfigResponse Client::modifyVulConfig(const ModifyVulConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVulConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies the configurations of the vulnerability scan feature for a server.
 *
 * @param request ModifyVulTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVulTargetResponse
 */
ModifyVulTargetResponse Client::modifyVulTargetWithOptions(const ModifyVulTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVulTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVulTargetResponse>();
}

/**
 * @summary Modifies the configurations of the vulnerability scan feature for a server.
 *
 * @param request ModifyVulTargetRequest
 * @return ModifyVulTargetResponse
 */
ModifyVulTargetResponse Client::modifyVulTarget(const ModifyVulTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVulTargetWithOptions(request, runtime);
}

/**
 * @summary Configures vulnerability scan for a server.
 *
 * @param request ModifyVulTargetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVulTargetConfigResponse
 */
ModifyVulTargetConfigResponse Client::modifyVulTargetConfigWithOptions(const ModifyVulTargetConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVulTargetConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVulTargetConfigResponse>();
}

/**
 * @summary Configures vulnerability scan for a server.
 *
 * @param request ModifyVulTargetConfigRequest
 * @return ModifyVulTargetConfigResponse
 */
ModifyVulTargetConfigResponse Client::modifyVulTargetConfig(const ModifyVulTargetConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVulTargetConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies the servers that are added to a vulnerability whitelist.
 *
 * @param request ModifyVulWhitelistTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVulWhitelistTargetResponse
 */
ModifyVulWhitelistTargetResponse Client::modifyVulWhitelistTargetWithOptions(const ModifyVulWhitelistTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasReason()) {
    query["Reason"] = request.reason();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTargetInfo()) {
    query["TargetInfo"] = request.targetInfo();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyVulWhitelistTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyVulWhitelistTargetResponse>();
}

/**
 * @summary Modifies the servers that are added to a vulnerability whitelist.
 *
 * @param request ModifyVulWhitelistTargetRequest
 * @return ModifyVulWhitelistTargetResponse
 */
ModifyVulWhitelistTargetResponse Client::modifyVulWhitelistTarget(const ModifyVulWhitelistTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyVulWhitelistTargetWithOptions(request, runtime);
}

/**
 * @summary Adds a directory to protect for a specified server.
 *
 * @param request ModifyWebLockCreateConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockCreateConfigResponse
 */
ModifyWebLockCreateConfigResponse Client::modifyWebLockCreateConfigWithOptions(const ModifyWebLockCreateConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDefenceMode()) {
    query["DefenceMode"] = request.defenceMode();
  }

  if (!!request.hasDir()) {
    query["Dir"] = request.dir();
  }

  if (!!request.hasExclusiveDir()) {
    query["ExclusiveDir"] = request.exclusiveDir();
  }

  if (!!request.hasExclusiveFile()) {
    query["ExclusiveFile"] = request.exclusiveFile();
  }

  if (!!request.hasExclusiveFileType()) {
    query["ExclusiveFileType"] = request.exclusiveFileType();
  }

  if (!!request.hasInclusiveFile()) {
    query["InclusiveFile"] = request.inclusiveFile();
  }

  if (!!request.hasInclusiveFileType()) {
    query["InclusiveFileType"] = request.inclusiveFileType();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLocalBackupDir()) {
    query["LocalBackupDir"] = request.localBackupDir();
  }

  if (!!request.hasMode()) {
    query["Mode"] = request.mode();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyWebLockCreateConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyWebLockCreateConfigResponse>();
}

/**
 * @summary Adds a directory to protect for a specified server.
 *
 * @param request ModifyWebLockCreateConfigRequest
 * @return ModifyWebLockCreateConfigResponse
 */
ModifyWebLockCreateConfigResponse Client::modifyWebLockCreateConfig(const ModifyWebLockCreateConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyWebLockCreateConfigWithOptions(request, runtime);
}

/**
 * @summary Deletes a directory on a specified server from the protected directories of web tamper proofing.
 *
 * @description After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
 *
 * @param request ModifyWebLockDeleteConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockDeleteConfigResponse
 */
ModifyWebLockDeleteConfigResponse Client::modifyWebLockDeleteConfigWithOptions(const ModifyWebLockDeleteConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyWebLockDeleteConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyWebLockDeleteConfigResponse>();
}

/**
 * @summary Deletes a directory on a specified server from the protected directories of web tamper proofing.
 *
 * @description After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
 *
 * @param request ModifyWebLockDeleteConfigRequest
 * @return ModifyWebLockDeleteConfigResponse
 */
ModifyWebLockDeleteConfigResponse Client::modifyWebLockDeleteConfig(const ModifyWebLockDeleteConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyWebLockDeleteConfigWithOptions(request, runtime);
}

/**
 * @summary Changes the status of processes for web tamper proofing.
 *
 * @param request ModifyWebLockProcessStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockProcessStatusResponse
 */
ModifyWebLockProcessStatusResponse Client::modifyWebLockProcessStatusWithOptions(const ModifyWebLockProcessStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDealAll()) {
    query["DealAll"] = request.dealAll();
  }

  if (!!request.hasOperateInfo()) {
    query["OperateInfo"] = request.operateInfo();
  }

  if (!!request.hasProcessPath()) {
    query["ProcessPath"] = request.processPath();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyWebLockProcessStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyWebLockProcessStatusResponse>();
}

/**
 * @summary Changes the status of processes for web tamper proofing.
 *
 * @param request ModifyWebLockProcessStatusRequest
 * @return ModifyWebLockProcessStatusResponse
 */
ModifyWebLockProcessStatusResponse Client::modifyWebLockProcessStatus(const ModifyWebLockProcessStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyWebLockProcessStatusWithOptions(request, runtime);
}

/**
 * @summary Refreshes the status of the web tamper proofing feature for a server.
 *
 * @description If an exception occurs when you enable or disable the web tamper proofing feature for a server, you can call this operation to refresh the status of the web tamper proofing feature.
 *
 * @param request ModifyWebLockRefreshRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockRefreshResponse
 */
ModifyWebLockRefreshResponse Client::modifyWebLockRefreshWithOptions(const ModifyWebLockRefreshRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyWebLockRefresh"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyWebLockRefreshResponse>();
}

/**
 * @summary Refreshes the status of the web tamper proofing feature for a server.
 *
 * @description If an exception occurs when you enable or disable the web tamper proofing feature for a server, you can call this operation to refresh the status of the web tamper proofing feature.
 *
 * @param request ModifyWebLockRefreshRequest
 * @return ModifyWebLockRefreshResponse
 */
ModifyWebLockRefreshResponse Client::modifyWebLockRefresh(const ModifyWebLockRefreshRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyWebLockRefreshWithOptions(request, runtime);
}

/**
 * @summary Enables web tamper proofing for a specified server.
 *
 * @param request ModifyWebLockStartRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockStartResponse
 */
ModifyWebLockStartResponse Client::modifyWebLockStartWithOptions(const ModifyWebLockStartRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDefenceMode()) {
    query["DefenceMode"] = request.defenceMode();
  }

  if (!!request.hasDir()) {
    query["Dir"] = request.dir();
  }

  if (!!request.hasExclusiveDir()) {
    query["ExclusiveDir"] = request.exclusiveDir();
  }

  if (!!request.hasExclusiveFile()) {
    query["ExclusiveFile"] = request.exclusiveFile();
  }

  if (!!request.hasExclusiveFileType()) {
    query["ExclusiveFileType"] = request.exclusiveFileType();
  }

  if (!!request.hasInclusiveFileType()) {
    query["InclusiveFileType"] = request.inclusiveFileType();
  }

  if (!!request.hasLocalBackupDir()) {
    query["LocalBackupDir"] = request.localBackupDir();
  }

  if (!!request.hasMode()) {
    query["Mode"] = request.mode();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyWebLockStart"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyWebLockStartResponse>();
}

/**
 * @summary Enables web tamper proofing for a specified server.
 *
 * @param request ModifyWebLockStartRequest
 * @return ModifyWebLockStartResponse
 */
ModifyWebLockStartResponse Client::modifyWebLockStart(const ModifyWebLockStartRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyWebLockStartWithOptions(request, runtime);
}

/**
 * @summary Enables or disables web tamper proofing for a server.
 *
 * @param request ModifyWebLockStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockStatusResponse
 */
ModifyWebLockStatusResponse Client::modifyWebLockStatusWithOptions(const ModifyWebLockStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyWebLockStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyWebLockStatusResponse>();
}

/**
 * @summary Enables or disables web tamper proofing for a server.
 *
 * @param request ModifyWebLockStatusRequest
 * @return ModifyWebLockStatusResponse
 */
ModifyWebLockStatusResponse Client::modifyWebLockStatus(const ModifyWebLockStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyWebLockStatusWithOptions(request, runtime);
}

/**
 * @summary Disables web tamper proofing for a specified server.
 *
 * @param request ModifyWebLockUnbindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockUnbindResponse
 */
ModifyWebLockUnbindResponse Client::modifyWebLockUnbindWithOptions(const ModifyWebLockUnbindRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyWebLockUnbind"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyWebLockUnbindResponse>();
}

/**
 * @summary Disables web tamper proofing for a specified server.
 *
 * @param request ModifyWebLockUnbindRequest
 * @return ModifyWebLockUnbindResponse
 */
ModifyWebLockUnbindResponse Client::modifyWebLockUnbind(const ModifyWebLockUnbindRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyWebLockUnbindWithOptions(request, runtime);
}

/**
 * @summary Modifies the protection policy for a specified server.
 *
 * @param request ModifyWebLockUpdateConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebLockUpdateConfigResponse
 */
ModifyWebLockUpdateConfigResponse Client::modifyWebLockUpdateConfigWithOptions(const ModifyWebLockUpdateConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDefenceMode()) {
    query["DefenceMode"] = request.defenceMode();
  }

  if (!!request.hasDir()) {
    query["Dir"] = request.dir();
  }

  if (!!request.hasExclusiveDir()) {
    query["ExclusiveDir"] = request.exclusiveDir();
  }

  if (!!request.hasExclusiveFile()) {
    query["ExclusiveFile"] = request.exclusiveFile();
  }

  if (!!request.hasExclusiveFileType()) {
    query["ExclusiveFileType"] = request.exclusiveFileType();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasInclusiveFile()) {
    query["InclusiveFile"] = request.inclusiveFile();
  }

  if (!!request.hasInclusiveFileType()) {
    query["InclusiveFileType"] = request.inclusiveFileType();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasLocalBackupDir()) {
    query["LocalBackupDir"] = request.localBackupDir();
  }

  if (!!request.hasMode()) {
    query["Mode"] = request.mode();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyWebLockUpdateConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyWebLockUpdateConfigResponse>();
}

/**
 * @summary Modifies the protection policy for a specified server.
 *
 * @param request ModifyWebLockUpdateConfigRequest
 * @return ModifyWebLockUpdateConfigResponse
 */
ModifyWebLockUpdateConfigResponse Client::modifyWebLockUpdateConfig(const ModifyWebLockUpdateConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyWebLockUpdateConfigWithOptions(request, runtime);
}

/**
 * @summary Modifies a custom web directory.
 *
 * @param request ModifyWebPathRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebPathResponse
 */
ModifyWebPathResponse Client::modifyWebPathWithOptions(const ModifyWebPathRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ModifyWebPath"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ModifyWebPathResponse>();
}

/**
 * @summary Modifies a custom web directory.
 *
 * @param request ModifyWebPathRequest
 * @return ModifyWebPathResponse
 */
ModifyWebPathResponse Client::modifyWebPath(const ModifyWebPathRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return modifyWebPathWithOptions(request, runtime);
}

/**
 * @summary Enables the automatic configuration of anti-ransomware policies for servers in the managed anti-ransomware feature. You can call this operation only after you purchase the managed anti-ransomware feature.
 *
 * @param request OpenBackupAutoConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenBackupAutoConfigResponse
 */
OpenBackupAutoConfigResponse Client::openBackupAutoConfigWithOptions(const OpenBackupAutoConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMaxBatchSize()) {
    query["MaxBatchSize"] = request.maxBatchSize();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OpenBackupAutoConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OpenBackupAutoConfigResponse>();
}

/**
 * @summary Enables the automatic configuration of anti-ransomware policies for servers in the managed anti-ransomware feature. You can call this operation only after you purchase the managed anti-ransomware feature.
 *
 * @param request OpenBackupAutoConfigRequest
 * @return OpenBackupAutoConfigResponse
 */
OpenBackupAutoConfigResponse Client::openBackupAutoConfig(const OpenBackupAutoConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return openBackupAutoConfigWithOptions(request, runtime);
}

/**
 * @summary 开启按量购买
 *
 * @param request OpenPartialBuyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenPartialBuyResponse
 */
OpenPartialBuyResponse Client::openPartialBuyWithOptions(const OpenPartialBuyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceId()) {
    query["InstanceId"] = request.instanceId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OpenPartialBuy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OpenPartialBuyResponse>();
}

/**
 * @summary 开启按量购买
 *
 * @param request OpenPartialBuyRequest
 * @return OpenPartialBuyResponse
 */
OpenPartialBuyResponse Client::openPartialBuy(const OpenPartialBuyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return openPartialBuyWithOptions(request, runtime);
}

/**
 * @summary Enables or disables sensitive file scan.
 *
 * @param request OpenSensitiveFileScanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenSensitiveFileScanResponse
 */
OpenSensitiveFileScanResponse Client::openSensitiveFileScanWithOptions(const OpenSensitiveFileScanRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSwitchOn()) {
    query["SwitchOn"] = request.switchOn();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OpenSensitiveFileScan"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OpenSensitiveFileScanResponse>();
}

/**
 * @summary Enables or disables sensitive file scan.
 *
 * @param request OpenSensitiveFileScanRequest
 * @return OpenSensitiveFileScanResponse
 */
OpenSensitiveFileScanResponse Client::openSensitiveFileScan(const OpenSensitiveFileScanRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return openSensitiveFileScanWithOptions(request, runtime);
}

/**
 * @summary Installs the Security Center agent on servers.
 *
 * @param request OperateAgentClientInstallRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateAgentClientInstallResponse
 */
OperateAgentClientInstallResponse Client::operateAgentClientInstallWithOptions(const OperateAgentClientInstallRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasOs()) {
    query["Os"] = request.os();
  }

  if (!!request.hasRegion()) {
    query["Region"] = request.region();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateAgentClientInstall"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateAgentClientInstallResponse>();
}

/**
 * @summary Installs the Security Center agent on servers.
 *
 * @param request OperateAgentClientInstallRequest
 * @return OperateAgentClientInstallResponse
 */
OperateAgentClientInstallResponse Client::operateAgentClientInstall(const OperateAgentClientInstallRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateAgentClientInstallWithOptions(request, runtime);
}

/**
 * @summary Adds or deletes container applications for tamper proofing.
 *
 * @param request OperateApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateApplicationResponse
 */
OperateApplicationResponse Client::operateApplicationWithOptions(const OperateApplicationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasContainerWebDefenseApplicationDTOS()) {
    query["ContainerWebDefenseApplicationDTOS"] = request.containerWebDefenseApplicationDTOS();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateApplication"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateApplicationResponse>();
}

/**
 * @summary Adds or deletes container applications for tamper proofing.
 *
 * @param request OperateApplicationRequest
 * @return OperateApplicationResponse
 */
OperateApplicationResponse Client::operateApplication(const OperateApplicationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateApplicationWithOptions(request, runtime);
}

/**
 * @summary Manages an Object Storage Service (OSS) bucket check task.
 *
 * @param request OperateBucketScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateBucketScanTaskResponse
 */
OperateBucketScanTaskResponse Client::operateBucketScanTaskWithOptions(const OperateBucketScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBucketName()) {
    query["BucketName"] = request.bucketName();
  }

  if (!!request.hasOperateCode()) {
    query["OperateCode"] = request.operateCode();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateBucketScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateBucketScanTaskResponse>();
}

/**
 * @summary Manages an Object Storage Service (OSS) bucket check task.
 *
 * @param request OperateBucketScanTaskRequest
 * @return OperateBucketScanTaskResponse
 */
OperateBucketScanTaskResponse Client::operateBucketScanTask(const OperateBucketScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateBucketScanTaskWithOptions(request, runtime);
}

/**
 * @summary Enables or disables a feature by type.
 *
 * @param request OperateCommonOverallConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateCommonOverallConfigResponse
 */
OperateCommonOverallConfigResponse Client::operateCommonOverallConfigWithOptions(const OperateCommonOverallConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasNoTargetAsOn()) {
    query["NoTargetAsOn"] = request.noTargetAsOn();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateCommonOverallConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateCommonOverallConfigResponse>();
}

/**
 * @summary Enables or disables a feature by type.
 *
 * @param request OperateCommonOverallConfigRequest
 * @return OperateCommonOverallConfigResponse
 */
OperateCommonOverallConfigResponse Client::operateCommonOverallConfig(const OperateCommonOverallConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateCommonOverallConfigWithOptions(request, runtime);
}

/**
 * @summary Configures features by type. The features include container image scan, local file detection, container network visualization, and container escape prevention.
 *
 * @param request OperateCommonTargetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateCommonTargetConfigResponse
 */
OperateCommonTargetConfigResponse Client::operateCommonTargetConfigWithOptions(const OperateCommonTargetConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFieldName()) {
    query["FieldName"] = request.fieldName();
  }

  if (!!request.hasFieldValue()) {
    query["FieldValue"] = request.fieldValue();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTargetOperations()) {
    query["TargetOperations"] = request.targetOperations();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateCommonTargetConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateCommonTargetConfigResponse>();
}

/**
 * @summary Configures features by type. The features include container image scan, local file detection, container network visualization, and container escape prevention.
 *
 * @param request OperateCommonTargetConfigRequest
 * @return OperateCommonTargetConfigResponse
 */
OperateCommonTargetConfigResponse Client::operateCommonTargetConfig(const OperateCommonTargetConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateCommonTargetConfigWithOptions(request, runtime);
}

/**
 * @summary Adds a check item of an image baseline to the whitelist, or removes a check item of an image baseline from the whitelist.
 *
 * @param request OperateImageBaselineWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateImageBaselineWhitelistResponse
 */
OperateImageBaselineWhitelistResponse Client::operateImageBaselineWhitelistWithOptions(const OperateImageBaselineWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBaselineItemKeyList()) {
    query["BaselineItemKeyList"] = request.baselineItemKeyList();
  }

  if (!!request.hasImageUuid()) {
    query["ImageUuid"] = request.imageUuid();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasOperation()) {
    query["Operation"] = request.operation();
  }

  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateImageBaselineWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateImageBaselineWhitelistResponse>();
}

/**
 * @summary Adds a check item of an image baseline to the whitelist, or removes a check item of an image baseline from the whitelist.
 *
 * @param request OperateImageBaselineWhitelistRequest
 * @return OperateImageBaselineWhitelistResponse
 */
OperateImageBaselineWhitelistResponse Client::operateImageBaselineWhitelist(const OperateImageBaselineWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateImageBaselineWhitelistWithOptions(request, runtime);
}

/**
 * @summary Handles an image vulnerability, such as fixing the image vulnerability, verifying the fix of the image vulnerability, ignoring the image vulnerability, or canceling ignoring the image vulnerability.
 *
 * @param request OperateImageVulRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateImageVulResponse
 */
OperateImageVulResponse Client::operateImageVulWithOptions(const OperateImageVulRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInfo()) {
    query["Info"] = request.info();
  }

  if (!!request.hasOperateType()) {
    query["OperateType"] = request.operateType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateImageVul"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateImageVulResponse>();
}

/**
 * @summary Handles an image vulnerability, such as fixing the image vulnerability, verifying the fix of the image vulnerability, ignoring the image vulnerability, or canceling ignoring the image vulnerability.
 *
 * @param request OperateImageVulRequest
 * @return OperateImageVulResponse
 */
OperateImageVulResponse Client::operateImageVul(const OperateImageVulRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateImageVulWithOptions(request, runtime);
}

/**
 * @summary Enables or disables a feature that detects exceptions.
 *
 * @param request OperateSuspiciousOverallConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateSuspiciousOverallConfigResponse
 */
OperateSuspiciousOverallConfigResponse Client::operateSuspiciousOverallConfigWithOptions(const OperateSuspiciousOverallConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNoTargetAsOn()) {
    query["NoTargetAsOn"] = request.noTargetAsOn();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateSuspiciousOverallConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateSuspiciousOverallConfigResponse>();
}

/**
 * @summary Enables or disables a feature that detects exceptions.
 *
 * @param request OperateSuspiciousOverallConfigRequest
 * @return OperateSuspiciousOverallConfigResponse
 */
OperateSuspiciousOverallConfigResponse Client::operateSuspiciousOverallConfig(const OperateSuspiciousOverallConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateSuspiciousOverallConfigWithOptions(request, runtime);
}

/**
 * @summary Configures the scope on which proactive defense takes effect.
 *
 * @param request OperateSuspiciousTargetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateSuspiciousTargetConfigResponse
 */
OperateSuspiciousTargetConfigResponse Client::operateSuspiciousTargetConfigWithOptions(const OperateSuspiciousTargetConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTargetOperations()) {
    query["TargetOperations"] = request.targetOperations();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateSuspiciousTargetConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateSuspiciousTargetConfigResponse>();
}

/**
 * @summary Configures the scope on which proactive defense takes effect.
 *
 * @param request OperateSuspiciousTargetConfigRequest
 * @return OperateSuspiciousTargetConfigResponse
 */
OperateSuspiciousTargetConfigResponse Client::operateSuspiciousTargetConfig(const OperateSuspiciousTargetConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateSuspiciousTargetConfigWithOptions(request, runtime);
}

/**
 * @summary Changes the status of a rule for container tamper-proofing.
 *
 * @param request OperateSwitchStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateSwitchStatusResponse
 */
OperateSwitchStatusResponse Client::operateSwitchStatusWithOptions(const OperateSwitchStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateSwitchStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateSwitchStatusResponse>();
}

/**
 * @summary Changes the status of a rule for container tamper-proofing.
 *
 * @param request OperateSwitchStatusRequest
 * @return OperateSwitchStatusResponse
 */
OperateSwitchStatusResponse Client::operateSwitchStatus(const OperateSwitchStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateSwitchStatusWithOptions(request, runtime);
}

/**
 * @summary Handles alert events that are generated by the antivirus feature. You can perform in-depth detection and removal, add alert events to the whitelist, ignore alert events, or manually handle alert events.
 *
 * @param request OperateVirusEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateVirusEventsResponse
 */
OperateVirusEventsResponse Client::operateVirusEventsWithOptions(const OperateVirusEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOperationAll()) {
    query["OperationAll"] = request.operationAll();
  }

  if (!!request.hasOperationCode()) {
    query["OperationCode"] = request.operationCode();
  }

  if (!!request.hasOperationRange()) {
    query["OperationRange"] = request.operationRange();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateVirusEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateVirusEventsResponse>();
}

/**
 * @summary Handles alert events that are generated by the antivirus feature. You can perform in-depth detection and removal, add alert events to the whitelist, ignore alert events, or manually handle alert events.
 *
 * @param request OperateVirusEventsRequest
 * @return OperateVirusEventsResponse
 */
OperateVirusEventsResponse Client::operateVirusEvents(const OperateVirusEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateVirusEventsWithOptions(request, runtime);
}

/**
 * @summary Fixes Linux software vulnerabilities.
 *
 * @param request OperateVulsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateVulsResponse
 */
OperateVulsResponse Client::operateVulsWithOptions(const OperateVulsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasOperateType()) {
    query["OperateType"] = request.operateType();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  if (!!request.hasVulNames()) {
    query["VulNames"] = request.vulNames();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateVuls"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateVulsResponse>();
}

/**
 * @summary Fixes Linux software vulnerabilities.
 *
 * @param request OperateVulsRequest
 * @return OperateVulsResponse
 */
OperateVulsResponse Client::operateVuls(const OperateVulsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateVulsWithOptions(request, runtime);
}

/**
 * @summary Handles alert events that are generated for web tamper proofing.
 *
 * @param request OperateWebLockFileEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperateWebLockFileEventsResponse
 */
OperateWebLockFileEventsResponse Client::operateWebLockFileEventsWithOptions(const OperateWebLockFileEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDealAll()) {
    query["DealAll"] = request.dealAll();
  }

  if (!!request.hasEventIds()) {
    query["EventIds"] = request.eventIds();
  }

  if (!!request.hasOperationCode()) {
    query["OperationCode"] = request.operationCode();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperateWebLockFileEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperateWebLockFileEventsResponse>();
}

/**
 * @summary Handles alert events that are generated for web tamper proofing.
 *
 * @param request OperateWebLockFileEventsRequest
 * @return OperateWebLockFileEventsResponse
 */
OperateWebLockFileEventsResponse Client::operateWebLockFileEvents(const OperateWebLockFileEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operateWebLockFileEventsWithOptions(request, runtime);
}

/**
 * @summary Cancels ignoring alert events.
 *
 * @param request OperationCancelIgnoreSuspEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperationCancelIgnoreSuspEventResponse
 */
OperationCancelIgnoreSuspEventResponse Client::operationCancelIgnoreSuspEventWithOptions(const OperationCancelIgnoreSuspEventRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasSecurityEventIds()) {
    query["SecurityEventIds"] = request.securityEventIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperationCancelIgnoreSuspEvent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperationCancelIgnoreSuspEventResponse>();
}

/**
 * @summary Cancels ignoring alert events.
 *
 * @param request OperationCancelIgnoreSuspEventRequest
 * @return OperationCancelIgnoreSuspEventResponse
 */
OperationCancelIgnoreSuspEventResponse Client::operationCancelIgnoreSuspEvent(const OperationCancelIgnoreSuspEventRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operationCancelIgnoreSuspEventWithOptions(request, runtime);
}

/**
 * @summary Modifies the chart of a security report.
 *
 * @param request OperationCustomizeReportChartRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperationCustomizeReportChartResponse
 */
OperationCustomizeReportChartResponse Client::operationCustomizeReportChartWithOptions(const OperationCustomizeReportChartRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasChartIds()) {
    query["ChartIds"] = request.chartIds();
  }

  if (!!request.hasReportId()) {
    query["ReportId"] = request.reportId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperationCustomizeReportChart"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperationCustomizeReportChartResponse>();
}

/**
 * @summary Modifies the chart of a security report.
 *
 * @param request OperationCustomizeReportChartRequest
 * @return OperationCustomizeReportChartResponse
 */
OperationCustomizeReportChartResponse Client::operationCustomizeReportChart(const OperationCustomizeReportChartRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operationCustomizeReportChartWithOptions(request, runtime);
}

/**
 * @summary Handles multiple exceptions at a time.
 *
 * @param request OperationSuspEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OperationSuspEventsResponse
 */
OperationSuspEventsResponse Client::operationSuspEventsWithOptions(const OperationSuspEventsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasOperation()) {
    query["Operation"] = request.operation();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasSubOperation()) {
    query["SubOperation"] = request.subOperation();
  }

  if (!!request.hasSuspiciousEventIds()) {
    query["SuspiciousEventIds"] = request.suspiciousEventIds();
  }

  if (!!request.hasWarnType()) {
    query["WarnType"] = request.warnType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "OperationSuspEvents"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<OperationSuspEventsResponse>();
}

/**
 * @summary Handles multiple exceptions at a time.
 *
 * @param request OperationSuspEventsRequest
 * @return OperationSuspEventsResponse
 */
OperationSuspEventsResponse Client::operationSuspEvents(const OperationSuspEventsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return operationSuspEventsWithOptions(request, runtime);
}

/**
 * @summary Queries image repositories by page.
 *
 * @param request PageImageRegistryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PageImageRegistryResponse
 */
PageImageRegistryResponse Client::pageImageRegistryWithOptions(const PageImageRegistryRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  json body = {};
  if (!!request.hasCurrentPage()) {
    body["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasPageSize()) {
    body["PageSize"] = request.pageSize();
  }

  if (!!request.hasRegistryNameLike()) {
    body["RegistryNameLike"] = request.registryNameLike();
  }

  if (!!request.hasRegistryTypeInList()) {
    body["RegistryTypeInList"] = request.registryTypeInList();
  }

  if (!!request.hasRegistryTypeNotInList()) {
    body["RegistryTypeNotInList"] = request.registryTypeNotInList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "PageImageRegistry"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<PageImageRegistryResponse>();
}

/**
 * @summary Queries image repositories by page.
 *
 * @param request PageImageRegistryRequest
 * @return PageImageRegistryResponse
 */
PageImageRegistryResponse Client::pageImageRegistry(const PageImageRegistryRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return pageImageRegistryWithOptions(request, runtime);
}

/**
 * @summary Enables or disables the Security Center agent.
 *
 * @param request PauseClientRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PauseClientResponse
 */
PauseClientResponse Client::pauseClientWithOptions(const PauseClientRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  if (!!request.hasValue()) {
    query["Value"] = request.value();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "PauseClient"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<PauseClientResponse>();
}

/**
 * @summary Enables or disables the Security Center agent.
 *
 * @param request PauseClientRequest
 * @return PauseClientResponse
 */
PauseClientResponse Client::pauseClient(const PauseClientRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return pauseClientWithOptions(request, runtime);
}

/**
 * @summary Modify the status of strategy tasks
 *
 * @description This API call is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request ProcessSoarStrategyTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ProcessSoarStrategyTaskResponse
 */
ProcessSoarStrategyTaskResponse Client::processSoarStrategyTaskWithOptions(const ProcessSoarStrategyTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasStrategyTaskId()) {
    query["StrategyTaskId"] = request.strategyTaskId();
  }

  if (!!request.hasTaskAction()) {
    query["TaskAction"] = request.taskAction();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ProcessSoarStrategyTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ProcessSoarStrategyTaskResponse>();
}

/**
 * @summary Modify the status of strategy tasks
 *
 * @description This API call is only supported by the Enterprise and Flagship editions of Cloud Security Center, other versions do not support it.
 *
 * @param request ProcessSoarStrategyTaskRequest
 * @return ProcessSoarStrategyTaskResponse
 */
ProcessSoarStrategyTaskResponse Client::processSoarStrategyTask(const ProcessSoarStrategyTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return processSoarStrategyTaskWithOptions(request, runtime);
}

/**
 * @summary Creates an image scan task.
 *
 * @description Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
 *
 * @param request PublicCreateImageScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublicCreateImageScanTaskResponse
 */
PublicCreateImageScanTaskResponse Client::publicCreateImageScanTaskWithOptions(const PublicCreateImageScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDigests()) {
    query["Digests"] = request.digests();
  }

  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  if (!!request.hasRegionIds()) {
    query["RegionIds"] = request.regionIds();
  }

  if (!!request.hasRegistryTypes()) {
    query["RegistryTypes"] = request.registryTypes();
  }

  if (!!request.hasRepoIds()) {
    query["RepoIds"] = request.repoIds();
  }

  if (!!request.hasRepoNames()) {
    query["RepoNames"] = request.repoNames();
  }

  if (!!request.hasRepoNamespaces()) {
    query["RepoNamespaces"] = request.repoNamespaces();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "PublicCreateImageScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<PublicCreateImageScanTaskResponse>();
}

/**
 * @summary Creates an image scan task.
 *
 * @description Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
 *
 * @param request PublicCreateImageScanTaskRequest
 * @return PublicCreateImageScanTaskResponse
 */
PublicCreateImageScanTaskResponse Client::publicCreateImageScanTask(const PublicCreateImageScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return publicCreateImageScanTaskWithOptions(request, runtime);
}

/**
 * @summary Queries the number of images to scan in an image scan task and the quota for container image scan to be consumed by the task.
 *
 * @description You can call the PublicPreCheckImageScanTask operation to estimate the quota for container image scan to be consumed by the task. This ensures that you know the quota to be consumed before you perform the task. If the remaining quota for container image scan is less than the quota to be consumed by the task, you must purchase a sufficient quota. This prevents the task from being stopped due to an insufficient quota.
 * If you do not specify the optional parameters when you call this operation, the total number of protected images and the quota for container image scan to be consumed by scanning all the protected images are queried. If you specify the optional parameters, the number of images that meet the specified conditions and the quota for container image scan to be consumed by scanning the images are queried.
 *
 * @param request PublicPreCheckImageScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublicPreCheckImageScanTaskResponse
 */
PublicPreCheckImageScanTaskResponse Client::publicPreCheckImageScanTaskWithOptions(const PublicPreCheckImageScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDigests()) {
    query["Digests"] = request.digests();
  }

  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  if (!!request.hasRegionIds()) {
    query["RegionIds"] = request.regionIds();
  }

  if (!!request.hasRegistryTypes()) {
    query["RegistryTypes"] = request.registryTypes();
  }

  if (!!request.hasRepoIds()) {
    query["RepoIds"] = request.repoIds();
  }

  if (!!request.hasRepoNames()) {
    query["RepoNames"] = request.repoNames();
  }

  if (!!request.hasRepoNamespaces()) {
    query["RepoNamespaces"] = request.repoNamespaces();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasTags()) {
    query["Tags"] = request.tags();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "PublicPreCheckImageScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<PublicPreCheckImageScanTaskResponse>();
}

/**
 * @summary Queries the number of images to scan in an image scan task and the quota for container image scan to be consumed by the task.
 *
 * @description You can call the PublicPreCheckImageScanTask operation to estimate the quota for container image scan to be consumed by the task. This ensures that you know the quota to be consumed before you perform the task. If the remaining quota for container image scan is less than the quota to be consumed by the task, you must purchase a sufficient quota. This prevents the task from being stopped due to an insufficient quota.
 * If you do not specify the optional parameters when you call this operation, the total number of protected images and the quota for container image scan to be consumed by scanning all the protected images are queried. If you specify the optional parameters, the number of images that meet the specified conditions and the quota for container image scan to be consumed by scanning the images are queried.
 *
 * @param request PublicPreCheckImageScanTaskRequest
 * @return PublicPreCheckImageScanTaskResponse
 */
PublicPreCheckImageScanTaskResponse Client::publicPreCheckImageScanTask(const PublicPreCheckImageScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return publicPreCheckImageScanTaskWithOptions(request, runtime);
}

/**
 * @summary Adds images to Security Center and creates an image scan task to scan the images.
 *
 * @param request PublicSyncAndCreateImageScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublicSyncAndCreateImageScanTaskResponse
 */
PublicSyncAndCreateImageScanTaskResponse Client::publicSyncAndCreateImageScanTaskWithOptions(const PublicSyncAndCreateImageScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasImages()) {
    query["Images"] = request.images();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "PublicSyncAndCreateImageScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<PublicSyncAndCreateImageScanTaskResponse>();
}

/**
 * @summary Adds images to Security Center and creates an image scan task to scan the images.
 *
 * @param request PublicSyncAndCreateImageScanTaskRequest
 * @return PublicSyncAndCreateImageScanTaskResponse
 */
PublicSyncAndCreateImageScanTaskResponse Client::publicSyncAndCreateImageScanTask(const PublicSyncAndCreateImageScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return publicSyncAndCreateImageScanTaskWithOptions(request, runtime);
}

/**
 * @summary Queries the number of alert events in each attack phase.
 *
 * @param request QueryAttackCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryAttackCountResponse
 */
QueryAttackCountResponse Client::queryAttackCountWithOptions(const QueryAttackCountRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  json body = {};
  if (!!request.hasFrom()) {
    body["From"] = request.from();
  }

  if (!!request.hasLang()) {
    body["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "QueryAttackCount"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<QueryAttackCountResponse>();
}

/**
 * @summary Queries the number of alert events in each attack phase.
 *
 * @param request QueryAttackCountRequest
 * @return QueryAttackCountResponse
 */
QueryAttackCountResponse Client::queryAttackCount(const QueryAttackCountRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return queryAttackCountWithOptions(request, runtime);
}

/**
 * @summary Queries the progress of a database scan task.
 *
 * @param request QueryDiscoverDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDiscoverDatabaseResponse
 */
QueryDiscoverDatabaseResponse Client::queryDiscoverDatabaseWithOptions(const QueryDiscoverDatabaseRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCreateMark()) {
    query["CreateMark"] = request.createMark();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "QueryDiscoverDatabase"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<QueryDiscoverDatabaseResponse>();
}

/**
 * @summary Queries the progress of a database scan task.
 *
 * @param request QueryDiscoverDatabaseRequest
 * @return QueryDiscoverDatabaseResponse
 */
QueryDiscoverDatabaseResponse Client::queryDiscoverDatabase(const QueryDiscoverDatabaseRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return queryDiscoverDatabaseWithOptions(request, runtime);
}

/**
 * @summary Queries the ID of an asset group by using the name of the asset group.
 *
 * @description You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request QueryGroupIdByGroupNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryGroupIdByGroupNameResponse
 */
QueryGroupIdByGroupNameResponse Client::queryGroupIdByGroupNameWithOptions(const QueryGroupIdByGroupNameRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGroupName()) {
    query["GroupName"] = request.groupName();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "QueryGroupIdByGroupName"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<QueryGroupIdByGroupNameResponse>();
}

/**
 * @summary Queries the ID of an asset group by using the name of the asset group.
 *
 * @description You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request QueryGroupIdByGroupNameRequest
 * @return QueryGroupIdByGroupNameResponse
 */
QueryGroupIdByGroupNameResponse Client::queryGroupIdByGroupName(const QueryGroupIdByGroupNameRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return queryGroupIdByGroupNameWithOptions(request, runtime);
}

/**
 * @summary Queries whitelist rules.
 *
 * @param request QueryGroupedSecurityEventMarkMissListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryGroupedSecurityEventMarkMissListResponse
 */
QueryGroupedSecurityEventMarkMissListResponse Client::queryGroupedSecurityEventMarkMissListWithOptions(const QueryGroupedSecurityEventMarkMissListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDisposalWay()) {
    query["DisposalWay"] = request.disposalWay();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  json body = {};
  if (!!request.hasCurrentPage()) {
    body["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasEventName()) {
    body["EventName"] = request.eventName();
  }

  if (!!request.hasFrom()) {
    body["From"] = request.from();
  }

  if (!!request.hasLang()) {
    body["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    body["PageSize"] = request.pageSize();
  }

  if (!!request.hasRemark()) {
    body["Remark"] = request.remark();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "QueryGroupedSecurityEventMarkMissList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<QueryGroupedSecurityEventMarkMissListResponse>();
}

/**
 * @summary Queries whitelist rules.
 *
 * @param request QueryGroupedSecurityEventMarkMissListRequest
 * @return QueryGroupedSecurityEventMarkMissListResponse
 */
QueryGroupedSecurityEventMarkMissListResponse Client::queryGroupedSecurityEventMarkMissList(const QueryGroupedSecurityEventMarkMissListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return queryGroupedSecurityEventMarkMissListWithOptions(request, runtime);
}

/**
 * @summary Queries the list of beginner tasks. Security Center provides rewards for users who complete tasks. The rewards include the quota for a value-added feature and log storage capacity.
 *
 * @param request QueryGuidTaskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryGuidTaskListResponse
 */
QueryGuidTaskListResponse Client::queryGuidTaskListWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "QueryGuidTaskList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<QueryGuidTaskListResponse>();
}

/**
 * @summary Queries the list of beginner tasks. Security Center provides rewards for users who complete tasks. The rewards include the quota for a value-added feature and log storage capacity.
 *
 * @return QueryGuidTaskListResponse
 */
QueryGuidTaskListResponse Client::queryGuidTaskList() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return queryGuidTaskListWithOptions(runtime);
}

/**
 * @summary Queries the retention period of images that are stored in a Jenkins image repository.
 *
 * @param request QueryJenkinsImageRegistryPersistenceDayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryJenkinsImageRegistryPersistenceDayResponse
 */
QueryJenkinsImageRegistryPersistenceDayResponse Client::queryJenkinsImageRegistryPersistenceDayWithOptions(const QueryJenkinsImageRegistryPersistenceDayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "QueryJenkinsImageRegistryPersistenceDay"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<QueryJenkinsImageRegistryPersistenceDayResponse>();
}

/**
 * @summary Queries the retention period of images that are stored in a Jenkins image repository.
 *
 * @param request QueryJenkinsImageRegistryPersistenceDayRequest
 * @return QueryJenkinsImageRegistryPersistenceDayResponse
 */
QueryJenkinsImageRegistryPersistenceDayResponse Client::queryJenkinsImageRegistryPersistenceDay(const QueryJenkinsImageRegistryPersistenceDayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return queryJenkinsImageRegistryPersistenceDayWithOptions(request, runtime);
}

/**
 * @summary Queries the result of a database precheck task.
 *
 * @param request QueryPreCheckDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPreCheckDatabaseResponse
 */
QueryPreCheckDatabaseResponse Client::queryPreCheckDatabaseWithOptions(const QueryPreCheckDatabaseRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasInstanceUuid()) {
    query["InstanceUuid"] = request.instanceUuid();
  }

  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  if (!!request.hasUniRegionId()) {
    query["UniRegionId"] = request.uniRegionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "QueryPreCheckDatabase"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<QueryPreCheckDatabaseResponse>();
}

/**
 * @summary Queries the result of a database precheck task.
 *
 * @param request QueryPreCheckDatabaseRequest
 * @return QueryPreCheckDatabaseResponse
 */
QueryPreCheckDatabaseResponse Client::queryPreCheckDatabase(const QueryPreCheckDatabaseRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return queryPreCheckDatabaseWithOptions(request, runtime);
}

/**
 * @summary Restarts a server. Only Windows servers are supported.
 *
 * @param request RebootMachineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RebootMachineResponse
 */
RebootMachineResponse Client::rebootMachineWithOptions(const RebootMachineRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RebootMachine"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RebootMachineResponse>();
}

/**
 * @summary Restarts a server. Only Windows servers are supported.
 *
 * @param request RebootMachineRequest
 * @return RebootMachineResponse
 */
RebootMachineResponse Client::rebootMachine(const RebootMachineRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return rebootMachineWithOptions(request, runtime);
}

/**
 * @summary Receives a reward that allows you to enable a free trial of the cloud honeypot feature or the feature of SDK for malicious file detection. You can receive a reward after you complete the required task.
 *
 * @param request ReceiveFunctionTrialRewardByAliUidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReceiveFunctionTrialRewardByAliUidResponse
 */
ReceiveFunctionTrialRewardByAliUidResponse Client::receiveFunctionTrialRewardByAliUidWithOptions(const ReceiveFunctionTrialRewardByAliUidRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFunctionName()) {
    query["FunctionName"] = request.functionName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ReceiveFunctionTrialRewardByAliUid"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ReceiveFunctionTrialRewardByAliUidResponse>();
}

/**
 * @summary Receives a reward that allows you to enable a free trial of the cloud honeypot feature or the feature of SDK for malicious file detection. You can receive a reward after you complete the required task.
 *
 * @param request ReceiveFunctionTrialRewardByAliUidRequest
 * @return ReceiveFunctionTrialRewardByAliUidResponse
 */
ReceiveFunctionTrialRewardByAliUidResponse Client::receiveFunctionTrialRewardByAliUid(const ReceiveFunctionTrialRewardByAliUidRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return receiveFunctionTrialRewardByAliUidWithOptions(request, runtime);
}

/**
 * @summary Synchronizes assets.
 *
 * @param request RefreshAssetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshAssetsResponse
 */
RefreshAssetsResponse Client::refreshAssetsWithOptions(const RefreshAssetsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssetType()) {
    query["AssetType"] = request.assetType();
  }

  if (!!request.hasCloudAssetSubType()) {
    query["CloudAssetSubType"] = request.cloudAssetSubType();
  }

  if (!!request.hasCloudAssetType()) {
    query["CloudAssetType"] = request.cloudAssetType();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RefreshAssets"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RefreshAssetsResponse>();
}

/**
 * @summary Synchronizes assets.
 *
 * @param request RefreshAssetsRequest
 * @return RefreshAssetsResponse
 */
RefreshAssetsResponse Client::refreshAssets(const RefreshAssetsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return refreshAssetsWithOptions(request, runtime);
}

/**
 * @summary Refreshes the statistics of container assets in the Assets module.
 *
 * @param request RefreshContainerAssetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshContainerAssetsResponse
 */
RefreshContainerAssetsResponse Client::refreshContainerAssetsWithOptions(const RefreshContainerAssetsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAssetType()) {
    query["AssetType"] = request.assetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RefreshContainerAssets"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RefreshContainerAssetsResponse>();
}

/**
 * @summary Refreshes the statistics of container assets in the Assets module.
 *
 * @param request RefreshContainerAssetsRequest
 * @return RefreshContainerAssetsResponse
 */
RefreshContainerAssetsResponse Client::refreshContainerAssets(const RefreshContainerAssetsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return refreshContainerAssetsWithOptions(request, runtime);
}

/**
 * @summary Refreshes the list of Object Storage Service (OSS) buckets.
 *
 * @param request RefreshOssBucketScanInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshOssBucketScanInfoResponse
 */
RefreshOssBucketScanInfoResponse Client::refreshOssBucketScanInfoWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "RefreshOssBucketScanInfo"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RefreshOssBucketScanInfoResponse>();
}

/**
 * @summary Refreshes the list of Object Storage Service (OSS) buckets.
 *
 * @return RefreshOssBucketScanInfoResponse
 */
RefreshOssBucketScanInfoResponse Client::refreshOssBucketScanInfo() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return refreshOssBucketScanInfoWithOptions(runtime);
}

/**
 * @summary Updates an image token.
 *
 * @param request RefreshRegistryTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshRegistryTokenResponse
 */
RefreshRegistryTokenResponse Client::refreshRegistryTokenWithOptions(const RefreshRegistryTokenRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRegistryId()) {
    query["RegistryId"] = request.registryId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RefreshRegistryToken"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RefreshRegistryTokenResponse>();
}

/**
 * @summary Updates an image token.
 *
 * @param request RefreshRegistryTokenRequest
 * @return RefreshRegistryTokenResponse
 */
RefreshRegistryTokenResponse Client::refreshRegistryToken(const RefreshRegistryTokenRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return refreshRegistryTokenWithOptions(request, runtime);
}

/**
 * @summary 释放云安全中心实例
 *
 * @param request ReleaseSasInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseSasInstanceResponse
 */
ReleaseSasInstanceResponse Client::releaseSasInstanceWithOptions(const ReleaseSasInstanceRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json body = {};
  if (!!request.hasChargeType()) {
    body["ChargeType"] = request.chargeType();
  }

  if (!!request.hasInstanceId()) {
    body["InstanceId"] = request.instanceId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"body" , Utils::Utils::parseToMap(body)}
  }).get<map<string, json>>());
  Params params = Params(json({
    {"action" , "ReleaseSasInstance"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ReleaseSasInstanceResponse>();
}

/**
 * @summary 释放云安全中心实例
 *
 * @param request ReleaseSasInstanceRequest
 * @return ReleaseSasInstanceResponse
 */
ReleaseSasInstanceResponse Client::releaseSasInstance(const ReleaseSasInstanceRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return releaseSasInstanceWithOptions(request, runtime);
}

/**
 * @summary Removes an instance from the whitelist.
 *
 * @param request RemoveCheckInstanceResultWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveCheckInstanceResultWhiteListResponse
 */
RemoveCheckInstanceResultWhiteListResponse Client::removeCheckInstanceResultWhiteListWithOptions(const RemoveCheckInstanceResultWhiteListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RemoveCheckInstanceResultWhiteList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RemoveCheckInstanceResultWhiteListResponse>();
}

/**
 * @summary Removes an instance from the whitelist.
 *
 * @param request RemoveCheckInstanceResultWhiteListRequest
 * @return RemoveCheckInstanceResultWhiteListResponse
 */
RemoveCheckInstanceResultWhiteListResponse Client::removeCheckInstanceResultWhiteList(const RemoveCheckInstanceResultWhiteListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return removeCheckInstanceResultWhiteListWithOptions(request, runtime);
}

/**
 * @summary Removes the check items of the configuration assessment feature from the whitelist.
 *
 * @param request RemoveCheckResultWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveCheckResultWhiteListResponse
 */
RemoveCheckResultWhiteListResponse Client::removeCheckResultWhiteListWithOptions(const RemoveCheckResultWhiteListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckGroupId()) {
    query["CheckGroupId"] = request.checkGroupId();
  }

  if (!!request.hasCheckIds()) {
    query["CheckIds"] = request.checkIds();
  }

  if (!!request.hasRuleId()) {
    query["RuleId"] = request.ruleId();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RemoveCheckResultWhiteList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RemoveCheckResultWhiteListResponse>();
}

/**
 * @summary Removes the check items of the configuration assessment feature from the whitelist.
 *
 * @param request RemoveCheckResultWhiteListRequest
 * @return RemoveCheckResultWhiteListResponse
 */
RemoveCheckResultWhiteListResponse Client::removeCheckResultWhiteList(const RemoveCheckResultWhiteListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return removeCheckResultWhiteListWithOptions(request, runtime);
}

/**
 * @summary Resets a honeypot.
 *
 * @param request ResetHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetHoneypotResponse
 */
ResetHoneypotResponse Client::resetHoneypotWithOptions(const ResetHoneypotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneypotId()) {
    query["HoneypotId"] = request.honeypotId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ResetHoneypot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ResetHoneypotResponse>();
}

/**
 * @summary Resets a honeypot.
 *
 * @param request ResetHoneypotRequest
 * @return ResetHoneypotResponse
 */
ResetHoneypotResponse Client::resetHoneypot(const ResetHoneypotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return resetHoneypotWithOptions(request, runtime);
}

/**
 * @summary Resets and upgrades the log analysis feature. You can call this operation only when the log analysis feature uses the pay-as-you-go billing method.
 *
 * @param request ResetLogShipperRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetLogShipperResponse
 */
ResetLogShipperResponse Client::resetLogShipperWithOptions(const ResetLogShipperRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHotTtl()) {
    query["HotTtl"] = request.hotTtl();
  }

  if (!!request.hasLogMetaList()) {
    query["LogMetaList"] = request.logMetaList();
  }

  if (!!request.hasTtl()) {
    query["Ttl"] = request.ttl();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ResetLogShipper"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ResetLogShipperResponse>();
}

/**
 * @summary Resets and upgrades the log analysis feature. You can call this operation only when the log analysis feature uses the pay-as-you-go billing method.
 *
 * @param request ResetLogShipperRequest
 * @return ResetLogShipperResponse
 */
ResetLogShipperResponse Client::resetLogShipper(const ResetLogShipperRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return resetLogShipperWithOptions(request, runtime);
}

/**
 * @summary Retries agentless detection tasks.
 *
 * @param request RetryAgentlessTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetryAgentlessTaskResponse
 */
RetryAgentlessTaskResponse Client::retryAgentlessTaskWithOptions(const RetryAgentlessTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTaskId()) {
    query["TaskId"] = request.taskId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RetryAgentlessTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RetryAgentlessTaskResponse>();
}

/**
 * @summary Retries agentless detection tasks.
 *
 * @param request RetryAgentlessTaskRequest
 * @return RetryAgentlessTaskResponse
 */
RetryAgentlessTaskResponse Client::retryAgentlessTask(const RetryAgentlessTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return retryAgentlessTaskWithOptions(request, runtime);
}

/**
 * @summary Retry installing the honeypot probe.
 *
 * @param request RetryInstallProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetryInstallProbeResponse
 */
RetryInstallProbeResponse Client::retryInstallProbeWithOptions(const RetryInstallProbeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasProbeId()) {
    query["ProbeId"] = request.probeId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RetryInstallProbe"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RetryInstallProbeResponse>();
}

/**
 * @summary Retry installing the honeypot probe.
 *
 * @param request RetryInstallProbeRequest
 * @return RetryInstallProbeResponse
 */
RetryInstallProbeResponse Client::retryInstallProbe(const RetryInstallProbeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return retryInstallProbeWithOptions(request, runtime);
}

/**
 * @summary Restores a quarantined file.
 *
 * @param request RollbackSuspEventQuaraFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RollbackSuspEventQuaraFileResponse
 */
RollbackSuspEventQuaraFileResponse Client::rollbackSuspEventQuaraFileWithOptions(const RollbackSuspEventQuaraFileRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasQuaraFileId()) {
    query["QuaraFileId"] = request.quaraFileId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "RollbackSuspEventQuaraFile"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<RollbackSuspEventQuaraFileResponse>();
}

/**
 * @summary Restores a quarantined file.
 *
 * @param request RollbackSuspEventQuaraFileRequest
 * @return RollbackSuspEventQuaraFileResponse
 */
RollbackSuspEventQuaraFileResponse Client::rollbackSuspEventQuaraFile(const RollbackSuspEventQuaraFileRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return rollbackSuspEventQuaraFileWithOptions(request, runtime);
}

/**
 * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
 *
 * @param request SasInstallCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SasInstallCodeResponse
 */
SasInstallCodeResponse Client::sasInstallCodeWithOptions(const SasInstallCodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SasInstallCode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SasInstallCodeResponse>();
}

/**
 * @summary Queries the installation verification code that is used to run the installation command of the Security Center agent.
 *
 * @param request SasInstallCodeRequest
 * @return SasInstallCodeResponse
 */
SasInstallCodeResponse Client::sasInstallCode(const SasInstallCodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return sasInstallCodeWithOptions(request, runtime);
}

/**
 * @summary Saves the configurations of a custom security report.
 *
 * @param request SaveCustomizeReportConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveCustomizeReportConfigResponse
 */
SaveCustomizeReportConfigResponse Client::saveCustomizeReportConfigWithOptions(const SaveCustomizeReportConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGroupType()) {
    query["GroupType"] = request.groupType();
  }

  if (!!request.hasMemberAccountSyncFlag()) {
    query["MemberAccountSyncFlag"] = request.memberAccountSyncFlag();
  }

  if (!!request.hasPinnedTime()) {
    query["PinnedTime"] = request.pinnedTime();
  }

  if (!!request.hasRecipients()) {
    query["Recipients"] = request.recipients();
  }

  if (!!request.hasReportDays()) {
    query["ReportDays"] = request.reportDays();
  }

  if (!!request.hasReportEndDate()) {
    query["ReportEndDate"] = request.reportEndDate();
  }

  if (!!request.hasReportId()) {
    query["ReportId"] = request.reportId();
  }

  if (!!request.hasReportLang()) {
    query["ReportLang"] = request.reportLang();
  }

  if (!!request.hasReportSendType()) {
    query["ReportSendType"] = request.reportSendType();
  }

  if (!!request.hasReportStartDate()) {
    query["ReportStartDate"] = request.reportStartDate();
  }

  if (!!request.hasReportStatus()) {
    query["ReportStatus"] = request.reportStatus();
  }

  if (!!request.hasReportType()) {
    query["ReportType"] = request.reportType();
  }

  if (!!request.hasReportVersion()) {
    query["ReportVersion"] = request.reportVersion();
  }

  if (!!request.hasSendEndTime()) {
    query["SendEndTime"] = request.sendEndTime();
  }

  if (!!request.hasSendPeriodDays()) {
    query["SendPeriodDays"] = request.sendPeriodDays();
  }

  if (!!request.hasSendPeriodType()) {
    query["SendPeriodType"] = request.sendPeriodType();
  }

  if (!!request.hasSendStartTime()) {
    query["SendStartTime"] = request.sendStartTime();
  }

  if (!!request.hasTargetGroups()) {
    query["TargetGroups"] = request.targetGroups();
  }

  if (!!request.hasTargetUids()) {
    query["TargetUids"] = request.targetUids();
  }

  if (!!request.hasTitle()) {
    query["Title"] = request.title();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SaveCustomizeReportConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SaveCustomizeReportConfigResponse>();
}

/**
 * @summary Saves the configurations of a custom security report.
 *
 * @param request SaveCustomizeReportConfigRequest
 * @return SaveCustomizeReportConfigResponse
 */
SaveCustomizeReportConfigResponse Client::saveCustomizeReportConfig(const SaveCustomizeReportConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return saveCustomizeReportConfigWithOptions(request, runtime);
}

/**
 * @summary Saves a baseline check policy for images.
 *
 * @param request SaveImageBaselineStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveImageBaselineStrategyResponse
 */
SaveImageBaselineStrategyResponse Client::saveImageBaselineStrategyWithOptions(const SaveImageBaselineStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBaselineItemList()) {
    query["BaselineItemList"] = request.baselineItemList();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasStrategyName()) {
    query["StrategyName"] = request.strategyName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SaveImageBaselineStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SaveImageBaselineStrategyResponse>();
}

/**
 * @summary Saves a baseline check policy for images.
 *
 * @param request SaveImageBaselineStrategyRequest
 * @return SaveImageBaselineStrategyResponse
 */
SaveImageBaselineStrategyResponse Client::saveImageBaselineStrategy(const SaveImageBaselineStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return saveImageBaselineStrategyWithOptions(request, runtime);
}

/**
 * @summary Saves alert settings.
 *
 * @param request SaveSuspEventUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveSuspEventUserSettingResponse
 */
SaveSuspEventUserSettingResponse Client::saveSuspEventUserSettingWithOptions(const SaveSuspEventUserSettingRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFrom()) {
    query["From"] = request.from();
  }

  if (!!request.hasLevelsOn()) {
    query["LevelsOn"] = request.levelsOn();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SaveSuspEventUserSetting"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SaveSuspEventUserSettingResponse>();
}

/**
 * @summary Saves alert settings.
 *
 * @param request SaveSuspEventUserSettingRequest
 * @return SaveSuspEventUserSettingResponse
 */
SaveSuspEventUserSettingResponse Client::saveSuspEventUserSetting(const SaveSuspEventUserSettingRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return saveSuspEventUserSettingWithOptions(request, runtime);
}

/**
 * @summary Creates an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or enabled the feature, you can call this operation.
 *
 * @param request SaveWhiteListStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveWhiteListStrategyResponse
 */
SaveWhiteListStrategyResponse Client::saveWhiteListStrategyWithOptions(const SaveWhiteListStrategyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasStrategyName()) {
    query["StrategyName"] = request.strategyName();
  }

  if (!!request.hasStudyTime()) {
    query["StudyTime"] = request.studyTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SaveWhiteListStrategy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SaveWhiteListStrategyResponse>();
}

/**
 * @summary Creates an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or enabled the feature, you can call this operation.
 *
 * @param request SaveWhiteListStrategyRequest
 * @return SaveWhiteListStrategyResponse
 */
SaveWhiteListStrategyResponse Client::saveWhiteListStrategy(const SaveWhiteListStrategyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return saveWhiteListStrategyWithOptions(request, runtime);
}

/**
 * @summary Manages the servers to which an application whitelist policy is applied.
 *
 * @param request SaveWhiteListStrategyAssetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveWhiteListStrategyAssetsResponse
 */
SaveWhiteListStrategyAssetsResponse Client::saveWhiteListStrategyAssetsWithOptions(const SaveWhiteListStrategyAssetsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasOperations()) {
    query["Operations"] = request.operations();
  }

  if (!!request.hasRelationType()) {
    query["RelationType"] = request.relationType();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SaveWhiteListStrategyAssets"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SaveWhiteListStrategyAssetsResponse>();
}

/**
 * @summary Manages the servers to which an application whitelist policy is applied.
 *
 * @param request SaveWhiteListStrategyAssetsRequest
 * @return SaveWhiteListStrategyAssetsResponse
 */
SaveWhiteListStrategyAssetsResponse Client::saveWhiteListStrategyAssets(const SaveWhiteListStrategyAssetsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return saveWhiteListStrategyAssetsWithOptions(request, runtime);
}

/**
 * @summary Sends a security report to an email address that you specify. You can send only a security report whose statistics are collected in a custom time range.
 *
 * @param request SendCustomizeReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendCustomizeReportResponse
 */
SendCustomizeReportResponse Client::sendCustomizeReportWithOptions(const SendCustomizeReportRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasReportId()) {
    query["ReportId"] = request.reportId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SendCustomizeReport"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SendCustomizeReportResponse>();
}

/**
 * @summary Sends a security report to an email address that you specify. You can send only a security report whose statistics are collected in a custom time range.
 *
 * @param request SendCustomizeReportRequest
 * @return SendCustomizeReportResponse
 */
SendCustomizeReportResponse Client::sendCustomizeReport(const SendCustomizeReportRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return sendCustomizeReportWithOptions(request, runtime);
}

/**
 * @summary Modifies configurations for scanning image build command risks.
 *
 * @param request SetBuildRiskDefineRuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetBuildRiskDefineRuleConfigResponse
 */
SetBuildRiskDefineRuleConfigResponse Client::setBuildRiskDefineRuleConfigWithOptions(const SetBuildRiskDefineRuleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SetBuildRiskDefineRuleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SetBuildRiskDefineRuleConfigResponse>();
}

/**
 * @summary Modifies configurations for scanning image build command risks.
 *
 * @param request SetBuildRiskDefineRuleConfigRequest
 * @return SetBuildRiskDefineRuleConfigResponse
 */
SetBuildRiskDefineRuleConfigResponse Client::setBuildRiskDefineRuleConfig(const SetBuildRiskDefineRuleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return setBuildRiskDefineRuleConfigWithOptions(request, runtime);
}

/**
 * @summary Configures the status of the container firewall feature.
 *
 * @param request SetClusterInterceptionConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetClusterInterceptionConfigResponse
 */
SetClusterInterceptionConfigResponse Client::setClusterInterceptionConfigWithOptions(const SetClusterInterceptionConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterIds()) {
    query["ClusterIds"] = request.clusterIds();
  }

  if (!!request.hasSwitchOn()) {
    query["SwitchOn"] = request.switchOn();
  }

  if (!!request.hasSwitchType()) {
    query["SwitchType"] = request.switchType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SetClusterInterceptionConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SetClusterInterceptionConfigResponse>();
}

/**
 * @summary Configures the status of the container firewall feature.
 *
 * @param request SetClusterInterceptionConfigRequest
 * @return SetClusterInterceptionConfigResponse
 */
SetClusterInterceptionConfigResponse Client::setClusterInterceptionConfig(const SetClusterInterceptionConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return setClusterInterceptionConfigWithOptions(request, runtime);
}

/**
 * @summary Specifies the status of an image build command risk.
 *
 * @param request SetImageBuildRiskStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetImageBuildRiskStatusResponse
 */
SetImageBuildRiskStatusResponse Client::setImageBuildRiskStatusWithOptions(const SetImageBuildRiskStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasImageUuids()) {
    query["ImageUuids"] = request.imageUuids();
  }

  if (!!request.hasRiskKey()) {
    query["RiskKey"] = request.riskKey();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SetImageBuildRiskStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SetImageBuildRiskStatusResponse>();
}

/**
 * @summary Specifies the status of an image build command risk.
 *
 * @param request SetImageBuildRiskStatusRequest
 * @return SetImageBuildRiskStatusResponse
 */
SetImageBuildRiskStatusResponse Client::setImageBuildRiskStatus(const SetImageBuildRiskStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return setImageBuildRiskStatusWithOptions(request, runtime);
}

/**
 * @summary Modifies the status of sensitive files in an image.
 *
 * @param tmpReq SetImageSensitiveFileStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetImageSensitiveFileStatusResponse
 */
SetImageSensitiveFileStatusResponse Client::setImageSensitiveFileStatusWithOptions(const SetImageSensitiveFileStatusRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  SetImageSensitiveFileStatusShrinkRequest request = SetImageSensitiveFileStatusShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasScanRange()) {
    request.setScanRangeShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.scanRange(), "ScanRange", "json"));
  }

  json query = {};
  if (!!request.hasIdList()) {
    query["IdList"] = request.idList();
  }

  if (!!request.hasImageUuids()) {
    query["ImageUuids"] = request.imageUuids();
  }

  if (!!request.hasScanRangeShrink()) {
    query["ScanRange"] = request.scanRangeShrink();
  }

  if (!!request.hasSensitiveFileKey()) {
    query["SensitiveFileKey"] = request.sensitiveFileKey();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SetImageSensitiveFileStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SetImageSensitiveFileStatusResponse>();
}

/**
 * @summary Modifies the status of sensitive files in an image.
 *
 * @param request SetImageSensitiveFileStatusRequest
 * @return SetImageSensitiveFileStatusResponse
 */
SetImageSensitiveFileStatusResponse Client::setImageSensitiveFileStatus(const SetImageSensitiveFileStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return setImageSensitiveFileStatusWithOptions(request, runtime);
}

/**
 * @summary Specifies a cycle to scan images for image repositories. Unit: days.
 *
 * @param request SetRegistryScanDayNumRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetRegistryScanDayNumResponse
 */
SetRegistryScanDayNumResponse Client::setRegistryScanDayNumWithOptions(const SetRegistryScanDayNumRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasScanDayNum()) {
    query["ScanDayNum"] = request.scanDayNum();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SetRegistryScanDayNum"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SetRegistryScanDayNumResponse>();
}

/**
 * @summary Specifies a cycle to scan images for image repositories. Unit: days.
 *
 * @param request SetRegistryScanDayNumRequest
 * @return SetRegistryScanDayNumResponse
 */
SetRegistryScanDayNumResponse Client::setRegistryScanDayNum(const SetRegistryScanDayNumRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return setRegistryScanDayNumWithOptions(request, runtime);
}

/**
 * @summary Configure the check rules of sensitive files.
 *
 * @param request SetSensitiveDefineRuleConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetSensitiveDefineRuleConfigResponse
 */
SetSensitiveDefineRuleConfigResponse Client::setSensitiveDefineRuleConfigWithOptions(const SetSensitiveDefineRuleConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfig()) {
    query["Config"] = request.config();
  }

  if (!!request.hasEnableNewRule()) {
    query["EnableNewRule"] = request.enableNewRule();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SetSensitiveDefineRuleConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SetSensitiveDefineRuleConfigResponse>();
}

/**
 * @summary Configure the check rules of sensitive files.
 *
 * @param request SetSensitiveDefineRuleConfigRequest
 * @return SetSensitiveDefineRuleConfigResponse
 */
SetSensitiveDefineRuleConfigResponse Client::setSensitiveDefineRuleConfig(const SetSensitiveDefineRuleConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return setSensitiveDefineRuleConfigWithOptions(request, runtime);
}

/**
 * @summary Configures the regions from which you want to synchronize assets.
 *
 * @param request SetSyncRefreshRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetSyncRefreshRegionResponse
 */
SetSyncRefreshRegionResponse Client::setSyncRefreshRegionWithOptions(const SetSyncRefreshRegionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDefaultRegion()) {
    query["DefaultRegion"] = request.defaultRegion();
  }

  if (!!request.hasRegionIds()) {
    query["RegionIds"] = request.regionIds();
  }

  if (!!request.hasVendor()) {
    query["Vendor"] = request.vendor();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SetSyncRefreshRegion"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SetSyncRefreshRegionResponse>();
}

/**
 * @summary Configures the regions from which you want to synchronize assets.
 *
 * @param request SetSyncRefreshRegionRequest
 * @return SetSyncRefreshRegionResponse
 */
SetSyncRefreshRegionResponse Client::setSyncRefreshRegion(const SetSyncRefreshRegionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return setSyncRefreshRegionWithOptions(request, runtime);
}

/**
 * @deprecated OpenAPI StartBaselineSecurityCheck is deprecated, please use Sas::2018-12-03::SubmitCheck instead.
 *
 * @summary Checks cloud service configurations. You can check all items or a single item and verify whether an item is checked.
 *
 * @param request StartBaselineSecurityCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartBaselineSecurityCheckResponse
 */
StartBaselineSecurityCheckResponse Client::startBaselineSecurityCheckWithOptions(const StartBaselineSecurityCheckRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasItemIds()) {
    query["ItemIds"] = request.itemIds();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasResourceOwnerId()) {
    query["ResourceOwnerId"] = request.resourceOwnerId();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "StartBaselineSecurityCheck"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<StartBaselineSecurityCheckResponse>();
}

/**
 * @deprecated OpenAPI StartBaselineSecurityCheck is deprecated, please use Sas::2018-12-03::SubmitCheck instead.
 *
 * @summary Checks cloud service configurations. You can check all items or a single item and verify whether an item is checked.
 *
 * @param request StartBaselineSecurityCheckRequest
 * @return StartBaselineSecurityCheckResponse
 */
StartBaselineSecurityCheckResponse Client::startBaselineSecurityCheck(const StartBaselineSecurityCheckRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return startBaselineSecurityCheckWithOptions(request, runtime);
}

/**
 * @summary Starts a database scan task.
 *
 * @param request StartDiscoverDatabaseTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartDiscoverDatabaseTaskResponse
 */
StartDiscoverDatabaseTaskResponse Client::startDiscoverDatabaseTaskWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "StartDiscoverDatabaseTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<StartDiscoverDatabaseTaskResponse>();
}

/**
 * @summary Starts a database scan task.
 *
 * @return StartDiscoverDatabaseTaskResponse
 */
StartDiscoverDatabaseTaskResponse Client::startDiscoverDatabaseTask() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return startDiscoverDatabaseTaskWithOptions(runtime);
}

/**
 * @summary Starts a honeypot.
 *
 * @param request StartHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartHoneypotResponse
 */
StartHoneypotResponse Client::startHoneypotWithOptions(const StartHoneypotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneypotId()) {
    query["HoneypotId"] = request.honeypotId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "StartHoneypot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<StartHoneypotResponse>();
}

/**
 * @summary Starts a honeypot.
 *
 * @param request StartHoneypotRequest
 * @return StartHoneypotResponse
 */
StartHoneypotResponse Client::startHoneypot(const StartHoneypotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return startHoneypotWithOptions(request, runtime);
}

/**
 * @summary Starts an IDC scan task.
 *
 * @param request StartIdcProbeScanRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartIdcProbeScanResponse
 */
StartIdcProbeScanResponse Client::startIdcProbeScanWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "StartIdcProbeScan"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<StartIdcProbeScanResponse>();
}

/**
 * @summary Starts an IDC scan task.
 *
 * @return StartIdcProbeScanResponse
 */
StartIdcProbeScanResponse Client::startIdcProbeScan() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return startIdcProbeScanWithOptions(runtime);
}

/**
 * @summary Starts a database precheck task.
 *
 * @param request StartPreCheckDatabaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartPreCheckDatabaseResponse
 */
StartPreCheckDatabaseResponse Client::startPreCheckDatabaseWithOptions(const StartPreCheckDatabaseRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasDatabaseType()) {
    query["DatabaseType"] = request.databaseType();
  }

  if (!!request.hasInstanceUuid()) {
    query["InstanceUuid"] = request.instanceUuid();
  }

  if (!!request.hasUniRegionId()) {
    query["UniRegionId"] = request.uniRegionId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "StartPreCheckDatabase"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<StartPreCheckDatabaseResponse>();
}

/**
 * @summary Starts a database precheck task.
 *
 * @param request StartPreCheckDatabaseRequest
 * @return StartPreCheckDatabaseResponse
 */
StartPreCheckDatabaseResponse Client::startPreCheckDatabase(const StartPreCheckDatabaseRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return startPreCheckDatabaseWithOptions(request, runtime);
}

/**
 * @summary Performs a virus scan task on a server or multiple servers.
 *
 * @param request StartVirusScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartVirusScanTaskResponse
 */
StartVirusScanTaskResponse Client::startVirusScanTaskWithOptions(const StartVirusScanTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTargetInfo()) {
    query["TargetInfo"] = request.targetInfo();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "StartVirusScanTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<StartVirusScanTaskResponse>();
}

/**
 * @summary Performs a virus scan task on a server or multiple servers.
 *
 * @param request StartVirusScanTaskRequest
 * @return StartVirusScanTaskResponse
 */
StartVirusScanTaskResponse Client::startVirusScanTask(const StartVirusScanTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return startVirusScanTaskWithOptions(request, runtime);
}

/**
 * @summary Stops a honeypot.
 *
 * @param request StopHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopHoneypotResponse
 */
StopHoneypotResponse Client::stopHoneypotWithOptions(const StopHoneypotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneypotId()) {
    query["HoneypotId"] = request.honeypotId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "StopHoneypot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<StopHoneypotResponse>();
}

/**
 * @summary Stops a honeypot.
 *
 * @param request StopHoneypotRequest
 * @return StopHoneypotResponse
 */
StopHoneypotResponse Client::stopHoneypot(const StopHoneypotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return stopHoneypotWithOptions(request, runtime);
}

/**
 * @summary Submits a configuration assessment task.
 *
 * @param request SubmitCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitCheckResponse
 */
SubmitCheckResponse Client::submitCheckWithOptions(const SubmitCheckRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasScanRange()) {
    query["ScanRange"] = request.scanRange();
  }

  if (!!request.hasTaskSource()) {
    query["TaskSource"] = request.taskSource();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SubmitCheck"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SubmitCheckResponse>();
}

/**
 * @summary Submits a configuration assessment task.
 *
 * @param request SubmitCheckRequest
 * @return SubmitCheckResponse
 */
SubmitCheckResponse Client::submitCheck(const SubmitCheckRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return submitCheckWithOptions(request, runtime);
}

/**
 * @summary Submits a repair task of risk items detected in configuration assessment or rolls back a repair task that is executed.
 *
 * @param request SubmitOperationTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitOperationTaskResponse
 */
SubmitOperationTaskResponse Client::submitOperationTaskWithOptions(const SubmitOperationTaskRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasDimensionType()) {
    query["DimensionType"] = request.dimensionType();
  }

  if (!!request.hasOperationTaskInstances()) {
    query["OperationTaskInstances"] = request.operationTaskInstances();
  }

  if (!!request.hasRelationKey()) {
    query["RelationKey"] = request.relationKey();
  }

  if (!!request.hasRepairTempParam()) {
    query["RepairTempParam"] = request.repairTempParam();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "SubmitOperationTask"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SubmitOperationTaskResponse>();
}

/**
 * @summary Submits a repair task of risk items detected in configuration assessment or rolls back a repair task that is executed.
 *
 * @param request SubmitOperationTaskRequest
 * @return SubmitOperationTaskResponse
 */
SubmitOperationTaskResponse Client::submitOperationTask(const SubmitOperationTaskRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return submitOperationTaskWithOptions(request, runtime);
}

/**
 * @summary Submits a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
 *
 * @param request SubmitTenantCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitTenantCheckResponse
 */
SubmitTenantCheckResponse Client::submitTenantCheckWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "SubmitTenantCheck"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<SubmitTenantCheckResponse>();
}

/**
 * @summary Submits a free quick scan task, which includes vulnerability detection in the free category and free check items of Cloud Security Posture Management (CSPM).
 *
 * @return SubmitTenantCheckResponse
 */
SubmitTenantCheckResponse Client::submitTenantCheck() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return submitTenantCheckWithOptions(runtime);
}

/**
 * @summary Triggers ISO 27001 compliance checks of Security Center.
 *
 * @param request TriggerCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TriggerCheckResponse
 */
TriggerCheckResponse Client::triggerCheckWithOptions(const Darabonba::RuntimeOptions &runtime) {
  OpenApiRequest req = OpenApiRequest();
  Params params = Params(json({
    {"action" , "TriggerCheck"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<TriggerCheckResponse>();
}

/**
 * @summary Triggers ISO 27001 compliance checks of Security Center.
 *
 * @return TriggerCheckResponse
 */
TriggerCheckResponse Client::triggerCheck() {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return triggerCheckWithOptions(runtime);
}

/**
 * @summary Removes servers from a proxy cluster.
 *
 * @param request UnBindHybridProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnBindHybridProxyResponse
 */
UnBindHybridProxyResponse Client::unBindHybridProxyWithOptions(const UnBindHybridProxyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasYundunUuids()) {
    query["YundunUuids"] = request.yundunUuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnBindHybridProxy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnBindHybridProxyResponse>();
}

/**
 * @summary Removes servers from a proxy cluster.
 *
 * @param request UnBindHybridProxyRequest
 * @return UnBindHybridProxyResponse
 */
UnBindHybridProxyResponse Client::unBindHybridProxy(const UnBindHybridProxyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unBindHybridProxyWithOptions(request, runtime);
}

/**
 * @summary Cancel marking for members. You can call this operation to remove followed members from the list. In the Security Center console, the drop-down list above the left-side navigation pane no longer displays the members.
 *
 * @param request UnMarkMonitorAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnMarkMonitorAccountsResponse
 */
UnMarkMonitorAccountsResponse Client::unMarkMonitorAccountsWithOptions(const UnMarkMonitorAccountsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAccountIds()) {
    query["AccountIds"] = request.accountIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnMarkMonitorAccounts"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnMarkMonitorAccountsResponse>();
}

/**
 * @summary Cancel marking for members. You can call this operation to remove followed members from the list. In the Security Center console, the drop-down list above the left-side navigation pane no longer displays the members.
 *
 * @param request UnMarkMonitorAccountsRequest
 * @return UnMarkMonitorAccountsResponse
 */
UnMarkMonitorAccountsResponse Client::unMarkMonitorAccounts(const UnMarkMonitorAccountsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unMarkMonitorAccountsWithOptions(request, runtime);
}

/**
 * @summary Unbinds servers that are not deployed on Alibaba Cloud from Security Center.
 *
 * @description If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
 * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
 * **Prerequisites**
 * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
 * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
 *
 * @param request UnbindAegisRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindAegisResponse
 */
UnbindAegisResponse Client::unbindAegisWithOptions(const UnbindAegisRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UnbindAegis"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UnbindAegisResponse>();
}

/**
 * @summary Unbinds servers that are not deployed on Alibaba Cloud from Security Center.
 *
 * @description If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
 * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
 * **Prerequisites**
 * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
 * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
 *
 * @param request UnbindAegisRequest
 * @return UnbindAegisResponse
 */
UnbindAegisResponse Client::unbindAegis(const UnbindAegisRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return unbindAegisWithOptions(request, runtime);
}

/**
 * @summary Uninstalls the anti-ransomware agent.
 *
 * @param request UninstallBackupClientRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UninstallBackupClientResponse
 */
UninstallBackupClientResponse Client::uninstallBackupClientWithOptions(const UninstallBackupClientRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPolicyVersion()) {
    query["PolicyVersion"] = request.policyVersion();
  }

  if (!!request.hasUuid()) {
    query["Uuid"] = request.uuid();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UninstallBackupClient"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UninstallBackupClientResponse>();
}

/**
 * @summary Uninstalls the anti-ransomware agent.
 *
 * @param request UninstallBackupClientRequest
 * @return UninstallBackupClientResponse
 */
UninstallBackupClientResponse Client::uninstallBackupClient(const UninstallBackupClientRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return uninstallBackupClientWithOptions(request, runtime);
}

/**
 * @summary Uninstalls the database backup agent.
 *
 * @param request UninstallUniBackupAgentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UninstallUniBackupAgentResponse
 */
UninstallUniBackupAgentResponse Client::uninstallUniBackupAgentWithOptions(const UninstallUniBackupAgentRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPolicyId()) {
    query["PolicyId"] = request.policyId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UninstallUniBackupAgent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UninstallUniBackupAgentResponse>();
}

/**
 * @summary Uninstalls the database backup agent.
 *
 * @param request UninstallUniBackupAgentRequest
 * @return UninstallUniBackupAgentResponse
 */
UninstallUniBackupAgentResponse Client::uninstallUniBackupAgent(const UninstallUniBackupAgentRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return uninstallUniBackupAgentWithOptions(request, runtime);
}

/**
 * @summary Updates the status of the honeypot installation time.
 *
 * @param request UpdateAlarmEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAlarmEventResponse
 */
UpdateAlarmEventResponse Client::updateAlarmEventWithOptions(const UpdateAlarmEventRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json body = {};
  if (!!request.hasAlarmEventIdList()) {
    body["AlarmEventIdList"] = request.alarmEventIdList();
  }

  if (!!request.hasLang()) {
    body["Lang"] = request.lang();
  }

  if (!!request.hasOperationCode()) {
    body["OperationCode"] = request.operationCode();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"body" , Utils::Utils::parseToMap(body)}
  }).get<map<string, json>>());
  Params params = Params(json({
    {"action" , "UpdateAlarmEvent"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateAlarmEventResponse>();
}

/**
 * @summary Updates the status of the honeypot installation time.
 *
 * @param request UpdateAlarmEventRequest
 * @return UpdateAlarmEventResponse
 */
UpdateAlarmEventResponse Client::updateAlarmEvent(const UpdateAlarmEventRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateAlarmEventWithOptions(request, runtime);
}

/**
 * @summary Update the configuration of sensitive assets in the attack path.
 *
 * @param request UpdateAttackPathSensitiveAssetConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAttackPathSensitiveAssetConfigResponse
 */
UpdateAttackPathSensitiveAssetConfigResponse Client::updateAttackPathSensitiveAssetConfigWithOptions(const UpdateAttackPathSensitiveAssetConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAttackPathAssetList()) {
    query["AttackPathAssetList"] = request.attackPathAssetList();
  }

  if (!!request.hasAttackPathSensitiveAssetConfigId()) {
    query["AttackPathSensitiveAssetConfigId"] = request.attackPathSensitiveAssetConfigId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateAttackPathSensitiveAssetConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateAttackPathSensitiveAssetConfigResponse>();
}

/**
 * @summary Update the configuration of sensitive assets in the attack path.
 *
 * @param request UpdateAttackPathSensitiveAssetConfigRequest
 * @return UpdateAttackPathSensitiveAssetConfigResponse
 */
UpdateAttackPathSensitiveAssetConfigResponse Client::updateAttackPathSensitiveAssetConfig(const UpdateAttackPathSensitiveAssetConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateAttackPathSensitiveAssetConfigWithOptions(request, runtime);
}

/**
 * @summary Update Attack Path Whitelist.
 *
 * @param request UpdateAttackPathWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAttackPathWhitelistResponse
 */
UpdateAttackPathWhitelistResponse Client::updateAttackPathWhitelistWithOptions(const UpdateAttackPathWhitelistRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAttackPathAssetList()) {
    query["AttackPathAssetList"] = request.attackPathAssetList();
  }

  if (!!request.hasAttackPathWhitelistId()) {
    query["AttackPathWhitelistId"] = request.attackPathWhitelistId();
  }

  if (!!request.hasPathName()) {
    query["PathName"] = request.pathName();
  }

  if (!!request.hasPathType()) {
    query["PathType"] = request.pathType();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  if (!!request.hasWhitelistName()) {
    query["WhitelistName"] = request.whitelistName();
  }

  if (!!request.hasWhitelistType()) {
    query["WhitelistType"] = request.whitelistType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateAttackPathWhitelist"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateAttackPathWhitelistResponse>();
}

/**
 * @summary Update Attack Path Whitelist.
 *
 * @param request UpdateAttackPathWhitelistRequest
 * @return UpdateAttackPathWhitelistResponse
 */
UpdateAttackPathWhitelistResponse Client::updateAttackPathWhitelist(const UpdateAttackPathWhitelistRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateAttackPathWhitelistWithOptions(request, runtime);
}

/**
 * @summary Updates the whitelist rule for a baseline check item.
 *
 * @param request UpdateBaselineCheckWhiteRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBaselineCheckWhiteRecordResponse
 */
UpdateBaselineCheckWhiteRecordResponse Client::updateBaselineCheckWhiteRecordWithOptions(const UpdateBaselineCheckWhiteRecordRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasReason()) {
    query["Reason"] = request.reason();
  }

  if (!!request.hasRecordId()) {
    query["RecordId"] = request.recordId();
  }

  if (!!request.hasRemoveContainerUuids()) {
    query["RemoveContainerUuids"] = request.removeContainerUuids();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateBaselineCheckWhiteRecord"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateBaselineCheckWhiteRecordResponse>();
}

/**
 * @summary Updates the whitelist rule for a baseline check item.
 *
 * @param request UpdateBaselineCheckWhiteRecordRequest
 * @return UpdateBaselineCheckWhiteRecordResponse
 */
UpdateBaselineCheckWhiteRecordResponse Client::updateBaselineCheckWhiteRecord(const UpdateBaselineCheckWhiteRecordRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateBaselineCheckWhiteRecordWithOptions(request, runtime);
}

/**
 * @summary Modifies alerting settings for servers.
 *
 * @param request UpdateClientAlertModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateClientAlertModeResponse
 */
UpdateClientAlertModeResponse Client::updateClientAlertModeWithOptions(const UpdateClientAlertModeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasMode()) {
    query["Mode"] = request.mode();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateClientAlertMode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateClientAlertModeResponse>();
}

/**
 * @summary Modifies alerting settings for servers.
 *
 * @param request UpdateClientAlertModeRequest
 * @return UpdateClientAlertModeResponse
 */
UpdateClientAlertModeResponse Client::updateClientAlertMode(const UpdateClientAlertModeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateClientAlertModeWithOptions(request, runtime);
}

/**
 * @summary Modifies the settings of common switches.
 *
 * @param request UpdateCommonSwitchConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCommonSwitchConfigResponse
 */
UpdateCommonSwitchConfigResponse Client::updateCommonSwitchConfigWithOptions(const UpdateCommonSwitchConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasTargetDefault()) {
    query["TargetDefault"] = request.targetDefault();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateCommonSwitchConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateCommonSwitchConfigResponse>();
}

/**
 * @summary Modifies the settings of common switches.
 *
 * @param request UpdateCommonSwitchConfigRequest
 * @return UpdateCommonSwitchConfigResponse
 */
UpdateCommonSwitchConfigResponse Client::updateCommonSwitchConfig(const UpdateCommonSwitchConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateCommonSwitchConfigWithOptions(request, runtime);
}

/**
 * @summary Changes the status of a security report.
 *
 * @param request UpdateCustomizeReportStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCustomizeReportStatusResponse
 */
UpdateCustomizeReportStatusResponse Client::updateCustomizeReportStatusWithOptions(const UpdateCustomizeReportStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasPinnedTime()) {
    query["PinnedTime"] = request.pinnedTime();
  }

  if (!!request.hasReportId()) {
    query["ReportId"] = request.reportId();
  }

  if (!!request.hasReportStatus()) {
    query["ReportStatus"] = request.reportStatus();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateCustomizeReportStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateCustomizeReportStatusResponse>();
}

/**
 * @summary Changes the status of a security report.
 *
 * @param request UpdateCustomizeReportStatusRequest
 * @return UpdateCustomizeReportStatusResponse
 */
UpdateCustomizeReportStatusResponse Client::updateCustomizeReportStatus(const UpdateCustomizeReportStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateCustomizeReportStatusWithOptions(request, runtime);
}

/**
 * @summary Modifies the status of core file monitoring events reported by the Security Center agent.
 *
 * @param request UpdateFileProtectEventStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileProtectEventStatusResponse
 */
UpdateFileProtectEventStatusResponse Client::updateFileProtectEventStatusWithOptions(const UpdateFileProtectEventStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateFileProtectEventStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateFileProtectEventStatusResponse>();
}

/**
 * @summary Modifies the status of core file monitoring events reported by the Security Center agent.
 *
 * @param request UpdateFileProtectEventStatusRequest
 * @return UpdateFileProtectEventStatusResponse
 */
UpdateFileProtectEventStatusResponse Client::updateFileProtectEventStatus(const UpdateFileProtectEventStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateFileProtectEventStatusWithOptions(request, runtime);
}

/**
 * @summary Adds remarks to core file monitoring events reported by the Security Center agent.
 *
 * @param request UpdateFileProtectRemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileProtectRemarkResponse
 */
UpdateFileProtectRemarkResponse Client::updateFileProtectRemarkWithOptions(const UpdateFileProtectRemarkRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasRemark()) {
    query["Remark"] = request.remark();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateFileProtectRemark"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateFileProtectRemarkResponse>();
}

/**
 * @summary Adds remarks to core file monitoring events reported by the Security Center agent.
 *
 * @param request UpdateFileProtectRemarkRequest
 * @return UpdateFileProtectRemarkResponse
 */
UpdateFileProtectRemarkResponse Client::updateFileProtectRemark(const UpdateFileProtectRemarkRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateFileProtectRemarkWithOptions(request, runtime);
}

/**
 * @summary Modifies the content of a core file monitoring rule based on the ID of the rule.
 *
 * @param request UpdateFileProtectRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileProtectRuleResponse
 */
UpdateFileProtectRuleResponse Client::updateFileProtectRuleWithOptions(const UpdateFileProtectRuleRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAlertLevel()) {
    query["AlertLevel"] = request.alertLevel();
  }

  if (!!request.hasFileOps()) {
    query["FileOps"] = request.fileOps();
  }

  if (!!request.hasFilePaths()) {
    query["FilePaths"] = request.filePaths();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasProcPaths()) {
    query["ProcPaths"] = request.procPaths();
  }

  if (!!request.hasRuleAction()) {
    query["RuleAction"] = request.ruleAction();
  }

  if (!!request.hasRuleName()) {
    query["RuleName"] = request.ruleName();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateFileProtectRule"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateFileProtectRuleResponse>();
}

/**
 * @summary Modifies the content of a core file monitoring rule based on the ID of the rule.
 *
 * @param request UpdateFileProtectRuleRequest
 * @return UpdateFileProtectRuleResponse
 */
UpdateFileProtectRuleResponse Client::updateFileProtectRule(const UpdateFileProtectRuleRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateFileProtectRuleWithOptions(request, runtime);
}

/**
 * @summary Modifies the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @param request UpdateFileUploadLimitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileUploadLimitResponse
 */
UpdateFileUploadLimitResponse Client::updateFileUploadLimitWithOptions(const UpdateFileUploadLimitRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLimit()) {
    query["Limit"] = request.limit();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateFileUploadLimit"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateFileUploadLimitResponse>();
}

/**
 * @summary Modifies the queries per second (QPS) limit on the files uploaded from the client.
 *
 * @param request UpdateFileUploadLimitRequest
 * @return UpdateFileUploadLimitResponse
 */
UpdateFileUploadLimitResponse Client::updateFileUploadLimit(const UpdateFileUploadLimitRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateFileUploadLimitWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a specified honeypot.
 *
 * @param request UpdateHoneypotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHoneypotResponse
 */
UpdateHoneypotResponse Client::updateHoneypotWithOptions(const UpdateHoneypotRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneypotId()) {
    query["HoneypotId"] = request.honeypotId();
  }

  if (!!request.hasHoneypotName()) {
    query["HoneypotName"] = request.honeypotName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMeta()) {
    query["Meta"] = request.meta();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateHoneypot"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateHoneypotResponse>();
}

/**
 * @summary Modifies the configuration of a specified honeypot.
 *
 * @param request UpdateHoneypotRequest
 * @return UpdateHoneypotResponse
 */
UpdateHoneypotResponse Client::updateHoneypot(const UpdateHoneypotRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateHoneypotWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of a specified management node.
 *
 * @param request UpdateHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHoneypotNodeResponse
 */
UpdateHoneypotNodeResponse Client::updateHoneypotNodeWithOptions(const UpdateHoneypotNodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAvailableProbeNum()) {
    query["AvailableProbeNum"] = request.availableProbeNum();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  if (!!request.hasNodeName()) {
    query["NodeName"] = request.nodeName();
  }

  if (!!request.hasSecurityGroupProbeIpList()) {
    query["SecurityGroupProbeIpList"] = request.securityGroupProbeIpList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateHoneypotNode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateHoneypotNodeResponse>();
}

/**
 * @summary Modifies the configuration of a specified management node.
 *
 * @param request UpdateHoneypotNodeRequest
 * @return UpdateHoneypotNodeResponse
 */
UpdateHoneypotNodeResponse Client::updateHoneypotNode(const UpdateHoneypotNodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateHoneypotNodeWithOptions(request, runtime);
}

/**
 * @summary Modifies the configurations of the specified honeypot template.
 *
 * @param request UpdateHoneypotPresetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHoneypotPresetResponse
 */
UpdateHoneypotPresetResponse Client::updateHoneypotPresetWithOptions(const UpdateHoneypotPresetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasHoneypotImageName()) {
    query["HoneypotImageName"] = request.honeypotImageName();
  }

  if (!!request.hasHoneypotPresetId()) {
    query["HoneypotPresetId"] = request.honeypotPresetId();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasMeta()) {
    query["Meta"] = request.meta();
  }

  if (!!request.hasPresetName()) {
    query["PresetName"] = request.presetName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateHoneypotPreset"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateHoneypotPresetResponse>();
}

/**
 * @summary Modifies the configurations of the specified honeypot template.
 *
 * @param request UpdateHoneypotPresetRequest
 * @return UpdateHoneypotPresetResponse
 */
UpdateHoneypotPresetResponse Client::updateHoneypotPreset(const UpdateHoneypotPresetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateHoneypotPresetWithOptions(request, runtime);
}

/**
 * @summary Modifies the attributes of a specified probe.
 *
 * @param request UpdateHoneypotProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHoneypotProbeResponse
 */
UpdateHoneypotProbeResponse Client::updateHoneypotProbeWithOptions(const UpdateHoneypotProbeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasArp()) {
    query["Arp"] = request.arp();
  }

  if (!!request.hasDisplayName()) {
    query["DisplayName"] = request.displayName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPing()) {
    query["Ping"] = request.ping();
  }

  if (!!request.hasProbeId()) {
    query["ProbeId"] = request.probeId();
  }

  if (!!request.hasServiceIpList()) {
    query["ServiceIpList"] = request.serviceIpList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateHoneypotProbe"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateHoneypotProbeResponse>();
}

/**
 * @summary Modifies the attributes of a specified probe.
 *
 * @param request UpdateHoneypotProbeRequest
 * @return UpdateHoneypotProbeResponse
 */
UpdateHoneypotProbeResponse Client::updateHoneypotProbe(const UpdateHoneypotProbeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateHoneypotProbeWithOptions(request, runtime);
}

/**
 * @summary Modifies a probe service.
 *
 * @param request UpdateHoneypotProbeBindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHoneypotProbeBindResponse
 */
UpdateHoneypotProbeBindResponse Client::updateHoneypotProbeBindWithOptions(const UpdateHoneypotProbeBindRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBindId()) {
    query["BindId"] = request.bindId();
  }

  if (!!request.hasBindPortList()) {
    query["BindPortList"] = request.bindPortList();
  }

  if (!!request.hasBindType()) {
    query["BindType"] = request.bindType();
  }

  if (!!request.hasCurrentPage()) {
    query["CurrentPage"] = request.currentPage();
  }

  if (!!request.hasHoneypotId()) {
    query["HoneypotId"] = request.honeypotId();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasPageSize()) {
    query["PageSize"] = request.pageSize();
  }

  if (!!request.hasPorts()) {
    query["Ports"] = request.ports();
  }

  if (!!request.hasProbeId()) {
    query["ProbeId"] = request.probeId();
  }

  if (!!request.hasServiceIpList()) {
    query["ServiceIpList"] = request.serviceIpList();
  }

  if (!!request.hasSetStatus()) {
    query["SetStatus"] = request.setStatus();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateHoneypotProbeBind"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateHoneypotProbeBindResponse>();
}

/**
 * @summary Modifies a probe service.
 *
 * @param request UpdateHoneypotProbeBindRequest
 * @return UpdateHoneypotProbeBindResponse
 */
UpdateHoneypotProbeBindResponse Client::updateHoneypotProbeBind(const UpdateHoneypotProbeBindRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateHoneypotProbeBindWithOptions(request, runtime);
}

/**
 * @summary Updates the Security Center agent that is installed on a proxy server in a hybrid cloud.
 *
 * @param request UpdateHybridProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHybridProxyResponse
 */
UpdateHybridProxyResponse Client::updateHybridProxyWithOptions(const UpdateHybridProxyRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasProxyUuid()) {
    query["ProxyUuid"] = request.proxyUuid();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateHybridProxy"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateHybridProxyResponse>();
}

/**
 * @summary Updates the Security Center agent that is installed on a proxy server in a hybrid cloud.
 *
 * @param request UpdateHybridProxyRequest
 * @return UpdateHybridProxyResponse
 */
UpdateHybridProxyResponse Client::updateHybridProxy(const UpdateHybridProxyRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateHybridProxyWithOptions(request, runtime);
}

/**
 * @summary Updates an alert handling rule.
 *
 * @param request UpdateImageEventOperationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateImageEventOperationResponse
 */
UpdateImageEventOperationResponse Client::updateImageEventOperationWithOptions(const UpdateImageEventOperationRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConditions()) {
    query["Conditions"] = request.conditions();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasNote()) {
    query["Note"] = request.note();
  }

  if (!!request.hasScenarios()) {
    query["Scenarios"] = request.scenarios();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateImageEventOperation"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateImageEventOperationResponse>();
}

/**
 * @summary Updates an alert handling rule.
 *
 * @param request UpdateImageEventOperationRequest
 * @return UpdateImageEventOperationResponse
 */
UpdateImageEventOperationResponse Client::updateImageEventOperation(const UpdateImageEventOperationRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateImageEventOperationWithOptions(request, runtime);
}

/**
 * @summary Updates the vulnerability whitelist of an image.
 *
 * @param request UpdateImageVulWhitelistTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateImageVulWhitelistTargetResponse
 */
UpdateImageVulWhitelistTargetResponse Client::updateImageVulWhitelistTargetWithOptions(const UpdateImageVulWhitelistTargetRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasReason()) {
    query["Reason"] = request.reason();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasTarget()) {
    query["Target"] = request.target();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateImageVulWhitelistTarget"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateImageVulWhitelistTargetResponse>();
}

/**
 * @summary Updates the vulnerability whitelist of an image.
 *
 * @param request UpdateImageVulWhitelistTargetRequest
 * @return UpdateImageVulWhitelistTargetResponse
 */
UpdateImageVulWhitelistTargetResponse Client::updateImageVulWhitelistTarget(const UpdateImageVulWhitelistTargetRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateImageVulWhitelistTargetWithOptions(request, runtime);
}

/**
 * @summary Modifies the name of a Jenkins image repository.
 *
 * @param request UpdateJenkinsImageRegistryNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateJenkinsImageRegistryNameResponse
 */
UpdateJenkinsImageRegistryNameResponse Client::updateJenkinsImageRegistryNameWithOptions(const UpdateJenkinsImageRegistryNameRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  json body = {};
  if (!!request.hasRegistryId()) {
    body["RegistryId"] = request.registryId();
  }

  if (!!request.hasRegistryName()) {
    body["RegistryName"] = request.registryName();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "UpdateJenkinsImageRegistryName"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateJenkinsImageRegistryNameResponse>();
}

/**
 * @summary Modifies the name of a Jenkins image repository.
 *
 * @param request UpdateJenkinsImageRegistryNameRequest
 * @return UpdateJenkinsImageRegistryNameResponse
 */
UpdateJenkinsImageRegistryNameResponse Client::updateJenkinsImageRegistryName(const UpdateJenkinsImageRegistryNameRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateJenkinsImageRegistryNameWithOptions(request, runtime);
}

/**
 * @summary Modifies the retention period of images that are stored in a Jenkins image repository.
 *
 * @param request UpdateJenkinsImageRegistryPersistenceDayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateJenkinsImageRegistryPersistenceDayResponse
 */
UpdateJenkinsImageRegistryPersistenceDayResponse Client::updateJenkinsImageRegistryPersistenceDayWithOptions(const UpdateJenkinsImageRegistryPersistenceDayRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  json body = {};
  if (!!request.hasPersistenceDay()) {
    body["PersistenceDay"] = request.persistenceDay();
  }

  if (!!request.hasRegistryId()) {
    body["RegistryId"] = request.registryId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)},
    {"body" , Utils::Utils::parseToMap(body)}
  }));
  Params params = Params(json({
    {"action" , "UpdateJenkinsImageRegistryPersistenceDay"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateJenkinsImageRegistryPersistenceDayResponse>();
}

/**
 * @summary Modifies the retention period of images that are stored in a Jenkins image repository.
 *
 * @param request UpdateJenkinsImageRegistryPersistenceDayRequest
 * @return UpdateJenkinsImageRegistryPersistenceDayResponse
 */
UpdateJenkinsImageRegistryPersistenceDayResponse Client::updateJenkinsImageRegistryPersistenceDay(const UpdateJenkinsImageRegistryPersistenceDayRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateJenkinsImageRegistryPersistenceDayWithOptions(request, runtime);
}

/**
 * @summary Modifies an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request UpdateMaliciousFileWhitelistConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMaliciousFileWhitelistConfigResponse
 */
UpdateMaliciousFileWhitelistConfigResponse Client::updateMaliciousFileWhitelistConfigWithOptions(const UpdateMaliciousFileWhitelistConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasConfigId()) {
    query["ConfigId"] = request.configId();
  }

  if (!!request.hasEventName()) {
    query["EventName"] = request.eventName();
  }

  if (!!request.hasField()) {
    query["Field"] = request.field();
  }

  if (!!request.hasFieldValue()) {
    query["FieldValue"] = request.fieldValue();
  }

  if (!!request.hasOperator()) {
    query["Operator"] = request._operator();
  }

  if (!!request.hasSource()) {
    query["Source"] = request.source();
  }

  if (!!request.hasTargetType()) {
    query["TargetType"] = request.targetType();
  }

  if (!!request.hasTargetValue()) {
    query["TargetValue"] = request.targetValue();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateMaliciousFileWhitelistConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateMaliciousFileWhitelistConfigResponse>();
}

/**
 * @summary Modifies an alert whitelist rule of sensitive files that are detected by using the agentless detection feature.
 *
 * @param request UpdateMaliciousFileWhitelistConfigRequest
 * @return UpdateMaliciousFileWhitelistConfigResponse
 */
UpdateMaliciousFileWhitelistConfigResponse Client::updateMaliciousFileWhitelistConfig(const UpdateMaliciousFileWhitelistConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateMaliciousFileWhitelistConfigWithOptions(request, runtime);
}

/**
 * @summary Updates the blocking rule for at-risk images.
 *
 * @param tmpReq UpdateOpaStrategyNewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOpaStrategyNewResponse
 */
UpdateOpaStrategyNewResponse Client::updateOpaStrategyNewWithOptions(const UpdateOpaStrategyNewRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  UpdateOpaStrategyNewShrinkRequest request = UpdateOpaStrategyNewShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasAlarmDetail()) {
    request.setAlarmDetailShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.alarmDetail(), "AlarmDetail", "json"));
  }

  json query = {};
  if (!!request.hasAlarmDetailShrink()) {
    query["AlarmDetail"] = request.alarmDetailShrink();
  }

  if (!!request.hasClusterId()) {
    query["ClusterId"] = request.clusterId();
  }

  if (!!request.hasClusterName()) {
    query["ClusterName"] = request.clusterName();
  }

  if (!!request.hasDescription()) {
    query["Description"] = request.description();
  }

  if (!!request.hasImageName()) {
    query["ImageName"] = request.imageName();
  }

  if (!!request.hasLabel()) {
    query["Label"] = request.label();
  }

  if (!!request.hasMaliciousImage()) {
    query["MaliciousImage"] = request.maliciousImage();
  }

  if (!!request.hasRuleAction()) {
    query["RuleAction"] = request.ruleAction();
  }

  if (!!request.hasScopes()) {
    query["Scopes"] = request.scopes();
  }

  if (!!request.hasStrategyId()) {
    query["StrategyId"] = request.strategyId();
  }

  if (!!request.hasStrategyName()) {
    query["StrategyName"] = request.strategyName();
  }

  if (!!request.hasStrategyTemplateId()) {
    query["StrategyTemplateId"] = request.strategyTemplateId();
  }

  if (!!request.hasUnScanedImage()) {
    query["UnScanedImage"] = request.unScanedImage();
  }

  if (!!request.hasWhiteList()) {
    query["WhiteList"] = request.whiteList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateOpaStrategyNew"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateOpaStrategyNewResponse>();
}

/**
 * @summary Updates the blocking rule for at-risk images.
 *
 * @param request UpdateOpaStrategyNewRequest
 * @return UpdateOpaStrategyNewResponse
 */
UpdateOpaStrategyNewResponse Client::updateOpaStrategyNew(const UpdateOpaStrategyNewRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateOpaStrategyNewWithOptions(request, runtime);
}

/**
 * @summary Modifies a policy of detecting Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
 *
 * @param request UpdateOssScanConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOssScanConfigResponse
 */
UpdateOssScanConfigResponse Client::updateOssScanConfigWithOptions(const UpdateOssScanConfigRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllKeyPrefix()) {
    query["AllKeyPrefix"] = request.allKeyPrefix();
  }

  if (!!request.hasBucketNameList()) {
    query["BucketNameList"] = request.bucketNameList();
  }

  if (!!request.hasDecompressMaxFileCount()) {
    query["DecompressMaxFileCount"] = request.decompressMaxFileCount();
  }

  if (!!request.hasDecompressMaxLayer()) {
    query["DecompressMaxLayer"] = request.decompressMaxLayer();
  }

  if (!!request.hasDecryptionList()) {
    query["DecryptionList"] = request.decryptionList();
  }

  if (!!request.hasEnable()) {
    query["Enable"] = request.enable();
  }

  if (!!request.hasEndTime()) {
    query["EndTime"] = request.endTime();
  }

  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  if (!!request.hasKeyPrefixList()) {
    query["KeyPrefixList"] = request.keyPrefixList();
  }

  if (!!request.hasKeySuffixList()) {
    query["KeySuffixList"] = request.keySuffixList();
  }

  if (!!request.hasLastModifiedStartTime()) {
    query["LastModifiedStartTime"] = request.lastModifiedStartTime();
  }

  if (!!request.hasName()) {
    query["Name"] = request.name();
  }

  if (!!request.hasRealTimeIncr()) {
    query["RealTimeIncr"] = request.realTimeIncr();
  }

  if (!!request.hasScanDayList()) {
    query["ScanDayList"] = request.scanDayList();
  }

  if (!!request.hasStartTime()) {
    query["StartTime"] = request.startTime();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateOssScanConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateOssScanConfigResponse>();
}

/**
 * @summary Modifies a policy of detecting Object Storage Service (OSS) objects by using the SDK for malicious file detection feature.
 *
 * @param request UpdateOssScanConfigRequest
 * @return UpdateOssScanConfigResponse
 */
UpdateOssScanConfigResponse Client::updateOssScanConfig(const UpdateOssScanConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateOssScanConfigWithOptions(request, runtime);
}

/**
 * @summary Change Postpaid Asset Authorization Version
 *
 * @param request UpdatePostPaidBindRelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePostPaidBindRelResponse
 */
UpdatePostPaidBindRelResponse Client::updatePostPaidBindRelWithOptions(const UpdatePostPaidBindRelRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoBind()) {
    query["AutoBind"] = request.autoBind();
  }

  if (!!request.hasAutoBindVersion()) {
    query["AutoBindVersion"] = request.autoBindVersion();
  }

  if (!!request.hasBindAction()) {
    query["BindAction"] = request.bindAction();
  }

  if (!!request.hasUpdateIfNecessary()) {
    query["UpdateIfNecessary"] = request.updateIfNecessary();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdatePostPaidBindRel"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdatePostPaidBindRelResponse>();
}

/**
 * @summary Change Postpaid Asset Authorization Version
 *
 * @param request UpdatePostPaidBindRelRequest
 * @return UpdatePostPaidBindRelResponse
 */
UpdatePostPaidBindRelResponse Client::updatePostPaidBindRel(const UpdatePostPaidBindRelRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updatePostPaidBindRelWithOptions(request, runtime);
}

/**
 * @summary Enables or disables automatic upgrade.
 *
 * @param request UpdatePublishAutoUpgradeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublishAutoUpgradeResponse
 */
UpdatePublishAutoUpgradeResponse Client::updatePublishAutoUpgradeWithOptions(const UpdatePublishAutoUpgradeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAutoUpgrade()) {
    query["AutoUpgrade"] = request.autoUpgrade();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdatePublishAutoUpgrade"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdatePublishAutoUpgradeResponse>();
}

/**
 * @summary Enables or disables automatic upgrade.
 *
 * @param request UpdatePublishAutoUpgradeRequest
 * @return UpdatePublishAutoUpgradeResponse
 */
UpdatePublishAutoUpgradeResponse Client::updatePublishAutoUpgrade(const UpdatePublishAutoUpgradeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updatePublishAutoUpgradeWithOptions(request, runtime);
}

/**
 * @summary Updates a release batch.
 *
 * @param request UpdatePublishBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublishBatchResponse
 */
UpdatePublishBatchResponse Client::updatePublishBatchWithOptions(const UpdatePublishBatchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBatchId()) {
    query["BatchId"] = request.batchId();
  }

  if (!!request.hasBatchName()) {
    query["BatchName"] = request.batchName();
  }

  if (!!request.hasInterval()) {
    query["Interval"] = request.interval();
  }

  if (!!request.hasOperationBase()) {
    query["OperationBase"] = request.operationBase();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdatePublishBatch"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdatePublishBatchResponse>();
}

/**
 * @summary Updates a release batch.
 *
 * @param request UpdatePublishBatchRequest
 * @return UpdatePublishBatchResponse
 */
UpdatePublishBatchResponse Client::updatePublishBatch(const UpdatePublishBatchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updatePublishBatchWithOptions(request, runtime);
}

/**
 * @summary Modifies the configuration of the client upgrade time. If you want to call this operation, contact technical support.
 *
 * @param request UpdatePublishCronRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublishCronResponse
 */
UpdatePublishCronResponse Client::updatePublishCronWithOptions(const UpdatePublishCronRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCron()) {
    query["Cron"] = request.cron();
  }

  if (!!request.hasCronDay()) {
    query["CronDay"] = request.cronDay();
  }

  if (!!request.hasCronTime()) {
    query["CronTime"] = request.cronTime();
  }

  if (!!request.hasCronType()) {
    query["CronType"] = request.cronType();
  }

  if (!!request.hasDuration()) {
    query["Duration"] = request.duration();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdatePublishCron"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdatePublishCronResponse>();
}

/**
 * @summary Modifies the configuration of the client upgrade time. If you want to call this operation, contact technical support.
 *
 * @param request UpdatePublishCronRequest
 * @return UpdatePublishCronResponse
 */
UpdatePublishCronResponse Client::updatePublishCron(const UpdatePublishCronRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updatePublishCronWithOptions(request, runtime);
}

/**
 * @summary Modifies the settings of the canary release feature for agent upgrade. If you want to use the feature, contact technical support.
 *
 * @param request UpdatePublishGraySwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublishGraySwitchResponse
 */
UpdatePublishGraySwitchResponse Client::updatePublishGraySwitchWithOptions(const UpdatePublishGraySwitchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasGraySwitchStatus()) {
    query["GraySwitchStatus"] = request.graySwitchStatus();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdatePublishGraySwitch"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdatePublishGraySwitchResponse>();
}

/**
 * @summary Modifies the settings of the canary release feature for agent upgrade. If you want to use the feature, contact technical support.
 *
 * @param request UpdatePublishGraySwitchRequest
 * @return UpdatePublishGraySwitchResponse
 */
UpdatePublishGraySwitchResponse Client::updatePublishGraySwitch(const UpdatePublishGraySwitchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updatePublishGraySwitchWithOptions(request, runtime);
}

/**
 * @summary Updates the unique identifier of an asset selection.
 *
 * @param request UpdateSelectionKeyByTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSelectionKeyByTypeResponse
 */
UpdateSelectionKeyByTypeResponse Client::updateSelectionKeyByTypeWithOptions(const UpdateSelectionKeyByTypeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBusinessType()) {
    query["BusinessType"] = request.businessType();
  }

  if (!!request.hasSelectionKey()) {
    query["SelectionKey"] = request.selectionKey();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateSelectionKeyByType"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateSelectionKeyByTypeResponse>();
}

/**
 * @summary Updates the unique identifier of an asset selection.
 *
 * @param request UpdateSelectionKeyByTypeRequest
 * @return UpdateSelectionKeyByTypeResponse
 */
UpdateSelectionKeyByTypeResponse Client::updateSelectionKeyByType(const UpdateSelectionKeyByTypeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateSelectionKeyByTypeWithOptions(request, runtime);
}

/**
 * @summary Update the selected strict events in strict mode
 *
 * @param request UpdateStrictEventNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateStrictEventNameResponse
 */
UpdateStrictEventNameResponse Client::updateStrictEventNameWithOptions(const UpdateStrictEventNameRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasEventNameList()) {
    query["EventNameList"] = request.eventNameList();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasOperator()) {
    query["Operator"] = request._operator();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateStrictEventName"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateStrictEventNameResponse>();
}

/**
 * @summary Update the selected strict events in strict mode
 *
 * @param request UpdateStrictEventNameRequest
 * @return UpdateStrictEventNameResponse
 */
UpdateStrictEventNameResponse Client::updateStrictEventName(const UpdateStrictEventNameRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateStrictEventNameWithOptions(request, runtime);
}

/**
 * @summary Updates machines in a release batch.
 *
 * @param request UpdateTargetListByBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTargetListByBatchResponse
 */
UpdateTargetListByBatchResponse Client::updateTargetListByBatchWithOptions(const UpdateTargetListByBatchRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasBatchId()) {
    query["BatchId"] = request.batchId();
  }

  if (!!request.hasOperationList()) {
    query["OperationList"] = request.operationList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateTargetListByBatch"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateTargetListByBatchResponse>();
}

/**
 * @summary Updates machines in a release batch.
 *
 * @param request UpdateTargetListByBatchRequest
 * @return UpdateTargetListByBatchResponse
 */
UpdateTargetListByBatchResponse Client::updateTargetListByBatch(const UpdateTargetListByBatchRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateTargetListByBatchWithOptions(request, runtime);
}

/**
 * @summary Modify Image Service Whitelist.
 *
 * @param request UpdateWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWhiteListResponse
 */
UpdateWhiteListResponse Client::updateWhiteListWithOptions(const UpdateWhiteListRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasRegistryId()) {
    query["RegistryId"] = request.registryId();
  }

  if (!!request.hasWhiteList()) {
    query["WhiteList"] = request.whiteList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateWhiteList"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateWhiteListResponse>();
}

/**
 * @summary Modify Image Service Whitelist.
 *
 * @param request UpdateWhiteListRequest
 * @return UpdateWhiteListResponse
 */
UpdateWhiteListResponse Client::updateWhiteList(const UpdateWhiteListRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateWhiteListWithOptions(request, runtime);
}

/**
 * @summary Updates the status of an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request UpdateWhiteListStrategyStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWhiteListStrategyStatusResponse
 */
UpdateWhiteListStrategyStatusResponse Client::updateWhiteListStrategyStatusWithOptions(const UpdateWhiteListStrategyStatusRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasSourceIp()) {
    query["SourceIp"] = request.sourceIp();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasStrategyIds()) {
    query["StrategyIds"] = request.strategyIds();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpdateWhiteListStrategyStatus"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpdateWhiteListStrategyStatusResponse>();
}

/**
 * @summary Updates the status of an application whitelist policy.
 *
 * @description The application whitelist feature is in public preview. You cannot apply for a trial of the feature. If you applied for a trial of the feature or the feature is in use, you can call this operation.
 *
 * @param request UpdateWhiteListStrategyStatusRequest
 * @return UpdateWhiteListStrategyStatusResponse
 */
UpdateWhiteListStrategyStatusResponse Client::updateWhiteListStrategyStatus(const UpdateWhiteListStrategyStatusRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return updateWhiteListStrategyStatusWithOptions(request, runtime);
}

/**
 * @summary Upgrades the version of an anti-ransomware policy.
 *
 * @param request UpgradeBackupPolicyVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeBackupPolicyVersionResponse
 */
UpgradeBackupPolicyVersionResponse Client::upgradeBackupPolicyVersionWithOptions(const UpgradeBackupPolicyVersionRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasId()) {
    query["Id"] = request.id();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpgradeBackupPolicyVersion"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpgradeBackupPolicyVersionResponse>();
}

/**
 * @summary Upgrades the version of an anti-ransomware policy.
 *
 * @param request UpgradeBackupPolicyVersionRequest
 * @return UpgradeBackupPolicyVersionResponse
 */
UpgradeBackupPolicyVersionResponse Client::upgradeBackupPolicyVersion(const UpgradeBackupPolicyVersionRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return upgradeBackupPolicyVersionWithOptions(request, runtime);
}

/**
 * @summary Upgrades the version of the management node to which a honeypot belongs.
 *
 * @param request UpgradeHoneypotNodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeHoneypotNodeResponse
 */
UpgradeHoneypotNodeResponse Client::upgradeHoneypotNodeWithOptions(const UpgradeHoneypotNodeRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasAllowHoneypotAccessInternet()) {
    query["AllowHoneypotAccessInternet"] = request.allowHoneypotAccessInternet();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpgradeHoneypotNode"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpgradeHoneypotNodeResponse>();
}

/**
 * @summary Upgrades the version of the management node to which a honeypot belongs.
 *
 * @param request UpgradeHoneypotNodeRequest
 * @return UpgradeHoneypotNodeResponse
 */
UpgradeHoneypotNodeResponse Client::upgradeHoneypotNode(const UpgradeHoneypotNodeRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return upgradeHoneypotNodeWithOptions(request, runtime);
}

/**
 * @summary Manually upgrades the client version on assets.
 *
 * @param request UpgradeVersionByUuidsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeVersionByUuidsResponse
 */
UpgradeVersionByUuidsResponse Client::upgradeVersionByUuidsWithOptions(const UpgradeVersionByUuidsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasUpgradeVersion()) {
    query["UpgradeVersion"] = request.upgradeVersion();
  }

  if (!!request.hasUuidList()) {
    query["UuidList"] = request.uuidList();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UpgradeVersionByUuids"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UpgradeVersionByUuidsResponse>();
}

/**
 * @summary Manually upgrades the client version on assets.
 *
 * @param request UpgradeVersionByUuidsRequest
 * @return UpgradeVersionByUuidsResponse
 */
UpgradeVersionByUuidsResponse Client::upgradeVersionByUuids(const UpgradeVersionByUuidsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return upgradeVersionByUuidsWithOptions(request, runtime);
}

/**
 * @summary Uploads a honeypot file.
 *
 * @param request UploadedHoneyPotFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadedHoneyPotFileResponse
 */
UploadedHoneyPotFileResponse Client::uploadedHoneyPotFileWithOptions(const UploadedHoneyPotFileRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasFileKey()) {
    query["FileKey"] = request.fileKey();
  }

  if (!!request.hasFileName()) {
    query["FileName"] = request.fileName();
  }

  if (!!request.hasFileType()) {
    query["FileType"] = request.fileType();
  }

  if (!!request.hasHoneypotImageName()) {
    query["HoneypotImageName"] = request.honeypotImageName();
  }

  if (!!request.hasLang()) {
    query["Lang"] = request.lang();
  }

  if (!!request.hasNodeId()) {
    query["NodeId"] = request.nodeId();
  }

  if (!!request.hasTemplateExtra()) {
    query["TemplateExtra"] = request.templateExtra();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "UploadedHoneyPotFile"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<UploadedHoneyPotFileResponse>();
}

/**
 * @summary Uploads a honeypot file.
 *
 * @param request UploadedHoneyPotFileRequest
 * @return UploadedHoneyPotFileResponse
 */
UploadedHoneyPotFileResponse Client::uploadedHoneyPotFile(const UploadedHoneyPotFileRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return uploadedHoneyPotFileWithOptions(request, runtime);
}

/**
 * @summary Verifies whether risk items are fixed. If a risk item is fixed, the status of the related check item is updated to Passed.
 *
 * @param request ValidateHcWarningsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ValidateHcWarningsResponse
 */
ValidateHcWarningsResponse Client::validateHcWarningsWithOptions(const ValidateHcWarningsRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckIds()) {
    query["CheckIds"] = request.checkIds();
  }

  if (!!request.hasRiskIds()) {
    query["RiskIds"] = request.riskIds();
  }

  if (!!request.hasStatus()) {
    query["Status"] = request.status();
  }

  if (!!request.hasUuids()) {
    query["Uuids"] = request.uuids();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "ValidateHcWarnings"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<ValidateHcWarningsResponse>();
}

/**
 * @summary Verifies whether risk items are fixed. If a risk item is fixed, the status of the related check item is updated to Passed.
 *
 * @param request ValidateHcWarningsRequest
 * @return ValidateHcWarningsResponse
 */
ValidateHcWarningsResponse Client::validateHcWarnings(const ValidateHcWarningsRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return validateHcWarningsWithOptions(request, runtime);
}

/**
 * @summary Customization and validation of check items and repair parameters
 *
 * @param tmpReq VerifyCheckCustomConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return VerifyCheckCustomConfigResponse
 */
VerifyCheckCustomConfigResponse Client::verifyCheckCustomConfigWithOptions(const VerifyCheckCustomConfigRequest &tmpReq, const Darabonba::RuntimeOptions &runtime) {
  tmpReq.validate();
  VerifyCheckCustomConfigShrinkRequest request = VerifyCheckCustomConfigShrinkRequest();
  Utils::Utils::convert(tmpReq, request);
  if (!!tmpReq.hasCustomCheckConfig()) {
    request.setCustomCheckConfigShrink(Utils::Utils::arrayToStringWithSpecifiedStyle(tmpReq.customCheckConfig(), "CustomCheckConfig", "json"));
  }

  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasCustomCheckConfigShrink()) {
    query["CustomCheckConfig"] = request.customCheckConfigShrink();
  }

  if (!!request.hasCustomConfigs()) {
    query["CustomConfigs"] = request.customConfigs();
  }

  if (!!request.hasRepairConfigs()) {
    query["RepairConfigs"] = request.repairConfigs();
  }

  if (!!request.hasType()) {
    query["Type"] = request.type();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "VerifyCheckCustomConfig"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<VerifyCheckCustomConfigResponse>();
}

/**
 * @summary Customization and validation of check items and repair parameters
 *
 * @param request VerifyCheckCustomConfigRequest
 * @return VerifyCheckCustomConfigResponse
 */
VerifyCheckCustomConfigResponse Client::verifyCheckCustomConfig(const VerifyCheckCustomConfigRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return verifyCheckCustomConfigWithOptions(request, runtime);
}

/**
 * @summary Verifies the instances on which risks are detected based on a check item.
 *
 * @param request VerifyCheckInstanceResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return VerifyCheckInstanceResultResponse
 */
VerifyCheckInstanceResultResponse Client::verifyCheckInstanceResultWithOptions(const VerifyCheckInstanceResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckId()) {
    query["CheckId"] = request.checkId();
  }

  if (!!request.hasInstanceIds()) {
    query["InstanceIds"] = request.instanceIds();
  }

  if (!!request.hasTaskSource()) {
    query["TaskSource"] = request.taskSource();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "VerifyCheckInstanceResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<VerifyCheckInstanceResultResponse>();
}

/**
 * @summary Verifies the instances on which risks are detected based on a check item.
 *
 * @param request VerifyCheckInstanceResultRequest
 * @return VerifyCheckInstanceResultResponse
 */
VerifyCheckInstanceResultResponse Client::verifyCheckInstanceResult(const VerifyCheckInstanceResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return verifyCheckInstanceResultWithOptions(request, runtime);
}

/**
 * @summary Verifies risk items that are detected based on check items.
 *
 * @param request VerifyCheckResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return VerifyCheckResultResponse
 */
VerifyCheckResultResponse Client::verifyCheckResultWithOptions(const VerifyCheckResultRequest &request, const Darabonba::RuntimeOptions &runtime) {
  request.validate();
  json query = {};
  if (!!request.hasCheckIds()) {
    query["CheckIds"] = request.checkIds();
  }

  if (!!request.hasTaskSource()) {
    query["TaskSource"] = request.taskSource();
  }

  OpenApiRequest req = OpenApiRequest(json({
    {"query" , Utils::Utils::query(query)}
  }).get<map<string, map<string, string>>>());
  Params params = Params(json({
    {"action" , "VerifyCheckResult"},
    {"version" , "2018-12-03"},
    {"protocol" , "HTTPS"},
    {"pathname" , "/"},
    {"method" , "POST"},
    {"authType" , "AK"},
    {"style" , "RPC"},
    {"reqBodyType" , "formData"},
    {"bodyType" , "json"}
  }).get<map<string, string>>());
  return json(callApi(params, req, runtime)).get<VerifyCheckResultResponse>();
}

/**
 * @summary Verifies risk items that are detected based on check items.
 *
 * @param request VerifyCheckResultRequest
 * @return VerifyCheckResultResponse
 */
VerifyCheckResultResponse Client::verifyCheckResult(const VerifyCheckResultRequest &request) {
  Darabonba::RuntimeOptions runtime = RuntimeOptions();
  return verifyCheckResultWithOptions(request, runtime);
}
} // namespace AlibabaCloud
} // namespace Sas20181203