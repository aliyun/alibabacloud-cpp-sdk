// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_VOD20170321_H_
#define ALIBABACLOUD_VOD20170321_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Vod20170321 {
class AddAITemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  AddAITemplateRequest() {}

  explicit AddAITemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~AddAITemplateRequest() = default;
};
class AddAITemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  AddAITemplateResponseBody() {}

  explicit AddAITemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~AddAITemplateResponseBody() = default;
};
class AddAITemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAITemplateResponseBody> body{};

  AddAITemplateResponse() {}

  explicit AddAITemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAITemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAITemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddAITemplateResponse() = default;
};
class AddCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> cateName{};
  shared_ptr<long> parentId{};
  shared_ptr<string> type{};

  AddCategoryRequest() {}

  explicit AddCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddCategoryRequest() = default;
};
class AddCategoryResponseBodyCategory : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};
  shared_ptr<string> type{};

  AddCategoryResponseBodyCategory() {}

  explicit AddCategoryResponseBodyCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddCategoryResponseBodyCategory() = default;
};
class AddCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCategoryResponseBodyCategory> category{};
  shared_ptr<string> requestId{};

  AddCategoryResponseBody() {}

  explicit AddCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = category ? boost::any(category->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(map<string, boost::any>) == m["Category"].type()) {
        AddCategoryResponseBodyCategory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Category"]));
        category = make_shared<AddCategoryResponseBodyCategory>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCategoryResponseBody() = default;
};
class AddCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCategoryResponseBody> body{};

  AddCategoryResponse() {}

  explicit AddCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~AddCategoryResponse() = default;
};
class AddEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> division{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  AddEditingProjectRequest() {}

  explicit AddEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (division) {
      res["Division"] = boost::any(*division);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Division") != m.end() && !m["Division"].empty()) {
      division = make_shared<string>(boost::any_cast<string>(m["Division"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~AddEditingProjectRequest() = default;
};
class AddEditingProjectResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};

  AddEditingProjectResponseBodyProject() {}

  explicit AddEditingProjectResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~AddEditingProjectResponseBodyProject() = default;
};
class AddEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddEditingProjectResponseBodyProject> project{};
  shared_ptr<string> requestId{};

  AddEditingProjectResponseBody() {}

  explicit AddEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        AddEditingProjectResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<AddEditingProjectResponseBodyProject>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddEditingProjectResponseBody() = default;
};
class AddEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddEditingProjectResponseBody> body{};

  AddEditingProjectResponse() {}

  explicit AddEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~AddEditingProjectResponse() = default;
};
class AddEditingProjectMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> materialIds{};
  shared_ptr<string> materialType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  AddEditingProjectMaterialsRequest() {}

  explicit AddEditingProjectMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialIds) {
      res["MaterialIds"] = boost::any(*materialIds);
    }
    if (materialType) {
      res["MaterialType"] = boost::any(*materialType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialIds") != m.end() && !m["MaterialIds"].empty()) {
      materialIds = make_shared<string>(boost::any_cast<string>(m["MaterialIds"]));
    }
    if (m.find("MaterialType") != m.end() && !m["MaterialType"].empty()) {
      materialType = make_shared<string>(boost::any_cast<string>(m["MaterialType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~AddEditingProjectMaterialsRequest() = default;
};
class AddEditingProjectMaterialsResponseBodyMaterialList : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<long> customerId{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> materialId{};
  shared_ptr<string> materialType{};
  shared_ptr<string> modifyTime{};
  shared_ptr<long> size{};
  shared_ptr<vector<string>> snapshots{};
  shared_ptr<string> spriteConfig{};
  shared_ptr<vector<string>> sprites{};
  shared_ptr<string> status{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};

  AddEditingProjectMaterialsResponseBodyMaterialList() {}

  explicit AddEditingProjectMaterialsResponseBodyMaterialList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customerId) {
      res["CustomerId"] = boost::any(*customerId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (materialType) {
      res["MaterialType"] = boost::any(*materialType);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (spriteConfig) {
      res["SpriteConfig"] = boost::any(*spriteConfig);
    }
    if (sprites) {
      res["Sprites"] = boost::any(*sprites);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CustomerId") != m.end() && !m["CustomerId"].empty()) {
      customerId = make_shared<long>(boost::any_cast<long>(m["CustomerId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("MaterialType") != m.end() && !m["MaterialType"].empty()) {
      materialType = make_shared<string>(boost::any_cast<string>(m["MaterialType"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Snapshots"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshots = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpriteConfig") != m.end() && !m["SpriteConfig"].empty()) {
      spriteConfig = make_shared<string>(boost::any_cast<string>(m["SpriteConfig"]));
    }
    if (m.find("Sprites") != m.end() && !m["Sprites"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Sprites"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Sprites"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sprites = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyMaterialList() = default;
};
class AddEditingProjectMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<AddEditingProjectMaterialsResponseBodyMaterialList>> materialList{};
  shared_ptr<string> requestId{};

  AddEditingProjectMaterialsResponseBody() {}

  explicit AddEditingProjectMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialList) {
      vector<boost::any> temp1;
      for(auto item1:*materialList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MaterialList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialList") != m.end() && !m["MaterialList"].empty()) {
      if (typeid(vector<boost::any>) == m["MaterialList"].type()) {
        vector<AddEditingProjectMaterialsResponseBodyMaterialList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MaterialList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddEditingProjectMaterialsResponseBodyMaterialList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        materialList = make_shared<vector<AddEditingProjectMaterialsResponseBodyMaterialList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBody() = default;
};
class AddEditingProjectMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddEditingProjectMaterialsResponseBody> body{};

  AddEditingProjectMaterialsResponse() {}

  explicit AddEditingProjectMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddEditingProjectMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddEditingProjectMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~AddEditingProjectMaterialsResponse() = default;
};
class AddTranscodeTemplateGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> name{};
  shared_ptr<string> transcodeTemplateGroupId{};
  shared_ptr<string> transcodeTemplateList{};

  AddTranscodeTemplateGroupRequest() {}

  explicit AddTranscodeTemplateGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    if (transcodeTemplateList) {
      res["TranscodeTemplateList"] = boost::any(*transcodeTemplateList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
    if (m.find("TranscodeTemplateList") != m.end() && !m["TranscodeTemplateList"].empty()) {
      transcodeTemplateList = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateList"]));
    }
  }


  virtual ~AddTranscodeTemplateGroupRequest() = default;
};
class AddTranscodeTemplateGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> transcodeTemplateGroupId{};

  AddTranscodeTemplateGroupResponseBody() {}

  explicit AddTranscodeTemplateGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
  }


  virtual ~AddTranscodeTemplateGroupResponseBody() = default;
};
class AddTranscodeTemplateGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTranscodeTemplateGroupResponseBody> body{};

  AddTranscodeTemplateGroupResponse() {}

  explicit AddTranscodeTemplateGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTranscodeTemplateGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTranscodeTemplateGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddTranscodeTemplateGroupResponse() = default;
};
class AddVodDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkUrl{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> scope{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<string> topLevelDomain{};

  AddVodDomainRequest() {}

  explicit AddVodDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~AddVodDomainRequest() = default;
};
class AddVodDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddVodDomainResponseBody() {}

  explicit AddVodDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddVodDomainResponseBody() = default;
};
class AddVodDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddVodDomainResponseBody> body{};

  AddVodDomainResponse() {}

  explicit AddVodDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddVodDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddVodDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddVodDomainResponse() = default;
};
class AddVodStorageForAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> storageType{};

  AddVodStorageForAppRequest() {}

  explicit AddVodStorageForAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~AddVodStorageForAppRequest() = default;
};
class AddVodStorageForAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> storageLocation{};

  AddVodStorageForAppResponseBody() {}

  explicit AddVodStorageForAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
  }


  virtual ~AddVodStorageForAppResponseBody() = default;
};
class AddVodStorageForAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddVodStorageForAppResponseBody> body{};

  AddVodStorageForAppResponse() {}

  explicit AddVodStorageForAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddVodStorageForAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddVodStorageForAppResponseBody>(model1);
      }
    }
  }


  virtual ~AddVodStorageForAppResponse() = default;
};
class AddVodTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> name{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateType{};

  AddVodTemplateRequest() {}

  explicit AddVodTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~AddVodTemplateRequest() = default;
};
class AddVodTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vodTemplateId{};

  AddVodTemplateResponseBody() {}

  explicit AddVodTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vodTemplateId) {
      res["VodTemplateId"] = boost::any(*vodTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VodTemplateId") != m.end() && !m["VodTemplateId"].empty()) {
      vodTemplateId = make_shared<string>(boost::any_cast<string>(m["VodTemplateId"]));
    }
  }


  virtual ~AddVodTemplateResponseBody() = default;
};
class AddVodTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddVodTemplateResponseBody> body{};

  AddVodTemplateResponse() {}

  explicit AddVodTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddVodTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddVodTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddVodTemplateResponse() = default;
};
class AddWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> watermarkConfig{};

  AddWatermarkRequest() {}

  explicit AddWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (watermarkConfig) {
      res["WatermarkConfig"] = boost::any(*watermarkConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WatermarkConfig") != m.end() && !m["WatermarkConfig"].empty()) {
      watermarkConfig = make_shared<string>(boost::any_cast<string>(m["WatermarkConfig"]));
    }
  }


  virtual ~AddWatermarkRequest() = default;
};
class AddWatermarkResponseBodyWatermarkInfo : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> watermarkConfig{};
  shared_ptr<string> watermarkId{};

  AddWatermarkResponseBodyWatermarkInfo() {}

  explicit AddWatermarkResponseBodyWatermarkInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (watermarkConfig) {
      res["WatermarkConfig"] = boost::any(*watermarkConfig);
    }
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WatermarkConfig") != m.end() && !m["WatermarkConfig"].empty()) {
      watermarkConfig = make_shared<string>(boost::any_cast<string>(m["WatermarkConfig"]));
    }
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
  }


  virtual ~AddWatermarkResponseBodyWatermarkInfo() = default;
};
class AddWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddWatermarkResponseBodyWatermarkInfo> watermarkInfo{};

  AddWatermarkResponseBody() {}

  explicit AddWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (watermarkInfo) {
      res["WatermarkInfo"] = watermarkInfo ? boost::any(watermarkInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WatermarkInfo") != m.end() && !m["WatermarkInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["WatermarkInfo"].type()) {
        AddWatermarkResponseBodyWatermarkInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WatermarkInfo"]));
        watermarkInfo = make_shared<AddWatermarkResponseBodyWatermarkInfo>(model1);
      }
    }
  }


  virtual ~AddWatermarkResponseBody() = default;
};
class AddWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddWatermarkResponseBody> body{};

  AddWatermarkResponse() {}

  explicit AddWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~AddWatermarkResponse() = default;
};
class AttachAppPolicyToIdentityRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> identityName{};
  shared_ptr<string> identityType{};
  shared_ptr<string> policyNames{};

  AttachAppPolicyToIdentityRequest() {}

  explicit AttachAppPolicyToIdentityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (identityName) {
      res["IdentityName"] = boost::any(*identityName);
    }
    if (identityType) {
      res["IdentityType"] = boost::any(*identityType);
    }
    if (policyNames) {
      res["PolicyNames"] = boost::any(*policyNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("IdentityName") != m.end() && !m["IdentityName"].empty()) {
      identityName = make_shared<string>(boost::any_cast<string>(m["IdentityName"]));
    }
    if (m.find("IdentityType") != m.end() && !m["IdentityType"].empty()) {
      identityType = make_shared<string>(boost::any_cast<string>(m["IdentityType"]));
    }
    if (m.find("PolicyNames") != m.end() && !m["PolicyNames"].empty()) {
      policyNames = make_shared<string>(boost::any_cast<string>(m["PolicyNames"]));
    }
  }


  virtual ~AttachAppPolicyToIdentityRequest() = default;
};
class AttachAppPolicyToIdentityResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failedPolicyNames{};
  shared_ptr<vector<string>> nonExistPolicyNames{};
  shared_ptr<string> requestId{};

  AttachAppPolicyToIdentityResponseBody() {}

  explicit AttachAppPolicyToIdentityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedPolicyNames) {
      res["FailedPolicyNames"] = boost::any(*failedPolicyNames);
    }
    if (nonExistPolicyNames) {
      res["NonExistPolicyNames"] = boost::any(*nonExistPolicyNames);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedPolicyNames") != m.end() && !m["FailedPolicyNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailedPolicyNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailedPolicyNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failedPolicyNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NonExistPolicyNames") != m.end() && !m["NonExistPolicyNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistPolicyNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistPolicyNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistPolicyNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachAppPolicyToIdentityResponseBody() = default;
};
class AttachAppPolicyToIdentityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachAppPolicyToIdentityResponseBody> body{};

  AttachAppPolicyToIdentityResponse() {}

  explicit AttachAppPolicyToIdentityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachAppPolicyToIdentityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachAppPolicyToIdentityResponseBody>(model1);
      }
    }
  }


  virtual ~AttachAppPolicyToIdentityResponse() = default;
};
class BatchSetVodDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functions{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchSetVodDomainConfigsRequest() {}

  explicit BatchSetVodDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchSetVodDomainConfigsRequest() = default;
};
class BatchSetVodDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetVodDomainConfigsResponseBody() {}

  explicit BatchSetVodDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetVodDomainConfigsResponseBody() = default;
};
class BatchSetVodDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetVodDomainConfigsResponseBody> body{};

  BatchSetVodDomainConfigsResponse() {}

  explicit BatchSetVodDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetVodDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetVodDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetVodDomainConfigsResponse() = default;
};
class BatchStartVodDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchStartVodDomainRequest() {}

  explicit BatchStartVodDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchStartVodDomainRequest() = default;
};
class BatchStartVodDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchStartVodDomainResponseBody() {}

  explicit BatchStartVodDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchStartVodDomainResponseBody() = default;
};
class BatchStartVodDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStartVodDomainResponseBody> body{};

  BatchStartVodDomainResponse() {}

  explicit BatchStartVodDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStartVodDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStartVodDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStartVodDomainResponse() = default;
};
class BatchStopVodDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchStopVodDomainRequest() {}

  explicit BatchStopVodDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchStopVodDomainRequest() = default;
};
class BatchStopVodDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchStopVodDomainResponseBody() {}

  explicit BatchStopVodDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchStopVodDomainResponseBody() = default;
};
class BatchStopVodDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStopVodDomainResponseBody> body{};

  BatchStopVodDomainResponse() {}

  explicit BatchStopVodDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStopVodDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStopVodDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStopVodDomainResponse() = default;
};
class CancelUrlUploadJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> uploadUrls{};

  CancelUrlUploadJobsRequest() {}

  explicit CancelUrlUploadJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (uploadUrls) {
      res["UploadUrls"] = boost::any(*uploadUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("UploadUrls") != m.end() && !m["UploadUrls"].empty()) {
      uploadUrls = make_shared<string>(boost::any_cast<string>(m["UploadUrls"]));
    }
  }


  virtual ~CancelUrlUploadJobsRequest() = default;
};
class CancelUrlUploadJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> canceledJobs{};
  shared_ptr<vector<string>> nonExists{};
  shared_ptr<string> requestId{};

  CancelUrlUploadJobsResponseBody() {}

  explicit CancelUrlUploadJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canceledJobs) {
      res["CanceledJobs"] = boost::any(*canceledJobs);
    }
    if (nonExists) {
      res["NonExists"] = boost::any(*nonExists);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanceledJobs") != m.end() && !m["CanceledJobs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CanceledJobs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CanceledJobs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      canceledJobs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NonExists") != m.end() && !m["NonExists"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExists"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExists"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExists = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelUrlUploadJobsResponseBody() = default;
};
class CancelUrlUploadJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelUrlUploadJobsResponseBody> body{};

  CancelUrlUploadJobsResponse() {}

  explicit CancelUrlUploadJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelUrlUploadJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelUrlUploadJobsResponseBody>(model1);
      }
    }
  }


  virtual ~CancelUrlUploadJobsResponse() = default;
};
class CreateAppInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> description{};

  CreateAppInfoRequest() {}

  explicit CreateAppInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateAppInfoRequest() = default;
};
class CreateAppInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> requestId{};

  CreateAppInfoResponseBody() {}

  explicit CreateAppInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAppInfoResponseBody() = default;
};
class CreateAppInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAppInfoResponseBody> body{};

  CreateAppInfoResponse() {}

  explicit CreateAppInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAppInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAppInfoResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAppInfoResponse() = default;
};
class CreateAuditRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditContent{};

  CreateAuditRequest() {}

  explicit CreateAuditRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditContent) {
      res["AuditContent"] = boost::any(*auditContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditContent") != m.end() && !m["AuditContent"].empty()) {
      auditContent = make_shared<string>(boost::any_cast<string>(m["AuditContent"]));
    }
  }


  virtual ~CreateAuditRequest() = default;
};
class CreateAuditResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateAuditResponseBody() {}

  explicit CreateAuditResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAuditResponseBody() = default;
};
class CreateAuditResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAuditResponseBody> body{};

  CreateAuditResponse() {}

  explicit CreateAuditResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAuditResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAuditResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAuditResponse() = default;
};
class CreateUploadAttachedMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> businessType{};
  shared_ptr<string> cateIds{};
  shared_ptr<string> description{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> mediaExt{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  CreateUploadAttachedMediaRequest() {}

  explicit CreateUploadAttachedMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateIds) {
      res["CateIds"] = boost::any(*cateIds);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (mediaExt) {
      res["MediaExt"] = boost::any(*mediaExt);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateIds") != m.end() && !m["CateIds"].empty()) {
      cateIds = make_shared<string>(boost::any_cast<string>(m["CateIds"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("MediaExt") != m.end() && !m["MediaExt"].empty()) {
      mediaExt = make_shared<string>(boost::any_cast<string>(m["MediaExt"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateUploadAttachedMediaRequest() = default;
};
class CreateUploadAttachedMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> requestId{};
  shared_ptr<string> uploadAddress{};
  shared_ptr<string> uploadAuth{};

  CreateUploadAttachedMediaResponseBody() {}

  explicit CreateUploadAttachedMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadAddress) {
      res["UploadAddress"] = boost::any(*uploadAddress);
    }
    if (uploadAuth) {
      res["UploadAuth"] = boost::any(*uploadAuth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadAddress") != m.end() && !m["UploadAddress"].empty()) {
      uploadAddress = make_shared<string>(boost::any_cast<string>(m["UploadAddress"]));
    }
    if (m.find("UploadAuth") != m.end() && !m["UploadAuth"].empty()) {
      uploadAuth = make_shared<string>(boost::any_cast<string>(m["UploadAuth"]));
    }
  }


  virtual ~CreateUploadAttachedMediaResponseBody() = default;
};
class CreateUploadAttachedMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUploadAttachedMediaResponseBody> body{};

  CreateUploadAttachedMediaResponse() {}

  explicit CreateUploadAttachedMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUploadAttachedMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUploadAttachedMediaResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUploadAttachedMediaResponse() = default;
};
class CreateUploadImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> description{};
  shared_ptr<string> imageExt{};
  shared_ptr<string> imageType{};
  shared_ptr<string> originalFileName{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  CreateUploadImageRequest() {}

  explicit CreateUploadImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (imageExt) {
      res["ImageExt"] = boost::any(*imageExt);
    }
    if (imageType) {
      res["ImageType"] = boost::any(*imageType);
    }
    if (originalFileName) {
      res["OriginalFileName"] = boost::any(*originalFileName);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ImageExt") != m.end() && !m["ImageExt"].empty()) {
      imageExt = make_shared<string>(boost::any_cast<string>(m["ImageExt"]));
    }
    if (m.find("ImageType") != m.end() && !m["ImageType"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["ImageType"]));
    }
    if (m.find("OriginalFileName") != m.end() && !m["OriginalFileName"].empty()) {
      originalFileName = make_shared<string>(boost::any_cast<string>(m["OriginalFileName"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateUploadImageRequest() = default;
};
class CreateUploadImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileURL{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageURL{};
  shared_ptr<string> requestId{};
  shared_ptr<string> uploadAddress{};
  shared_ptr<string> uploadAuth{};

  CreateUploadImageResponseBody() {}

  explicit CreateUploadImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageURL) {
      res["ImageURL"] = boost::any(*imageURL);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadAddress) {
      res["UploadAddress"] = boost::any(*uploadAddress);
    }
    if (uploadAuth) {
      res["UploadAuth"] = boost::any(*uploadAuth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageURL") != m.end() && !m["ImageURL"].empty()) {
      imageURL = make_shared<string>(boost::any_cast<string>(m["ImageURL"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadAddress") != m.end() && !m["UploadAddress"].empty()) {
      uploadAddress = make_shared<string>(boost::any_cast<string>(m["UploadAddress"]));
    }
    if (m.find("UploadAuth") != m.end() && !m["UploadAuth"].empty()) {
      uploadAuth = make_shared<string>(boost::any_cast<string>(m["UploadAuth"]));
    }
  }


  virtual ~CreateUploadImageResponseBody() = default;
};
class CreateUploadImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUploadImageResponseBody> body{};

  CreateUploadImageResponse() {}

  explicit CreateUploadImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUploadImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUploadImageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUploadImageResponse() = default;
};
class CreateUploadVideoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> templateGroupId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};
  shared_ptr<string> workflowId{};

  CreateUploadVideoRequest() {}

  explicit CreateUploadVideoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (templateGroupId) {
      res["TemplateGroupId"] = boost::any(*templateGroupId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TemplateGroupId") != m.end() && !m["TemplateGroupId"].empty()) {
      templateGroupId = make_shared<string>(boost::any_cast<string>(m["TemplateGroupId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
  }


  virtual ~CreateUploadVideoRequest() = default;
};
class CreateUploadVideoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> uploadAddress{};
  shared_ptr<string> uploadAuth{};
  shared_ptr<string> videoId{};

  CreateUploadVideoResponseBody() {}

  explicit CreateUploadVideoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadAddress) {
      res["UploadAddress"] = boost::any(*uploadAddress);
    }
    if (uploadAuth) {
      res["UploadAuth"] = boost::any(*uploadAuth);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadAddress") != m.end() && !m["UploadAddress"].empty()) {
      uploadAddress = make_shared<string>(boost::any_cast<string>(m["UploadAddress"]));
    }
    if (m.find("UploadAuth") != m.end() && !m["UploadAuth"].empty()) {
      uploadAuth = make_shared<string>(boost::any_cast<string>(m["UploadAuth"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~CreateUploadVideoResponseBody() = default;
};
class CreateUploadVideoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUploadVideoResponseBody> body{};

  CreateUploadVideoResponse() {}

  explicit CreateUploadVideoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUploadVideoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUploadVideoResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUploadVideoResponse() = default;
};
class DecryptKMSDataKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> cipherText{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  DecryptKMSDataKeyRequest() {}

  explicit DecryptKMSDataKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherText) {
      res["CipherText"] = boost::any(*cipherText);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherText") != m.end() && !m["CipherText"].empty()) {
      cipherText = make_shared<string>(boost::any_cast<string>(m["CipherText"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DecryptKMSDataKeyRequest() = default;
};
class DecryptKMSDataKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> keyId{};
  shared_ptr<string> plaintext{};
  shared_ptr<string> requestId{};

  DecryptKMSDataKeyResponseBody() {}

  explicit DecryptKMSDataKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyId) {
      res["KeyId"] = boost::any(*keyId);
    }
    if (plaintext) {
      res["Plaintext"] = boost::any(*plaintext);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyId") != m.end() && !m["KeyId"].empty()) {
      keyId = make_shared<string>(boost::any_cast<string>(m["KeyId"]));
    }
    if (m.find("Plaintext") != m.end() && !m["Plaintext"].empty()) {
      plaintext = make_shared<string>(boost::any_cast<string>(m["Plaintext"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DecryptKMSDataKeyResponseBody() = default;
};
class DecryptKMSDataKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DecryptKMSDataKeyResponseBody> body{};

  DecryptKMSDataKeyResponse() {}

  explicit DecryptKMSDataKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DecryptKMSDataKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DecryptKMSDataKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DecryptKMSDataKeyResponse() = default;
};
class DeleteAIImageInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIImageInfoIds{};

  DeleteAIImageInfosRequest() {}

  explicit DeleteAIImageInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIImageInfoIds) {
      res["AIImageInfoIds"] = boost::any(*AIImageInfoIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIImageInfoIds") != m.end() && !m["AIImageInfoIds"].empty()) {
      AIImageInfoIds = make_shared<string>(boost::any_cast<string>(m["AIImageInfoIds"]));
    }
  }


  virtual ~DeleteAIImageInfosRequest() = default;
};
class DeleteAIImageInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAIImageInfosResponseBody() {}

  explicit DeleteAIImageInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAIImageInfosResponseBody() = default;
};
class DeleteAIImageInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAIImageInfosResponseBody> body{};

  DeleteAIImageInfosResponse() {}

  explicit DeleteAIImageInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAIImageInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAIImageInfosResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAIImageInfosResponse() = default;
};
class DeleteAITemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  DeleteAITemplateRequest() {}

  explicit DeleteAITemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteAITemplateRequest() = default;
};
class DeleteAITemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  DeleteAITemplateResponseBody() {}

  explicit DeleteAITemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteAITemplateResponseBody() = default;
};
class DeleteAITemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAITemplateResponseBody> body{};

  DeleteAITemplateResponse() {}

  explicit DeleteAITemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAITemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAITemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAITemplateResponse() = default;
};
class DeleteAppInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  DeleteAppInfoRequest() {}

  explicit DeleteAppInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteAppInfoRequest() = default;
};
class DeleteAppInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAppInfoResponseBody() {}

  explicit DeleteAppInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAppInfoResponseBody() = default;
};
class DeleteAppInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAppInfoResponseBody> body{};

  DeleteAppInfoResponse() {}

  explicit DeleteAppInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAppInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAppInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAppInfoResponse() = default;
};
class DeleteAttachedMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaIds{};

  DeleteAttachedMediaRequest() {}

  explicit DeleteAttachedMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
  }


  virtual ~DeleteAttachedMediaRequest() = default;
};
class DeleteAttachedMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nonExistMediaIds{};
  shared_ptr<string> requestId{};

  DeleteAttachedMediaResponseBody() {}

  explicit DeleteAttachedMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistMediaIds) {
      res["NonExistMediaIds"] = boost::any(*nonExistMediaIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistMediaIds") != m.end() && !m["NonExistMediaIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistMediaIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistMediaIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistMediaIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAttachedMediaResponseBody() = default;
};
class DeleteAttachedMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAttachedMediaResponseBody> body{};

  DeleteAttachedMediaResponse() {}

  explicit DeleteAttachedMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAttachedMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAttachedMediaResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAttachedMediaResponse() = default;
};
class DeleteCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};

  DeleteCategoryRequest() {}

  explicit DeleteCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
  }


  virtual ~DeleteCategoryRequest() = default;
};
class DeleteCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCategoryResponseBody() {}

  explicit DeleteCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCategoryResponseBody() = default;
};
class DeleteCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCategoryResponseBody> body{};

  DeleteCategoryResponse() {}

  explicit DeleteCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCategoryResponse() = default;
};
class DeleteDynamicImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> dynamicImageIds{};
  shared_ptr<string> videoId{};

  DeleteDynamicImageRequest() {}

  explicit DeleteDynamicImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicImageIds) {
      res["DynamicImageIds"] = boost::any(*dynamicImageIds);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicImageIds") != m.end() && !m["DynamicImageIds"].empty()) {
      dynamicImageIds = make_shared<string>(boost::any_cast<string>(m["DynamicImageIds"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~DeleteDynamicImageRequest() = default;
};
class DeleteDynamicImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDynamicImageResponseBody() {}

  explicit DeleteDynamicImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDynamicImageResponseBody() = default;
};
class DeleteDynamicImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDynamicImageResponseBody> body{};

  DeleteDynamicImageResponse() {}

  explicit DeleteDynamicImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDynamicImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDynamicImageResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDynamicImageResponse() = default;
};
class DeleteEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectIds{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  DeleteEditingProjectRequest() {}

  explicit DeleteEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectIds) {
      res["ProjectIds"] = boost::any(*projectIds);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectIds") != m.end() && !m["ProjectIds"].empty()) {
      projectIds = make_shared<string>(boost::any_cast<string>(m["ProjectIds"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteEditingProjectRequest() = default;
};
class DeleteEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEditingProjectResponseBody() {}

  explicit DeleteEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEditingProjectResponseBody() = default;
};
class DeleteEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEditingProjectResponseBody> body{};

  DeleteEditingProjectResponse() {}

  explicit DeleteEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEditingProjectResponse() = default;
};
class DeleteEditingProjectMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> materialIds{};
  shared_ptr<string> materialType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  DeleteEditingProjectMaterialsRequest() {}

  explicit DeleteEditingProjectMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialIds) {
      res["MaterialIds"] = boost::any(*materialIds);
    }
    if (materialType) {
      res["MaterialType"] = boost::any(*materialType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialIds") != m.end() && !m["MaterialIds"].empty()) {
      materialIds = make_shared<string>(boost::any_cast<string>(m["MaterialIds"]));
    }
    if (m.find("MaterialType") != m.end() && !m["MaterialType"].empty()) {
      materialType = make_shared<string>(boost::any_cast<string>(m["MaterialType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteEditingProjectMaterialsRequest() = default;
};
class DeleteEditingProjectMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEditingProjectMaterialsResponseBody() {}

  explicit DeleteEditingProjectMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEditingProjectMaterialsResponseBody() = default;
};
class DeleteEditingProjectMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEditingProjectMaterialsResponseBody> body{};

  DeleteEditingProjectMaterialsResponse() {}

  explicit DeleteEditingProjectMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEditingProjectMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEditingProjectMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEditingProjectMaterialsResponse() = default;
};
class DeleteImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteImageType{};
  shared_ptr<string> imageIds{};
  shared_ptr<string> imageType{};
  shared_ptr<string> imageURLs{};
  shared_ptr<string> videoId{};

  DeleteImageRequest() {}

  explicit DeleteImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteImageType) {
      res["DeleteImageType"] = boost::any(*deleteImageType);
    }
    if (imageIds) {
      res["ImageIds"] = boost::any(*imageIds);
    }
    if (imageType) {
      res["ImageType"] = boost::any(*imageType);
    }
    if (imageURLs) {
      res["ImageURLs"] = boost::any(*imageURLs);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteImageType") != m.end() && !m["DeleteImageType"].empty()) {
      deleteImageType = make_shared<string>(boost::any_cast<string>(m["DeleteImageType"]));
    }
    if (m.find("ImageIds") != m.end() && !m["ImageIds"].empty()) {
      imageIds = make_shared<string>(boost::any_cast<string>(m["ImageIds"]));
    }
    if (m.find("ImageType") != m.end() && !m["ImageType"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["ImageType"]));
    }
    if (m.find("ImageURLs") != m.end() && !m["ImageURLs"].empty()) {
      imageURLs = make_shared<string>(boost::any_cast<string>(m["ImageURLs"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~DeleteImageRequest() = default;
};
class DeleteImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteImageResponseBody() {}

  explicit DeleteImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteImageResponseBody() = default;
};
class DeleteImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteImageResponseBody> body{};

  DeleteImageResponse() {}

  explicit DeleteImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteImageResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteImageResponse() = default;
};
class DeleteMessageCallbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ownerAccount{};

  DeleteMessageCallbackRequest() {}

  explicit DeleteMessageCallbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteMessageCallbackRequest() = default;
};
class DeleteMessageCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMessageCallbackResponseBody() {}

  explicit DeleteMessageCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMessageCallbackResponseBody() = default;
};
class DeleteMessageCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMessageCallbackResponseBody> body{};

  DeleteMessageCallbackResponse() {}

  explicit DeleteMessageCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMessageCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMessageCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMessageCallbackResponse() = default;
};
class DeleteMezzaninesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> force{};
  shared_ptr<string> videoIds{};

  DeleteMezzaninesRequest() {}

  explicit DeleteMezzaninesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (videoIds) {
      res["VideoIds"] = boost::any(*videoIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("VideoIds") != m.end() && !m["VideoIds"].empty()) {
      videoIds = make_shared<string>(boost::any_cast<string>(m["VideoIds"]));
    }
  }


  virtual ~DeleteMezzaninesRequest() = default;
};
class DeleteMezzaninesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nonExistVideoIds{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> unRemoveableVideoIds{};

  DeleteMezzaninesResponseBody() {}

  explicit DeleteMezzaninesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistVideoIds) {
      res["NonExistVideoIds"] = boost::any(*nonExistVideoIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (unRemoveableVideoIds) {
      res["UnRemoveableVideoIds"] = boost::any(*unRemoveableVideoIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistVideoIds") != m.end() && !m["NonExistVideoIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistVideoIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistVideoIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistVideoIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UnRemoveableVideoIds") != m.end() && !m["UnRemoveableVideoIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UnRemoveableVideoIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UnRemoveableVideoIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      unRemoveableVideoIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteMezzaninesResponseBody() = default;
};
class DeleteMezzaninesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMezzaninesResponseBody> body{};

  DeleteMezzaninesResponse() {}

  explicit DeleteMezzaninesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMezzaninesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMezzaninesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMezzaninesResponse() = default;
};
class DeleteMultipartUploadRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> ownerAccount{};

  DeleteMultipartUploadRequest() {}

  explicit DeleteMultipartUploadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~DeleteMultipartUploadRequest() = default;
};
class DeleteMultipartUploadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMultipartUploadResponseBody() {}

  explicit DeleteMultipartUploadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMultipartUploadResponseBody() = default;
};
class DeleteMultipartUploadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMultipartUploadResponseBody> body{};

  DeleteMultipartUploadResponse() {}

  explicit DeleteMultipartUploadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMultipartUploadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMultipartUploadResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMultipartUploadResponse() = default;
};
class DeleteStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> videoId{};

  DeleteStreamRequest() {}

  explicit DeleteStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~DeleteStreamRequest() = default;
};
class DeleteStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteStreamResponseBody() {}

  explicit DeleteStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteStreamResponseBody() = default;
};
class DeleteStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStreamResponseBody> body{};

  DeleteStreamResponse() {}

  explicit DeleteStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStreamResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStreamResponse() = default;
};
class DeleteTranscodeTemplateGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> forceDelGroup{};
  shared_ptr<string> transcodeTemplateGroupId{};
  shared_ptr<string> transcodeTemplateIds{};

  DeleteTranscodeTemplateGroupRequest() {}

  explicit DeleteTranscodeTemplateGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forceDelGroup) {
      res["ForceDelGroup"] = boost::any(*forceDelGroup);
    }
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    if (transcodeTemplateIds) {
      res["TranscodeTemplateIds"] = boost::any(*transcodeTemplateIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForceDelGroup") != m.end() && !m["ForceDelGroup"].empty()) {
      forceDelGroup = make_shared<string>(boost::any_cast<string>(m["ForceDelGroup"]));
    }
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
    if (m.find("TranscodeTemplateIds") != m.end() && !m["TranscodeTemplateIds"].empty()) {
      transcodeTemplateIds = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateIds"]));
    }
  }


  virtual ~DeleteTranscodeTemplateGroupRequest() = default;
};
class DeleteTranscodeTemplateGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nonExistTranscodeTemplateIds{};
  shared_ptr<string> requestId{};

  DeleteTranscodeTemplateGroupResponseBody() {}

  explicit DeleteTranscodeTemplateGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistTranscodeTemplateIds) {
      res["NonExistTranscodeTemplateIds"] = boost::any(*nonExistTranscodeTemplateIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistTranscodeTemplateIds") != m.end() && !m["NonExistTranscodeTemplateIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistTranscodeTemplateIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistTranscodeTemplateIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistTranscodeTemplateIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTranscodeTemplateGroupResponseBody() = default;
};
class DeleteTranscodeTemplateGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTranscodeTemplateGroupResponseBody> body{};

  DeleteTranscodeTemplateGroupResponse() {}

  explicit DeleteTranscodeTemplateGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTranscodeTemplateGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTranscodeTemplateGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTranscodeTemplateGroupResponse() = default;
};
class DeleteVideoRequest : public Darabonba::Model {
public:
  shared_ptr<string> videoIds{};

  DeleteVideoRequest() {}

  explicit DeleteVideoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoIds) {
      res["VideoIds"] = boost::any(*videoIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoIds") != m.end() && !m["VideoIds"].empty()) {
      videoIds = make_shared<string>(boost::any_cast<string>(m["VideoIds"]));
    }
  }


  virtual ~DeleteVideoRequest() = default;
};
class DeleteVideoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forbiddenVideoIds{};
  shared_ptr<vector<string>> nonExistVideoIds{};
  shared_ptr<string> requestId{};

  DeleteVideoResponseBody() {}

  explicit DeleteVideoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbiddenVideoIds) {
      res["ForbiddenVideoIds"] = boost::any(*forbiddenVideoIds);
    }
    if (nonExistVideoIds) {
      res["NonExistVideoIds"] = boost::any(*nonExistVideoIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbiddenVideoIds") != m.end() && !m["ForbiddenVideoIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForbiddenVideoIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForbiddenVideoIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forbiddenVideoIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NonExistVideoIds") != m.end() && !m["NonExistVideoIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistVideoIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistVideoIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistVideoIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVideoResponseBody() = default;
};
class DeleteVideoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVideoResponseBody> body{};

  DeleteVideoResponse() {}

  explicit DeleteVideoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVideoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVideoResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVideoResponse() = default;
};
class DeleteVodDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteVodDomainRequest() {}

  explicit DeleteVodDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteVodDomainRequest() = default;
};
class DeleteVodDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVodDomainResponseBody() {}

  explicit DeleteVodDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVodDomainResponseBody() = default;
};
class DeleteVodDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVodDomainResponseBody> body{};

  DeleteVodDomainResponse() {}

  explicit DeleteVodDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVodDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVodDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVodDomainResponse() = default;
};
class DeleteVodSpecificConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> env{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteVodSpecificConfigRequest() {}

  explicit DeleteVodSpecificConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteVodSpecificConfigRequest() = default;
};
class DeleteVodSpecificConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVodSpecificConfigResponseBody() {}

  explicit DeleteVodSpecificConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVodSpecificConfigResponseBody() = default;
};
class DeleteVodSpecificConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVodSpecificConfigResponseBody> body{};

  DeleteVodSpecificConfigResponse() {}

  explicit DeleteVodSpecificConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVodSpecificConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVodSpecificConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVodSpecificConfigResponse() = default;
};
class DeleteVodTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> vodTemplateId{};

  DeleteVodTemplateRequest() {}

  explicit DeleteVodTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vodTemplateId) {
      res["VodTemplateId"] = boost::any(*vodTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VodTemplateId") != m.end() && !m["VodTemplateId"].empty()) {
      vodTemplateId = make_shared<string>(boost::any_cast<string>(m["VodTemplateId"]));
    }
  }


  virtual ~DeleteVodTemplateRequest() = default;
};
class DeleteVodTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vodTemplateId{};

  DeleteVodTemplateResponseBody() {}

  explicit DeleteVodTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vodTemplateId) {
      res["VodTemplateId"] = boost::any(*vodTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VodTemplateId") != m.end() && !m["VodTemplateId"].empty()) {
      vodTemplateId = make_shared<string>(boost::any_cast<string>(m["VodTemplateId"]));
    }
  }


  virtual ~DeleteVodTemplateResponseBody() = default;
};
class DeleteVodTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVodTemplateResponseBody> body{};

  DeleteVodTemplateResponse() {}

  explicit DeleteVodTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVodTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVodTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVodTemplateResponse() = default;
};
class DeleteWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> watermarkId{};

  DeleteWatermarkRequest() {}

  explicit DeleteWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
  }


  virtual ~DeleteWatermarkRequest() = default;
};
class DeleteWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteWatermarkResponseBody() {}

  explicit DeleteWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteWatermarkResponseBody() = default;
};
class DeleteWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteWatermarkResponseBody> body{};

  DeleteWatermarkResponse() {}

  explicit DeleteWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteWatermarkResponse() = default;
};
class DescribePlayTopVideosRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizDate{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  DescribePlayTopVideosRequest() {}

  explicit DescribePlayTopVideosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribePlayTopVideosRequest() = default;
};
class DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis : public Darabonba::Model {
public:
  shared_ptr<string> playDuration{};
  shared_ptr<string> title{};
  shared_ptr<string> UV{};
  shared_ptr<string> VV{};
  shared_ptr<string> videoId{};

  DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis() {}

  explicit DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (playDuration) {
      res["PlayDuration"] = boost::any(*playDuration);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (UV) {
      res["UV"] = boost::any(*UV);
    }
    if (VV) {
      res["VV"] = boost::any(*VV);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlayDuration") != m.end() && !m["PlayDuration"].empty()) {
      playDuration = make_shared<string>(boost::any_cast<string>(m["PlayDuration"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UV") != m.end() && !m["UV"].empty()) {
      UV = make_shared<string>(boost::any_cast<string>(m["UV"]));
    }
    if (m.find("VV") != m.end() && !m["VV"].empty()) {
      VV = make_shared<string>(boost::any_cast<string>(m["VV"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis() = default;
};
class DescribePlayTopVideosResponseBodyTopPlayVideos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis>> topPlayVideoStatis{};

  DescribePlayTopVideosResponseBodyTopPlayVideos() {}

  explicit DescribePlayTopVideosResponseBodyTopPlayVideos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topPlayVideoStatis) {
      vector<boost::any> temp1;
      for(auto item1:*topPlayVideoStatis){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopPlayVideoStatis"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopPlayVideoStatis") != m.end() && !m["TopPlayVideoStatis"].empty()) {
      if (typeid(vector<boost::any>) == m["TopPlayVideoStatis"].type()) {
        vector<DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopPlayVideoStatis"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topPlayVideoStatis = make_shared<vector<DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis>>(expect1);
      }
    }
  }


  virtual ~DescribePlayTopVideosResponseBodyTopPlayVideos() = default;
};
class DescribePlayTopVideosResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribePlayTopVideosResponseBodyTopPlayVideos> topPlayVideos{};
  shared_ptr<long> totalNum{};

  DescribePlayTopVideosResponseBody() {}

  explicit DescribePlayTopVideosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (topPlayVideos) {
      res["TopPlayVideos"] = topPlayVideos ? boost::any(topPlayVideos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TopPlayVideos") != m.end() && !m["TopPlayVideos"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopPlayVideos"].type()) {
        DescribePlayTopVideosResponseBodyTopPlayVideos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopPlayVideos"]));
        topPlayVideos = make_shared<DescribePlayTopVideosResponseBodyTopPlayVideos>(model1);
      }
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
  }


  virtual ~DescribePlayTopVideosResponseBody() = default;
};
class DescribePlayTopVideosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayTopVideosResponseBody> body{};

  DescribePlayTopVideosResponse() {}

  explicit DescribePlayTopVideosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayTopVideosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayTopVideosResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayTopVideosResponse() = default;
};
class DescribePlayUserAvgRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribePlayUserAvgRequest() {}

  explicit DescribePlayUserAvgRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribePlayUserAvgRequest() = default;
};
class DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg : public Darabonba::Model {
public:
  shared_ptr<string> avgPlayCount{};
  shared_ptr<string> avgPlayDuration{};
  shared_ptr<string> date{};

  DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg() {}

  explicit DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgPlayCount) {
      res["AvgPlayCount"] = boost::any(*avgPlayCount);
    }
    if (avgPlayDuration) {
      res["AvgPlayDuration"] = boost::any(*avgPlayDuration);
    }
    if (date) {
      res["Date"] = boost::any(*date);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgPlayCount") != m.end() && !m["AvgPlayCount"].empty()) {
      avgPlayCount = make_shared<string>(boost::any_cast<string>(m["AvgPlayCount"]));
    }
    if (m.find("AvgPlayDuration") != m.end() && !m["AvgPlayDuration"].empty()) {
      avgPlayDuration = make_shared<string>(boost::any_cast<string>(m["AvgPlayDuration"]));
    }
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
  }


  virtual ~DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg() = default;
};
class DescribePlayUserAvgResponseBodyUserPlayStatisAvgs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg>> userPlayStatisAvg{};

  DescribePlayUserAvgResponseBodyUserPlayStatisAvgs() {}

  explicit DescribePlayUserAvgResponseBodyUserPlayStatisAvgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userPlayStatisAvg) {
      vector<boost::any> temp1;
      for(auto item1:*userPlayStatisAvg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserPlayStatisAvg"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserPlayStatisAvg") != m.end() && !m["UserPlayStatisAvg"].empty()) {
      if (typeid(vector<boost::any>) == m["UserPlayStatisAvg"].type()) {
        vector<DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserPlayStatisAvg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userPlayStatisAvg = make_shared<vector<DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg>>(expect1);
      }
    }
  }


  virtual ~DescribePlayUserAvgResponseBodyUserPlayStatisAvgs() = default;
};
class DescribePlayUserAvgResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePlayUserAvgResponseBodyUserPlayStatisAvgs> userPlayStatisAvgs{};

  DescribePlayUserAvgResponseBody() {}

  explicit DescribePlayUserAvgResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userPlayStatisAvgs) {
      res["UserPlayStatisAvgs"] = userPlayStatisAvgs ? boost::any(userPlayStatisAvgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserPlayStatisAvgs") != m.end() && !m["UserPlayStatisAvgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserPlayStatisAvgs"].type()) {
        DescribePlayUserAvgResponseBodyUserPlayStatisAvgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserPlayStatisAvgs"]));
        userPlayStatisAvgs = make_shared<DescribePlayUserAvgResponseBodyUserPlayStatisAvgs>(model1);
      }
    }
  }


  virtual ~DescribePlayUserAvgResponseBody() = default;
};
class DescribePlayUserAvgResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayUserAvgResponseBody> body{};

  DescribePlayUserAvgResponse() {}

  explicit DescribePlayUserAvgResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayUserAvgResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayUserAvgResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayUserAvgResponse() = default;
};
class DescribePlayUserTotalRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribePlayUserTotalRequest() {}

  explicit DescribePlayUserTotalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribePlayUserTotalRequest() = default;
};
class DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV : public Darabonba::Model {
public:
  shared_ptr<string> android{};
  shared_ptr<string> flash{};
  shared_ptr<string> HTML5{};
  shared_ptr<string> iOS{};

  DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV() {}

  explicit DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (android) {
      res["Android"] = boost::any(*android);
    }
    if (flash) {
      res["Flash"] = boost::any(*flash);
    }
    if (HTML5) {
      res["HTML5"] = boost::any(*HTML5);
    }
    if (iOS) {
      res["iOS"] = boost::any(*iOS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Android") != m.end() && !m["Android"].empty()) {
      android = make_shared<string>(boost::any_cast<string>(m["Android"]));
    }
    if (m.find("Flash") != m.end() && !m["Flash"].empty()) {
      flash = make_shared<string>(boost::any_cast<string>(m["Flash"]));
    }
    if (m.find("HTML5") != m.end() && !m["HTML5"].empty()) {
      HTML5 = make_shared<string>(boost::any_cast<string>(m["HTML5"]));
    }
    if (m.find("iOS") != m.end() && !m["iOS"].empty()) {
      iOS = make_shared<string>(boost::any_cast<string>(m["iOS"]));
    }
  }


  virtual ~DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV() = default;
};
class DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV : public Darabonba::Model {
public:
  shared_ptr<string> android{};
  shared_ptr<string> flash{};
  shared_ptr<string> HTML5{};
  shared_ptr<string> iOS{};

  DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV() {}

  explicit DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (android) {
      res["Android"] = boost::any(*android);
    }
    if (flash) {
      res["Flash"] = boost::any(*flash);
    }
    if (HTML5) {
      res["HTML5"] = boost::any(*HTML5);
    }
    if (iOS) {
      res["iOS"] = boost::any(*iOS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Android") != m.end() && !m["Android"].empty()) {
      android = make_shared<string>(boost::any_cast<string>(m["Android"]));
    }
    if (m.find("Flash") != m.end() && !m["Flash"].empty()) {
      flash = make_shared<string>(boost::any_cast<string>(m["Flash"]));
    }
    if (m.find("HTML5") != m.end() && !m["HTML5"].empty()) {
      HTML5 = make_shared<string>(boost::any_cast<string>(m["HTML5"]));
    }
    if (m.find("iOS") != m.end() && !m["iOS"].empty()) {
      iOS = make_shared<string>(boost::any_cast<string>(m["iOS"]));
    }
  }


  virtual ~DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV() = default;
};
class DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> playDuration{};
  shared_ptr<string> playRange{};
  shared_ptr<DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV> UV{};
  shared_ptr<DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV> VV{};

  DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal() {}

  explicit DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (playDuration) {
      res["PlayDuration"] = boost::any(*playDuration);
    }
    if (playRange) {
      res["PlayRange"] = boost::any(*playRange);
    }
    if (UV) {
      res["UV"] = UV ? boost::any(UV->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (VV) {
      res["VV"] = VV ? boost::any(VV->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("PlayDuration") != m.end() && !m["PlayDuration"].empty()) {
      playDuration = make_shared<string>(boost::any_cast<string>(m["PlayDuration"]));
    }
    if (m.find("PlayRange") != m.end() && !m["PlayRange"].empty()) {
      playRange = make_shared<string>(boost::any_cast<string>(m["PlayRange"]));
    }
    if (m.find("UV") != m.end() && !m["UV"].empty()) {
      if (typeid(map<string, boost::any>) == m["UV"].type()) {
        DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UV"]));
        UV = make_shared<DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV>(model1);
      }
    }
    if (m.find("VV") != m.end() && !m["VV"].empty()) {
      if (typeid(map<string, boost::any>) == m["VV"].type()) {
        DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VV"]));
        VV = make_shared<DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV>(model1);
      }
    }
  }


  virtual ~DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal() = default;
};
class DescribePlayUserTotalResponseBodyUserPlayStatisTotals : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal>> userPlayStatisTotal{};

  DescribePlayUserTotalResponseBodyUserPlayStatisTotals() {}

  explicit DescribePlayUserTotalResponseBodyUserPlayStatisTotals(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userPlayStatisTotal) {
      vector<boost::any> temp1;
      for(auto item1:*userPlayStatisTotal){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserPlayStatisTotal"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserPlayStatisTotal") != m.end() && !m["UserPlayStatisTotal"].empty()) {
      if (typeid(vector<boost::any>) == m["UserPlayStatisTotal"].type()) {
        vector<DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserPlayStatisTotal"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userPlayStatisTotal = make_shared<vector<DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal>>(expect1);
      }
    }
  }


  virtual ~DescribePlayUserTotalResponseBodyUserPlayStatisTotals() = default;
};
class DescribePlayUserTotalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePlayUserTotalResponseBodyUserPlayStatisTotals> userPlayStatisTotals{};

  DescribePlayUserTotalResponseBody() {}

  explicit DescribePlayUserTotalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userPlayStatisTotals) {
      res["UserPlayStatisTotals"] = userPlayStatisTotals ? boost::any(userPlayStatisTotals->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserPlayStatisTotals") != m.end() && !m["UserPlayStatisTotals"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserPlayStatisTotals"].type()) {
        DescribePlayUserTotalResponseBodyUserPlayStatisTotals model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserPlayStatisTotals"]));
        userPlayStatisTotals = make_shared<DescribePlayUserTotalResponseBodyUserPlayStatisTotals>(model1);
      }
    }
  }


  virtual ~DescribePlayUserTotalResponseBody() = default;
};
class DescribePlayUserTotalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayUserTotalResponseBody> body{};

  DescribePlayUserTotalResponse() {}

  explicit DescribePlayUserTotalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayUserTotalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayUserTotalResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayUserTotalResponse() = default;
};
class DescribePlayVideoStatisRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> videoId{};

  DescribePlayVideoStatisRequest() {}

  explicit DescribePlayVideoStatisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~DescribePlayVideoStatisRequest() = default;
};
class DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail : public Darabonba::Model {
public:
  shared_ptr<string> date{};
  shared_ptr<string> playDuration{};
  shared_ptr<string> playRange{};
  shared_ptr<string> title{};
  shared_ptr<string> UV{};
  shared_ptr<string> VV{};

  DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail() {}

  explicit DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (playDuration) {
      res["PlayDuration"] = boost::any(*playDuration);
    }
    if (playRange) {
      res["PlayRange"] = boost::any(*playRange);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (UV) {
      res["UV"] = boost::any(*UV);
    }
    if (VV) {
      res["VV"] = boost::any(*VV);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("PlayDuration") != m.end() && !m["PlayDuration"].empty()) {
      playDuration = make_shared<string>(boost::any_cast<string>(m["PlayDuration"]));
    }
    if (m.find("PlayRange") != m.end() && !m["PlayRange"].empty()) {
      playRange = make_shared<string>(boost::any_cast<string>(m["PlayRange"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UV") != m.end() && !m["UV"].empty()) {
      UV = make_shared<string>(boost::any_cast<string>(m["UV"]));
    }
    if (m.find("VV") != m.end() && !m["VV"].empty()) {
      VV = make_shared<string>(boost::any_cast<string>(m["VV"]));
    }
  }


  virtual ~DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail() = default;
};
class DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail>> videoPlayStatisDetail{};

  DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails() {}

  explicit DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoPlayStatisDetail) {
      vector<boost::any> temp1;
      for(auto item1:*videoPlayStatisDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoPlayStatisDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoPlayStatisDetail") != m.end() && !m["VideoPlayStatisDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoPlayStatisDetail"].type()) {
        vector<DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoPlayStatisDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoPlayStatisDetail = make_shared<vector<DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail>>(expect1);
      }
    }
  }


  virtual ~DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails() = default;
};
class DescribePlayVideoStatisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails> videoPlayStatisDetails{};

  DescribePlayVideoStatisResponseBody() {}

  explicit DescribePlayVideoStatisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (videoPlayStatisDetails) {
      res["VideoPlayStatisDetails"] = videoPlayStatisDetails ? boost::any(videoPlayStatisDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VideoPlayStatisDetails") != m.end() && !m["VideoPlayStatisDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoPlayStatisDetails"].type()) {
        DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoPlayStatisDetails"]));
        videoPlayStatisDetails = make_shared<DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails>(model1);
      }
    }
  }


  virtual ~DescribePlayVideoStatisResponseBody() = default;
};
class DescribePlayVideoStatisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayVideoStatisResponseBody> body{};

  DescribePlayVideoStatisResponse() {}

  explicit DescribePlayVideoStatisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayVideoStatisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayVideoStatisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayVideoStatisResponse() = default;
};
class DescribeVodAIDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIType{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> startTime{};

  DescribeVodAIDataRequest() {}

  explicit DescribeVodAIDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIType) {
      res["AIType"] = boost::any(*AIType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIType") != m.end() && !m["AIType"].empty()) {
      AIType = make_shared<string>(boost::any_cast<string>(m["AIType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVodAIDataRequest() = default;
};
class DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem() {}

  explicit DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem() = default;
};
class DescribeVodAIDataResponseBodyAIDataAIDataItemData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem>> dataItem{};

  DescribeVodAIDataResponseBodyAIDataAIDataItemData() {}

  explicit DescribeVodAIDataResponseBodyAIDataAIDataItemData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataItem) {
      vector<boost::any> temp1;
      for(auto item1:*dataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DataItem"].type()) {
        vector<DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataItem = make_shared<vector<DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeVodAIDataResponseBodyAIDataAIDataItemData() = default;
};
class DescribeVodAIDataResponseBodyAIDataAIDataItem : public Darabonba::Model {
public:
  shared_ptr<DescribeVodAIDataResponseBodyAIDataAIDataItemData> data{};
  shared_ptr<string> timeStamp{};

  DescribeVodAIDataResponseBodyAIDataAIDataItem() {}

  explicit DescribeVodAIDataResponseBodyAIDataAIDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeVodAIDataResponseBodyAIDataAIDataItemData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeVodAIDataResponseBodyAIDataAIDataItemData>(model1);
      }
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeVodAIDataResponseBodyAIDataAIDataItem() = default;
};
class DescribeVodAIDataResponseBodyAIData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodAIDataResponseBodyAIDataAIDataItem>> AIDataItem{};

  DescribeVodAIDataResponseBodyAIData() {}

  explicit DescribeVodAIDataResponseBodyAIData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*AIDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AIDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIDataItem") != m.end() && !m["AIDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["AIDataItem"].type()) {
        vector<DescribeVodAIDataResponseBodyAIDataAIDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AIDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodAIDataResponseBodyAIDataAIDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        AIDataItem = make_shared<vector<DescribeVodAIDataResponseBodyAIDataAIDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeVodAIDataResponseBodyAIData() = default;
};
class DescribeVodAIDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVodAIDataResponseBodyAIData> AIData{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> requestId{};

  DescribeVodAIDataResponseBody() {}

  explicit DescribeVodAIDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIData) {
      res["AIData"] = AIData ? boost::any(AIData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIData") != m.end() && !m["AIData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AIData"].type()) {
        DescribeVodAIDataResponseBodyAIData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AIData"]));
        AIData = make_shared<DescribeVodAIDataResponseBodyAIData>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVodAIDataResponseBody() = default;
};
class DescribeVodAIDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodAIDataResponseBody> body{};

  DescribeVodAIDataResponse() {}

  explicit DescribeVodAIDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodAIDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodAIDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodAIDataResponse() = default;
};
class DescribeVodCertificateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeVodCertificateListRequest() {}

  explicit DescribeVodCertificateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeVodCertificateListRequest() = default;
};
class DescribeVodCertificateListResponseBodyCertificateListModelCertListCert : public Darabonba::Model {
public:
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> common{};
  shared_ptr<string> fingerprint{};
  shared_ptr<string> issuer{};
  shared_ptr<long> lastTime{};

  DescribeVodCertificateListResponseBodyCertificateListModelCertListCert() {}

  explicit DescribeVodCertificateListResponseBodyCertificateListModelCertListCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
  }


  virtual ~DescribeVodCertificateListResponseBodyCertificateListModelCertListCert() = default;
};
class DescribeVodCertificateListResponseBodyCertificateListModelCertList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodCertificateListResponseBodyCertificateListModelCertListCert>> cert{};

  DescribeVodCertificateListResponseBodyCertificateListModelCertList() {}

  explicit DescribeVodCertificateListResponseBodyCertificateListModelCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      vector<boost::any> temp1;
      for(auto item1:*cert){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cert"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      if (typeid(vector<boost::any>) == m["Cert"].type()) {
        vector<DescribeVodCertificateListResponseBodyCertificateListModelCertListCert> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cert"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodCertificateListResponseBodyCertificateListModelCertListCert model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cert = make_shared<vector<DescribeVodCertificateListResponseBodyCertificateListModelCertListCert>>(expect1);
      }
    }
  }


  virtual ~DescribeVodCertificateListResponseBodyCertificateListModelCertList() = default;
};
class DescribeVodCertificateListResponseBodyCertificateListModel : public Darabonba::Model {
public:
  shared_ptr<DescribeVodCertificateListResponseBodyCertificateListModelCertList> certList{};
  shared_ptr<long> count{};

  DescribeVodCertificateListResponseBodyCertificateListModel() {}

  explicit DescribeVodCertificateListResponseBodyCertificateListModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certList) {
      res["CertList"] = certList ? boost::any(certList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertList") != m.end() && !m["CertList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertList"].type()) {
        DescribeVodCertificateListResponseBodyCertificateListModelCertList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertList"]));
        certList = make_shared<DescribeVodCertificateListResponseBodyCertificateListModelCertList>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeVodCertificateListResponseBodyCertificateListModel() = default;
};
class DescribeVodCertificateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVodCertificateListResponseBodyCertificateListModel> certificateListModel{};
  shared_ptr<string> requestId{};

  DescribeVodCertificateListResponseBody() {}

  explicit DescribeVodCertificateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateListModel) {
      res["CertificateListModel"] = certificateListModel ? boost::any(certificateListModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateListModel") != m.end() && !m["CertificateListModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertificateListModel"].type()) {
        DescribeVodCertificateListResponseBodyCertificateListModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertificateListModel"]));
        certificateListModel = make_shared<DescribeVodCertificateListResponseBodyCertificateListModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVodCertificateListResponseBody() = default;
};
class DescribeVodCertificateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodCertificateListResponseBody> body{};

  DescribeVodCertificateListResponse() {}

  explicit DescribeVodCertificateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodCertificateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodCertificateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodCertificateListResponse() = default;
};
class DescribeVodDomainBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVodDomainBpsDataRequest() {}

  explicit DescribeVodDomainBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVodDomainBpsDataRequest() = default;
};
class DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> domesticValue{};
  shared_ptr<string> httpsDomesticValue{};
  shared_ptr<string> httpsOverseasValue{};
  shared_ptr<string> httpsValue{};
  shared_ptr<string> overseasValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domesticValue) {
      res["DomesticValue"] = boost::any(*domesticValue);
    }
    if (httpsDomesticValue) {
      res["HttpsDomesticValue"] = boost::any(*httpsDomesticValue);
    }
    if (httpsOverseasValue) {
      res["HttpsOverseasValue"] = boost::any(*httpsOverseasValue);
    }
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (overseasValue) {
      res["OverseasValue"] = boost::any(*overseasValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomesticValue") != m.end() && !m["DomesticValue"].empty()) {
      domesticValue = make_shared<string>(boost::any_cast<string>(m["DomesticValue"]));
    }
    if (m.find("HttpsDomesticValue") != m.end() && !m["HttpsDomesticValue"].empty()) {
      httpsDomesticValue = make_shared<string>(boost::any_cast<string>(m["HttpsDomesticValue"]));
    }
    if (m.find("HttpsOverseasValue") != m.end() && !m["HttpsOverseasValue"].empty()) {
      httpsOverseasValue = make_shared<string>(boost::any_cast<string>(m["HttpsOverseasValue"]));
    }
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("OverseasValue") != m.end() && !m["OverseasValue"].empty()) {
      overseasValue = make_shared<string>(boost::any_cast<string>(m["OverseasValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeVodDomainBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeVodDomainBpsDataResponseBody() {}

  explicit DescribeVodDomainBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVodDomainBpsDataResponseBody() = default;
};
class DescribeVodDomainBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodDomainBpsDataResponseBody> body{};

  DescribeVodDomainBpsDataResponse() {}

  explicit DescribeVodDomainBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodDomainBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodDomainBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainBpsDataResponse() = default;
};
class DescribeVodDomainCertificateInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeVodDomainCertificateInfoRequest() {}

  explicit DescribeVodDomainCertificateInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeVodDomainCertificateInfoRequest() = default;
};
class DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certDomainName{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certLife{};
  shared_ptr<string> certName{};
  shared_ptr<string> certOrg{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> serverCertificateStatus{};
  shared_ptr<string> status{};

  DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo() {}

  explicit DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certDomainName) {
      res["CertDomainName"] = boost::any(*certDomainName);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certLife) {
      res["CertLife"] = boost::any(*certLife);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certOrg) {
      res["CertOrg"] = boost::any(*certOrg);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (serverCertificateStatus) {
      res["ServerCertificateStatus"] = boost::any(*serverCertificateStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertDomainName") != m.end() && !m["CertDomainName"].empty()) {
      certDomainName = make_shared<string>(boost::any_cast<string>(m["CertDomainName"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertLife") != m.end() && !m["CertLife"].empty()) {
      certLife = make_shared<string>(boost::any_cast<string>(m["CertLife"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertOrg") != m.end() && !m["CertOrg"].empty()) {
      certOrg = make_shared<string>(boost::any_cast<string>(m["CertOrg"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ServerCertificateStatus") != m.end() && !m["ServerCertificateStatus"].empty()) {
      serverCertificateStatus = make_shared<string>(boost::any_cast<string>(m["ServerCertificateStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo() = default;
};
class DescribeVodDomainCertificateInfoResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeVodDomainCertificateInfoResponseBodyCertInfos() {}

  explicit DescribeVodDomainCertificateInfoResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainCertificateInfoResponseBodyCertInfos() = default;
};
class DescribeVodDomainCertificateInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVodDomainCertificateInfoResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};

  DescribeVodDomainCertificateInfoResponseBody() {}

  explicit DescribeVodDomainCertificateInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeVodDomainCertificateInfoResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeVodDomainCertificateInfoResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVodDomainCertificateInfoResponseBody() = default;
};
class DescribeVodDomainCertificateInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodDomainCertificateInfoResponseBody> body{};

  DescribeVodDomainCertificateInfoResponse() {}

  explicit DescribeVodDomainCertificateInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodDomainCertificateInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodDomainCertificateInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainCertificateInfoResponse() = default;
};
class DescribeVodDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeVodDomainConfigsRequest() {}

  explicit DescribeVodDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeVodDomainConfigsRequest() = default;
};
class DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() {}

  explicit DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() = default;
};
class DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>> functionArg{};

  DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() {}

  explicit DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionArg) {
      vector<boost::any> temp1;
      for(auto item1:*functionArg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArg"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionArg") != m.end() && !m["FunctionArg"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArg"].type()) {
        vector<DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArg = make_shared<vector<DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() = default;
};
class DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> status{};

  DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig() {}

  explicit DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      res["FunctionArgs"] = functionArgs ? boost::any(functionArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionArgs"].type()) {
        DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionArgs"]));
        functionArgs = make_shared<DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs>(model1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig() = default;
};
class DescribeVodDomainConfigsResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig>> domainConfig{};

  DescribeVodDomainConfigsResponseBodyDomainConfigs() {}

  explicit DescribeVodDomainConfigsResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfig) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfig") != m.end() && !m["DomainConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfig"].type()) {
        vector<DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfig = make_shared<vector<DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainConfigsResponseBodyDomainConfigs() = default;
};
class DescribeVodDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVodDomainConfigsResponseBodyDomainConfigs> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeVodDomainConfigsResponseBody() {}

  explicit DescribeVodDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      res["DomainConfigs"] = domainConfigs ? boost::any(domainConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfigs"].type()) {
        DescribeVodDomainConfigsResponseBodyDomainConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfigs"]));
        domainConfigs = make_shared<DescribeVodDomainConfigsResponseBodyDomainConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVodDomainConfigsResponseBody() = default;
};
class DescribeVodDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodDomainConfigsResponseBody> body{};

  DescribeVodDomainConfigsResponse() {}

  explicit DescribeVodDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainConfigsResponse() = default;
};
class DescribeVodDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeVodDomainDetailRequest() {}

  explicit DescribeVodDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeVodDomainDetailRequest() = default;
};
class DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> enabled{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};

  DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource() {}

  explicit DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<string>(boost::any_cast<string>(m["Enabled"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource() = default;
};
class DescribeVodDomainDetailResponseBodyDomainDetailSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource>> source{};

  DescribeVodDomainDetailResponseBodyDomainDetailSources() {}

  explicit DescribeVodDomainDetailResponseBodyDomainDetailSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainDetailResponseBodyDomainDetailSources() = default;
};
class DescribeVodDomainDetailResponseBodyDomainDetail : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> scope{};
  shared_ptr<DescribeVodDomainDetailResponseBodyDomainDetailSources> sources{};
  shared_ptr<string> weight{};

  DescribeVodDomainDetailResponseBodyDomainDetail() {}

  explicit DescribeVodDomainDetailResponseBodyDomainDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeVodDomainDetailResponseBodyDomainDetailSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeVodDomainDetailResponseBodyDomainDetailSources>(model1);
      }
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~DescribeVodDomainDetailResponseBodyDomainDetail() = default;
};
class DescribeVodDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVodDomainDetailResponseBodyDomainDetail> domainDetail{};
  shared_ptr<string> requestId{};

  DescribeVodDomainDetailResponseBody() {}

  explicit DescribeVodDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainDetail) {
      res["DomainDetail"] = domainDetail ? boost::any(domainDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainDetail") != m.end() && !m["DomainDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainDetail"].type()) {
        DescribeVodDomainDetailResponseBodyDomainDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainDetail"]));
        domainDetail = make_shared<DescribeVodDomainDetailResponseBodyDomainDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVodDomainDetailResponseBody() = default;
};
class DescribeVodDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodDomainDetailResponseBody> body{};

  DescribeVodDomainDetailResponse() {}

  explicit DescribeVodDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainDetailResponse() = default;
};
class DescribeVodDomainLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};

  DescribeVodDomainLogRequest() {}

  explicit DescribeVodDomainLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVodDomainLogRequest() = default;
};
class DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> logCount{};
  shared_ptr<DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeVodDomainLogResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeVodDomainLogResponseBodyDomainLogDetails() {}

  explicit DescribeVodDomainLogResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainLogResponseBodyDomainLogDetails() = default;
};
class DescribeVodDomainLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVodDomainLogResponseBodyDomainLogDetails> domainLogDetails{};
  shared_ptr<string> requestId{};

  DescribeVodDomainLogResponseBody() {}

  explicit DescribeVodDomainLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeVodDomainLogResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeVodDomainLogResponseBodyDomainLogDetails>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVodDomainLogResponseBody() = default;
};
class DescribeVodDomainLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodDomainLogResponseBody> body{};

  DescribeVodDomainLogResponse() {}

  explicit DescribeVodDomainLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodDomainLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodDomainLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainLogResponse() = default;
};
class DescribeVodDomainSrcBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVodDomainSrcBpsDataRequest() {}

  explicit DescribeVodDomainSrcBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVodDomainSrcBpsDataRequest() = default;
};
class DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> httpsValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule() {}

  explicit DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule() = default;
};
class DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule>> dataModule{};

  DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval() {}

  explicit DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval() = default;
};
class DescribeVodDomainSrcBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval> srcBpsDataPerInterval{};
  shared_ptr<string> startTime{};

  DescribeVodDomainSrcBpsDataResponseBody() {}

  explicit DescribeVodDomainSrcBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (srcBpsDataPerInterval) {
      res["SrcBpsDataPerInterval"] = srcBpsDataPerInterval ? boost::any(srcBpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SrcBpsDataPerInterval") != m.end() && !m["SrcBpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcBpsDataPerInterval"].type()) {
        DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcBpsDataPerInterval"]));
        srcBpsDataPerInterval = make_shared<DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVodDomainSrcBpsDataResponseBody() = default;
};
class DescribeVodDomainSrcBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodDomainSrcBpsDataResponseBody> body{};

  DescribeVodDomainSrcBpsDataResponse() {}

  explicit DescribeVodDomainSrcBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodDomainSrcBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodDomainSrcBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainSrcBpsDataResponse() = default;
};
class DescribeVodDomainSrcTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVodDomainSrcTrafficDataRequest() {}

  explicit DescribeVodDomainSrcTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVodDomainSrcTrafficDataRequest() = default;
};
class DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> httpsValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule() {}

  explicit DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule() = default;
};
class DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval() {}

  explicit DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval() = default;
};
class DescribeVodDomainSrcTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval> srcTrafficDataPerInterval{};
  shared_ptr<string> startTime{};
  shared_ptr<string> totalTraffic{};

  DescribeVodDomainSrcTrafficDataResponseBody() {}

  explicit DescribeVodDomainSrcTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (srcTrafficDataPerInterval) {
      res["SrcTrafficDataPerInterval"] = srcTrafficDataPerInterval ? boost::any(srcTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalTraffic) {
      res["TotalTraffic"] = boost::any(*totalTraffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SrcTrafficDataPerInterval") != m.end() && !m["SrcTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["SrcTrafficDataPerInterval"].type()) {
        DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SrcTrafficDataPerInterval"]));
        srcTrafficDataPerInterval = make_shared<DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TotalTraffic") != m.end() && !m["TotalTraffic"].empty()) {
      totalTraffic = make_shared<string>(boost::any_cast<string>(m["TotalTraffic"]));
    }
  }


  virtual ~DescribeVodDomainSrcTrafficDataResponseBody() = default;
};
class DescribeVodDomainSrcTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodDomainSrcTrafficDataResponseBody> body{};

  DescribeVodDomainSrcTrafficDataResponse() {}

  explicit DescribeVodDomainSrcTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodDomainSrcTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodDomainSrcTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainSrcTrafficDataResponse() = default;
};
class DescribeVodDomainTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};

  DescribeVodDomainTrafficDataRequest() {}

  explicit DescribeVodDomainTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeVodDomainTrafficDataRequest() = default;
};
class DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> domesticValue{};
  shared_ptr<string> httpsDomesticValue{};
  shared_ptr<string> httpsOverseasValue{};
  shared_ptr<string> httpsValue{};
  shared_ptr<string> overseasValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domesticValue) {
      res["DomesticValue"] = boost::any(*domesticValue);
    }
    if (httpsDomesticValue) {
      res["HttpsDomesticValue"] = boost::any(*httpsDomesticValue);
    }
    if (httpsOverseasValue) {
      res["HttpsOverseasValue"] = boost::any(*httpsOverseasValue);
    }
    if (httpsValue) {
      res["HttpsValue"] = boost::any(*httpsValue);
    }
    if (overseasValue) {
      res["OverseasValue"] = boost::any(*overseasValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomesticValue") != m.end() && !m["DomesticValue"].empty()) {
      domesticValue = make_shared<string>(boost::any_cast<string>(m["DomesticValue"]));
    }
    if (m.find("HttpsDomesticValue") != m.end() && !m["HttpsDomesticValue"].empty()) {
      httpsDomesticValue = make_shared<string>(boost::any_cast<string>(m["HttpsDomesticValue"]));
    }
    if (m.find("HttpsOverseasValue") != m.end() && !m["HttpsOverseasValue"].empty()) {
      httpsOverseasValue = make_shared<string>(boost::any_cast<string>(m["HttpsOverseasValue"]));
    }
    if (m.find("HttpsValue") != m.end() && !m["HttpsValue"].empty()) {
      httpsValue = make_shared<string>(boost::any_cast<string>(m["HttpsValue"]));
    }
    if (m.find("OverseasValue") != m.end() && !m["OverseasValue"].empty()) {
      overseasValue = make_shared<string>(boost::any_cast<string>(m["OverseasValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeVodDomainTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> totalTraffic{};
  shared_ptr<DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeVodDomainTrafficDataResponseBody() {}

  explicit DescribeVodDomainTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalTraffic) {
      res["TotalTraffic"] = boost::any(*totalTraffic);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TotalTraffic") != m.end() && !m["TotalTraffic"].empty()) {
      totalTraffic = make_shared<string>(boost::any_cast<string>(m["TotalTraffic"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainTrafficDataResponseBody() = default;
};
class DescribeVodDomainTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodDomainTrafficDataResponseBody> body{};

  DescribeVodDomainTrafficDataResponse() {}

  explicit DescribeVodDomainTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodDomainTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodDomainTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainTrafficDataResponse() = default;
};
class DescribeVodDomainUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> field{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  DescribeVodDomainUsageDataRequest() {}

  explicit DescribeVodDomainUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeVodDomainUsageDataRequest() = default;
};
class DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule() {}

  explicit DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule() = default;
};
class DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule>> dataModule{};

  DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval() {}

  explicit DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval() = default;
};
class DescribeVodDomainUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};
  shared_ptr<DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval> usageDataPerInterval{};

  DescribeVodDomainUsageDataResponseBody() {}

  explicit DescribeVodDomainUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usageDataPerInterval) {
      res["UsageDataPerInterval"] = usageDataPerInterval ? boost::any(usageDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UsageDataPerInterval") != m.end() && !m["UsageDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsageDataPerInterval"].type()) {
        DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsageDataPerInterval"]));
        usageDataPerInterval = make_shared<DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainUsageDataResponseBody() = default;
};
class DescribeVodDomainUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodDomainUsageDataResponseBody> body{};

  DescribeVodDomainUsageDataResponse() {}

  explicit DescribeVodDomainUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodDomainUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodDomainUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodDomainUsageDataResponse() = default;
};
class DescribeVodRefreshQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeVodRefreshQuotaRequest() {}

  explicit DescribeVodRefreshQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeVodRefreshQuotaRequest() = default;
};
class DescribeVodRefreshQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> blockQuota{};
  shared_ptr<string> dirQuota{};
  shared_ptr<string> dirRemain{};
  shared_ptr<string> preloadQuota{};
  shared_ptr<string> preloadRemain{};
  shared_ptr<string> requestId{};
  shared_ptr<string> urlQuota{};
  shared_ptr<string> urlRemain{};
  shared_ptr<string> blockRemain{};

  DescribeVodRefreshQuotaResponseBody() {}

  explicit DescribeVodRefreshQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockQuota) {
      res["BlockQuota"] = boost::any(*blockQuota);
    }
    if (dirQuota) {
      res["DirQuota"] = boost::any(*dirQuota);
    }
    if (dirRemain) {
      res["DirRemain"] = boost::any(*dirRemain);
    }
    if (preloadQuota) {
      res["PreloadQuota"] = boost::any(*preloadQuota);
    }
    if (preloadRemain) {
      res["PreloadRemain"] = boost::any(*preloadRemain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (urlQuota) {
      res["UrlQuota"] = boost::any(*urlQuota);
    }
    if (urlRemain) {
      res["UrlRemain"] = boost::any(*urlRemain);
    }
    if (blockRemain) {
      res["blockRemain"] = boost::any(*blockRemain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockQuota") != m.end() && !m["BlockQuota"].empty()) {
      blockQuota = make_shared<string>(boost::any_cast<string>(m["BlockQuota"]));
    }
    if (m.find("DirQuota") != m.end() && !m["DirQuota"].empty()) {
      dirQuota = make_shared<string>(boost::any_cast<string>(m["DirQuota"]));
    }
    if (m.find("DirRemain") != m.end() && !m["DirRemain"].empty()) {
      dirRemain = make_shared<string>(boost::any_cast<string>(m["DirRemain"]));
    }
    if (m.find("PreloadQuota") != m.end() && !m["PreloadQuota"].empty()) {
      preloadQuota = make_shared<string>(boost::any_cast<string>(m["PreloadQuota"]));
    }
    if (m.find("PreloadRemain") != m.end() && !m["PreloadRemain"].empty()) {
      preloadRemain = make_shared<string>(boost::any_cast<string>(m["PreloadRemain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UrlQuota") != m.end() && !m["UrlQuota"].empty()) {
      urlQuota = make_shared<string>(boost::any_cast<string>(m["UrlQuota"]));
    }
    if (m.find("UrlRemain") != m.end() && !m["UrlRemain"].empty()) {
      urlRemain = make_shared<string>(boost::any_cast<string>(m["UrlRemain"]));
    }
    if (m.find("blockRemain") != m.end() && !m["blockRemain"].empty()) {
      blockRemain = make_shared<string>(boost::any_cast<string>(m["blockRemain"]));
    }
  }


  virtual ~DescribeVodRefreshQuotaResponseBody() = default;
};
class DescribeVodRefreshQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodRefreshQuotaResponseBody> body{};

  DescribeVodRefreshQuotaResponse() {}

  explicit DescribeVodRefreshQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodRefreshQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodRefreshQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodRefreshQuotaResponse() = default;
};
class DescribeVodRefreshTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeVodRefreshTasksRequest() {}

  explicit DescribeVodRefreshTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeVodRefreshTasksRequest() = default;
};
class DescribeVodRefreshTasksResponseBodyTasksTask : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<string> process{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeVodRefreshTasksResponseBodyTasksTask() {}

  explicit DescribeVodRefreshTasksResponseBodyTasksTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeVodRefreshTasksResponseBodyTasksTask() = default;
};
class DescribeVodRefreshTasksResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodRefreshTasksResponseBodyTasksTask>> task{};

  DescribeVodRefreshTasksResponseBodyTasks() {}

  explicit DescribeVodRefreshTasksResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (task) {
      vector<boost::any> temp1;
      for(auto item1:*task){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Task"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(vector<boost::any>) == m["Task"].type()) {
        vector<DescribeVodRefreshTasksResponseBodyTasksTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Task"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodRefreshTasksResponseBodyTasksTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        task = make_shared<vector<DescribeVodRefreshTasksResponseBodyTasksTask>>(expect1);
      }
    }
  }


  virtual ~DescribeVodRefreshTasksResponseBodyTasks() = default;
};
class DescribeVodRefreshTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVodRefreshTasksResponseBodyTasks> tasks{};
  shared_ptr<long> totalCount{};

  DescribeVodRefreshTasksResponseBody() {}

  explicit DescribeVodRefreshTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      res["Tasks"] = tasks ? boost::any(tasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tasks"].type()) {
        DescribeVodRefreshTasksResponseBodyTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tasks"]));
        tasks = make_shared<DescribeVodRefreshTasksResponseBodyTasks>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeVodRefreshTasksResponseBody() = default;
};
class DescribeVodRefreshTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodRefreshTasksResponseBody> body{};

  DescribeVodRefreshTasksResponse() {}

  explicit DescribeVodRefreshTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodRefreshTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodRefreshTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodRefreshTasksResponse() = default;
};
class DescribeVodStorageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> startTime{};
  shared_ptr<string> storage{};
  shared_ptr<string> storageType{};

  DescribeVodStorageDataRequest() {}

  explicit DescribeVodStorageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      storage = make_shared<string>(boost::any_cast<string>(m["Storage"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~DescribeVodStorageDataRequest() = default;
};
class DescribeVodStorageDataResponseBodyStorageDataStorageDataItem : public Darabonba::Model {
public:
  shared_ptr<string> networkOut{};
  shared_ptr<string> storageUtilization{};
  shared_ptr<string> timeStamp{};

  DescribeVodStorageDataResponseBodyStorageDataStorageDataItem() {}

  explicit DescribeVodStorageDataResponseBodyStorageDataStorageDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkOut) {
      res["NetworkOut"] = boost::any(*networkOut);
    }
    if (storageUtilization) {
      res["StorageUtilization"] = boost::any(*storageUtilization);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkOut") != m.end() && !m["NetworkOut"].empty()) {
      networkOut = make_shared<string>(boost::any_cast<string>(m["NetworkOut"]));
    }
    if (m.find("StorageUtilization") != m.end() && !m["StorageUtilization"].empty()) {
      storageUtilization = make_shared<string>(boost::any_cast<string>(m["StorageUtilization"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeVodStorageDataResponseBodyStorageDataStorageDataItem() = default;
};
class DescribeVodStorageDataResponseBodyStorageData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodStorageDataResponseBodyStorageDataStorageDataItem>> storageDataItem{};

  DescribeVodStorageDataResponseBodyStorageData() {}

  explicit DescribeVodStorageDataResponseBodyStorageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (storageDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*storageDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StorageDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StorageDataItem") != m.end() && !m["StorageDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["StorageDataItem"].type()) {
        vector<DescribeVodStorageDataResponseBodyStorageDataStorageDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StorageDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodStorageDataResponseBodyStorageDataStorageDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        storageDataItem = make_shared<vector<DescribeVodStorageDataResponseBodyStorageDataStorageDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeVodStorageDataResponseBodyStorageData() = default;
};
class DescribeVodStorageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVodStorageDataResponseBodyStorageData> storageData{};

  DescribeVodStorageDataResponseBody() {}

  explicit DescribeVodStorageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (storageData) {
      res["StorageData"] = storageData ? boost::any(storageData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StorageData") != m.end() && !m["StorageData"].empty()) {
      if (typeid(map<string, boost::any>) == m["StorageData"].type()) {
        DescribeVodStorageDataResponseBodyStorageData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StorageData"]));
        storageData = make_shared<DescribeVodStorageDataResponseBodyStorageData>(model1);
      }
    }
  }


  virtual ~DescribeVodStorageDataResponseBody() = default;
};
class DescribeVodStorageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodStorageDataResponseBody> body{};

  DescribeVodStorageDataResponse() {}

  explicit DescribeVodStorageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodStorageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodStorageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodStorageDataResponse() = default;
};
class DescribeVodTranscodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> specification{};
  shared_ptr<string> startTime{};
  shared_ptr<string> storage{};

  DescribeVodTranscodeDataRequest() {}

  explicit DescribeVodTranscodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (storage) {
      res["Storage"] = boost::any(*storage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Storage") != m.end() && !m["Storage"].empty()) {
      storage = make_shared<string>(boost::any_cast<string>(m["Storage"]));
    }
  }


  virtual ~DescribeVodTranscodeDataRequest() = default;
};
class DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem() {}

  explicit DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem() = default;
};
class DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem>> dataItem{};

  DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData() {}

  explicit DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataItem) {
      vector<boost::any> temp1;
      for(auto item1:*dataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataItem") != m.end() && !m["DataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DataItem"].type()) {
        vector<DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataItem = make_shared<vector<DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData() = default;
};
class DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem : public Darabonba::Model {
public:
  shared_ptr<DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData> data{};
  shared_ptr<string> timeStamp{};

  DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem() {}

  explicit DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData>(model1);
      }
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem() = default;
};
class DescribeVodTranscodeDataResponseBodyTranscodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem>> transcodeDataItem{};

  DescribeVodTranscodeDataResponseBodyTranscodeData() {}

  explicit DescribeVodTranscodeDataResponseBodyTranscodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeDataItem") != m.end() && !m["TranscodeDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeDataItem"].type()) {
        vector<DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeDataItem = make_shared<vector<DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeVodTranscodeDataResponseBodyTranscodeData() = default;
};
class DescribeVodTranscodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVodTranscodeDataResponseBodyTranscodeData> transcodeData{};

  DescribeVodTranscodeDataResponseBody() {}

  explicit DescribeVodTranscodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeData) {
      res["TranscodeData"] = transcodeData ? boost::any(transcodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeData") != m.end() && !m["TranscodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeData"].type()) {
        DescribeVodTranscodeDataResponseBodyTranscodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeData"]));
        transcodeData = make_shared<DescribeVodTranscodeDataResponseBodyTranscodeData>(model1);
      }
    }
  }


  virtual ~DescribeVodTranscodeDataResponseBody() = default;
};
class DescribeVodTranscodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodTranscodeDataResponseBody> body{};

  DescribeVodTranscodeDataResponse() {}

  explicit DescribeVodTranscodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodTranscodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodTranscodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodTranscodeDataResponse() = default;
};
class DescribeVodUserDomainsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVodUserDomainsRequestTag() {}

  explicit DescribeVodUserDomainsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVodUserDomainsRequestTag() = default;
};
class DescribeVodUserDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSearchType{};
  shared_ptr<string> domainStatus{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeVodUserDomainsRequestTag>> tag{};

  DescribeVodUserDomainsRequest() {}

  explicit DescribeVodUserDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSearchType) {
      res["DomainSearchType"] = boost::any(*domainSearchType);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSearchType") != m.end() && !m["DomainSearchType"].empty()) {
      domainSearchType = make_shared<string>(boost::any_cast<string>(m["DomainSearchType"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVodUserDomainsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodUserDomainsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVodUserDomainsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeVodUserDomainsRequest() = default;
};
class DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};

  DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource() {}

  explicit DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource() = default;
};
class DescribeVodUserDomainsResponseBodyDomainsPageDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource>> source{};

  DescribeVodUserDomainsResponseBodyDomainsPageDataSources() {}

  explicit DescribeVodUserDomainsResponseBodyDomainsPageDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeVodUserDomainsResponseBodyDomainsPageDataSources() = default;
};
class DescribeVodUserDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> sandbox{};
  shared_ptr<DescribeVodUserDomainsResponseBodyDomainsPageDataSources> sources{};
  shared_ptr<string> sslProtocol{};

  DescribeVodUserDomainsResponseBodyDomainsPageData() {}

  explicit DescribeVodUserDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sslProtocol) {
      res["SslProtocol"] = boost::any(*sslProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<string>(boost::any_cast<string>(m["Sandbox"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeVodUserDomainsResponseBodyDomainsPageDataSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeVodUserDomainsResponseBodyDomainsPageDataSources>(model1);
      }
    }
    if (m.find("SslProtocol") != m.end() && !m["SslProtocol"].empty()) {
      sslProtocol = make_shared<string>(boost::any_cast<string>(m["SslProtocol"]));
    }
  }


  virtual ~DescribeVodUserDomainsResponseBodyDomainsPageData() = default;
};
class DescribeVodUserDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVodUserDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeVodUserDomainsResponseBodyDomains() {}

  explicit DescribeVodUserDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeVodUserDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVodUserDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeVodUserDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeVodUserDomainsResponseBodyDomains() = default;
};
class DescribeVodUserDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeVodUserDomainsResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeVodUserDomainsResponseBody() {}

  explicit DescribeVodUserDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeVodUserDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeVodUserDomainsResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeVodUserDomainsResponseBody() = default;
};
class DescribeVodUserDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodUserDomainsResponseBody> body{};

  DescribeVodUserDomainsResponse() {}

  explicit DescribeVodUserDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodUserDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodUserDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodUserDomainsResponse() = default;
};
class DescribeVodVerifyContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};

  DescribeVodVerifyContentRequest() {}

  explicit DescribeVodVerifyContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeVodVerifyContentRequest() = default;
};
class DescribeVodVerifyContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeVodVerifyContentResponseBody() {}

  explicit DescribeVodVerifyContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeVodVerifyContentResponseBody() = default;
};
class DescribeVodVerifyContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVodVerifyContentResponseBody> body{};

  DescribeVodVerifyContentResponse() {}

  explicit DescribeVodVerifyContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVodVerifyContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVodVerifyContentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVodVerifyContentResponse() = default;
};
class DetachAppPolicyFromIdentityRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> identityName{};
  shared_ptr<string> identityType{};
  shared_ptr<string> policyNames{};

  DetachAppPolicyFromIdentityRequest() {}

  explicit DetachAppPolicyFromIdentityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (identityName) {
      res["IdentityName"] = boost::any(*identityName);
    }
    if (identityType) {
      res["IdentityType"] = boost::any(*identityType);
    }
    if (policyNames) {
      res["PolicyNames"] = boost::any(*policyNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("IdentityName") != m.end() && !m["IdentityName"].empty()) {
      identityName = make_shared<string>(boost::any_cast<string>(m["IdentityName"]));
    }
    if (m.find("IdentityType") != m.end() && !m["IdentityType"].empty()) {
      identityType = make_shared<string>(boost::any_cast<string>(m["IdentityType"]));
    }
    if (m.find("PolicyNames") != m.end() && !m["PolicyNames"].empty()) {
      policyNames = make_shared<string>(boost::any_cast<string>(m["PolicyNames"]));
    }
  }


  virtual ~DetachAppPolicyFromIdentityRequest() = default;
};
class DetachAppPolicyFromIdentityResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failedPolicyNames{};
  shared_ptr<vector<string>> nonExistPolicyNames{};
  shared_ptr<string> requestId{};

  DetachAppPolicyFromIdentityResponseBody() {}

  explicit DetachAppPolicyFromIdentityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedPolicyNames) {
      res["FailedPolicyNames"] = boost::any(*failedPolicyNames);
    }
    if (nonExistPolicyNames) {
      res["NonExistPolicyNames"] = boost::any(*nonExistPolicyNames);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedPolicyNames") != m.end() && !m["FailedPolicyNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailedPolicyNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailedPolicyNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failedPolicyNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NonExistPolicyNames") != m.end() && !m["NonExistPolicyNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistPolicyNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistPolicyNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistPolicyNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachAppPolicyFromIdentityResponseBody() = default;
};
class DetachAppPolicyFromIdentityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachAppPolicyFromIdentityResponseBody> body{};

  DetachAppPolicyFromIdentityResponse() {}

  explicit DetachAppPolicyFromIdentityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachAppPolicyFromIdentityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachAppPolicyFromIdentityResponseBody>(model1);
      }
    }
  }


  virtual ~DetachAppPolicyFromIdentityResponse() = default;
};
class GenerateDownloadSecretKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> appDecryptKey{};
  shared_ptr<string> appIdentification{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  GenerateDownloadSecretKeyRequest() {}

  explicit GenerateDownloadSecretKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appDecryptKey) {
      res["AppDecryptKey"] = boost::any(*appDecryptKey);
    }
    if (appIdentification) {
      res["AppIdentification"] = boost::any(*appIdentification);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppDecryptKey") != m.end() && !m["AppDecryptKey"].empty()) {
      appDecryptKey = make_shared<string>(boost::any_cast<string>(m["AppDecryptKey"]));
    }
    if (m.find("AppIdentification") != m.end() && !m["AppIdentification"].empty()) {
      appIdentification = make_shared<string>(boost::any_cast<string>(m["AppIdentification"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GenerateDownloadSecretKeyRequest() = default;
};
class GenerateDownloadSecretKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appEncryptKey{};
  shared_ptr<string> requestId{};

  GenerateDownloadSecretKeyResponseBody() {}

  explicit GenerateDownloadSecretKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appEncryptKey) {
      res["AppEncryptKey"] = boost::any(*appEncryptKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppEncryptKey") != m.end() && !m["AppEncryptKey"].empty()) {
      appEncryptKey = make_shared<string>(boost::any_cast<string>(m["AppEncryptKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateDownloadSecretKeyResponseBody() = default;
};
class GenerateDownloadSecretKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateDownloadSecretKeyResponseBody> body{};

  GenerateDownloadSecretKeyResponse() {}

  explicit GenerateDownloadSecretKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateDownloadSecretKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateDownloadSecretKeyResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateDownloadSecretKeyResponse() = default;
};
class GenerateKMSDataKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  GenerateKMSDataKeyRequest() {}

  explicit GenerateKMSDataKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GenerateKMSDataKeyRequest() = default;
};
class GenerateKMSDataKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ciphertextBlob{};
  shared_ptr<string> keyId{};
  shared_ptr<string> plaintext{};
  shared_ptr<string> requestId{};

  GenerateKMSDataKeyResponseBody() {}

  explicit GenerateKMSDataKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ciphertextBlob) {
      res["CiphertextBlob"] = boost::any(*ciphertextBlob);
    }
    if (keyId) {
      res["KeyId"] = boost::any(*keyId);
    }
    if (plaintext) {
      res["Plaintext"] = boost::any(*plaintext);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CiphertextBlob") != m.end() && !m["CiphertextBlob"].empty()) {
      ciphertextBlob = make_shared<string>(boost::any_cast<string>(m["CiphertextBlob"]));
    }
    if (m.find("KeyId") != m.end() && !m["KeyId"].empty()) {
      keyId = make_shared<string>(boost::any_cast<string>(m["KeyId"]));
    }
    if (m.find("Plaintext") != m.end() && !m["Plaintext"].empty()) {
      plaintext = make_shared<string>(boost::any_cast<string>(m["Plaintext"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateKMSDataKeyResponseBody() = default;
};
class GenerateKMSDataKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateKMSDataKeyResponseBody> body{};

  GenerateKMSDataKeyResponse() {}

  explicit GenerateKMSDataKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateKMSDataKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateKMSDataKeyResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateKMSDataKeyResponse() = default;
};
class GetAIImageJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  GetAIImageJobsRequest() {}

  explicit GetAIImageJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetAIImageJobsRequest() = default;
};
class GetAIImageJobsResponseBodyAIImageJobList : public Darabonba::Model {
public:
  shared_ptr<string> AIImageResult{};
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> status{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};
  shared_ptr<string> videoId{};

  GetAIImageJobsResponseBodyAIImageJobList() {}

  explicit GetAIImageJobsResponseBodyAIImageJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIImageResult) {
      res["AIImageResult"] = boost::any(*AIImageResult);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIImageResult") != m.end() && !m["AIImageResult"].empty()) {
      AIImageResult = make_shared<string>(boost::any_cast<string>(m["AIImageResult"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetAIImageJobsResponseBodyAIImageJobList() = default;
};
class GetAIImageJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetAIImageJobsResponseBodyAIImageJobList>> AIImageJobList{};
  shared_ptr<string> requestId{};

  GetAIImageJobsResponseBody() {}

  explicit GetAIImageJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIImageJobList) {
      vector<boost::any> temp1;
      for(auto item1:*AIImageJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AIImageJobList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIImageJobList") != m.end() && !m["AIImageJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["AIImageJobList"].type()) {
        vector<GetAIImageJobsResponseBodyAIImageJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AIImageJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIImageJobsResponseBodyAIImageJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        AIImageJobList = make_shared<vector<GetAIImageJobsResponseBodyAIImageJobList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAIImageJobsResponseBody() = default;
};
class GetAIImageJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAIImageJobsResponseBody> body{};

  GetAIImageJobsResponse() {}

  explicit GetAIImageJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAIImageJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAIImageJobsResponseBody>(model1);
      }
    }
  }


  virtual ~GetAIImageJobsResponse() = default;
};
class GetAIMediaAuditJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetAIMediaAuditJobRequest() {}

  explicit GetAIMediaAuditJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetAIMediaAuditJobRequest() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> score{};
  shared_ptr<string> suggestion{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> score{};
  shared_ptr<string> suggestion{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult>> result{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult>>(expect1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> score{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> type{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList>> counterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList>> topList{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (counterList) {
      vector<boost::any> temp1;
      for(auto item1:*counterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CounterList"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (topList) {
      vector<boost::any> temp1;
      for(auto item1:*topList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("CounterList") != m.end() && !m["CounterList"].empty()) {
      if (typeid(vector<boost::any>) == m["CounterList"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CounterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counterList = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TopList") != m.end() && !m["TopList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopList"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topList = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList>>(expect1);
      }
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList>> counterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList>> topList{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (counterList) {
      vector<boost::any> temp1;
      for(auto item1:*counterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CounterList"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (topList) {
      vector<boost::any> temp1;
      for(auto item1:*topList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("CounterList") != m.end() && !m["CounterList"].empty()) {
      if (typeid(vector<boost::any>) == m["CounterList"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CounterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counterList = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TopList") != m.end() && !m["TopList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopList"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topList = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList>>(expect1);
      }
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList>> counterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList>> topList{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (counterList) {
      vector<boost::any> temp1;
      for(auto item1:*counterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CounterList"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (topList) {
      vector<boost::any> temp1;
      for(auto item1:*topList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("CounterList") != m.end() && !m["CounterList"].empty()) {
      if (typeid(vector<boost::any>) == m["CounterList"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CounterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counterList = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TopList") != m.end() && !m["TopList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopList"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topList = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList>>(expect1);
      }
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList>> counterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList>> topList{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (counterList) {
      vector<boost::any> temp1;
      for(auto item1:*counterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CounterList"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (topList) {
      vector<boost::any> temp1;
      for(auto item1:*topList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("CounterList") != m.end() && !m["CounterList"].empty()) {
      if (typeid(vector<boost::any>) == m["CounterList"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CounterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counterList = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TopList") != m.end() && !m["TopList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopList"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topList = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList>>(expect1);
      }
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList>> counterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList>> topList{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (counterList) {
      vector<boost::any> temp1;
      for(auto item1:*counterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CounterList"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (topList) {
      vector<boost::any> temp1;
      for(auto item1:*topList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("CounterList") != m.end() && !m["CounterList"].empty()) {
      if (typeid(vector<boost::any>) == m["CounterList"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CounterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counterList = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TopList") != m.end() && !m["TopList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopList"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topList = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList>>(expect1);
      }
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult : public Darabonba::Model {
public:
  shared_ptr<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult> adResult{};
  shared_ptr<string> label{};
  shared_ptr<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult> liveResult{};
  shared_ptr<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult> logoResult{};
  shared_ptr<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult> pornResult{};
  shared_ptr<string> suggestion{};
  shared_ptr<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult> terrorismResult{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adResult) {
      res["AdResult"] = adResult ? boost::any(adResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (liveResult) {
      res["LiveResult"] = liveResult ? boost::any(liveResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logoResult) {
      res["LogoResult"] = logoResult ? boost::any(logoResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pornResult) {
      res["PornResult"] = pornResult ? boost::any(pornResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (terrorismResult) {
      res["TerrorismResult"] = terrorismResult ? boost::any(terrorismResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdResult") != m.end() && !m["AdResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdResult"].type()) {
        GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdResult"]));
        adResult = make_shared<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult>(model1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("LiveResult") != m.end() && !m["LiveResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveResult"].type()) {
        GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveResult"]));
        liveResult = make_shared<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult>(model1);
      }
    }
    if (m.find("LogoResult") != m.end() && !m["LogoResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogoResult"].type()) {
        GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogoResult"]));
        logoResult = make_shared<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult>(model1);
      }
    }
    if (m.find("PornResult") != m.end() && !m["PornResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornResult"].type()) {
        GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornResult"]));
        pornResult = make_shared<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult>(model1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TerrorismResult") != m.end() && !m["TerrorismResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismResult"].type()) {
        GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismResult"]));
        terrorismResult = make_shared<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult>(model1);
      }
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJobData : public Darabonba::Model {
public:
  shared_ptr<string> abnormalModules{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult>> audioResult{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult>> imageResult{};
  shared_ptr<string> label{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult>> textResult{};
  shared_ptr<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult> videoResult{};

  GetAIMediaAuditJobResponseBodyMediaAuditJobData() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJobData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalModules) {
      res["AbnormalModules"] = boost::any(*abnormalModules);
    }
    if (audioResult) {
      vector<boost::any> temp1;
      for(auto item1:*audioResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioResult"] = boost::any(temp1);
    }
    if (imageResult) {
      vector<boost::any> temp1;
      for(auto item1:*imageResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageResult"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (textResult) {
      vector<boost::any> temp1;
      for(auto item1:*textResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextResult"] = boost::any(temp1);
    }
    if (videoResult) {
      res["VideoResult"] = videoResult ? boost::any(videoResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalModules") != m.end() && !m["AbnormalModules"].empty()) {
      abnormalModules = make_shared<string>(boost::any_cast<string>(m["AbnormalModules"]));
    }
    if (m.find("AudioResult") != m.end() && !m["AudioResult"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioResult"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioResult = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult>>(expect1);
      }
    }
    if (m.find("ImageResult") != m.end() && !m["ImageResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageResult"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageResult = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TextResult") != m.end() && !m["TextResult"].empty()) {
      if (typeid(vector<boost::any>) == m["TextResult"].type()) {
        vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textResult = make_shared<vector<GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult>>(expect1);
      }
    }
    if (m.find("VideoResult") != m.end() && !m["VideoResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoResult"].type()) {
        GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoResult"]));
        videoResult = make_shared<GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult>(model1);
      }
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJobData() = default;
};
class GetAIMediaAuditJobResponseBodyMediaAuditJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<GetAIMediaAuditJobResponseBodyMediaAuditJobData> data{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> message{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetAIMediaAuditJobResponseBodyMediaAuditJob() {}

  explicit GetAIMediaAuditJobResponseBodyMediaAuditJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAIMediaAuditJobResponseBodyMediaAuditJobData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAIMediaAuditJobResponseBodyMediaAuditJobData>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBodyMediaAuditJob() = default;
};
class GetAIMediaAuditJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAIMediaAuditJobResponseBodyMediaAuditJob> mediaAuditJob{};
  shared_ptr<string> requestId{};

  GetAIMediaAuditJobResponseBody() {}

  explicit GetAIMediaAuditJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaAuditJob) {
      res["MediaAuditJob"] = mediaAuditJob ? boost::any(mediaAuditJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaAuditJob") != m.end() && !m["MediaAuditJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaAuditJob"].type()) {
        GetAIMediaAuditJobResponseBodyMediaAuditJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaAuditJob"]));
        mediaAuditJob = make_shared<GetAIMediaAuditJobResponseBodyMediaAuditJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAIMediaAuditJobResponseBody() = default;
};
class GetAIMediaAuditJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAIMediaAuditJobResponseBody> body{};

  GetAIMediaAuditJobResponse() {}

  explicit GetAIMediaAuditJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAIMediaAuditJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAIMediaAuditJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetAIMediaAuditJobResponse() = default;
};
class GetAITemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  GetAITemplateRequest() {}

  explicit GetAITemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetAITemplateRequest() = default;
};
class GetAITemplateResponseBodyTemplateInfo : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> source{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  GetAITemplateResponseBodyTemplateInfo() {}

  explicit GetAITemplateResponseBodyTemplateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~GetAITemplateResponseBodyTemplateInfo() = default;
};
class GetAITemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAITemplateResponseBodyTemplateInfo> templateInfo{};

  GetAITemplateResponseBody() {}

  explicit GetAITemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateInfo) {
      res["TemplateInfo"] = templateInfo ? boost::any(templateInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateInfo") != m.end() && !m["TemplateInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateInfo"].type()) {
        GetAITemplateResponseBodyTemplateInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateInfo"]));
        templateInfo = make_shared<GetAITemplateResponseBodyTemplateInfo>(model1);
      }
    }
  }


  virtual ~GetAITemplateResponseBody() = default;
};
class GetAITemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAITemplateResponseBody> body{};

  GetAITemplateResponse() {}

  explicit GetAITemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAITemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAITemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetAITemplateResponse() = default;
};
class GetAIVideoTagResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  GetAIVideoTagResultRequest() {}

  explicit GetAIVideoTagResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetAIVideoTagResultRequest() = default;
};
class GetAIVideoTagResultResponseBodyVideoTagResultCategory : public Darabonba::Model {
public:
  shared_ptr<string> tag{};

  GetAIVideoTagResultResponseBodyVideoTagResultCategory() {}

  explicit GetAIVideoTagResultResponseBodyVideoTagResultCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~GetAIVideoTagResultResponseBodyVideoTagResultCategory() = default;
};
class GetAIVideoTagResultResponseBodyVideoTagResultKeyword : public Darabonba::Model {
public:
  shared_ptr<string> tag{};
  shared_ptr<vector<string>> times{};

  GetAIVideoTagResultResponseBodyVideoTagResultKeyword() {}

  explicit GetAIVideoTagResultResponseBodyVideoTagResultKeyword(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Times"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Times"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      times = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetAIVideoTagResultResponseBodyVideoTagResultKeyword() = default;
};
class GetAIVideoTagResultResponseBodyVideoTagResultLocation : public Darabonba::Model {
public:
  shared_ptr<string> tag{};
  shared_ptr<vector<string>> times{};

  GetAIVideoTagResultResponseBodyVideoTagResultLocation() {}

  explicit GetAIVideoTagResultResponseBodyVideoTagResultLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Times"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Times"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      times = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetAIVideoTagResultResponseBodyVideoTagResultLocation() = default;
};
class GetAIVideoTagResultResponseBodyVideoTagResultPerson : public Darabonba::Model {
public:
  shared_ptr<string> faceUrl{};
  shared_ptr<string> tag{};
  shared_ptr<vector<string>> times{};

  GetAIVideoTagResultResponseBodyVideoTagResultPerson() {}

  explicit GetAIVideoTagResultResponseBodyVideoTagResultPerson(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (faceUrl) {
      res["FaceUrl"] = boost::any(*faceUrl);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FaceUrl") != m.end() && !m["FaceUrl"].empty()) {
      faceUrl = make_shared<string>(boost::any_cast<string>(m["FaceUrl"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Times"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Times"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      times = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetAIVideoTagResultResponseBodyVideoTagResultPerson() = default;
};
class GetAIVideoTagResultResponseBodyVideoTagResultTime : public Darabonba::Model {
public:
  shared_ptr<string> tag{};
  shared_ptr<vector<string>> times{};

  GetAIVideoTagResultResponseBodyVideoTagResultTime() {}

  explicit GetAIVideoTagResultResponseBodyVideoTagResultTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (times) {
      res["Times"] = boost::any(*times);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Times") != m.end() && !m["Times"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Times"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Times"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      times = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetAIVideoTagResultResponseBodyVideoTagResultTime() = default;
};
class GetAIVideoTagResultResponseBodyVideoTagResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetAIVideoTagResultResponseBodyVideoTagResultCategory>> category{};
  shared_ptr<vector<GetAIVideoTagResultResponseBodyVideoTagResultKeyword>> keyword{};
  shared_ptr<vector<GetAIVideoTagResultResponseBodyVideoTagResultLocation>> location{};
  shared_ptr<vector<GetAIVideoTagResultResponseBodyVideoTagResultPerson>> person{};
  shared_ptr<vector<GetAIVideoTagResultResponseBodyVideoTagResultTime>> time{};

  GetAIVideoTagResultResponseBodyVideoTagResult() {}

  explicit GetAIVideoTagResultResponseBodyVideoTagResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    if (keyword) {
      vector<boost::any> temp1;
      for(auto item1:*keyword){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Keyword"] = boost::any(temp1);
    }
    if (location) {
      vector<boost::any> temp1;
      for(auto item1:*location){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Location"] = boost::any(temp1);
    }
    if (person) {
      vector<boost::any> temp1;
      for(auto item1:*person){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Person"] = boost::any(temp1);
    }
    if (time) {
      vector<boost::any> temp1;
      for(auto item1:*time){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Time"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<GetAIVideoTagResultResponseBodyVideoTagResultCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIVideoTagResultResponseBodyVideoTagResultCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<GetAIVideoTagResultResponseBodyVideoTagResultCategory>>(expect1);
      }
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      if (typeid(vector<boost::any>) == m["Keyword"].type()) {
        vector<GetAIVideoTagResultResponseBodyVideoTagResultKeyword> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Keyword"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIVideoTagResultResponseBodyVideoTagResultKeyword model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyword = make_shared<vector<GetAIVideoTagResultResponseBodyVideoTagResultKeyword>>(expect1);
      }
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      if (typeid(vector<boost::any>) == m["Location"].type()) {
        vector<GetAIVideoTagResultResponseBodyVideoTagResultLocation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Location"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIVideoTagResultResponseBodyVideoTagResultLocation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        location = make_shared<vector<GetAIVideoTagResultResponseBodyVideoTagResultLocation>>(expect1);
      }
    }
    if (m.find("Person") != m.end() && !m["Person"].empty()) {
      if (typeid(vector<boost::any>) == m["Person"].type()) {
        vector<GetAIVideoTagResultResponseBodyVideoTagResultPerson> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Person"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIVideoTagResultResponseBodyVideoTagResultPerson model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        person = make_shared<vector<GetAIVideoTagResultResponseBodyVideoTagResultPerson>>(expect1);
      }
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      if (typeid(vector<boost::any>) == m["Time"].type()) {
        vector<GetAIVideoTagResultResponseBodyVideoTagResultTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Time"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAIVideoTagResultResponseBodyVideoTagResultTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        time = make_shared<vector<GetAIVideoTagResultResponseBodyVideoTagResultTime>>(expect1);
      }
    }
  }


  virtual ~GetAIVideoTagResultResponseBodyVideoTagResult() = default;
};
class GetAIVideoTagResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAIVideoTagResultResponseBodyVideoTagResult> videoTagResult{};

  GetAIVideoTagResultResponseBody() {}

  explicit GetAIVideoTagResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (videoTagResult) {
      res["VideoTagResult"] = videoTagResult ? boost::any(videoTagResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VideoTagResult") != m.end() && !m["VideoTagResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoTagResult"].type()) {
        GetAIVideoTagResultResponseBodyVideoTagResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoTagResult"]));
        videoTagResult = make_shared<GetAIVideoTagResultResponseBodyVideoTagResult>(model1);
      }
    }
  }


  virtual ~GetAIVideoTagResultResponseBody() = default;
};
class GetAIVideoTagResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAIVideoTagResultResponseBody> body{};

  GetAIVideoTagResultResponse() {}

  explicit GetAIVideoTagResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAIVideoTagResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAIVideoTagResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetAIVideoTagResultResponse() = default;
};
class GetAppInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> appIds{};

  GetAppInfosRequest() {}

  explicit GetAppInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
  }


  virtual ~GetAppInfosRequest() = default;
};
class GetAppInfosResponseBodyAppInfoList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetAppInfosResponseBodyAppInfoList() {}

  explicit GetAppInfosResponseBodyAppInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAppInfosResponseBodyAppInfoList() = default;
};
class GetAppInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetAppInfosResponseBodyAppInfoList>> appInfoList{};
  shared_ptr<string> code{};
  shared_ptr<vector<string>> nonExistAppIds{};
  shared_ptr<string> requestId{};

  GetAppInfosResponseBody() {}

  explicit GetAppInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*appInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppInfoList"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (nonExistAppIds) {
      res["NonExistAppIds"] = boost::any(*nonExistAppIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppInfoList") != m.end() && !m["AppInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AppInfoList"].type()) {
        vector<GetAppInfosResponseBodyAppInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAppInfosResponseBodyAppInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appInfoList = make_shared<vector<GetAppInfosResponseBodyAppInfoList>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("NonExistAppIds") != m.end() && !m["NonExistAppIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistAppIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistAppIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistAppIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAppInfosResponseBody() = default;
};
class GetAppInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAppInfosResponseBody> body{};

  GetAppInfosResponse() {}

  explicit GetAppInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAppInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAppInfosResponseBody>(model1);
      }
    }
  }


  virtual ~GetAppInfosResponse() = default;
};
class GetAttachedMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> authTimeout{};
  shared_ptr<string> mediaIds{};
  shared_ptr<string> outputType{};

  GetAttachedMediaInfoRequest() {}

  explicit GetAttachedMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<long>(boost::any_cast<long>(m["AuthTimeout"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
  }


  virtual ~GetAttachedMediaInfoRequest() = default;
};
class GetAttachedMediaInfoResponseBodyAttachedMediaListCategories : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};

  GetAttachedMediaInfoResponseBodyAttachedMediaListCategories() {}

  explicit GetAttachedMediaInfoResponseBodyAttachedMediaListCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~GetAttachedMediaInfoResponseBodyAttachedMediaListCategories() = default;
};
class GetAttachedMediaInfoResponseBodyAttachedMediaList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<vector<GetAttachedMediaInfoResponseBodyAttachedMediaListCategories>> categories{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<string> URL{};

  GetAttachedMediaInfoResponseBodyAttachedMediaList() {}

  explicit GetAttachedMediaInfoResponseBodyAttachedMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Categories"] = boost::any(temp1);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<GetAttachedMediaInfoResponseBodyAttachedMediaListCategories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Categories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAttachedMediaInfoResponseBodyAttachedMediaListCategories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categories = make_shared<vector<GetAttachedMediaInfoResponseBodyAttachedMediaListCategories>>(expect1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~GetAttachedMediaInfoResponseBodyAttachedMediaList() = default;
};
class GetAttachedMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetAttachedMediaInfoResponseBodyAttachedMediaList>> attachedMediaList{};
  shared_ptr<vector<string>> nonExistMediaIds{};
  shared_ptr<string> requestId{};

  GetAttachedMediaInfoResponseBody() {}

  explicit GetAttachedMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachedMediaList) {
      vector<boost::any> temp1;
      for(auto item1:*attachedMediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttachedMediaList"] = boost::any(temp1);
    }
    if (nonExistMediaIds) {
      res["NonExistMediaIds"] = boost::any(*nonExistMediaIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachedMediaList") != m.end() && !m["AttachedMediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["AttachedMediaList"].type()) {
        vector<GetAttachedMediaInfoResponseBodyAttachedMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttachedMediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAttachedMediaInfoResponseBodyAttachedMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachedMediaList = make_shared<vector<GetAttachedMediaInfoResponseBodyAttachedMediaList>>(expect1);
      }
    }
    if (m.find("NonExistMediaIds") != m.end() && !m["NonExistMediaIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistMediaIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistMediaIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistMediaIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAttachedMediaInfoResponseBody() = default;
};
class GetAttachedMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAttachedMediaInfoResponseBody> body{};

  GetAttachedMediaInfoResponse() {}

  explicit GetAttachedMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAttachedMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAttachedMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetAttachedMediaInfoResponse() = default;
};
class GetAuditHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> videoId{};

  GetAuditHistoryRequest() {}

  explicit GetAuditHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetAuditHistoryRequest() = default;
};
class GetAuditHistoryResponseBodyHistories : public Darabonba::Model {
public:
  shared_ptr<string> auditor{};
  shared_ptr<string> comment{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> reason{};
  shared_ptr<string> status{};

  GetAuditHistoryResponseBodyHistories() {}

  explicit GetAuditHistoryResponseBodyHistories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditor) {
      res["Auditor"] = boost::any(*auditor);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Auditor") != m.end() && !m["Auditor"].empty()) {
      auditor = make_shared<string>(boost::any_cast<string>(m["Auditor"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetAuditHistoryResponseBodyHistories() = default;
};
class GetAuditHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetAuditHistoryResponseBodyHistories>> histories{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<long> total{};

  GetAuditHistoryResponseBody() {}

  explicit GetAuditHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (histories) {
      vector<boost::any> temp1;
      for(auto item1:*histories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Histories"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Histories") != m.end() && !m["Histories"].empty()) {
      if (typeid(vector<boost::any>) == m["Histories"].type()) {
        vector<GetAuditHistoryResponseBodyHistories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Histories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAuditHistoryResponseBodyHistories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        histories = make_shared<vector<GetAuditHistoryResponseBodyHistories>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetAuditHistoryResponseBody() = default;
};
class GetAuditHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAuditHistoryResponseBody> body{};

  GetAuditHistoryResponse() {}

  explicit GetAuditHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAuditHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAuditHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~GetAuditHistoryResponse() = default;
};
class GetCategoriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};

  GetCategoriesRequest() {}

  explicit GetCategoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCategoriesRequest() = default;
};
class GetCategoriesResponseBodyCategory : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};
  shared_ptr<string> type{};

  GetCategoriesResponseBodyCategory() {}

  explicit GetCategoriesResponseBodyCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCategoriesResponseBodyCategory() = default;
};
class GetCategoriesResponseBodySubCategoriesCategory : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};
  shared_ptr<long> subTotal{};
  shared_ptr<string> type{};

  GetCategoriesResponseBodySubCategoriesCategory() {}

  explicit GetCategoriesResponseBodySubCategoriesCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (subTotal) {
      res["SubTotal"] = boost::any(*subTotal);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("SubTotal") != m.end() && !m["SubTotal"].empty()) {
      subTotal = make_shared<long>(boost::any_cast<long>(m["SubTotal"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCategoriesResponseBodySubCategoriesCategory() = default;
};
class GetCategoriesResponseBodySubCategories : public Darabonba::Model {
public:
  shared_ptr<vector<GetCategoriesResponseBodySubCategoriesCategory>> category{};

  GetCategoriesResponseBodySubCategories() {}

  explicit GetCategoriesResponseBodySubCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<GetCategoriesResponseBodySubCategoriesCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCategoriesResponseBodySubCategoriesCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<GetCategoriesResponseBodySubCategoriesCategory>>(expect1);
      }
    }
  }


  virtual ~GetCategoriesResponseBodySubCategories() = default;
};
class GetCategoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCategoriesResponseBodyCategory> category{};
  shared_ptr<string> requestId{};
  shared_ptr<GetCategoriesResponseBodySubCategories> subCategories{};
  shared_ptr<long> subTotal{};

  GetCategoriesResponseBody() {}

  explicit GetCategoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = category ? boost::any(category->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCategories) {
      res["SubCategories"] = subCategories ? boost::any(subCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subTotal) {
      res["SubTotal"] = boost::any(*subTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(map<string, boost::any>) == m["Category"].type()) {
        GetCategoriesResponseBodyCategory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Category"]));
        category = make_shared<GetCategoriesResponseBodyCategory>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCategories") != m.end() && !m["SubCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubCategories"].type()) {
        GetCategoriesResponseBodySubCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubCategories"]));
        subCategories = make_shared<GetCategoriesResponseBodySubCategories>(model1);
      }
    }
    if (m.find("SubTotal") != m.end() && !m["SubTotal"].empty()) {
      subTotal = make_shared<long>(boost::any_cast<long>(m["SubTotal"]));
    }
  }


  virtual ~GetCategoriesResponseBody() = default;
};
class GetCategoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCategoriesResponseBody> body{};

  GetCategoriesResponse() {}

  explicit GetCategoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCategoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCategoriesResponseBody>(model1);
      }
    }
  }


  virtual ~GetCategoriesResponse() = default;
};
class GetDefaultAITemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateType{};

  GetDefaultAITemplateRequest() {}

  explicit GetDefaultAITemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~GetDefaultAITemplateRequest() = default;
};
class GetDefaultAITemplateResponseBodyTemplateInfo : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> source{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  GetDefaultAITemplateResponseBodyTemplateInfo() {}

  explicit GetDefaultAITemplateResponseBodyTemplateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~GetDefaultAITemplateResponseBodyTemplateInfo() = default;
};
class GetDefaultAITemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetDefaultAITemplateResponseBodyTemplateInfo> templateInfo{};

  GetDefaultAITemplateResponseBody() {}

  explicit GetDefaultAITemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateInfo) {
      res["TemplateInfo"] = templateInfo ? boost::any(templateInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateInfo") != m.end() && !m["TemplateInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateInfo"].type()) {
        GetDefaultAITemplateResponseBodyTemplateInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateInfo"]));
        templateInfo = make_shared<GetDefaultAITemplateResponseBodyTemplateInfo>(model1);
      }
    }
  }


  virtual ~GetDefaultAITemplateResponseBody() = default;
};
class GetDefaultAITemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDefaultAITemplateResponseBody> body{};

  GetDefaultAITemplateResponse() {}

  explicit GetDefaultAITemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDefaultAITemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDefaultAITemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetDefaultAITemplateResponse() = default;
};
class GetDigitalWatermarkExtractResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> extractType{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  GetDigitalWatermarkExtractResultRequest() {}

  explicit GetDigitalWatermarkExtractResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extractType) {
      res["ExtractType"] = boost::any(*extractType);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtractType") != m.end() && !m["ExtractType"].empty()) {
      extractType = make_shared<string>(boost::any_cast<string>(m["ExtractType"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetDigitalWatermarkExtractResultRequest() = default;
};
class GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> status{};
  shared_ptr<string> waterMarkText{};

  GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList() {}

  explicit GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (waterMarkText) {
      res["WaterMarkText"] = boost::any(*waterMarkText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("WaterMarkText") != m.end() && !m["WaterMarkText"].empty()) {
      waterMarkText = make_shared<string>(boost::any_cast<string>(m["WaterMarkText"]));
    }
  }


  virtual ~GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList() = default;
};
class GetDigitalWatermarkExtractResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList>> aiExtractResultList{};
  shared_ptr<string> requestId{};

  GetDigitalWatermarkExtractResultResponseBody() {}

  explicit GetDigitalWatermarkExtractResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiExtractResultList) {
      vector<boost::any> temp1;
      for(auto item1:*aiExtractResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AiExtractResultList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiExtractResultList") != m.end() && !m["AiExtractResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["AiExtractResultList"].type()) {
        vector<GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AiExtractResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aiExtractResultList = make_shared<vector<GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDigitalWatermarkExtractResultResponseBody() = default;
};
class GetDigitalWatermarkExtractResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDigitalWatermarkExtractResultResponseBody> body{};

  GetDigitalWatermarkExtractResultResponse() {}

  explicit GetDigitalWatermarkExtractResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDigitalWatermarkExtractResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDigitalWatermarkExtractResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetDigitalWatermarkExtractResultResponse() = default;
};
class GetEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  GetEditingProjectRequest() {}

  explicit GetEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetEditingProjectRequest() = default;
};
class GetEditingProjectResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  GetEditingProjectResponseBodyProject() {}

  explicit GetEditingProjectResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetEditingProjectResponseBodyProject() = default;
};
class GetEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetEditingProjectResponseBodyProject> project{};
  shared_ptr<string> requestId{};

  GetEditingProjectResponseBody() {}

  explicit GetEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        GetEditingProjectResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<GetEditingProjectResponseBodyProject>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEditingProjectResponseBody() = default;
};
class GetEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEditingProjectResponseBody> body{};

  GetEditingProjectResponse() {}

  explicit GetEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~GetEditingProjectResponse() = default;
};
class GetEditingProjectMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> materialType{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> type{};

  GetEditingProjectMaterialsRequest() {}

  explicit GetEditingProjectMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialType) {
      res["MaterialType"] = boost::any(*materialType);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialType") != m.end() && !m["MaterialType"].empty()) {
      materialType = make_shared<string>(boost::any_cast<string>(m["MaterialType"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetEditingProjectMaterialsRequest() = default;
};
class GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots : public Darabonba::Model {
public:
  shared_ptr<vector<string>> snapshot{};

  GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots() {}

  explicit GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      res["Snapshot"] = boost::any(*snapshot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Snapshot"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshot = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots() = default;
};
class GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites : public Darabonba::Model {
public:
  shared_ptr<vector<string>> sprite{};

  GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites() {}

  explicit GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sprite) {
      res["Sprite"] = boost::any(*sprite);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sprite") != m.end() && !m["Sprite"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Sprite"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Sprite"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sprite = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites() = default;
};
class GetEditingProjectMaterialsResponseBodyMaterialListMaterial : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> materialId{};
  shared_ptr<string> materialType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<long> size{};
  shared_ptr<GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteConfig{};
  shared_ptr<GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites> sprites{};
  shared_ptr<string> status{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};

  GetEditingProjectMaterialsResponseBodyMaterialListMaterial() {}

  explicit GetEditingProjectMaterialsResponseBodyMaterialListMaterial(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (materialId) {
      res["MaterialId"] = boost::any(*materialId);
    }
    if (materialType) {
      res["MaterialType"] = boost::any(*materialType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshots) {
      res["Snapshots"] = snapshots ? boost::any(snapshots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteConfig) {
      res["SpriteConfig"] = boost::any(*spriteConfig);
    }
    if (sprites) {
      res["Sprites"] = sprites ? boost::any(sprites->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("MaterialId") != m.end() && !m["MaterialId"].empty()) {
      materialId = make_shared<string>(boost::any_cast<string>(m["MaterialId"]));
    }
    if (m.find("MaterialType") != m.end() && !m["MaterialType"].empty()) {
      materialType = make_shared<string>(boost::any_cast<string>(m["MaterialType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(map<string, boost::any>) == m["Snapshots"].type()) {
        GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Snapshots"]));
        snapshots = make_shared<GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots>(model1);
      }
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteConfig") != m.end() && !m["SpriteConfig"].empty()) {
      spriteConfig = make_shared<string>(boost::any_cast<string>(m["SpriteConfig"]));
    }
    if (m.find("Sprites") != m.end() && !m["Sprites"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sprites"].type()) {
        GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sprites"]));
        sprites = make_shared<GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMaterialListMaterial() = default;
};
class GetEditingProjectMaterialsResponseBodyMaterialList : public Darabonba::Model {
public:
  shared_ptr<vector<GetEditingProjectMaterialsResponseBodyMaterialListMaterial>> material{};

  GetEditingProjectMaterialsResponseBodyMaterialList() {}

  explicit GetEditingProjectMaterialsResponseBodyMaterialList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (material) {
      vector<boost::any> temp1;
      for(auto item1:*material){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Material"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Material") != m.end() && !m["Material"].empty()) {
      if (typeid(vector<boost::any>) == m["Material"].type()) {
        vector<GetEditingProjectMaterialsResponseBodyMaterialListMaterial> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Material"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEditingProjectMaterialsResponseBodyMaterialListMaterial model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        material = make_shared<vector<GetEditingProjectMaterialsResponseBodyMaterialListMaterial>>(expect1);
      }
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMaterialList() = default;
};
class GetEditingProjectMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetEditingProjectMaterialsResponseBodyMaterialList> materialList{};
  shared_ptr<string> requestId{};

  GetEditingProjectMaterialsResponseBody() {}

  explicit GetEditingProjectMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialList) {
      res["MaterialList"] = materialList ? boost::any(materialList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialList") != m.end() && !m["MaterialList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MaterialList"].type()) {
        GetEditingProjectMaterialsResponseBodyMaterialList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MaterialList"]));
        materialList = make_shared<GetEditingProjectMaterialsResponseBodyMaterialList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBody() = default;
};
class GetEditingProjectMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEditingProjectMaterialsResponseBody> body{};

  GetEditingProjectMaterialsResponse() {}

  explicit GetEditingProjectMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEditingProjectMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEditingProjectMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~GetEditingProjectMaterialsResponse() = default;
};
class GetImageInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> authTimeout{};
  shared_ptr<string> imageId{};
  shared_ptr<string> outputType{};

  GetImageInfoRequest() {}

  explicit GetImageInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<long>(boost::any_cast<long>(m["AuthTimeout"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
  }


  virtual ~GetImageInfoRequest() = default;
};
class GetImageInfoResponseBodyImageInfoMezzanine : public Darabonba::Model {
public:
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileURL{};
  shared_ptr<long> height{};
  shared_ptr<string> originalFileName{};
  shared_ptr<long> width{};

  GetImageInfoResponseBodyImageInfoMezzanine() {}

  explicit GetImageInfoResponseBodyImageInfoMezzanine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (originalFileName) {
      res["OriginalFileName"] = boost::any(*originalFileName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("OriginalFileName") != m.end() && !m["OriginalFileName"].empty()) {
      originalFileName = make_shared<string>(boost::any_cast<string>(m["OriginalFileName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetImageInfoResponseBodyImageInfoMezzanine() = default;
};
class GetImageInfoResponseBodyImageInfo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<GetImageInfoResponseBodyImageInfoMezzanine> mezzanine{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> URL{};

  GetImageInfoResponseBodyImageInfo() {}

  explicit GetImageInfoResponseBodyImageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageType) {
      res["ImageType"] = boost::any(*imageType);
    }
    if (mezzanine) {
      res["Mezzanine"] = mezzanine ? boost::any(mezzanine->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageType") != m.end() && !m["ImageType"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["ImageType"]));
    }
    if (m.find("Mezzanine") != m.end() && !m["Mezzanine"].empty()) {
      if (typeid(map<string, boost::any>) == m["Mezzanine"].type()) {
        GetImageInfoResponseBodyImageInfoMezzanine model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Mezzanine"]));
        mezzanine = make_shared<GetImageInfoResponseBodyImageInfoMezzanine>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~GetImageInfoResponseBodyImageInfo() = default;
};
class GetImageInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetImageInfoResponseBodyImageInfo> imageInfo{};
  shared_ptr<string> requestId{};

  GetImageInfoResponseBody() {}

  explicit GetImageInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageInfo) {
      res["ImageInfo"] = imageInfo ? boost::any(imageInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageInfo") != m.end() && !m["ImageInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageInfo"].type()) {
        GetImageInfoResponseBodyImageInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageInfo"]));
        imageInfo = make_shared<GetImageInfoResponseBodyImageInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetImageInfoResponseBody() = default;
};
class GetImageInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetImageInfoResponseBody> body{};

  GetImageInfoResponse() {}

  explicit GetImageInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetImageInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetImageInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetImageInfoResponse() = default;
};
class GetImageInfosRequest : public Darabonba::Model {
public:
  shared_ptr<long> authTimeout{};
  shared_ptr<string> imageIds{};
  shared_ptr<string> outputType{};

  GetImageInfosRequest() {}

  explicit GetImageInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (imageIds) {
      res["ImageIds"] = boost::any(*imageIds);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<long>(boost::any_cast<long>(m["AuthTimeout"]));
    }
    if (m.find("ImageIds") != m.end() && !m["ImageIds"].empty()) {
      imageIds = make_shared<string>(boost::any_cast<string>(m["ImageIds"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
  }


  virtual ~GetImageInfosRequest() = default;
};
class GetImageInfosResponseBodyImageInfoMezzanine : public Darabonba::Model {
public:
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileURL{};
  shared_ptr<long> height{};
  shared_ptr<string> originalFileName{};
  shared_ptr<long> width{};

  GetImageInfosResponseBodyImageInfoMezzanine() {}

  explicit GetImageInfosResponseBodyImageInfoMezzanine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (originalFileName) {
      res["OriginalFileName"] = boost::any(*originalFileName);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("OriginalFileName") != m.end() && !m["OriginalFileName"].empty()) {
      originalFileName = make_shared<string>(boost::any_cast<string>(m["OriginalFileName"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetImageInfosResponseBodyImageInfoMezzanine() = default;
};
class GetImageInfosResponseBodyImageInfo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> imageId{};
  shared_ptr<string> imageType{};
  shared_ptr<GetImageInfosResponseBodyImageInfoMezzanine> mezzanine{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> URL{};

  GetImageInfosResponseBodyImageInfo() {}

  explicit GetImageInfosResponseBodyImageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (imageType) {
      res["ImageType"] = boost::any(*imageType);
    }
    if (mezzanine) {
      res["Mezzanine"] = mezzanine ? boost::any(mezzanine->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ImageType") != m.end() && !m["ImageType"].empty()) {
      imageType = make_shared<string>(boost::any_cast<string>(m["ImageType"]));
    }
    if (m.find("Mezzanine") != m.end() && !m["Mezzanine"].empty()) {
      if (typeid(map<string, boost::any>) == m["Mezzanine"].type()) {
        GetImageInfosResponseBodyImageInfoMezzanine model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Mezzanine"]));
        mezzanine = make_shared<GetImageInfosResponseBodyImageInfoMezzanine>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~GetImageInfosResponseBodyImageInfo() = default;
};
class GetImageInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetImageInfosResponseBodyImageInfo>> imageInfo{};
  shared_ptr<vector<string>> nonExistImageIds{};
  shared_ptr<string> requestId{};

  GetImageInfosResponseBody() {}

  explicit GetImageInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*imageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageInfo"] = boost::any(temp1);
    }
    if (nonExistImageIds) {
      res["NonExistImageIds"] = boost::any(*nonExistImageIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageInfo") != m.end() && !m["ImageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageInfo"].type()) {
        vector<GetImageInfosResponseBodyImageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetImageInfosResponseBodyImageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageInfo = make_shared<vector<GetImageInfosResponseBodyImageInfo>>(expect1);
      }
    }
    if (m.find("NonExistImageIds") != m.end() && !m["NonExistImageIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistImageIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistImageIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistImageIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetImageInfosResponseBody() = default;
};
class GetImageInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetImageInfosResponseBody> body{};

  GetImageInfosResponse() {}

  explicit GetImageInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetImageInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetImageInfosResponseBody>(model1);
      }
    }
  }


  virtual ~GetImageInfosResponse() = default;
};
class GetMediaAuditAudioResultDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  GetMediaAuditAudioResultDetailRequest() {}

  explicit GetMediaAuditAudioResultDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetMediaAuditAudioResultDetailRequest() = default;
};
class GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> label{};
  shared_ptr<long> startTime{};
  shared_ptr<string> text{};

  GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList() {}

  explicit GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList() = default;
};
class GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList>> list{};
  shared_ptr<long> pageTotal{};
  shared_ptr<long> total{};

  GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail() {}

  explicit GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageTotal) {
      res["PageTotal"] = boost::any(*pageTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList>>(expect1);
      }
    }
    if (m.find("PageTotal") != m.end() && !m["PageTotal"].empty()) {
      pageTotal = make_shared<long>(boost::any_cast<long>(m["PageTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail() = default;
};
class GetMediaAuditAudioResultDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail> mediaAuditAudioResultDetail{};
  shared_ptr<string> requestId{};

  GetMediaAuditAudioResultDetailResponseBody() {}

  explicit GetMediaAuditAudioResultDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaAuditAudioResultDetail) {
      res["MediaAuditAudioResultDetail"] = mediaAuditAudioResultDetail ? boost::any(mediaAuditAudioResultDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaAuditAudioResultDetail") != m.end() && !m["MediaAuditAudioResultDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaAuditAudioResultDetail"].type()) {
        GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaAuditAudioResultDetail"]));
        mediaAuditAudioResultDetail = make_shared<GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaAuditAudioResultDetailResponseBody() = default;
};
class GetMediaAuditAudioResultDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaAuditAudioResultDetailResponseBody> body{};

  GetMediaAuditAudioResultDetailResponse() {}

  explicit GetMediaAuditAudioResultDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaAuditAudioResultDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaAuditAudioResultDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaAuditAudioResultDetailResponse() = default;
};
class GetMediaAuditResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};

  GetMediaAuditResultRequest() {}

  explicit GetMediaAuditResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetMediaAuditResultRequest() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultAudioResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> score{};
  shared_ptr<string> suggestion{};

  GetMediaAuditResultResponseBodyMediaAuditResultAudioResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultAudioResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultAudioResult() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> score{};
  shared_ptr<string> suggestion{};

  GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultImageResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult>> result{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  GetMediaAuditResultResponseBodyMediaAuditResultImageResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultImageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult>>(expect1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultImageResult() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultTextResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> label{};
  shared_ptr<string> scene{};
  shared_ptr<string> score{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> type{};

  GetMediaAuditResultResponseBodyMediaAuditResultTextResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultTextResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultTextResult() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList>> counterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList>> topList{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (counterList) {
      vector<boost::any> temp1;
      for(auto item1:*counterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CounterList"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (topList) {
      vector<boost::any> temp1;
      for(auto item1:*topList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("CounterList") != m.end() && !m["CounterList"].empty()) {
      if (typeid(vector<boost::any>) == m["CounterList"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CounterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counterList = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TopList") != m.end() && !m["TopList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopList"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topList = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList>>(expect1);
      }
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList>> counterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList>> topList{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (counterList) {
      vector<boost::any> temp1;
      for(auto item1:*counterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CounterList"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (topList) {
      vector<boost::any> temp1;
      for(auto item1:*topList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("CounterList") != m.end() && !m["CounterList"].empty()) {
      if (typeid(vector<boost::any>) == m["CounterList"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CounterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counterList = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TopList") != m.end() && !m["TopList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopList"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topList = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList>>(expect1);
      }
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList>> counterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList>> topList{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (counterList) {
      vector<boost::any> temp1;
      for(auto item1:*counterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CounterList"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (topList) {
      vector<boost::any> temp1;
      for(auto item1:*topList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("CounterList") != m.end() && !m["CounterList"].empty()) {
      if (typeid(vector<boost::any>) == m["CounterList"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CounterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counterList = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TopList") != m.end() && !m["TopList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopList"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topList = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList>>(expect1);
      }
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList>> counterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList>> topList{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (counterList) {
      vector<boost::any> temp1;
      for(auto item1:*counterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CounterList"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (topList) {
      vector<boost::any> temp1;
      for(auto item1:*topList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("CounterList") != m.end() && !m["CounterList"].empty()) {
      if (typeid(vector<boost::any>) == m["CounterList"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CounterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counterList = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TopList") != m.end() && !m["TopList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopList"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topList = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList>>(expect1);
      }
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList>> counterList{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList>> topList{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (counterList) {
      vector<boost::any> temp1;
      for(auto item1:*counterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CounterList"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (topList) {
      vector<boost::any> temp1;
      for(auto item1:*topList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("CounterList") != m.end() && !m["CounterList"].empty()) {
      if (typeid(vector<boost::any>) == m["CounterList"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CounterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counterList = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TopList") != m.end() && !m["TopList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopList"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topList = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList>>(expect1);
      }
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResultVideoResult : public Darabonba::Model {
public:
  shared_ptr<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult> adResult{};
  shared_ptr<string> label{};
  shared_ptr<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult> liveResult{};
  shared_ptr<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult> logoResult{};
  shared_ptr<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult> pornResult{};
  shared_ptr<string> suggestion{};
  shared_ptr<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult> terrorismResult{};

  GetMediaAuditResultResponseBodyMediaAuditResultVideoResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResultVideoResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adResult) {
      res["AdResult"] = adResult ? boost::any(adResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (liveResult) {
      res["LiveResult"] = liveResult ? boost::any(liveResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logoResult) {
      res["LogoResult"] = logoResult ? boost::any(logoResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pornResult) {
      res["PornResult"] = pornResult ? boost::any(pornResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (terrorismResult) {
      res["TerrorismResult"] = terrorismResult ? boost::any(terrorismResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdResult") != m.end() && !m["AdResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdResult"].type()) {
        GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdResult"]));
        adResult = make_shared<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult>(model1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("LiveResult") != m.end() && !m["LiveResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveResult"].type()) {
        GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveResult"]));
        liveResult = make_shared<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult>(model1);
      }
    }
    if (m.find("LogoResult") != m.end() && !m["LogoResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogoResult"].type()) {
        GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogoResult"]));
        logoResult = make_shared<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult>(model1);
      }
    }
    if (m.find("PornResult") != m.end() && !m["PornResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornResult"].type()) {
        GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornResult"]));
        pornResult = make_shared<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult>(model1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TerrorismResult") != m.end() && !m["TerrorismResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismResult"].type()) {
        GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismResult"]));
        terrorismResult = make_shared<GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult>(model1);
      }
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResultVideoResult() = default;
};
class GetMediaAuditResultResponseBodyMediaAuditResult : public Darabonba::Model {
public:
  shared_ptr<string> abnormalModules{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultAudioResult>> audioResult{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultImageResult>> imageResult{};
  shared_ptr<string> label{};
  shared_ptr<string> suggestion{};
  shared_ptr<vector<GetMediaAuditResultResponseBodyMediaAuditResultTextResult>> textResult{};
  shared_ptr<GetMediaAuditResultResponseBodyMediaAuditResultVideoResult> videoResult{};

  GetMediaAuditResultResponseBodyMediaAuditResult() {}

  explicit GetMediaAuditResultResponseBodyMediaAuditResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalModules) {
      res["AbnormalModules"] = boost::any(*abnormalModules);
    }
    if (audioResult) {
      vector<boost::any> temp1;
      for(auto item1:*audioResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioResult"] = boost::any(temp1);
    }
    if (imageResult) {
      vector<boost::any> temp1;
      for(auto item1:*imageResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageResult"] = boost::any(temp1);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (textResult) {
      vector<boost::any> temp1;
      for(auto item1:*textResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextResult"] = boost::any(temp1);
    }
    if (videoResult) {
      res["VideoResult"] = videoResult ? boost::any(videoResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalModules") != m.end() && !m["AbnormalModules"].empty()) {
      abnormalModules = make_shared<string>(boost::any_cast<string>(m["AbnormalModules"]));
    }
    if (m.find("AudioResult") != m.end() && !m["AudioResult"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioResult"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultAudioResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultAudioResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioResult = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultAudioResult>>(expect1);
      }
    }
    if (m.find("ImageResult") != m.end() && !m["ImageResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageResult"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultImageResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultImageResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageResult = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultImageResult>>(expect1);
      }
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TextResult") != m.end() && !m["TextResult"].empty()) {
      if (typeid(vector<boost::any>) == m["TextResult"].type()) {
        vector<GetMediaAuditResultResponseBodyMediaAuditResultTextResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultResponseBodyMediaAuditResultTextResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textResult = make_shared<vector<GetMediaAuditResultResponseBodyMediaAuditResultTextResult>>(expect1);
      }
    }
    if (m.find("VideoResult") != m.end() && !m["VideoResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoResult"].type()) {
        GetMediaAuditResultResponseBodyMediaAuditResultVideoResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoResult"]));
        videoResult = make_shared<GetMediaAuditResultResponseBodyMediaAuditResultVideoResult>(model1);
      }
    }
  }


  virtual ~GetMediaAuditResultResponseBodyMediaAuditResult() = default;
};
class GetMediaAuditResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaAuditResultResponseBodyMediaAuditResult> mediaAuditResult{};
  shared_ptr<string> requestId{};

  GetMediaAuditResultResponseBody() {}

  explicit GetMediaAuditResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaAuditResult) {
      res["MediaAuditResult"] = mediaAuditResult ? boost::any(mediaAuditResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaAuditResult") != m.end() && !m["MediaAuditResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaAuditResult"].type()) {
        GetMediaAuditResultResponseBodyMediaAuditResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaAuditResult"]));
        mediaAuditResult = make_shared<GetMediaAuditResultResponseBodyMediaAuditResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaAuditResultResponseBody() = default;
};
class GetMediaAuditResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaAuditResultResponseBody> body{};

  GetMediaAuditResultResponse() {}

  explicit GetMediaAuditResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaAuditResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaAuditResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaAuditResultResponse() = default;
};
class GetMediaAuditResultDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<long> pageNo{};

  GetMediaAuditResultDetailRequest() {}

  explicit GetMediaAuditResultDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
  }


  virtual ~GetMediaAuditResultDetailRequest() = default;
};
class GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList : public Darabonba::Model {
public:
  shared_ptr<string> adLabel{};
  shared_ptr<string> adScore{};
  shared_ptr<string> liveLabel{};
  shared_ptr<string> liveScore{};
  shared_ptr<string> logoLabel{};
  shared_ptr<string> logoScore{};
  shared_ptr<string> pornLabel{};
  shared_ptr<string> pornScore{};
  shared_ptr<string> terrorismLabel{};
  shared_ptr<string> terrorismScore{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> url{};

  GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList() {}

  explicit GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adLabel) {
      res["AdLabel"] = boost::any(*adLabel);
    }
    if (adScore) {
      res["AdScore"] = boost::any(*adScore);
    }
    if (liveLabel) {
      res["LiveLabel"] = boost::any(*liveLabel);
    }
    if (liveScore) {
      res["LiveScore"] = boost::any(*liveScore);
    }
    if (logoLabel) {
      res["LogoLabel"] = boost::any(*logoLabel);
    }
    if (logoScore) {
      res["LogoScore"] = boost::any(*logoScore);
    }
    if (pornLabel) {
      res["PornLabel"] = boost::any(*pornLabel);
    }
    if (pornScore) {
      res["PornScore"] = boost::any(*pornScore);
    }
    if (terrorismLabel) {
      res["TerrorismLabel"] = boost::any(*terrorismLabel);
    }
    if (terrorismScore) {
      res["TerrorismScore"] = boost::any(*terrorismScore);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdLabel") != m.end() && !m["AdLabel"].empty()) {
      adLabel = make_shared<string>(boost::any_cast<string>(m["AdLabel"]));
    }
    if (m.find("AdScore") != m.end() && !m["AdScore"].empty()) {
      adScore = make_shared<string>(boost::any_cast<string>(m["AdScore"]));
    }
    if (m.find("LiveLabel") != m.end() && !m["LiveLabel"].empty()) {
      liveLabel = make_shared<string>(boost::any_cast<string>(m["LiveLabel"]));
    }
    if (m.find("LiveScore") != m.end() && !m["LiveScore"].empty()) {
      liveScore = make_shared<string>(boost::any_cast<string>(m["LiveScore"]));
    }
    if (m.find("LogoLabel") != m.end() && !m["LogoLabel"].empty()) {
      logoLabel = make_shared<string>(boost::any_cast<string>(m["LogoLabel"]));
    }
    if (m.find("LogoScore") != m.end() && !m["LogoScore"].empty()) {
      logoScore = make_shared<string>(boost::any_cast<string>(m["LogoScore"]));
    }
    if (m.find("PornLabel") != m.end() && !m["PornLabel"].empty()) {
      pornLabel = make_shared<string>(boost::any_cast<string>(m["PornLabel"]));
    }
    if (m.find("PornScore") != m.end() && !m["PornScore"].empty()) {
      pornScore = make_shared<string>(boost::any_cast<string>(m["PornScore"]));
    }
    if (m.find("TerrorismLabel") != m.end() && !m["TerrorismLabel"].empty()) {
      terrorismLabel = make_shared<string>(boost::any_cast<string>(m["TerrorismLabel"]));
    }
    if (m.find("TerrorismScore") != m.end() && !m["TerrorismScore"].empty()) {
      terrorismScore = make_shared<string>(boost::any_cast<string>(m["TerrorismScore"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList() = default;
};
class GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList>> list{};
  shared_ptr<long> total{};

  GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail() {}

  explicit GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail() = default;
};
class GetMediaAuditResultDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail> mediaAuditResultDetail{};
  shared_ptr<string> requestId{};

  GetMediaAuditResultDetailResponseBody() {}

  explicit GetMediaAuditResultDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaAuditResultDetail) {
      res["MediaAuditResultDetail"] = mediaAuditResultDetail ? boost::any(mediaAuditResultDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaAuditResultDetail") != m.end() && !m["MediaAuditResultDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaAuditResultDetail"].type()) {
        GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaAuditResultDetail"]));
        mediaAuditResultDetail = make_shared<GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaAuditResultDetailResponseBody() = default;
};
class GetMediaAuditResultDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaAuditResultDetailResponseBody> body{};

  GetMediaAuditResultDetailResponse() {}

  explicit GetMediaAuditResultDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaAuditResultDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaAuditResultDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaAuditResultDetailResponse() = default;
};
class GetMediaAuditResultTimelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};

  GetMediaAuditResultTimelineRequest() {}

  explicit GetMediaAuditResultTimelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetMediaAuditResultTimelineRequest() = default;
};
class GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};

  GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd() {}

  explicit GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd() = default;
};
class GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};

  GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive() {}

  explicit GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive() = default;
};
class GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};

  GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo() {}

  explicit GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo() = default;
};
class GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};

  GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn() {}

  explicit GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn() = default;
};
class GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};

  GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism() {}

  explicit GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism() = default;
};
class GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd>> ad{};
  shared_ptr<vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive>> live{};
  shared_ptr<vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo>> logo{};
  shared_ptr<vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn>> porn{};
  shared_ptr<vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism>> terrorism{};

  GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline() {}

  explicit GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ad) {
      vector<boost::any> temp1;
      for(auto item1:*ad){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ad"] = boost::any(temp1);
    }
    if (live) {
      vector<boost::any> temp1;
      for(auto item1:*live){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Live"] = boost::any(temp1);
    }
    if (logo) {
      vector<boost::any> temp1;
      for(auto item1:*logo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logo"] = boost::any(temp1);
    }
    if (porn) {
      vector<boost::any> temp1;
      for(auto item1:*porn){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Porn"] = boost::any(temp1);
    }
    if (terrorism) {
      vector<boost::any> temp1;
      for(auto item1:*terrorism){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Terrorism"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ad") != m.end() && !m["Ad"].empty()) {
      if (typeid(vector<boost::any>) == m["Ad"].type()) {
        vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ad"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ad = make_shared<vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd>>(expect1);
      }
    }
    if (m.find("Live") != m.end() && !m["Live"].empty()) {
      if (typeid(vector<boost::any>) == m["Live"].type()) {
        vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Live"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        live = make_shared<vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive>>(expect1);
      }
    }
    if (m.find("Logo") != m.end() && !m["Logo"].empty()) {
      if (typeid(vector<boost::any>) == m["Logo"].type()) {
        vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logo = make_shared<vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo>>(expect1);
      }
    }
    if (m.find("Porn") != m.end() && !m["Porn"].empty()) {
      if (typeid(vector<boost::any>) == m["Porn"].type()) {
        vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Porn"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        porn = make_shared<vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn>>(expect1);
      }
    }
    if (m.find("Terrorism") != m.end() && !m["Terrorism"].empty()) {
      if (typeid(vector<boost::any>) == m["Terrorism"].type()) {
        vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Terrorism"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        terrorism = make_shared<vector<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism>>(expect1);
      }
    }
  }


  virtual ~GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline() = default;
};
class GetMediaAuditResultTimelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline> mediaAuditResultTimeline{};
  shared_ptr<string> requestId{};

  GetMediaAuditResultTimelineResponseBody() {}

  explicit GetMediaAuditResultTimelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaAuditResultTimeline) {
      res["MediaAuditResultTimeline"] = mediaAuditResultTimeline ? boost::any(mediaAuditResultTimeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaAuditResultTimeline") != m.end() && !m["MediaAuditResultTimeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaAuditResultTimeline"].type()) {
        GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaAuditResultTimeline"]));
        mediaAuditResultTimeline = make_shared<GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaAuditResultTimelineResponseBody() = default;
};
class GetMediaAuditResultTimelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaAuditResultTimelineResponseBody> body{};

  GetMediaAuditResultTimelineResponse() {}

  explicit GetMediaAuditResultTimelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaAuditResultTimelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaAuditResultTimelineResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaAuditResultTimelineResponse() = default;
};
class GetMediaDNAResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  GetMediaDNAResultRequest() {}

  explicit GetMediaDNAResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~GetMediaDNAResultRequest() = default;
};
class GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication() {}

  explicit GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication() = default;
};
class GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput() {}

  explicit GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput() = default;
};
class GetMediaDNAResultResponseBodyDNAResultVideoDNADetail : public Darabonba::Model {
public:
  shared_ptr<GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication> duplication{};
  shared_ptr<GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput> input{};

  GetMediaDNAResultResponseBodyDNAResultVideoDNADetail() {}

  explicit GetMediaDNAResultResponseBodyDNAResultVideoDNADetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duplication) {
      res["Duplication"] = duplication ? boost::any(duplication->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duplication") != m.end() && !m["Duplication"].empty()) {
      if (typeid(map<string, boost::any>) == m["Duplication"].type()) {
        GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Duplication"]));
        duplication = make_shared<GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication>(model1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput>(model1);
      }
    }
  }


  virtual ~GetMediaDNAResultResponseBodyDNAResultVideoDNADetail() = default;
};
class GetMediaDNAResultResponseBodyDNAResultVideoDNA : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaDNAResultResponseBodyDNAResultVideoDNADetail>> detail{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> similarity{};

  GetMediaDNAResultResponseBodyDNAResultVideoDNA() {}

  explicit GetMediaDNAResultResponseBodyDNAResultVideoDNA(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      vector<boost::any> temp1;
      for(auto item1:*detail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Detail"] = boost::any(temp1);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(vector<boost::any>) == m["Detail"].type()) {
        vector<GetMediaDNAResultResponseBodyDNAResultVideoDNADetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Detail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaDNAResultResponseBodyDNAResultVideoDNADetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        detail = make_shared<vector<GetMediaDNAResultResponseBodyDNAResultVideoDNADetail>>(expect1);
      }
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<string>(boost::any_cast<string>(m["Similarity"]));
    }
  }


  virtual ~GetMediaDNAResultResponseBodyDNAResultVideoDNA() = default;
};
class GetMediaDNAResultResponseBodyDNAResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaDNAResultResponseBodyDNAResultVideoDNA>> videoDNA{};

  GetMediaDNAResultResponseBodyDNAResult() {}

  explicit GetMediaDNAResultResponseBodyDNAResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoDNA) {
      vector<boost::any> temp1;
      for(auto item1:*videoDNA){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoDNA"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoDNA") != m.end() && !m["VideoDNA"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoDNA"].type()) {
        vector<GetMediaDNAResultResponseBodyDNAResultVideoDNA> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoDNA"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaDNAResultResponseBodyDNAResultVideoDNA model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoDNA = make_shared<vector<GetMediaDNAResultResponseBodyDNAResultVideoDNA>>(expect1);
      }
    }
  }


  virtual ~GetMediaDNAResultResponseBodyDNAResult() = default;
};
class GetMediaDNAResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaDNAResultResponseBodyDNAResult> DNAResult{};
  shared_ptr<string> requestId{};

  GetMediaDNAResultResponseBody() {}

  explicit GetMediaDNAResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DNAResult) {
      res["DNAResult"] = DNAResult ? boost::any(DNAResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DNAResult") != m.end() && !m["DNAResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DNAResult"].type()) {
        GetMediaDNAResultResponseBodyDNAResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DNAResult"]));
        DNAResult = make_shared<GetMediaDNAResultResponseBodyDNAResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaDNAResultResponseBody() = default;
};
class GetMediaDNAResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaDNAResultResponseBody> body{};

  GetMediaDNAResultResponse() {}

  explicit GetMediaDNAResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaDNAResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaDNAResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaDNAResultResponse() = default;
};
class GetMediaRefreshJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaRefreshJobId{};

  GetMediaRefreshJobsRequest() {}

  explicit GetMediaRefreshJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaRefreshJobId) {
      res["MediaRefreshJobId"] = boost::any(*mediaRefreshJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaRefreshJobId") != m.end() && !m["MediaRefreshJobId"].empty()) {
      mediaRefreshJobId = make_shared<string>(boost::any_cast<string>(m["MediaRefreshJobId"]));
    }
  }


  virtual ~GetMediaRefreshJobsRequest() = default;
};
class GetMediaRefreshJobsResponseBodyMediaRefreshJobs : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> filterPolicy{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaRefreshJobId{};
  shared_ptr<string> status{};
  shared_ptr<string> successPlayUrls{};
  shared_ptr<string> taskIds{};
  shared_ptr<string> taskType{};
  shared_ptr<string> userData{};

  GetMediaRefreshJobsResponseBodyMediaRefreshJobs() {}

  explicit GetMediaRefreshJobsResponseBodyMediaRefreshJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (filterPolicy) {
      res["FilterPolicy"] = boost::any(*filterPolicy);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaRefreshJobId) {
      res["MediaRefreshJobId"] = boost::any(*mediaRefreshJobId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (successPlayUrls) {
      res["SuccessPlayUrls"] = boost::any(*successPlayUrls);
    }
    if (taskIds) {
      res["TaskIds"] = boost::any(*taskIds);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FilterPolicy") != m.end() && !m["FilterPolicy"].empty()) {
      filterPolicy = make_shared<string>(boost::any_cast<string>(m["FilterPolicy"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaRefreshJobId") != m.end() && !m["MediaRefreshJobId"].empty()) {
      mediaRefreshJobId = make_shared<string>(boost::any_cast<string>(m["MediaRefreshJobId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SuccessPlayUrls") != m.end() && !m["SuccessPlayUrls"].empty()) {
      successPlayUrls = make_shared<string>(boost::any_cast<string>(m["SuccessPlayUrls"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      taskIds = make_shared<string>(boost::any_cast<string>(m["TaskIds"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetMediaRefreshJobsResponseBodyMediaRefreshJobs() = default;
};
class GetMediaRefreshJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaRefreshJobsResponseBodyMediaRefreshJobs>> mediaRefreshJobs{};
  shared_ptr<string> requestId{};

  GetMediaRefreshJobsResponseBody() {}

  explicit GetMediaRefreshJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaRefreshJobs) {
      vector<boost::any> temp1;
      for(auto item1:*mediaRefreshJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaRefreshJobs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaRefreshJobs") != m.end() && !m["MediaRefreshJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaRefreshJobs"].type()) {
        vector<GetMediaRefreshJobsResponseBodyMediaRefreshJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaRefreshJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaRefreshJobsResponseBodyMediaRefreshJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaRefreshJobs = make_shared<vector<GetMediaRefreshJobsResponseBodyMediaRefreshJobs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaRefreshJobsResponseBody() = default;
};
class GetMediaRefreshJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaRefreshJobsResponseBody> body{};

  GetMediaRefreshJobsResponse() {}

  explicit GetMediaRefreshJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaRefreshJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaRefreshJobsResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaRefreshJobsResponse() = default;
};
class GetMessageCallbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> ownerAccount{};

  GetMessageCallbackRequest() {}

  explicit GetMessageCallbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~GetMessageCallbackRequest() = default;
};
class GetMessageCallbackResponseBodyMessageCallback : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> authKey{};
  shared_ptr<string> authSwitch{};
  shared_ptr<string> callbackType{};
  shared_ptr<string> callbackURL{};
  shared_ptr<string> eventTypeList{};
  shared_ptr<string> mnsEndpoint{};
  shared_ptr<string> mnsQueueName{};

  GetMessageCallbackResponseBodyMessageCallback() {}

  explicit GetMessageCallbackResponseBodyMessageCallback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (authSwitch) {
      res["AuthSwitch"] = boost::any(*authSwitch);
    }
    if (callbackType) {
      res["CallbackType"] = boost::any(*callbackType);
    }
    if (callbackURL) {
      res["CallbackURL"] = boost::any(*callbackURL);
    }
    if (eventTypeList) {
      res["EventTypeList"] = boost::any(*eventTypeList);
    }
    if (mnsEndpoint) {
      res["MnsEndpoint"] = boost::any(*mnsEndpoint);
    }
    if (mnsQueueName) {
      res["MnsQueueName"] = boost::any(*mnsQueueName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("AuthSwitch") != m.end() && !m["AuthSwitch"].empty()) {
      authSwitch = make_shared<string>(boost::any_cast<string>(m["AuthSwitch"]));
    }
    if (m.find("CallbackType") != m.end() && !m["CallbackType"].empty()) {
      callbackType = make_shared<string>(boost::any_cast<string>(m["CallbackType"]));
    }
    if (m.find("CallbackURL") != m.end() && !m["CallbackURL"].empty()) {
      callbackURL = make_shared<string>(boost::any_cast<string>(m["CallbackURL"]));
    }
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      eventTypeList = make_shared<string>(boost::any_cast<string>(m["EventTypeList"]));
    }
    if (m.find("MnsEndpoint") != m.end() && !m["MnsEndpoint"].empty()) {
      mnsEndpoint = make_shared<string>(boost::any_cast<string>(m["MnsEndpoint"]));
    }
    if (m.find("MnsQueueName") != m.end() && !m["MnsQueueName"].empty()) {
      mnsQueueName = make_shared<string>(boost::any_cast<string>(m["MnsQueueName"]));
    }
  }


  virtual ~GetMessageCallbackResponseBodyMessageCallback() = default;
};
class GetMessageCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMessageCallbackResponseBodyMessageCallback> messageCallback{};
  shared_ptr<string> requestId{};

  GetMessageCallbackResponseBody() {}

  explicit GetMessageCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageCallback) {
      res["MessageCallback"] = messageCallback ? boost::any(messageCallback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageCallback") != m.end() && !m["MessageCallback"].empty()) {
      if (typeid(map<string, boost::any>) == m["MessageCallback"].type()) {
        GetMessageCallbackResponseBodyMessageCallback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MessageCallback"]));
        messageCallback = make_shared<GetMessageCallbackResponseBodyMessageCallback>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMessageCallbackResponseBody() = default;
};
class GetMessageCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMessageCallbackResponseBody> body{};

  GetMessageCallbackResponse() {}

  explicit GetMessageCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMessageCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMessageCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~GetMessageCallbackResponse() = default;
};
class GetMezzanineInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> additionType{};
  shared_ptr<long> authTimeout{};
  shared_ptr<string> outputType{};
  shared_ptr<string> videoId{};

  GetMezzanineInfoRequest() {}

  explicit GetMezzanineInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionType) {
      res["AdditionType"] = boost::any(*additionType);
    }
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionType") != m.end() && !m["AdditionType"].empty()) {
      additionType = make_shared<string>(boost::any_cast<string>(m["AdditionType"]));
    }
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<long>(boost::any_cast<long>(m["AuthTimeout"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetMezzanineInfoRequest() = default;
};
class GetMezzanineInfoResponseBodyMezzanineAudioStreamList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetMezzanineInfoResponseBodyMezzanineAudioStreamList() {}

  explicit GetMezzanineInfoResponseBodyMezzanineAudioStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetMezzanineInfoResponseBodyMezzanineAudioStreamList() = default;
};
class GetMezzanineInfoResponseBodyMezzanineVideoStreamList : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> HDRType{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  GetMezzanineInfoResponseBodyMezzanineVideoStreamList() {}

  explicit GetMezzanineInfoResponseBodyMezzanineVideoStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (HDRType) {
      res["HDRType"] = boost::any(*HDRType);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HDRType") != m.end() && !m["HDRType"].empty()) {
      HDRType = make_shared<string>(boost::any_cast<string>(m["HDRType"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetMezzanineInfoResponseBodyMezzanineVideoStreamList() = default;
};
class GetMezzanineInfoResponseBodyMezzanine : public Darabonba::Model {
public:
  shared_ptr<vector<GetMezzanineInfoResponseBodyMezzanineAudioStreamList>> audioStreamList{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileURL{};
  shared_ptr<string> fps{};
  shared_ptr<long> height{};
  shared_ptr<string> outputType{};
  shared_ptr<string> restoreExpiration{};
  shared_ptr<string> restoreStatus{};
  shared_ptr<long> size{};
  shared_ptr<string> status{};
  shared_ptr<string> storageClass{};
  shared_ptr<string> videoId{};
  shared_ptr<vector<GetMezzanineInfoResponseBodyMezzanineVideoStreamList>> videoStreamList{};
  shared_ptr<long> width{};

  GetMezzanineInfoResponseBodyMezzanine() {}

  explicit GetMezzanineInfoResponseBodyMezzanine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamList"] = boost::any(temp1);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (restoreExpiration) {
      res["RestoreExpiration"] = boost::any(*restoreExpiration);
    }
    if (restoreStatus) {
      res["RestoreStatus"] = boost::any(*restoreStatus);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    if (videoStreamList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamList"] = boost::any(temp1);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamList"].type()) {
        vector<GetMezzanineInfoResponseBodyMezzanineAudioStreamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMezzanineInfoResponseBodyMezzanineAudioStreamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamList = make_shared<vector<GetMezzanineInfoResponseBodyMezzanineAudioStreamList>>(expect1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
    if (m.find("RestoreExpiration") != m.end() && !m["RestoreExpiration"].empty()) {
      restoreExpiration = make_shared<string>(boost::any_cast<string>(m["RestoreExpiration"]));
    }
    if (m.find("RestoreStatus") != m.end() && !m["RestoreStatus"].empty()) {
      restoreStatus = make_shared<string>(boost::any_cast<string>(m["RestoreStatus"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamList"].type()) {
        vector<GetMezzanineInfoResponseBodyMezzanineVideoStreamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMezzanineInfoResponseBodyMezzanineVideoStreamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamList = make_shared<vector<GetMezzanineInfoResponseBodyMezzanineVideoStreamList>>(expect1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetMezzanineInfoResponseBodyMezzanine() = default;
};
class GetMezzanineInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMezzanineInfoResponseBodyMezzanine> mezzanine{};
  shared_ptr<string> requestId{};

  GetMezzanineInfoResponseBody() {}

  explicit GetMezzanineInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mezzanine) {
      res["Mezzanine"] = mezzanine ? boost::any(mezzanine->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mezzanine") != m.end() && !m["Mezzanine"].empty()) {
      if (typeid(map<string, boost::any>) == m["Mezzanine"].type()) {
        GetMezzanineInfoResponseBodyMezzanine model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Mezzanine"]));
        mezzanine = make_shared<GetMezzanineInfoResponseBodyMezzanine>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMezzanineInfoResponseBody() = default;
};
class GetMezzanineInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMezzanineInfoResponseBody> body{};

  GetMezzanineInfoResponse() {}

  explicit GetMezzanineInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMezzanineInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMezzanineInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetMezzanineInfoResponse() = default;
};
class GetPlayInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> additionType{};
  shared_ptr<long> authTimeout{};
  shared_ptr<string> definition{};
  shared_ptr<string> digitalWatermarkType{};
  shared_ptr<string> formats{};
  shared_ptr<string> outputType{};
  shared_ptr<string> playConfig{};
  shared_ptr<string> reAuthInfo{};
  shared_ptr<string> resultType{};
  shared_ptr<string> streamType{};
  shared_ptr<string> trace{};
  shared_ptr<string> videoId{};

  GetPlayInfoRequest() {}

  explicit GetPlayInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionType) {
      res["AdditionType"] = boost::any(*additionType);
    }
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (digitalWatermarkType) {
      res["DigitalWatermarkType"] = boost::any(*digitalWatermarkType);
    }
    if (formats) {
      res["Formats"] = boost::any(*formats);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (playConfig) {
      res["PlayConfig"] = boost::any(*playConfig);
    }
    if (reAuthInfo) {
      res["ReAuthInfo"] = boost::any(*reAuthInfo);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (trace) {
      res["Trace"] = boost::any(*trace);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionType") != m.end() && !m["AdditionType"].empty()) {
      additionType = make_shared<string>(boost::any_cast<string>(m["AdditionType"]));
    }
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<long>(boost::any_cast<long>(m["AuthTimeout"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("DigitalWatermarkType") != m.end() && !m["DigitalWatermarkType"].empty()) {
      digitalWatermarkType = make_shared<string>(boost::any_cast<string>(m["DigitalWatermarkType"]));
    }
    if (m.find("Formats") != m.end() && !m["Formats"].empty()) {
      formats = make_shared<string>(boost::any_cast<string>(m["Formats"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
    if (m.find("PlayConfig") != m.end() && !m["PlayConfig"].empty()) {
      playConfig = make_shared<string>(boost::any_cast<string>(m["PlayConfig"]));
    }
    if (m.find("ReAuthInfo") != m.end() && !m["ReAuthInfo"].empty()) {
      reAuthInfo = make_shared<string>(boost::any_cast<string>(m["ReAuthInfo"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("Trace") != m.end() && !m["Trace"].empty()) {
      trace = make_shared<string>(boost::any_cast<string>(m["Trace"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetPlayInfoRequest() = default;
};
class GetPlayInfoResponseBodyPlayInfoListPlayInfo : public Darabonba::Model {
public:
  shared_ptr<long> bitDepth{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> definition{};
  shared_ptr<string> duration{};
  shared_ptr<long> encrypt{};
  shared_ptr<string> encryptType{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> HDRType{};
  shared_ptr<long> height{};
  shared_ptr<string> jobExt{};
  shared_ptr<string> jobId{};
  shared_ptr<long> jobType{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> narrowBandType{};
  shared_ptr<string> playURL{};
  shared_ptr<long> size{};
  shared_ptr<string> specification{};
  shared_ptr<string> status{};
  shared_ptr<string> streamType{};
  shared_ptr<string> watermarkId{};
  shared_ptr<long> width{};

  GetPlayInfoResponseBodyPlayInfoListPlayInfo() {}

  explicit GetPlayInfoResponseBodyPlayInfoListPlayInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitDepth) {
      res["BitDepth"] = boost::any(*bitDepth);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (HDRType) {
      res["HDRType"] = boost::any(*HDRType);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (jobExt) {
      res["JobExt"] = boost::any(*jobExt);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (narrowBandType) {
      res["NarrowBandType"] = boost::any(*narrowBandType);
    }
    if (playURL) {
      res["PlayURL"] = boost::any(*playURL);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitDepth") != m.end() && !m["BitDepth"].empty()) {
      bitDepth = make_shared<long>(boost::any_cast<long>(m["BitDepth"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<long>(boost::any_cast<long>(m["Encrypt"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HDRType") != m.end() && !m["HDRType"].empty()) {
      HDRType = make_shared<string>(boost::any_cast<string>(m["HDRType"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("JobExt") != m.end() && !m["JobExt"].empty()) {
      jobExt = make_shared<string>(boost::any_cast<string>(m["JobExt"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<long>(boost::any_cast<long>(m["JobType"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("NarrowBandType") != m.end() && !m["NarrowBandType"].empty()) {
      narrowBandType = make_shared<string>(boost::any_cast<string>(m["NarrowBandType"]));
    }
    if (m.find("PlayURL") != m.end() && !m["PlayURL"].empty()) {
      playURL = make_shared<string>(boost::any_cast<string>(m["PlayURL"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetPlayInfoResponseBodyPlayInfoListPlayInfo() = default;
};
class GetPlayInfoResponseBodyPlayInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<GetPlayInfoResponseBodyPlayInfoListPlayInfo>> playInfo{};

  GetPlayInfoResponseBodyPlayInfoList() {}

  explicit GetPlayInfoResponseBodyPlayInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (playInfo) {
      vector<boost::any> temp1;
      for(auto item1:*playInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlayInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlayInfo") != m.end() && !m["PlayInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["PlayInfo"].type()) {
        vector<GetPlayInfoResponseBodyPlayInfoListPlayInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlayInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPlayInfoResponseBodyPlayInfoListPlayInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playInfo = make_shared<vector<GetPlayInfoResponseBodyPlayInfoListPlayInfo>>(expect1);
      }
    }
  }


  virtual ~GetPlayInfoResponseBodyPlayInfoList() = default;
};
class GetPlayInfoResponseBodyVideoBase : public Darabonba::Model {
public:
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> danMuURL{};
  shared_ptr<string> duration{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> status{};
  shared_ptr<string> storageClass{};
  shared_ptr<string> title{};
  shared_ptr<string> videoId{};

  GetPlayInfoResponseBodyVideoBase() {}

  explicit GetPlayInfoResponseBodyVideoBase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (danMuURL) {
      res["DanMuURL"] = boost::any(*danMuURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DanMuURL") != m.end() && !m["DanMuURL"].empty()) {
      danMuURL = make_shared<string>(boost::any_cast<string>(m["DanMuURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetPlayInfoResponseBodyVideoBase() = default;
};
class GetPlayInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPlayInfoResponseBodyPlayInfoList> playInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<GetPlayInfoResponseBodyVideoBase> videoBase{};

  GetPlayInfoResponseBody() {}

  explicit GetPlayInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (playInfoList) {
      res["PlayInfoList"] = playInfoList ? boost::any(playInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (videoBase) {
      res["VideoBase"] = videoBase ? boost::any(videoBase->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlayInfoList") != m.end() && !m["PlayInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlayInfoList"].type()) {
        GetPlayInfoResponseBodyPlayInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlayInfoList"]));
        playInfoList = make_shared<GetPlayInfoResponseBodyPlayInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VideoBase") != m.end() && !m["VideoBase"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoBase"].type()) {
        GetPlayInfoResponseBodyVideoBase model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoBase"]));
        videoBase = make_shared<GetPlayInfoResponseBodyVideoBase>(model1);
      }
    }
  }


  virtual ~GetPlayInfoResponseBody() = default;
};
class GetPlayInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPlayInfoResponseBody> body{};

  GetPlayInfoResponse() {}

  explicit GetPlayInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPlayInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPlayInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetPlayInfoResponse() = default;
};
class GetTranscodeSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<string> videoIds{};

  GetTranscodeSummaryRequest() {}

  explicit GetTranscodeSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoIds) {
      res["VideoIds"] = boost::any(*videoIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoIds") != m.end() && !m["VideoIds"].empty()) {
      videoIds = make_shared<string>(boost::any_cast<string>(m["VideoIds"]));
    }
  }


  virtual ~GetTranscodeSummaryRequest() = default;
};
class GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> filesize{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> transcodeJobStatus{};
  shared_ptr<long> transcodeProgress{};
  shared_ptr<string> transcodeTemplateId{};
  shared_ptr<vector<string>> watermarkIdList{};
  shared_ptr<string> width{};

  GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList() {}

  explicit GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (filesize) {
      res["Filesize"] = boost::any(*filesize);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (transcodeJobStatus) {
      res["TranscodeJobStatus"] = boost::any(*transcodeJobStatus);
    }
    if (transcodeProgress) {
      res["TranscodeProgress"] = boost::any(*transcodeProgress);
    }
    if (transcodeTemplateId) {
      res["TranscodeTemplateId"] = boost::any(*transcodeTemplateId);
    }
    if (watermarkIdList) {
      res["WatermarkIdList"] = boost::any(*watermarkIdList);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Filesize") != m.end() && !m["Filesize"].empty()) {
      filesize = make_shared<long>(boost::any_cast<long>(m["Filesize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("TranscodeJobStatus") != m.end() && !m["TranscodeJobStatus"].empty()) {
      transcodeJobStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeJobStatus"]));
    }
    if (m.find("TranscodeProgress") != m.end() && !m["TranscodeProgress"].empty()) {
      transcodeProgress = make_shared<long>(boost::any_cast<long>(m["TranscodeProgress"]));
    }
    if (m.find("TranscodeTemplateId") != m.end() && !m["TranscodeTemplateId"].empty()) {
      transcodeTemplateId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateId"]));
    }
    if (m.find("WatermarkIdList") != m.end() && !m["WatermarkIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WatermarkIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WatermarkIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      watermarkIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList() = default;
};
class GetTranscodeSummaryResponseBodyTranscodeSummaryList : public Darabonba::Model {
public:
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<vector<GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList>> transcodeJobInfoSummaryList{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> transcodeTemplateGroupId{};
  shared_ptr<string> videoId{};

  GetTranscodeSummaryResponseBodyTranscodeSummaryList() {}

  explicit GetTranscodeSummaryResponseBodyTranscodeSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (transcodeJobInfoSummaryList) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeJobInfoSummaryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeJobInfoSummaryList"] = boost::any(temp1);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("TranscodeJobInfoSummaryList") != m.end() && !m["TranscodeJobInfoSummaryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeJobInfoSummaryList"].type()) {
        vector<GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeJobInfoSummaryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeJobInfoSummaryList = make_shared<vector<GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList>>(expect1);
      }
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetTranscodeSummaryResponseBodyTranscodeSummaryList() = default;
};
class GetTranscodeSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nonExistVideoIds{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetTranscodeSummaryResponseBodyTranscodeSummaryList>> transcodeSummaryList{};

  GetTranscodeSummaryResponseBody() {}

  explicit GetTranscodeSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistVideoIds) {
      res["NonExistVideoIds"] = boost::any(*nonExistVideoIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeSummaryList) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeSummaryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeSummaryList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistVideoIds") != m.end() && !m["NonExistVideoIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistVideoIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistVideoIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistVideoIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeSummaryList") != m.end() && !m["TranscodeSummaryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeSummaryList"].type()) {
        vector<GetTranscodeSummaryResponseBodyTranscodeSummaryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeSummaryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeSummaryResponseBodyTranscodeSummaryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeSummaryList = make_shared<vector<GetTranscodeSummaryResponseBodyTranscodeSummaryList>>(expect1);
      }
    }
  }


  virtual ~GetTranscodeSummaryResponseBody() = default;
};
class GetTranscodeSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTranscodeSummaryResponseBody> body{};

  GetTranscodeSummaryResponse() {}

  explicit GetTranscodeSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTranscodeSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTranscodeSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~GetTranscodeSummaryResponse() = default;
};
class GetTranscodeTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> transcodeTaskId{};

  GetTranscodeTaskRequest() {}

  explicit GetTranscodeTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeTaskId) {
      res["TranscodeTaskId"] = boost::any(*transcodeTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeTaskId") != m.end() && !m["TranscodeTaskId"].empty()) {
      transcodeTaskId = make_shared<string>(boost::any_cast<string>(m["TranscodeTaskId"]));
    }
  }


  virtual ~GetTranscodeTaskRequest() = default;
};
class GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> audioStreamList{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> encryption{};
  shared_ptr<long> filesize{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> outputFileUrl{};
  shared_ptr<string> subtitleStreamList{};
  shared_ptr<string> videoStreamList{};
  shared_ptr<vector<string>> watermarkIdList{};
  shared_ptr<string> width{};

  GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile() {}

  explicit GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamList) {
      res["AudioStreamList"] = boost::any(*audioStreamList);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (encryption) {
      res["Encryption"] = boost::any(*encryption);
    }
    if (filesize) {
      res["Filesize"] = boost::any(*filesize);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (outputFileUrl) {
      res["OutputFileUrl"] = boost::any(*outputFileUrl);
    }
    if (subtitleStreamList) {
      res["SubtitleStreamList"] = boost::any(*subtitleStreamList);
    }
    if (videoStreamList) {
      res["VideoStreamList"] = boost::any(*videoStreamList);
    }
    if (watermarkIdList) {
      res["WatermarkIdList"] = boost::any(*watermarkIdList);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamList") != m.end() && !m["AudioStreamList"].empty()) {
      audioStreamList = make_shared<string>(boost::any_cast<string>(m["AudioStreamList"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      encryption = make_shared<string>(boost::any_cast<string>(m["Encryption"]));
    }
    if (m.find("Filesize") != m.end() && !m["Filesize"].empty()) {
      filesize = make_shared<long>(boost::any_cast<long>(m["Filesize"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("OutputFileUrl") != m.end() && !m["OutputFileUrl"].empty()) {
      outputFileUrl = make_shared<string>(boost::any_cast<string>(m["OutputFileUrl"]));
    }
    if (m.find("SubtitleStreamList") != m.end() && !m["SubtitleStreamList"].empty()) {
      subtitleStreamList = make_shared<string>(boost::any_cast<string>(m["SubtitleStreamList"]));
    }
    if (m.find("VideoStreamList") != m.end() && !m["VideoStreamList"].empty()) {
      videoStreamList = make_shared<string>(boost::any_cast<string>(m["VideoStreamList"]));
    }
    if (m.find("WatermarkIdList") != m.end() && !m["WatermarkIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WatermarkIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WatermarkIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      watermarkIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile() = default;
};
class GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList : public Darabonba::Model {
public:
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> definition{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> inputFileUrl{};
  shared_ptr<GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile> outputFile{};
  shared_ptr<string> priority{};
  shared_ptr<string> transcodeJobId{};
  shared_ptr<string> transcodeJobStatus{};
  shared_ptr<long> transcodeProgress{};
  shared_ptr<string> transcodeTemplateId{};

  GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList() {}

  explicit GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (inputFileUrl) {
      res["InputFileUrl"] = boost::any(*inputFileUrl);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (transcodeJobId) {
      res["TranscodeJobId"] = boost::any(*transcodeJobId);
    }
    if (transcodeJobStatus) {
      res["TranscodeJobStatus"] = boost::any(*transcodeJobStatus);
    }
    if (transcodeProgress) {
      res["TranscodeProgress"] = boost::any(*transcodeProgress);
    }
    if (transcodeTemplateId) {
      res["TranscodeTemplateId"] = boost::any(*transcodeTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("InputFileUrl") != m.end() && !m["InputFileUrl"].empty()) {
      inputFileUrl = make_shared<string>(boost::any_cast<string>(m["InputFileUrl"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("TranscodeJobId") != m.end() && !m["TranscodeJobId"].empty()) {
      transcodeJobId = make_shared<string>(boost::any_cast<string>(m["TranscodeJobId"]));
    }
    if (m.find("TranscodeJobStatus") != m.end() && !m["TranscodeJobStatus"].empty()) {
      transcodeJobStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeJobStatus"]));
    }
    if (m.find("TranscodeProgress") != m.end() && !m["TranscodeProgress"].empty()) {
      transcodeProgress = make_shared<long>(boost::any_cast<long>(m["TranscodeProgress"]));
    }
    if (m.find("TranscodeTemplateId") != m.end() && !m["TranscodeTemplateId"].empty()) {
      transcodeTemplateId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateId"]));
    }
  }


  virtual ~GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList() = default;
};
class GetTranscodeTaskResponseBodyTranscodeTask : public Darabonba::Model {
public:
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> taskStatus{};
  shared_ptr<vector<GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList>> transcodeJobInfoList{};
  shared_ptr<string> transcodeTaskId{};
  shared_ptr<string> transcodeTemplateGroupId{};
  shared_ptr<string> trigger{};
  shared_ptr<string> videoId{};

  GetTranscodeTaskResponseBodyTranscodeTask() {}

  explicit GetTranscodeTaskResponseBodyTranscodeTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (transcodeJobInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeJobInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeJobInfoList"] = boost::any(temp1);
    }
    if (transcodeTaskId) {
      res["TranscodeTaskId"] = boost::any(*transcodeTaskId);
    }
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    if (trigger) {
      res["Trigger"] = boost::any(*trigger);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TranscodeJobInfoList") != m.end() && !m["TranscodeJobInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeJobInfoList"].type()) {
        vector<GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeJobInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeJobInfoList = make_shared<vector<GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList>>(expect1);
      }
    }
    if (m.find("TranscodeTaskId") != m.end() && !m["TranscodeTaskId"].empty()) {
      transcodeTaskId = make_shared<string>(boost::any_cast<string>(m["TranscodeTaskId"]));
    }
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      trigger = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetTranscodeTaskResponseBodyTranscodeTask() = default;
};
class GetTranscodeTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTranscodeTaskResponseBodyTranscodeTask> transcodeTask{};

  GetTranscodeTaskResponseBody() {}

  explicit GetTranscodeTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeTask) {
      res["TranscodeTask"] = transcodeTask ? boost::any(transcodeTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeTask") != m.end() && !m["TranscodeTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeTask"].type()) {
        GetTranscodeTaskResponseBodyTranscodeTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeTask"]));
        transcodeTask = make_shared<GetTranscodeTaskResponseBodyTranscodeTask>(model1);
      }
    }
  }


  virtual ~GetTranscodeTaskResponseBody() = default;
};
class GetTranscodeTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTranscodeTaskResponseBody> body{};

  GetTranscodeTaskResponse() {}

  explicit GetTranscodeTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTranscodeTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTranscodeTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetTranscodeTaskResponse() = default;
};
class GetTranscodeTemplateGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> transcodeTemplateGroupId{};

  GetTranscodeTemplateGroupRequest() {}

  explicit GetTranscodeTemplateGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
  }


  virtual ~GetTranscodeTemplateGroupRequest() = default;
};
class GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> audio{};
  shared_ptr<string> clip{};
  shared_ptr<string> container{};
  shared_ptr<string> copyrightMark{};
  shared_ptr<string> definition{};
  shared_ptr<string> encryptSetting{};
  shared_ptr<string> muxConfig{};
  shared_ptr<string> packageSetting{};
  shared_ptr<string> rotate{};
  shared_ptr<string> subtitleList{};
  shared_ptr<string> templateName{};
  shared_ptr<string> traceMark{};
  shared_ptr<string> transConfig{};
  shared_ptr<string> transcodeFileRegular{};
  shared_ptr<string> transcodeTemplateId{};
  shared_ptr<string> type{};
  shared_ptr<string> video{};
  shared_ptr<vector<string>> watermarkIds{};

  GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList() {}

  explicit GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = boost::any(*audio);
    }
    if (clip) {
      res["Clip"] = boost::any(*clip);
    }
    if (container) {
      res["Container"] = boost::any(*container);
    }
    if (copyrightMark) {
      res["CopyrightMark"] = boost::any(*copyrightMark);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (encryptSetting) {
      res["EncryptSetting"] = boost::any(*encryptSetting);
    }
    if (muxConfig) {
      res["MuxConfig"] = boost::any(*muxConfig);
    }
    if (packageSetting) {
      res["PackageSetting"] = boost::any(*packageSetting);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (subtitleList) {
      res["SubtitleList"] = boost::any(*subtitleList);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (traceMark) {
      res["TraceMark"] = boost::any(*traceMark);
    }
    if (transConfig) {
      res["TransConfig"] = boost::any(*transConfig);
    }
    if (transcodeFileRegular) {
      res["TranscodeFileRegular"] = boost::any(*transcodeFileRegular);
    }
    if (transcodeTemplateId) {
      res["TranscodeTemplateId"] = boost::any(*transcodeTemplateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    if (watermarkIds) {
      res["WatermarkIds"] = boost::any(*watermarkIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      audio = make_shared<string>(boost::any_cast<string>(m["Audio"]));
    }
    if (m.find("Clip") != m.end() && !m["Clip"].empty()) {
      clip = make_shared<string>(boost::any_cast<string>(m["Clip"]));
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      container = make_shared<string>(boost::any_cast<string>(m["Container"]));
    }
    if (m.find("CopyrightMark") != m.end() && !m["CopyrightMark"].empty()) {
      copyrightMark = make_shared<string>(boost::any_cast<string>(m["CopyrightMark"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("EncryptSetting") != m.end() && !m["EncryptSetting"].empty()) {
      encryptSetting = make_shared<string>(boost::any_cast<string>(m["EncryptSetting"]));
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      muxConfig = make_shared<string>(boost::any_cast<string>(m["MuxConfig"]));
    }
    if (m.find("PackageSetting") != m.end() && !m["PackageSetting"].empty()) {
      packageSetting = make_shared<string>(boost::any_cast<string>(m["PackageSetting"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("SubtitleList") != m.end() && !m["SubtitleList"].empty()) {
      subtitleList = make_shared<string>(boost::any_cast<string>(m["SubtitleList"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TraceMark") != m.end() && !m["TraceMark"].empty()) {
      traceMark = make_shared<string>(boost::any_cast<string>(m["TraceMark"]));
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      transConfig = make_shared<string>(boost::any_cast<string>(m["TransConfig"]));
    }
    if (m.find("TranscodeFileRegular") != m.end() && !m["TranscodeFileRegular"].empty()) {
      transcodeFileRegular = make_shared<string>(boost::any_cast<string>(m["TranscodeFileRegular"]));
    }
    if (m.find("TranscodeTemplateId") != m.end() && !m["TranscodeTemplateId"].empty()) {
      transcodeTemplateId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
    if (m.find("WatermarkIds") != m.end() && !m["WatermarkIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WatermarkIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WatermarkIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      watermarkIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList() = default;
};
class GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> locked{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> transcodeTemplateGroupId{};
  shared_ptr<vector<GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList>> transcodeTemplateList{};

  GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup() {}

  explicit GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (locked) {
      res["Locked"] = boost::any(*locked);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    if (transcodeTemplateList) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeTemplateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeTemplateList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("Locked") != m.end() && !m["Locked"].empty()) {
      locked = make_shared<string>(boost::any_cast<string>(m["Locked"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
    if (m.find("TranscodeTemplateList") != m.end() && !m["TranscodeTemplateList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeTemplateList"].type()) {
        vector<GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeTemplateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeTemplateList = make_shared<vector<GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList>>(expect1);
      }
    }
  }


  virtual ~GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup() = default;
};
class GetTranscodeTemplateGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup> transcodeTemplateGroup{};

  GetTranscodeTemplateGroupResponseBody() {}

  explicit GetTranscodeTemplateGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeTemplateGroup) {
      res["TranscodeTemplateGroup"] = transcodeTemplateGroup ? boost::any(transcodeTemplateGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeTemplateGroup") != m.end() && !m["TranscodeTemplateGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeTemplateGroup"].type()) {
        GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeTemplateGroup"]));
        transcodeTemplateGroup = make_shared<GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup>(model1);
      }
    }
  }


  virtual ~GetTranscodeTemplateGroupResponseBody() = default;
};
class GetTranscodeTemplateGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTranscodeTemplateGroupResponseBody> body{};

  GetTranscodeTemplateGroupResponse() {}

  explicit GetTranscodeTemplateGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTranscodeTemplateGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTranscodeTemplateGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetTranscodeTemplateGroupResponse() = default;
};
class GetURLUploadInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> uploadURLs{};

  GetURLUploadInfosRequest() {}

  explicit GetURLUploadInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (uploadURLs) {
      res["UploadURLs"] = boost::any(*uploadURLs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("UploadURLs") != m.end() && !m["UploadURLs"].empty()) {
      uploadURLs = make_shared<string>(boost::any_cast<string>(m["UploadURLs"]));
    }
  }


  virtual ~GetURLUploadInfosRequest() = default;
};
class GetURLUploadInfosResponseBodyURLUploadInfoList : public Darabonba::Model {
public:
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> status{};
  shared_ptr<string> uploadURL{};
  shared_ptr<string> userData{};

  GetURLUploadInfosResponseBodyURLUploadInfoList() {}

  explicit GetURLUploadInfosResponseBodyURLUploadInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uploadURL) {
      res["UploadURL"] = boost::any(*uploadURL);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UploadURL") != m.end() && !m["UploadURL"].empty()) {
      uploadURL = make_shared<string>(boost::any_cast<string>(m["UploadURL"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetURLUploadInfosResponseBodyURLUploadInfoList() = default;
};
class GetURLUploadInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nonExists{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetURLUploadInfosResponseBodyURLUploadInfoList>> URLUploadInfoList{};

  GetURLUploadInfosResponseBody() {}

  explicit GetURLUploadInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExists) {
      res["NonExists"] = boost::any(*nonExists);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (URLUploadInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*URLUploadInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["URLUploadInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExists") != m.end() && !m["NonExists"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExists"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExists"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExists = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("URLUploadInfoList") != m.end() && !m["URLUploadInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["URLUploadInfoList"].type()) {
        vector<GetURLUploadInfosResponseBodyURLUploadInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["URLUploadInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetURLUploadInfosResponseBodyURLUploadInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        URLUploadInfoList = make_shared<vector<GetURLUploadInfosResponseBodyURLUploadInfoList>>(expect1);
      }
    }
  }


  virtual ~GetURLUploadInfosResponseBody() = default;
};
class GetURLUploadInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetURLUploadInfosResponseBody> body{};

  GetURLUploadInfosResponse() {}

  explicit GetURLUploadInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetURLUploadInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetURLUploadInfosResponseBody>(model1);
      }
    }
  }


  virtual ~GetURLUploadInfosResponse() = default;
};
class GetUploadDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaIds{};
  shared_ptr<string> mediaType{};

  GetUploadDetailsRequest() {}

  explicit GetUploadDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~GetUploadDetailsRequest() = default;
};
class GetUploadDetailsResponseBodyUploadDetails : public Darabonba::Model {
public:
  shared_ptr<string> completionTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> deviceModel{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> uploadIP{};
  shared_ptr<double> uploadRatio{};
  shared_ptr<long> uploadSize{};
  shared_ptr<string> uploadSource{};
  shared_ptr<string> uploadStatus{};

  GetUploadDetailsResponseBodyUploadDetails() {}

  explicit GetUploadDetailsResponseBodyUploadDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completionTime) {
      res["CompletionTime"] = boost::any(*completionTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (uploadIP) {
      res["UploadIP"] = boost::any(*uploadIP);
    }
    if (uploadRatio) {
      res["UploadRatio"] = boost::any(*uploadRatio);
    }
    if (uploadSize) {
      res["UploadSize"] = boost::any(*uploadSize);
    }
    if (uploadSource) {
      res["UploadSource"] = boost::any(*uploadSource);
    }
    if (uploadStatus) {
      res["UploadStatus"] = boost::any(*uploadStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompletionTime") != m.end() && !m["CompletionTime"].empty()) {
      completionTime = make_shared<string>(boost::any_cast<string>(m["CompletionTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["FileSize"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UploadIP") != m.end() && !m["UploadIP"].empty()) {
      uploadIP = make_shared<string>(boost::any_cast<string>(m["UploadIP"]));
    }
    if (m.find("UploadRatio") != m.end() && !m["UploadRatio"].empty()) {
      uploadRatio = make_shared<double>(boost::any_cast<double>(m["UploadRatio"]));
    }
    if (m.find("UploadSize") != m.end() && !m["UploadSize"].empty()) {
      uploadSize = make_shared<long>(boost::any_cast<long>(m["UploadSize"]));
    }
    if (m.find("UploadSource") != m.end() && !m["UploadSource"].empty()) {
      uploadSource = make_shared<string>(boost::any_cast<string>(m["UploadSource"]));
    }
    if (m.find("UploadStatus") != m.end() && !m["UploadStatus"].empty()) {
      uploadStatus = make_shared<string>(boost::any_cast<string>(m["UploadStatus"]));
    }
  }


  virtual ~GetUploadDetailsResponseBodyUploadDetails() = default;
};
class GetUploadDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forbiddenMediaIds{};
  shared_ptr<vector<string>> nonExistMediaIds{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetUploadDetailsResponseBodyUploadDetails>> uploadDetails{};

  GetUploadDetailsResponseBody() {}

  explicit GetUploadDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbiddenMediaIds) {
      res["ForbiddenMediaIds"] = boost::any(*forbiddenMediaIds);
    }
    if (nonExistMediaIds) {
      res["NonExistMediaIds"] = boost::any(*nonExistMediaIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadDetails) {
      vector<boost::any> temp1;
      for(auto item1:*uploadDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UploadDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbiddenMediaIds") != m.end() && !m["ForbiddenMediaIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForbiddenMediaIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForbiddenMediaIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forbiddenMediaIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NonExistMediaIds") != m.end() && !m["NonExistMediaIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistMediaIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistMediaIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistMediaIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadDetails") != m.end() && !m["UploadDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["UploadDetails"].type()) {
        vector<GetUploadDetailsResponseBodyUploadDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UploadDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUploadDetailsResponseBodyUploadDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uploadDetails = make_shared<vector<GetUploadDetailsResponseBodyUploadDetails>>(expect1);
      }
    }
  }


  virtual ~GetUploadDetailsResponseBody() = default;
};
class GetUploadDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUploadDetailsResponseBody> body{};

  GetUploadDetailsResponse() {}

  explicit GetUploadDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUploadDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUploadDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~GetUploadDetailsResponse() = default;
};
class GetVideoInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> videoId{};

  GetVideoInfoRequest() {}

  explicit GetVideoInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetVideoInfoRequest() = default;
};
class GetVideoInfoResponseBodyVideoSnapshots : public Darabonba::Model {
public:
  shared_ptr<vector<string>> snapshot{};

  GetVideoInfoResponseBodyVideoSnapshots() {}

  explicit GetVideoInfoResponseBodyVideoSnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      res["Snapshot"] = boost::any(*snapshot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Snapshot"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshot = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetVideoInfoResponseBodyVideoSnapshots() = default;
};
class GetVideoInfoResponseBodyVideo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> auditStatus{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> customMediaInfo{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> restoreExpiration{};
  shared_ptr<string> restoreStatus{};
  shared_ptr<long> size{};
  shared_ptr<GetVideoInfoResponseBodyVideoSnapshots> snapshots{};
  shared_ptr<string> status{};
  shared_ptr<string> storageClass{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> templateGroupId{};
  shared_ptr<string> title{};
  shared_ptr<string> videoId{};

  GetVideoInfoResponseBodyVideo() {}

  explicit GetVideoInfoResponseBodyVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (auditStatus) {
      res["AuditStatus"] = boost::any(*auditStatus);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (customMediaInfo) {
      res["CustomMediaInfo"] = boost::any(*customMediaInfo);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (restoreExpiration) {
      res["RestoreExpiration"] = boost::any(*restoreExpiration);
    }
    if (restoreStatus) {
      res["RestoreStatus"] = boost::any(*restoreStatus);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshots) {
      res["Snapshots"] = snapshots ? boost::any(snapshots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (templateGroupId) {
      res["TemplateGroupId"] = boost::any(*templateGroupId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AuditStatus") != m.end() && !m["AuditStatus"].empty()) {
      auditStatus = make_shared<string>(boost::any_cast<string>(m["AuditStatus"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("CustomMediaInfo") != m.end() && !m["CustomMediaInfo"].empty()) {
      customMediaInfo = make_shared<string>(boost::any_cast<string>(m["CustomMediaInfo"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RestoreExpiration") != m.end() && !m["RestoreExpiration"].empty()) {
      restoreExpiration = make_shared<string>(boost::any_cast<string>(m["RestoreExpiration"]));
    }
    if (m.find("RestoreStatus") != m.end() && !m["RestoreStatus"].empty()) {
      restoreStatus = make_shared<string>(boost::any_cast<string>(m["RestoreStatus"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(map<string, boost::any>) == m["Snapshots"].type()) {
        GetVideoInfoResponseBodyVideoSnapshots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Snapshots"]));
        snapshots = make_shared<GetVideoInfoResponseBodyVideoSnapshots>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TemplateGroupId") != m.end() && !m["TemplateGroupId"].empty()) {
      templateGroupId = make_shared<string>(boost::any_cast<string>(m["TemplateGroupId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetVideoInfoResponseBodyVideo() = default;
};
class GetVideoInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetVideoInfoResponseBodyVideo> video{};

  GetVideoInfoResponseBody() {}

  explicit GetVideoInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        GetVideoInfoResponseBodyVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<GetVideoInfoResponseBodyVideo>(model1);
      }
    }
  }


  virtual ~GetVideoInfoResponseBody() = default;
};
class GetVideoInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVideoInfoResponseBody> body{};

  GetVideoInfoResponse() {}

  explicit GetVideoInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVideoInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVideoInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetVideoInfoResponse() = default;
};
class GetVideoInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> videoIds{};

  GetVideoInfosRequest() {}

  explicit GetVideoInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoIds) {
      res["VideoIds"] = boost::any(*videoIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoIds") != m.end() && !m["VideoIds"].empty()) {
      videoIds = make_shared<string>(boost::any_cast<string>(m["VideoIds"]));
    }
  }


  virtual ~GetVideoInfosRequest() = default;
};
class GetVideoInfosResponseBodyVideoList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> restoreExpiration{};
  shared_ptr<string> restoreStatus{};
  shared_ptr<long> size{};
  shared_ptr<vector<string>> snapshots{};
  shared_ptr<string> status{};
  shared_ptr<string> storageClass{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> templateGroupId{};
  shared_ptr<string> title{};
  shared_ptr<string> videoId{};

  GetVideoInfosResponseBodyVideoList() {}

  explicit GetVideoInfosResponseBodyVideoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (restoreExpiration) {
      res["RestoreExpiration"] = boost::any(*restoreExpiration);
    }
    if (restoreStatus) {
      res["RestoreStatus"] = boost::any(*restoreStatus);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (templateGroupId) {
      res["TemplateGroupId"] = boost::any(*templateGroupId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("RestoreExpiration") != m.end() && !m["RestoreExpiration"].empty()) {
      restoreExpiration = make_shared<string>(boost::any_cast<string>(m["RestoreExpiration"]));
    }
    if (m.find("RestoreStatus") != m.end() && !m["RestoreStatus"].empty()) {
      restoreStatus = make_shared<string>(boost::any_cast<string>(m["RestoreStatus"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Snapshots"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshots = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TemplateGroupId") != m.end() && !m["TemplateGroupId"].empty()) {
      templateGroupId = make_shared<string>(boost::any_cast<string>(m["TemplateGroupId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetVideoInfosResponseBodyVideoList() = default;
};
class GetVideoInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nonExistVideoIds{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetVideoInfosResponseBodyVideoList>> videoList{};

  GetVideoInfosResponseBody() {}

  explicit GetVideoInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistVideoIds) {
      res["NonExistVideoIds"] = boost::any(*nonExistVideoIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (videoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistVideoIds") != m.end() && !m["NonExistVideoIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistVideoIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistVideoIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistVideoIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VideoList") != m.end() && !m["VideoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoList"].type()) {
        vector<GetVideoInfosResponseBodyVideoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVideoInfosResponseBodyVideoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoList = make_shared<vector<GetVideoInfosResponseBodyVideoList>>(expect1);
      }
    }
  }


  virtual ~GetVideoInfosResponseBody() = default;
};
class GetVideoInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVideoInfosResponseBody> body{};

  GetVideoInfosResponse() {}

  explicit GetVideoInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVideoInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVideoInfosResponseBody>(model1);
      }
    }
  }


  virtual ~GetVideoInfosResponse() = default;
};
class GetVideoListRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};

  GetVideoListRequest() {}

  explicit GetVideoListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
  }


  virtual ~GetVideoListRequest() = default;
};
class GetVideoListResponseBodyVideoListVideoSnapshots : public Darabonba::Model {
public:
  shared_ptr<vector<string>> snapshot{};

  GetVideoListResponseBodyVideoListVideoSnapshots() {}

  explicit GetVideoListResponseBodyVideoListVideoSnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      res["Snapshot"] = boost::any(*snapshot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Snapshot"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshot = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetVideoListResponseBodyVideoListVideoSnapshots() = default;
};
class GetVideoListResponseBodyVideoListVideo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> restoreExpiration{};
  shared_ptr<string> restoreStatus{};
  shared_ptr<long> size{};
  shared_ptr<GetVideoListResponseBodyVideoListVideoSnapshots> snapshots{};
  shared_ptr<string> status{};
  shared_ptr<string> storageClass{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> videoId{};

  GetVideoListResponseBodyVideoListVideo() {}

  explicit GetVideoListResponseBodyVideoListVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (restoreExpiration) {
      res["RestoreExpiration"] = boost::any(*restoreExpiration);
    }
    if (restoreStatus) {
      res["RestoreStatus"] = boost::any(*restoreStatus);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshots) {
      res["Snapshots"] = snapshots ? boost::any(snapshots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("RestoreExpiration") != m.end() && !m["RestoreExpiration"].empty()) {
      restoreExpiration = make_shared<string>(boost::any_cast<string>(m["RestoreExpiration"]));
    }
    if (m.find("RestoreStatus") != m.end() && !m["RestoreStatus"].empty()) {
      restoreStatus = make_shared<string>(boost::any_cast<string>(m["RestoreStatus"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(map<string, boost::any>) == m["Snapshots"].type()) {
        GetVideoListResponseBodyVideoListVideoSnapshots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Snapshots"]));
        snapshots = make_shared<GetVideoListResponseBodyVideoListVideoSnapshots>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetVideoListResponseBodyVideoListVideo() = default;
};
class GetVideoListResponseBodyVideoList : public Darabonba::Model {
public:
  shared_ptr<vector<GetVideoListResponseBodyVideoListVideo>> video{};

  GetVideoListResponseBodyVideoList() {}

  explicit GetVideoListResponseBodyVideoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (video) {
      vector<boost::any> temp1;
      for(auto item1:*video){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Video"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(vector<boost::any>) == m["Video"].type()) {
        vector<GetVideoListResponseBodyVideoListVideo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Video"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVideoListResponseBodyVideoListVideo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        video = make_shared<vector<GetVideoListResponseBodyVideoListVideo>>(expect1);
      }
    }
  }


  virtual ~GetVideoListResponseBodyVideoList() = default;
};
class GetVideoListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<GetVideoListResponseBodyVideoList> videoList{};

  GetVideoListResponseBody() {}

  explicit GetVideoListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (videoList) {
      res["VideoList"] = videoList ? boost::any(videoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("VideoList") != m.end() && !m["VideoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoList"].type()) {
        GetVideoListResponseBodyVideoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoList"]));
        videoList = make_shared<GetVideoListResponseBodyVideoList>(model1);
      }
    }
  }


  virtual ~GetVideoListResponseBody() = default;
};
class GetVideoListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVideoListResponseBody> body{};

  GetVideoListResponse() {}

  explicit GetVideoListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVideoListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVideoListResponseBody>(model1);
      }
    }
  }


  virtual ~GetVideoListResponse() = default;
};
class GetVideoPlayAuthRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiVersion{};
  shared_ptr<long> authInfoTimeout{};
  shared_ptr<string> videoId{};

  GetVideoPlayAuthRequest() {}

  explicit GetVideoPlayAuthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiVersion) {
      res["ApiVersion"] = boost::any(*apiVersion);
    }
    if (authInfoTimeout) {
      res["AuthInfoTimeout"] = boost::any(*authInfoTimeout);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiVersion") != m.end() && !m["ApiVersion"].empty()) {
      apiVersion = make_shared<string>(boost::any_cast<string>(m["ApiVersion"]));
    }
    if (m.find("AuthInfoTimeout") != m.end() && !m["AuthInfoTimeout"].empty()) {
      authInfoTimeout = make_shared<long>(boost::any_cast<long>(m["AuthInfoTimeout"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetVideoPlayAuthRequest() = default;
};
class GetVideoPlayAuthResponseBodyVideoMeta : public Darabonba::Model {
public:
  shared_ptr<string> coverURL{};
  shared_ptr<double> duration{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> videoId{};

  GetVideoPlayAuthResponseBodyVideoMeta() {}

  explicit GetVideoPlayAuthResponseBodyVideoMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~GetVideoPlayAuthResponseBodyVideoMeta() = default;
};
class GetVideoPlayAuthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> playAuth{};
  shared_ptr<string> requestId{};
  shared_ptr<GetVideoPlayAuthResponseBodyVideoMeta> videoMeta{};

  GetVideoPlayAuthResponseBody() {}

  explicit GetVideoPlayAuthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (playAuth) {
      res["PlayAuth"] = boost::any(*playAuth);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (videoMeta) {
      res["VideoMeta"] = videoMeta ? boost::any(videoMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlayAuth") != m.end() && !m["PlayAuth"].empty()) {
      playAuth = make_shared<string>(boost::any_cast<string>(m["PlayAuth"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VideoMeta") != m.end() && !m["VideoMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoMeta"].type()) {
        GetVideoPlayAuthResponseBodyVideoMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoMeta"]));
        videoMeta = make_shared<GetVideoPlayAuthResponseBodyVideoMeta>(model1);
      }
    }
  }


  virtual ~GetVideoPlayAuthResponseBody() = default;
};
class GetVideoPlayAuthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVideoPlayAuthResponseBody> body{};

  GetVideoPlayAuthResponse() {}

  explicit GetVideoPlayAuthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVideoPlayAuthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVideoPlayAuthResponseBody>(model1);
      }
    }
  }


  virtual ~GetVideoPlayAuthResponse() = default;
};
class GetVodTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> vodTemplateId{};

  GetVodTemplateRequest() {}

  explicit GetVodTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vodTemplateId) {
      res["VodTemplateId"] = boost::any(*vodTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VodTemplateId") != m.end() && !m["VodTemplateId"].empty()) {
      vodTemplateId = make_shared<string>(boost::any_cast<string>(m["VodTemplateId"]));
    }
  }


  virtual ~GetVodTemplateRequest() = default;
};
class GetVodTemplateResponseBodyVodTemplateInfo : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateType{};
  shared_ptr<string> vodTemplateId{};

  GetVodTemplateResponseBodyVodTemplateInfo() {}

  explicit GetVodTemplateResponseBodyVodTemplateInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (vodTemplateId) {
      res["VodTemplateId"] = boost::any(*vodTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VodTemplateId") != m.end() && !m["VodTemplateId"].empty()) {
      vodTemplateId = make_shared<string>(boost::any_cast<string>(m["VodTemplateId"]));
    }
  }


  virtual ~GetVodTemplateResponseBodyVodTemplateInfo() = default;
};
class GetVodTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetVodTemplateResponseBodyVodTemplateInfo> vodTemplateInfo{};

  GetVodTemplateResponseBody() {}

  explicit GetVodTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vodTemplateInfo) {
      res["VodTemplateInfo"] = vodTemplateInfo ? boost::any(vodTemplateInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VodTemplateInfo") != m.end() && !m["VodTemplateInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["VodTemplateInfo"].type()) {
        GetVodTemplateResponseBodyVodTemplateInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VodTemplateInfo"]));
        vodTemplateInfo = make_shared<GetVodTemplateResponseBodyVodTemplateInfo>(model1);
      }
    }
  }


  virtual ~GetVodTemplateResponseBody() = default;
};
class GetVodTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVodTemplateResponseBody> body{};

  GetVodTemplateResponse() {}

  explicit GetVodTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVodTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVodTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetVodTemplateResponse() = default;
};
class GetWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> watermarkId{};

  GetWatermarkRequest() {}

  explicit GetWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
  }


  virtual ~GetWatermarkRequest() = default;
};
class GetWatermarkResponseBodyWatermarkInfo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> watermarkConfig{};
  shared_ptr<string> watermarkId{};

  GetWatermarkResponseBodyWatermarkInfo() {}

  explicit GetWatermarkResponseBodyWatermarkInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (watermarkConfig) {
      res["WatermarkConfig"] = boost::any(*watermarkConfig);
    }
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WatermarkConfig") != m.end() && !m["WatermarkConfig"].empty()) {
      watermarkConfig = make_shared<string>(boost::any_cast<string>(m["WatermarkConfig"]));
    }
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
  }


  virtual ~GetWatermarkResponseBodyWatermarkInfo() = default;
};
class GetWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetWatermarkResponseBodyWatermarkInfo> watermarkInfo{};

  GetWatermarkResponseBody() {}

  explicit GetWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (watermarkInfo) {
      res["WatermarkInfo"] = watermarkInfo ? boost::any(watermarkInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WatermarkInfo") != m.end() && !m["WatermarkInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["WatermarkInfo"].type()) {
        GetWatermarkResponseBodyWatermarkInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WatermarkInfo"]));
        watermarkInfo = make_shared<GetWatermarkResponseBodyWatermarkInfo>(model1);
      }
    }
  }


  virtual ~GetWatermarkResponseBody() = default;
};
class GetWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWatermarkResponseBody> body{};

  GetWatermarkResponse() {}

  explicit GetWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~GetWatermarkResponse() = default;
};
class ListAIImageInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> videoId{};

  ListAIImageInfoRequest() {}

  explicit ListAIImageInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~ListAIImageInfoRequest() = default;
};
class ListAIImageInfoResponseBodyAIImageInfoList : public Darabonba::Model {
public:
  shared_ptr<string> AIImageInfoId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> fileURL{};
  shared_ptr<string> format{};
  shared_ptr<string> jobId{};
  shared_ptr<string> score{};
  shared_ptr<string> version{};
  shared_ptr<string> videoId{};

  ListAIImageInfoResponseBodyAIImageInfoList() {}

  explicit ListAIImageInfoResponseBodyAIImageInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIImageInfoId) {
      res["AIImageInfoId"] = boost::any(*AIImageInfoId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIImageInfoId") != m.end() && !m["AIImageInfoId"].empty()) {
      AIImageInfoId = make_shared<string>(boost::any_cast<string>(m["AIImageInfoId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~ListAIImageInfoResponseBodyAIImageInfoList() = default;
};
class ListAIImageInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAIImageInfoResponseBodyAIImageInfoList>> AIImageInfoList{};
  shared_ptr<string> requestId{};

  ListAIImageInfoResponseBody() {}

  explicit ListAIImageInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIImageInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*AIImageInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AIImageInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIImageInfoList") != m.end() && !m["AIImageInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AIImageInfoList"].type()) {
        vector<ListAIImageInfoResponseBodyAIImageInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AIImageInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAIImageInfoResponseBodyAIImageInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        AIImageInfoList = make_shared<vector<ListAIImageInfoResponseBodyAIImageInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAIImageInfoResponseBody() = default;
};
class ListAIImageInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAIImageInfoResponseBody> body{};

  ListAIImageInfoResponse() {}

  explicit ListAIImageInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAIImageInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAIImageInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ListAIImageInfoResponse() = default;
};
class ListAIJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  ListAIJobRequest() {}

  explicit ListAIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListAIJobRequest() = default;
};
class ListAIJobResponseBodyAIJobListAIJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> data{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> message{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListAIJobResponseBodyAIJobListAIJob() {}

  explicit ListAIJobResponseBodyAIJobListAIJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAIJobResponseBodyAIJobListAIJob() = default;
};
class ListAIJobResponseBodyAIJobList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAIJobResponseBodyAIJobListAIJob>> AIJob{};

  ListAIJobResponseBodyAIJobList() {}

  explicit ListAIJobResponseBodyAIJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIJob) {
      vector<boost::any> temp1;
      for(auto item1:*AIJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AIJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIJob") != m.end() && !m["AIJob"].empty()) {
      if (typeid(vector<boost::any>) == m["AIJob"].type()) {
        vector<ListAIJobResponseBodyAIJobListAIJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AIJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAIJobResponseBodyAIJobListAIJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        AIJob = make_shared<vector<ListAIJobResponseBodyAIJobListAIJob>>(expect1);
      }
    }
  }


  virtual ~ListAIJobResponseBodyAIJobList() = default;
};
class ListAIJobResponseBodyNonExistAIJobIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  ListAIJobResponseBodyNonExistAIJobIds() {}

  explicit ListAIJobResponseBodyNonExistAIJobIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAIJobResponseBodyNonExistAIJobIds() = default;
};
class ListAIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAIJobResponseBodyAIJobList> AIJobList{};
  shared_ptr<ListAIJobResponseBodyNonExistAIJobIds> nonExistAIJobIds{};
  shared_ptr<string> requestId{};

  ListAIJobResponseBody() {}

  explicit ListAIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIJobList) {
      res["AIJobList"] = AIJobList ? boost::any(AIJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistAIJobIds) {
      res["NonExistAIJobIds"] = nonExistAIJobIds ? boost::any(nonExistAIJobIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIJobList") != m.end() && !m["AIJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AIJobList"].type()) {
        ListAIJobResponseBodyAIJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AIJobList"]));
        AIJobList = make_shared<ListAIJobResponseBodyAIJobList>(model1);
      }
    }
    if (m.find("NonExistAIJobIds") != m.end() && !m["NonExistAIJobIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistAIJobIds"].type()) {
        ListAIJobResponseBodyNonExistAIJobIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistAIJobIds"]));
        nonExistAIJobIds = make_shared<ListAIJobResponseBodyNonExistAIJobIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAIJobResponseBody() = default;
};
class ListAIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAIJobResponseBody> body{};

  ListAIJobResponse() {}

  explicit ListAIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAIJobResponseBody>(model1);
      }
    }
  }


  virtual ~ListAIJobResponse() = default;
};
class ListAITemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateType{};

  ListAITemplateRequest() {}

  explicit ListAITemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~ListAITemplateRequest() = default;
};
class ListAITemplateResponseBodyTemplateInfoList : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> source{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  ListAITemplateResponseBodyTemplateInfoList() {}

  explicit ListAITemplateResponseBodyTemplateInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~ListAITemplateResponseBodyTemplateInfoList() = default;
};
class ListAITemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAITemplateResponseBodyTemplateInfoList>> templateInfoList{};

  ListAITemplateResponseBody() {}

  explicit ListAITemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*templateInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateInfoList") != m.end() && !m["TemplateInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateInfoList"].type()) {
        vector<ListAITemplateResponseBodyTemplateInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAITemplateResponseBodyTemplateInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateInfoList = make_shared<vector<ListAITemplateResponseBodyTemplateInfoList>>(expect1);
      }
    }
  }


  virtual ~ListAITemplateResponseBody() = default;
};
class ListAITemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAITemplateResponseBody> body{};

  ListAITemplateResponse() {}

  explicit ListAITemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAITemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAITemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ListAITemplateResponse() = default;
};
class ListAppInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  ListAppInfoRequest() {}

  explicit ListAppInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAppInfoRequest() = default;
};
class ListAppInfoResponseBodyAppInfoList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListAppInfoResponseBodyAppInfoList() {}

  explicit ListAppInfoResponseBodyAppInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAppInfoResponseBodyAppInfoList() = default;
};
class ListAppInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAppInfoResponseBodyAppInfoList>> appInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListAppInfoResponseBody() {}

  explicit ListAppInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*appInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppInfoList") != m.end() && !m["AppInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AppInfoList"].type()) {
        vector<ListAppInfoResponseBodyAppInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppInfoResponseBodyAppInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appInfoList = make_shared<vector<ListAppInfoResponseBodyAppInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListAppInfoResponseBody() = default;
};
class ListAppInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAppInfoResponseBody> body{};

  ListAppInfoResponse() {}

  explicit ListAppInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAppInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAppInfoResponseBody>(model1);
      }
    }
  }


  virtual ~ListAppInfoResponse() = default;
};
class ListAppPoliciesForIdentityRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> identityName{};
  shared_ptr<string> identityType{};

  ListAppPoliciesForIdentityRequest() {}

  explicit ListAppPoliciesForIdentityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (identityName) {
      res["IdentityName"] = boost::any(*identityName);
    }
    if (identityType) {
      res["IdentityType"] = boost::any(*identityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("IdentityName") != m.end() && !m["IdentityName"].empty()) {
      identityName = make_shared<string>(boost::any_cast<string>(m["IdentityName"]));
    }
    if (m.find("IdentityType") != m.end() && !m["IdentityType"].empty()) {
      identityType = make_shared<string>(boost::any_cast<string>(m["IdentityType"]));
    }
  }


  virtual ~ListAppPoliciesForIdentityRequest() = default;
};
class ListAppPoliciesForIdentityResponseBodyAppPolicyList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyType{};
  shared_ptr<string> policyValue{};

  ListAppPoliciesForIdentityResponseBodyAppPolicyList() {}

  explicit ListAppPoliciesForIdentityResponseBodyAppPolicyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (policyType) {
      res["PolicyType"] = boost::any(*policyType);
    }
    if (policyValue) {
      res["PolicyValue"] = boost::any(*policyValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("PolicyType") != m.end() && !m["PolicyType"].empty()) {
      policyType = make_shared<string>(boost::any_cast<string>(m["PolicyType"]));
    }
    if (m.find("PolicyValue") != m.end() && !m["PolicyValue"].empty()) {
      policyValue = make_shared<string>(boost::any_cast<string>(m["PolicyValue"]));
    }
  }


  virtual ~ListAppPoliciesForIdentityResponseBodyAppPolicyList() = default;
};
class ListAppPoliciesForIdentityResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAppPoliciesForIdentityResponseBodyAppPolicyList>> appPolicyList{};
  shared_ptr<string> requestId{};

  ListAppPoliciesForIdentityResponseBody() {}

  explicit ListAppPoliciesForIdentityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appPolicyList) {
      vector<boost::any> temp1;
      for(auto item1:*appPolicyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppPolicyList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppPolicyList") != m.end() && !m["AppPolicyList"].empty()) {
      if (typeid(vector<boost::any>) == m["AppPolicyList"].type()) {
        vector<ListAppPoliciesForIdentityResponseBodyAppPolicyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppPolicyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppPoliciesForIdentityResponseBodyAppPolicyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appPolicyList = make_shared<vector<ListAppPoliciesForIdentityResponseBodyAppPolicyList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAppPoliciesForIdentityResponseBody() = default;
};
class ListAppPoliciesForIdentityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAppPoliciesForIdentityResponseBody> body{};

  ListAppPoliciesForIdentityResponse() {}

  explicit ListAppPoliciesForIdentityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAppPoliciesForIdentityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAppPoliciesForIdentityResponseBody>(model1);
      }
    }
  }


  virtual ~ListAppPoliciesForIdentityResponse() = default;
};
class ListAuditSecurityIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupName{};

  ListAuditSecurityIpRequest() {}

  explicit ListAuditSecurityIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~ListAuditSecurityIpRequest() = default;
};
class ListAuditSecurityIpResponseBodySecurityIpList : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> ips{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> securityGroupName{};

  ListAuditSecurityIpResponseBodySecurityIpList() {}

  explicit ListAuditSecurityIpResponseBodySecurityIpList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      ips = make_shared<string>(boost::any_cast<string>(m["Ips"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~ListAuditSecurityIpResponseBodySecurityIpList() = default;
};
class ListAuditSecurityIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAuditSecurityIpResponseBodySecurityIpList>> securityIpList{};

  ListAuditSecurityIpResponseBody() {}

  explicit ListAuditSecurityIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityIpList) {
      vector<boost::any> temp1;
      for(auto item1:*securityIpList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityIpList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityIpList") != m.end() && !m["SecurityIpList"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityIpList"].type()) {
        vector<ListAuditSecurityIpResponseBodySecurityIpList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityIpList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuditSecurityIpResponseBodySecurityIpList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityIpList = make_shared<vector<ListAuditSecurityIpResponseBodySecurityIpList>>(expect1);
      }
    }
  }


  virtual ~ListAuditSecurityIpResponseBody() = default;
};
class ListAuditSecurityIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAuditSecurityIpResponseBody> body{};

  ListAuditSecurityIpResponse() {}

  explicit ListAuditSecurityIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAuditSecurityIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAuditSecurityIpResponseBody>(model1);
      }
    }
  }


  virtual ~ListAuditSecurityIpResponse() = default;
};
class ListDynamicImageRequest : public Darabonba::Model {
public:
  shared_ptr<string> videoId{};

  ListDynamicImageRequest() {}

  explicit ListDynamicImageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~ListDynamicImageRequest() = default;
};
class ListDynamicImageResponseBodyDynamicImageList : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> dynamicImageId{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileURL{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> height{};
  shared_ptr<string> jobId{};
  shared_ptr<string> videoId{};
  shared_ptr<string> width{};

  ListDynamicImageResponseBodyDynamicImageList() {}

  explicit ListDynamicImageResponseBodyDynamicImageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (dynamicImageId) {
      res["DynamicImageId"] = boost::any(*dynamicImageId);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("DynamicImageId") != m.end() && !m["DynamicImageId"].empty()) {
      dynamicImageId = make_shared<string>(boost::any_cast<string>(m["DynamicImageId"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListDynamicImageResponseBodyDynamicImageList() = default;
};
class ListDynamicImageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDynamicImageResponseBodyDynamicImageList>> dynamicImageList{};
  shared_ptr<string> requestId{};

  ListDynamicImageResponseBody() {}

  explicit ListDynamicImageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicImageList) {
      vector<boost::any> temp1;
      for(auto item1:*dynamicImageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DynamicImageList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicImageList") != m.end() && !m["DynamicImageList"].empty()) {
      if (typeid(vector<boost::any>) == m["DynamicImageList"].type()) {
        vector<ListDynamicImageResponseBodyDynamicImageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DynamicImageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDynamicImageResponseBodyDynamicImageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dynamicImageList = make_shared<vector<ListDynamicImageResponseBodyDynamicImageList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDynamicImageResponseBody() = default;
};
class ListDynamicImageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDynamicImageResponseBody> body{};

  ListDynamicImageResponse() {}

  explicit ListDynamicImageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDynamicImageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDynamicImageResponseBody>(model1);
      }
    }
  }


  virtual ~ListDynamicImageResponse() = default;
};
class ListLiveRecordVideoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamName{};

  ListLiveRecordVideoRequest() {}

  explicit ListLiveRecordVideoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~ListLiveRecordVideoRequest() = default;
};
class ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots : public Darabonba::Model {
public:
  shared_ptr<vector<string>> snapshot{};

  ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots() {}

  explicit ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      res["Snapshot"] = boost::any(*snapshot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Snapshot"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshot = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots() = default;
};
class ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> modifyTime{};
  shared_ptr<long> size{};
  shared_ptr<ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots> snapshots{};
  shared_ptr<string> status{};
  shared_ptr<string> tags{};
  shared_ptr<string> templateGroupId{};
  shared_ptr<string> title{};
  shared_ptr<string> videoId{};

  ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo() {}

  explicit ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshots) {
      res["Snapshots"] = snapshots ? boost::any(snapshots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (templateGroupId) {
      res["TemplateGroupId"] = boost::any(*templateGroupId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(map<string, boost::any>) == m["Snapshots"].type()) {
        ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Snapshots"]));
        snapshots = make_shared<ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TemplateGroupId") != m.end() && !m["TemplateGroupId"].empty()) {
      templateGroupId = make_shared<string>(boost::any_cast<string>(m["TemplateGroupId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo() = default;
};
class ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> playlistId{};
  shared_ptr<string> recordEndTime{};
  shared_ptr<string> recordStartTime{};
  shared_ptr<string> streamName{};
  shared_ptr<ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo> video{};

  ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo() {}

  explicit ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (playlistId) {
      res["PlaylistId"] = boost::any(*playlistId);
    }
    if (recordEndTime) {
      res["RecordEndTime"] = boost::any(*recordEndTime);
    }
    if (recordStartTime) {
      res["RecordStartTime"] = boost::any(*recordStartTime);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PlaylistId") != m.end() && !m["PlaylistId"].empty()) {
      playlistId = make_shared<string>(boost::any_cast<string>(m["PlaylistId"]));
    }
    if (m.find("RecordEndTime") != m.end() && !m["RecordEndTime"].empty()) {
      recordEndTime = make_shared<string>(boost::any_cast<string>(m["RecordEndTime"]));
    }
    if (m.find("RecordStartTime") != m.end() && !m["RecordStartTime"].empty()) {
      recordStartTime = make_shared<string>(boost::any_cast<string>(m["RecordStartTime"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo>(model1);
      }
    }
  }


  virtual ~ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo() = default;
};
class ListLiveRecordVideoResponseBodyLiveRecordVideoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo>> liveRecordVideo{};

  ListLiveRecordVideoResponseBodyLiveRecordVideoList() {}

  explicit ListLiveRecordVideoResponseBodyLiveRecordVideoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveRecordVideo) {
      vector<boost::any> temp1;
      for(auto item1:*liveRecordVideo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveRecordVideo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveRecordVideo") != m.end() && !m["LiveRecordVideo"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveRecordVideo"].type()) {
        vector<ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveRecordVideo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveRecordVideo = make_shared<vector<ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo>>(expect1);
      }
    }
  }


  virtual ~ListLiveRecordVideoResponseBodyLiveRecordVideoList() = default;
};
class ListLiveRecordVideoResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLiveRecordVideoResponseBodyLiveRecordVideoList> liveRecordVideoList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListLiveRecordVideoResponseBody() {}

  explicit ListLiveRecordVideoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveRecordVideoList) {
      res["LiveRecordVideoList"] = liveRecordVideoList ? boost::any(liveRecordVideoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveRecordVideoList") != m.end() && !m["LiveRecordVideoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveRecordVideoList"].type()) {
        ListLiveRecordVideoResponseBodyLiveRecordVideoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveRecordVideoList"]));
        liveRecordVideoList = make_shared<ListLiveRecordVideoResponseBodyLiveRecordVideoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListLiveRecordVideoResponseBody() = default;
};
class ListLiveRecordVideoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRecordVideoResponseBody> body{};

  ListLiveRecordVideoResponse() {}

  explicit ListLiveRecordVideoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRecordVideoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRecordVideoResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRecordVideoResponse() = default;
};
class ListSnapshotsRequest : public Darabonba::Model {
public:
  shared_ptr<string> authTimeout{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> snapshotType{};
  shared_ptr<string> videoId{};

  ListSnapshotsRequest() {}

  explicit ListSnapshotsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (snapshotType) {
      res["SnapshotType"] = boost::any(*snapshotType);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<string>(boost::any_cast<string>(m["AuthTimeout"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SnapshotType") != m.end() && !m["SnapshotType"].empty()) {
      snapshotType = make_shared<string>(boost::any_cast<string>(m["SnapshotType"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~ListSnapshotsRequest() = default;
};
class ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<string> url{};

  ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot() {}

  explicit ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot() = default;
};
class ListSnapshotsResponseBodyMediaSnapshotSnapshots : public Darabonba::Model {
public:
  shared_ptr<vector<ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot>> snapshot{};

  ListSnapshotsResponseBodyMediaSnapshotSnapshots() {}

  explicit ListSnapshotsResponseBodyMediaSnapshotSnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snapshot) {
      vector<boost::any> temp1;
      for(auto item1:*snapshot){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshot"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Snapshot") != m.end() && !m["Snapshot"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshot"].type()) {
        vector<ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshot"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshot = make_shared<vector<ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot>>(expect1);
      }
    }
  }


  virtual ~ListSnapshotsResponseBodyMediaSnapshotSnapshots() = default;
};
class ListSnapshotsResponseBodyMediaSnapshot : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> regular{};
  shared_ptr<ListSnapshotsResponseBodyMediaSnapshotSnapshots> snapshots{};
  shared_ptr<long> total{};

  ListSnapshotsResponseBodyMediaSnapshot() {}

  explicit ListSnapshotsResponseBodyMediaSnapshot(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (regular) {
      res["Regular"] = boost::any(*regular);
    }
    if (snapshots) {
      res["Snapshots"] = snapshots ? boost::any(snapshots->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Regular") != m.end() && !m["Regular"].empty()) {
      regular = make_shared<string>(boost::any_cast<string>(m["Regular"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(map<string, boost::any>) == m["Snapshots"].type()) {
        ListSnapshotsResponseBodyMediaSnapshotSnapshots model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Snapshots"]));
        snapshots = make_shared<ListSnapshotsResponseBodyMediaSnapshotSnapshots>(model1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSnapshotsResponseBodyMediaSnapshot() = default;
};
class ListSnapshotsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSnapshotsResponseBodyMediaSnapshot> mediaSnapshot{};
  shared_ptr<string> requestId{};

  ListSnapshotsResponseBody() {}

  explicit ListSnapshotsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaSnapshot) {
      res["MediaSnapshot"] = mediaSnapshot ? boost::any(mediaSnapshot->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaSnapshot") != m.end() && !m["MediaSnapshot"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaSnapshot"].type()) {
        ListSnapshotsResponseBodyMediaSnapshot model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaSnapshot"]));
        mediaSnapshot = make_shared<ListSnapshotsResponseBodyMediaSnapshot>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSnapshotsResponseBody() = default;
};
class ListSnapshotsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSnapshotsResponseBody> body{};

  ListSnapshotsResponse() {}

  explicit ListSnapshotsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSnapshotsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSnapshotsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSnapshotsResponse() = default;
};
class ListTranscodeTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> videoId{};

  ListTranscodeTaskRequest() {}

  explicit ListTranscodeTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~ListTranscodeTaskRequest() = default;
};
class ListTranscodeTaskResponseBodyTranscodeTaskList : public Darabonba::Model {
public:
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> taskStatus{};
  shared_ptr<string> transcodeTaskId{};
  shared_ptr<string> transcodeTemplateGroupId{};
  shared_ptr<string> trigger{};
  shared_ptr<string> videoId{};

  ListTranscodeTaskResponseBodyTranscodeTaskList() {}

  explicit ListTranscodeTaskResponseBodyTranscodeTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (transcodeTaskId) {
      res["TranscodeTaskId"] = boost::any(*transcodeTaskId);
    }
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    if (trigger) {
      res["Trigger"] = boost::any(*trigger);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TranscodeTaskId") != m.end() && !m["TranscodeTaskId"].empty()) {
      transcodeTaskId = make_shared<string>(boost::any_cast<string>(m["TranscodeTaskId"]));
    }
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      trigger = make_shared<string>(boost::any_cast<string>(m["Trigger"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~ListTranscodeTaskResponseBodyTranscodeTaskList() = default;
};
class ListTranscodeTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTranscodeTaskResponseBodyTranscodeTaskList>> transcodeTaskList{};

  ListTranscodeTaskResponseBody() {}

  explicit ListTranscodeTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeTaskList) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeTaskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeTaskList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeTaskList") != m.end() && !m["TranscodeTaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeTaskList"].type()) {
        vector<ListTranscodeTaskResponseBodyTranscodeTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeTaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeTaskResponseBodyTranscodeTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeTaskList = make_shared<vector<ListTranscodeTaskResponseBodyTranscodeTaskList>>(expect1);
      }
    }
  }


  virtual ~ListTranscodeTaskResponseBody() = default;
};
class ListTranscodeTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTranscodeTaskResponseBody> body{};

  ListTranscodeTaskResponse() {}

  explicit ListTranscodeTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTranscodeTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTranscodeTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ListTranscodeTaskResponse() = default;
};
class ListTranscodeTemplateGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListTranscodeTemplateGroupRequest() {}

  explicit ListTranscodeTemplateGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListTranscodeTemplateGroupRequest() = default;
};
class ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> locked{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> transcodeTemplateGroupId{};

  ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList() {}

  explicit ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (locked) {
      res["Locked"] = boost::any(*locked);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("Locked") != m.end() && !m["Locked"].empty()) {
      locked = make_shared<string>(boost::any_cast<string>(m["Locked"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
  }


  virtual ~ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList() = default;
};
class ListTranscodeTemplateGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList>> transcodeTemplateGroupList{};

  ListTranscodeTemplateGroupResponseBody() {}

  explicit ListTranscodeTemplateGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeTemplateGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeTemplateGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeTemplateGroupList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeTemplateGroupList") != m.end() && !m["TranscodeTemplateGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeTemplateGroupList"].type()) {
        vector<ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeTemplateGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeTemplateGroupList = make_shared<vector<ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList>>(expect1);
      }
    }
  }


  virtual ~ListTranscodeTemplateGroupResponseBody() = default;
};
class ListTranscodeTemplateGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTranscodeTemplateGroupResponseBody> body{};

  ListTranscodeTemplateGroupResponse() {}

  explicit ListTranscodeTemplateGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTranscodeTemplateGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTranscodeTemplateGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListTranscodeTemplateGroupResponse() = default;
};
class ListVodTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> templateType{};

  ListVodTemplateRequest() {}

  explicit ListVodTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~ListVodTemplateRequest() = default;
};
class ListVodTemplateResponseBodyVodTemplateInfoList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateType{};
  shared_ptr<string> vodTemplateId{};

  ListVodTemplateResponseBodyVodTemplateInfoList() {}

  explicit ListVodTemplateResponseBodyVodTemplateInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (vodTemplateId) {
      res["VodTemplateId"] = boost::any(*vodTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("VodTemplateId") != m.end() && !m["VodTemplateId"].empty()) {
      vodTemplateId = make_shared<string>(boost::any_cast<string>(m["VodTemplateId"]));
    }
  }


  virtual ~ListVodTemplateResponseBodyVodTemplateInfoList() = default;
};
class ListVodTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListVodTemplateResponseBodyVodTemplateInfoList>> vodTemplateInfoList{};

  ListVodTemplateResponseBody() {}

  explicit ListVodTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vodTemplateInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*vodTemplateInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VodTemplateInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VodTemplateInfoList") != m.end() && !m["VodTemplateInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VodTemplateInfoList"].type()) {
        vector<ListVodTemplateResponseBodyVodTemplateInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VodTemplateInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVodTemplateResponseBodyVodTemplateInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vodTemplateInfoList = make_shared<vector<ListVodTemplateResponseBodyVodTemplateInfoList>>(expect1);
      }
    }
  }


  virtual ~ListVodTemplateResponseBody() = default;
};
class ListVodTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVodTemplateResponseBody> body{};

  ListVodTemplateResponse() {}

  explicit ListVodTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVodTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVodTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ListVodTemplateResponse() = default;
};
class ListWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};

  ListWatermarkRequest() {}

  explicit ListWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~ListWatermarkRequest() = default;
};
class ListWatermarkResponseBodyWatermarkInfos : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> watermarkConfig{};
  shared_ptr<string> watermarkId{};

  ListWatermarkResponseBodyWatermarkInfos() {}

  explicit ListWatermarkResponseBodyWatermarkInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (watermarkConfig) {
      res["WatermarkConfig"] = boost::any(*watermarkConfig);
    }
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WatermarkConfig") != m.end() && !m["WatermarkConfig"].empty()) {
      watermarkConfig = make_shared<string>(boost::any_cast<string>(m["WatermarkConfig"]));
    }
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
  }


  virtual ~ListWatermarkResponseBodyWatermarkInfos() = default;
};
class ListWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListWatermarkResponseBodyWatermarkInfos>> watermarkInfos{};

  ListWatermarkResponseBody() {}

  explicit ListWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (watermarkInfos) {
      vector<boost::any> temp1;
      for(auto item1:*watermarkInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WatermarkInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WatermarkInfos") != m.end() && !m["WatermarkInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["WatermarkInfos"].type()) {
        vector<ListWatermarkResponseBodyWatermarkInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WatermarkInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWatermarkResponseBodyWatermarkInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        watermarkInfos = make_shared<vector<ListWatermarkResponseBodyWatermarkInfos>>(expect1);
      }
    }
  }


  virtual ~ListWatermarkResponseBody() = default;
};
class ListWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWatermarkResponseBody> body{};

  ListWatermarkResponse() {}

  explicit ListWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~ListWatermarkResponse() = default;
};
class MoveAppResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> targetAppId{};

  MoveAppResourceRequest() {}

  explicit MoveAppResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (targetAppId) {
      res["TargetAppId"] = boost::any(*targetAppId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TargetAppId") != m.end() && !m["TargetAppId"].empty()) {
      targetAppId = make_shared<string>(boost::any_cast<string>(m["TargetAppId"]));
    }
  }


  virtual ~MoveAppResourceRequest() = default;
};
class MoveAppResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failedResourceIds{};
  shared_ptr<vector<string>> nonExistResourceIds{};
  shared_ptr<string> requestId{};

  MoveAppResourceResponseBody() {}

  explicit MoveAppResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedResourceIds) {
      res["FailedResourceIds"] = boost::any(*failedResourceIds);
    }
    if (nonExistResourceIds) {
      res["NonExistResourceIds"] = boost::any(*nonExistResourceIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedResourceIds") != m.end() && !m["FailedResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailedResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailedResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failedResourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NonExistResourceIds") != m.end() && !m["NonExistResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistResourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MoveAppResourceResponseBody() = default;
};
class MoveAppResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveAppResourceResponseBody> body{};

  MoveAppResourceResponse() {}

  explicit MoveAppResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveAppResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveAppResourceResponseBody>(model1);
      }
    }
  }


  virtual ~MoveAppResourceResponse() = default;
};
class PreloadVodObjectCachesRequest : public Darabonba::Model {
public:
  shared_ptr<string> objectPath{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  PreloadVodObjectCachesRequest() {}

  explicit PreloadVodObjectCachesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~PreloadVodObjectCachesRequest() = default;
};
class PreloadVodObjectCachesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> preloadTaskId{};
  shared_ptr<string> requestId{};

  PreloadVodObjectCachesResponseBody() {}

  explicit PreloadVodObjectCachesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTaskId) {
      res["PreloadTaskId"] = boost::any(*preloadTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTaskId") != m.end() && !m["PreloadTaskId"].empty()) {
      preloadTaskId = make_shared<string>(boost::any_cast<string>(m["PreloadTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PreloadVodObjectCachesResponseBody() = default;
};
class PreloadVodObjectCachesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PreloadVodObjectCachesResponseBody> body{};

  PreloadVodObjectCachesResponse() {}

  explicit PreloadVodObjectCachesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PreloadVodObjectCachesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PreloadVodObjectCachesResponseBody>(model1);
      }
    }
  }


  virtual ~PreloadVodObjectCachesResponse() = default;
};
class ProduceEditingProjectVideoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> mediaMetadata{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> produceConfig{};
  shared_ptr<string> projectId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  ProduceEditingProjectVideoRequest() {}

  explicit ProduceEditingProjectVideoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mediaMetadata) {
      res["MediaMetadata"] = boost::any(*mediaMetadata);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (produceConfig) {
      res["ProduceConfig"] = boost::any(*produceConfig);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MediaMetadata") != m.end() && !m["MediaMetadata"].empty()) {
      mediaMetadata = make_shared<string>(boost::any_cast<string>(m["MediaMetadata"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ProduceConfig") != m.end() && !m["ProduceConfig"].empty()) {
      produceConfig = make_shared<string>(boost::any_cast<string>(m["ProduceConfig"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ProduceEditingProjectVideoRequest() = default;
};
class ProduceEditingProjectVideoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> requestId{};

  ProduceEditingProjectVideoResponseBody() {}

  explicit ProduceEditingProjectVideoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ProduceEditingProjectVideoResponseBody() = default;
};
class ProduceEditingProjectVideoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ProduceEditingProjectVideoResponseBody> body{};

  ProduceEditingProjectVideoResponse() {}

  explicit ProduceEditingProjectVideoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProduceEditingProjectVideoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProduceEditingProjectVideoResponseBody>(model1);
      }
    }
  }


  virtual ~ProduceEditingProjectVideoResponse() = default;
};
class RefreshMediaPlayUrlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> definitions{};
  shared_ptr<string> formats{};
  shared_ptr<string> mediaIds{};
  shared_ptr<string> resultType{};
  shared_ptr<long> sliceCount{};
  shared_ptr<bool> sliceFlag{};
  shared_ptr<string> streamType{};
  shared_ptr<string> taskType{};
  shared_ptr<string> userData{};

  RefreshMediaPlayUrlsRequest() {}

  explicit RefreshMediaPlayUrlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (definitions) {
      res["Definitions"] = boost::any(*definitions);
    }
    if (formats) {
      res["Formats"] = boost::any(*formats);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (sliceCount) {
      res["SliceCount"] = boost::any(*sliceCount);
    }
    if (sliceFlag) {
      res["SliceFlag"] = boost::any(*sliceFlag);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Definitions") != m.end() && !m["Definitions"].empty()) {
      definitions = make_shared<string>(boost::any_cast<string>(m["Definitions"]));
    }
    if (m.find("Formats") != m.end() && !m["Formats"].empty()) {
      formats = make_shared<string>(boost::any_cast<string>(m["Formats"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("SliceCount") != m.end() && !m["SliceCount"].empty()) {
      sliceCount = make_shared<long>(boost::any_cast<long>(m["SliceCount"]));
    }
    if (m.find("SliceFlag") != m.end() && !m["SliceFlag"].empty()) {
      sliceFlag = make_shared<bool>(boost::any_cast<bool>(m["SliceFlag"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~RefreshMediaPlayUrlsRequest() = default;
};
class RefreshMediaPlayUrlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> forbiddenMediaIds{};
  shared_ptr<string> mediaRefreshJobId{};
  shared_ptr<string> nonExistMediaIds{};
  shared_ptr<string> requestId{};

  RefreshMediaPlayUrlsResponseBody() {}

  explicit RefreshMediaPlayUrlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbiddenMediaIds) {
      res["ForbiddenMediaIds"] = boost::any(*forbiddenMediaIds);
    }
    if (mediaRefreshJobId) {
      res["MediaRefreshJobId"] = boost::any(*mediaRefreshJobId);
    }
    if (nonExistMediaIds) {
      res["NonExistMediaIds"] = boost::any(*nonExistMediaIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbiddenMediaIds") != m.end() && !m["ForbiddenMediaIds"].empty()) {
      forbiddenMediaIds = make_shared<string>(boost::any_cast<string>(m["ForbiddenMediaIds"]));
    }
    if (m.find("MediaRefreshJobId") != m.end() && !m["MediaRefreshJobId"].empty()) {
      mediaRefreshJobId = make_shared<string>(boost::any_cast<string>(m["MediaRefreshJobId"]));
    }
    if (m.find("NonExistMediaIds") != m.end() && !m["NonExistMediaIds"].empty()) {
      nonExistMediaIds = make_shared<string>(boost::any_cast<string>(m["NonExistMediaIds"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshMediaPlayUrlsResponseBody() = default;
};
class RefreshMediaPlayUrlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshMediaPlayUrlsResponseBody> body{};

  RefreshMediaPlayUrlsResponse() {}

  explicit RefreshMediaPlayUrlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshMediaPlayUrlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshMediaPlayUrlsResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshMediaPlayUrlsResponse() = default;
};
class RefreshUploadVideoRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> videoId{};

  RefreshUploadVideoRequest() {}

  explicit RefreshUploadVideoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~RefreshUploadVideoRequest() = default;
};
class RefreshUploadVideoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> uploadAddress{};
  shared_ptr<string> uploadAuth{};
  shared_ptr<string> videoId{};

  RefreshUploadVideoResponseBody() {}

  explicit RefreshUploadVideoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadAddress) {
      res["UploadAddress"] = boost::any(*uploadAddress);
    }
    if (uploadAuth) {
      res["UploadAuth"] = boost::any(*uploadAuth);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadAddress") != m.end() && !m["UploadAddress"].empty()) {
      uploadAddress = make_shared<string>(boost::any_cast<string>(m["UploadAddress"]));
    }
    if (m.find("UploadAuth") != m.end() && !m["UploadAuth"].empty()) {
      uploadAuth = make_shared<string>(boost::any_cast<string>(m["UploadAuth"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~RefreshUploadVideoResponseBody() = default;
};
class RefreshUploadVideoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshUploadVideoResponseBody> body{};

  RefreshUploadVideoResponse() {}

  explicit RefreshUploadVideoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshUploadVideoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshUploadVideoResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshUploadVideoResponse() = default;
};
class RefreshVodObjectCachesRequest : public Darabonba::Model {
public:
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  RefreshVodObjectCachesRequest() {}

  explicit RefreshVodObjectCachesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RefreshVodObjectCachesRequest() = default;
};
class RefreshVodObjectCachesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> refreshTaskId{};
  shared_ptr<string> requestId{};

  RefreshVodObjectCachesResponseBody() {}

  explicit RefreshVodObjectCachesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refreshTaskId) {
      res["RefreshTaskId"] = boost::any(*refreshTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RefreshTaskId") != m.end() && !m["RefreshTaskId"].empty()) {
      refreshTaskId = make_shared<string>(boost::any_cast<string>(m["RefreshTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshVodObjectCachesResponseBody() = default;
};
class RefreshVodObjectCachesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshVodObjectCachesResponseBody> body{};

  RefreshVodObjectCachesResponse() {}

  explicit RefreshVodObjectCachesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshVodObjectCachesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshVodObjectCachesResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshVodObjectCachesResponse() = default;
};
class RegisterMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> registerMetadatas{};
  shared_ptr<string> templateGroupId{};
  shared_ptr<string> userData{};
  shared_ptr<string> workflowId{};

  RegisterMediaRequest() {}

  explicit RegisterMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (registerMetadatas) {
      res["RegisterMetadatas"] = boost::any(*registerMetadatas);
    }
    if (templateGroupId) {
      res["TemplateGroupId"] = boost::any(*templateGroupId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegisterMetadatas") != m.end() && !m["RegisterMetadatas"].empty()) {
      registerMetadatas = make_shared<string>(boost::any_cast<string>(m["RegisterMetadatas"]));
    }
    if (m.find("TemplateGroupId") != m.end() && !m["TemplateGroupId"].empty()) {
      templateGroupId = make_shared<string>(boost::any_cast<string>(m["TemplateGroupId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
  }


  virtual ~RegisterMediaRequest() = default;
};
class RegisterMediaResponseBodyRegisteredMediaList : public Darabonba::Model {
public:
  shared_ptr<string> fileURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<bool> newRegister{};

  RegisterMediaResponseBodyRegisteredMediaList() {}

  explicit RegisterMediaResponseBodyRegisteredMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (newRegister) {
      res["NewRegister"] = boost::any(*newRegister);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("NewRegister") != m.end() && !m["NewRegister"].empty()) {
      newRegister = make_shared<bool>(boost::any_cast<bool>(m["NewRegister"]));
    }
  }


  virtual ~RegisterMediaResponseBodyRegisteredMediaList() = default;
};
class RegisterMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failedFileURLs{};
  shared_ptr<vector<RegisterMediaResponseBodyRegisteredMediaList>> registeredMediaList{};
  shared_ptr<string> requestId{};

  RegisterMediaResponseBody() {}

  explicit RegisterMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedFileURLs) {
      res["FailedFileURLs"] = boost::any(*failedFileURLs);
    }
    if (registeredMediaList) {
      vector<boost::any> temp1;
      for(auto item1:*registeredMediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegisteredMediaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedFileURLs") != m.end() && !m["FailedFileURLs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailedFileURLs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailedFileURLs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failedFileURLs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegisteredMediaList") != m.end() && !m["RegisteredMediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["RegisteredMediaList"].type()) {
        vector<RegisterMediaResponseBodyRegisteredMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegisteredMediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RegisterMediaResponseBodyRegisteredMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registeredMediaList = make_shared<vector<RegisterMediaResponseBodyRegisteredMediaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterMediaResponseBody() = default;
};
class RegisterMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterMediaResponseBody> body{};

  RegisterMediaResponse() {}

  explicit RegisterMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterMediaResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterMediaResponse() = default;
};
class RestoreMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaIds{};
  shared_ptr<string> restoreDays{};
  shared_ptr<string> restoreTier{};
  shared_ptr<string> scope{};

  RestoreMediaRequest() {}

  explicit RestoreMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (restoreDays) {
      res["RestoreDays"] = boost::any(*restoreDays);
    }
    if (restoreTier) {
      res["RestoreTier"] = boost::any(*restoreTier);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("RestoreDays") != m.end() && !m["RestoreDays"].empty()) {
      restoreDays = make_shared<string>(boost::any_cast<string>(m["RestoreDays"]));
    }
    if (m.find("RestoreTier") != m.end() && !m["RestoreTier"].empty()) {
      restoreTier = make_shared<string>(boost::any_cast<string>(m["RestoreTier"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~RestoreMediaRequest() = default;
};
class RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> reason{};

  RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO() {}

  explicit RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO() = default;
};
class RestoreMediaResponseBodyForbiddenList : public Darabonba::Model {
public:
  shared_ptr<vector<RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO>> mediaForbiddenReasonDTO{};

  RestoreMediaResponseBodyForbiddenList() {}

  explicit RestoreMediaResponseBodyForbiddenList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaForbiddenReasonDTO) {
      vector<boost::any> temp1;
      for(auto item1:*mediaForbiddenReasonDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaForbiddenReasonDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaForbiddenReasonDTO") != m.end() && !m["MediaForbiddenReasonDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaForbiddenReasonDTO"].type()) {
        vector<RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaForbiddenReasonDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaForbiddenReasonDTO = make_shared<vector<RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO>>(expect1);
      }
    }
  }


  virtual ~RestoreMediaResponseBodyForbiddenList() = default;
};
class RestoreMediaResponseBodyIgnoredList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> mediaId{};

  RestoreMediaResponseBodyIgnoredList() {}

  explicit RestoreMediaResponseBodyIgnoredList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediaId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediaId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediaId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RestoreMediaResponseBodyIgnoredList() = default;
};
class RestoreMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<RestoreMediaResponseBodyForbiddenList> forbiddenList{};
  shared_ptr<RestoreMediaResponseBodyIgnoredList> ignoredList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RestoreMediaResponseBody() {}

  explicit RestoreMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbiddenList) {
      res["ForbiddenList"] = forbiddenList ? boost::any(forbiddenList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ignoredList) {
      res["IgnoredList"] = ignoredList ? boost::any(ignoredList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbiddenList") != m.end() && !m["ForbiddenList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForbiddenList"].type()) {
        RestoreMediaResponseBodyForbiddenList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForbiddenList"]));
        forbiddenList = make_shared<RestoreMediaResponseBodyForbiddenList>(model1);
      }
    }
    if (m.find("IgnoredList") != m.end() && !m["IgnoredList"].empty()) {
      if (typeid(map<string, boost::any>) == m["IgnoredList"].type()) {
        RestoreMediaResponseBodyIgnoredList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IgnoredList"]));
        ignoredList = make_shared<RestoreMediaResponseBodyIgnoredList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RestoreMediaResponseBody() = default;
};
class RestoreMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestoreMediaResponseBody> body{};

  RestoreMediaResponse() {}

  explicit RestoreMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestoreMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestoreMediaResponseBody>(model1);
      }
    }
  }


  virtual ~RestoreMediaResponse() = default;
};
class SearchEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};

  SearchEditingProjectRequest() {}

  explicit SearchEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~SearchEditingProjectRequest() = default;
};
class SearchEditingProjectResponseBodyProjectListProject : public Darabonba::Model {
public:
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> title{};

  SearchEditingProjectResponseBodyProjectListProject() {}

  explicit SearchEditingProjectResponseBodyProjectListProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~SearchEditingProjectResponseBodyProjectListProject() = default;
};
class SearchEditingProjectResponseBodyProjectList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchEditingProjectResponseBodyProjectListProject>> project{};

  SearchEditingProjectResponseBodyProjectList() {}

  explicit SearchEditingProjectResponseBodyProjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      vector<boost::any> temp1;
      for(auto item1:*project){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Project"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(vector<boost::any>) == m["Project"].type()) {
        vector<SearchEditingProjectResponseBodyProjectListProject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Project"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchEditingProjectResponseBodyProjectListProject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        project = make_shared<vector<SearchEditingProjectResponseBodyProjectListProject>>(expect1);
      }
    }
  }


  virtual ~SearchEditingProjectResponseBodyProjectList() = default;
};
class SearchEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<SearchEditingProjectResponseBodyProjectList> projectList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  SearchEditingProjectResponseBody() {}

  explicit SearchEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectList) {
      res["ProjectList"] = projectList ? boost::any(projectList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectList") != m.end() && !m["ProjectList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectList"].type()) {
        SearchEditingProjectResponseBodyProjectList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectList"]));
        projectList = make_shared<SearchEditingProjectResponseBodyProjectList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchEditingProjectResponseBody() = default;
};
class SearchEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchEditingProjectResponseBody> body{};

  SearchEditingProjectResponse() {}

  explicit SearchEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~SearchEditingProjectResponse() = default;
};
class SearchMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> fields{};
  shared_ptr<string> match{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scrollToken{};
  shared_ptr<string> searchType{};
  shared_ptr<string> sortBy{};

  SearchMediaRequest() {}

  explicit SearchMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    if (match) {
      res["Match"] = boost::any(*match);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scrollToken) {
      res["ScrollToken"] = boost::any(*scrollToken);
    }
    if (searchType) {
      res["SearchType"] = boost::any(*searchType);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      fields = make_shared<string>(boost::any_cast<string>(m["Fields"]));
    }
    if (m.find("Match") != m.end() && !m["Match"].empty()) {
      match = make_shared<string>(boost::any_cast<string>(m["Match"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScrollToken") != m.end() && !m["ScrollToken"].empty()) {
      scrollToken = make_shared<string>(boost::any_cast<string>(m["ScrollToken"]));
    }
    if (m.find("SearchType") != m.end() && !m["SearchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["SearchType"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~SearchMediaRequest() = default;
};
class SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences : public Darabonba::Model {
public:
  shared_ptr<double> from{};
  shared_ptr<double> score{};
  shared_ptr<double> to{};

  SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences() {}

  explicit SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences() = default;
};
class SearchMediaResponseBodyMediaListAiDataAiLabelInfo : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> labelId{};
  shared_ptr<string> labelName{};
  shared_ptr<vector<SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences>> occurrences{};

  SearchMediaResponseBodyMediaListAiDataAiLabelInfo() {}

  explicit SearchMediaResponseBodyMediaListAiDataAiLabelInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (labelId) {
      res["LabelId"] = boost::any(*labelId);
    }
    if (labelName) {
      res["LabelName"] = boost::any(*labelName);
    }
    if (occurrences) {
      vector<boost::any> temp1;
      for(auto item1:*occurrences){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Occurrences"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("LabelId") != m.end() && !m["LabelId"].empty()) {
      labelId = make_shared<string>(boost::any_cast<string>(m["LabelId"]));
    }
    if (m.find("LabelName") != m.end() && !m["LabelName"].empty()) {
      labelName = make_shared<string>(boost::any_cast<string>(m["LabelName"]));
    }
    if (m.find("Occurrences") != m.end() && !m["Occurrences"].empty()) {
      if (typeid(vector<boost::any>) == m["Occurrences"].type()) {
        vector<SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Occurrences"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        occurrences = make_shared<vector<SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences>>(expect1);
      }
    }
  }


  virtual ~SearchMediaResponseBodyMediaListAiDataAiLabelInfo() = default;
};
class SearchMediaResponseBodyMediaListAiDataOcrInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<double> from{};
  shared_ptr<double> to{};

  SearchMediaResponseBodyMediaListAiDataOcrInfo() {}

  explicit SearchMediaResponseBodyMediaListAiDataOcrInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaListAiDataOcrInfo() = default;
};
class SearchMediaResponseBodyMediaListAiData : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaResponseBodyMediaListAiDataAiLabelInfo>> aiLabelInfo{};
  shared_ptr<vector<SearchMediaResponseBodyMediaListAiDataOcrInfo>> ocrInfo{};

  SearchMediaResponseBodyMediaListAiData() {}

  explicit SearchMediaResponseBodyMediaListAiData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiLabelInfo) {
      vector<boost::any> temp1;
      for(auto item1:*aiLabelInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AiLabelInfo"] = boost::any(temp1);
    }
    if (ocrInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ocrInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OcrInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiLabelInfo") != m.end() && !m["AiLabelInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AiLabelInfo"].type()) {
        vector<SearchMediaResponseBodyMediaListAiDataAiLabelInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AiLabelInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaListAiDataAiLabelInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aiLabelInfo = make_shared<vector<SearchMediaResponseBodyMediaListAiDataAiLabelInfo>>(expect1);
      }
    }
    if (m.find("OcrInfo") != m.end() && !m["OcrInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["OcrInfo"].type()) {
        vector<SearchMediaResponseBodyMediaListAiDataOcrInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OcrInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaListAiDataOcrInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ocrInfo = make_shared<vector<SearchMediaResponseBodyMediaListAiDataOcrInfo>>(expect1);
      }
    }
  }


  virtual ~SearchMediaResponseBodyMediaListAiData() = default;
};
class SearchMediaResponseBodyMediaListAiRoughData : public Darabonba::Model {
public:
  shared_ptr<string> aiCategory{};
  shared_ptr<string> aiJobId{};
  shared_ptr<string> saveType{};
  shared_ptr<string> status{};

  SearchMediaResponseBodyMediaListAiRoughData() {}

  explicit SearchMediaResponseBodyMediaListAiRoughData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiCategory) {
      res["AiCategory"] = boost::any(*aiCategory);
    }
    if (aiJobId) {
      res["AiJobId"] = boost::any(*aiJobId);
    }
    if (saveType) {
      res["SaveType"] = boost::any(*saveType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiCategory") != m.end() && !m["AiCategory"].empty()) {
      aiCategory = make_shared<string>(boost::any_cast<string>(m["AiCategory"]));
    }
    if (m.find("AiJobId") != m.end() && !m["AiJobId"].empty()) {
      aiJobId = make_shared<string>(boost::any_cast<string>(m["AiJobId"]));
    }
    if (m.find("SaveType") != m.end() && !m["SaveType"].empty()) {
      saveType = make_shared<string>(boost::any_cast<string>(m["SaveType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaListAiRoughData() = default;
};
class SearchMediaResponseBodyMediaListAttachedMediaCategories : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};

  SearchMediaResponseBodyMediaListAttachedMediaCategories() {}

  explicit SearchMediaResponseBodyMediaListAttachedMediaCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaListAttachedMediaCategories() = default;
};
class SearchMediaResponseBodyMediaListAttachedMedia : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> businessType{};
  shared_ptr<vector<SearchMediaResponseBodyMediaListAttachedMediaCategories>> categories{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> URL{};

  SearchMediaResponseBodyMediaListAttachedMedia() {}

  explicit SearchMediaResponseBodyMediaListAttachedMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Categories"] = boost::any(temp1);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<SearchMediaResponseBodyMediaListAttachedMediaCategories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Categories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaListAttachedMediaCategories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categories = make_shared<vector<SearchMediaResponseBodyMediaListAttachedMediaCategories>>(expect1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaListAttachedMedia() = default;
};
class SearchMediaResponseBodyMediaListAudio : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> audioId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> downloadSwitch{};
  shared_ptr<double> duration{};
  shared_ptr<string> mediaSource{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> preprocessStatus{};
  shared_ptr<string> restoreExpiration{};
  shared_ptr<string> restoreStatus{};
  shared_ptr<long> size{};
  shared_ptr<vector<string>> snapshots{};
  shared_ptr<vector<string>> spriteSnapshots{};
  shared_ptr<string> status{};
  shared_ptr<string> storageClass{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeMode{};

  SearchMediaResponseBodyMediaListAudio() {}

  explicit SearchMediaResponseBodyMediaListAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (audioId) {
      res["AudioId"] = boost::any(*audioId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (downloadSwitch) {
      res["DownloadSwitch"] = boost::any(*downloadSwitch);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mediaSource) {
      res["MediaSource"] = boost::any(*mediaSource);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (preprocessStatus) {
      res["PreprocessStatus"] = boost::any(*preprocessStatus);
    }
    if (restoreExpiration) {
      res["RestoreExpiration"] = boost::any(*restoreExpiration);
    }
    if (restoreStatus) {
      res["RestoreStatus"] = boost::any(*restoreStatus);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (spriteSnapshots) {
      res["SpriteSnapshots"] = boost::any(*spriteSnapshots);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeMode) {
      res["TranscodeMode"] = boost::any(*transcodeMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AudioId") != m.end() && !m["AudioId"].empty()) {
      audioId = make_shared<string>(boost::any_cast<string>(m["AudioId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DownloadSwitch") != m.end() && !m["DownloadSwitch"].empty()) {
      downloadSwitch = make_shared<string>(boost::any_cast<string>(m["DownloadSwitch"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("MediaSource") != m.end() && !m["MediaSource"].empty()) {
      mediaSource = make_shared<string>(boost::any_cast<string>(m["MediaSource"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("PreprocessStatus") != m.end() && !m["PreprocessStatus"].empty()) {
      preprocessStatus = make_shared<string>(boost::any_cast<string>(m["PreprocessStatus"]));
    }
    if (m.find("RestoreExpiration") != m.end() && !m["RestoreExpiration"].empty()) {
      restoreExpiration = make_shared<string>(boost::any_cast<string>(m["RestoreExpiration"]));
    }
    if (m.find("RestoreStatus") != m.end() && !m["RestoreStatus"].empty()) {
      restoreStatus = make_shared<string>(boost::any_cast<string>(m["RestoreStatus"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Snapshots"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshots = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpriteSnapshots") != m.end() && !m["SpriteSnapshots"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpriteSnapshots"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpriteSnapshots"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spriteSnapshots = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeMode") != m.end() && !m["TranscodeMode"].empty()) {
      transcodeMode = make_shared<string>(boost::any_cast<string>(m["TranscodeMode"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaListAudio() = default;
};
class SearchMediaResponseBodyMediaListImage : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> imageId{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> URL{};

  SearchMediaResponseBodyMediaListImage() {}

  explicit SearchMediaResponseBodyMediaListImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      imageId = make_shared<string>(boost::any_cast<string>(m["ImageId"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaListImage() = default;
};
class SearchMediaResponseBodyMediaListVideo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> downloadSwitch{};
  shared_ptr<double> duration{};
  shared_ptr<string> mediaSource{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> preprocessStatus{};
  shared_ptr<string> restoreExpiration{};
  shared_ptr<string> restoreStatus{};
  shared_ptr<long> size{};
  shared_ptr<vector<string>> snapshots{};
  shared_ptr<vector<string>> spriteSnapshots{};
  shared_ptr<string> status{};
  shared_ptr<string> storageClass{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeMode{};
  shared_ptr<string> videoId{};

  SearchMediaResponseBodyMediaListVideo() {}

  explicit SearchMediaResponseBodyMediaListVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (downloadSwitch) {
      res["DownloadSwitch"] = boost::any(*downloadSwitch);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mediaSource) {
      res["MediaSource"] = boost::any(*mediaSource);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (preprocessStatus) {
      res["PreprocessStatus"] = boost::any(*preprocessStatus);
    }
    if (restoreExpiration) {
      res["RestoreExpiration"] = boost::any(*restoreExpiration);
    }
    if (restoreStatus) {
      res["RestoreStatus"] = boost::any(*restoreStatus);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (spriteSnapshots) {
      res["SpriteSnapshots"] = boost::any(*spriteSnapshots);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeMode) {
      res["TranscodeMode"] = boost::any(*transcodeMode);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DownloadSwitch") != m.end() && !m["DownloadSwitch"].empty()) {
      downloadSwitch = make_shared<string>(boost::any_cast<string>(m["DownloadSwitch"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("MediaSource") != m.end() && !m["MediaSource"].empty()) {
      mediaSource = make_shared<string>(boost::any_cast<string>(m["MediaSource"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("PreprocessStatus") != m.end() && !m["PreprocessStatus"].empty()) {
      preprocessStatus = make_shared<string>(boost::any_cast<string>(m["PreprocessStatus"]));
    }
    if (m.find("RestoreExpiration") != m.end() && !m["RestoreExpiration"].empty()) {
      restoreExpiration = make_shared<string>(boost::any_cast<string>(m["RestoreExpiration"]));
    }
    if (m.find("RestoreStatus") != m.end() && !m["RestoreStatus"].empty()) {
      restoreStatus = make_shared<string>(boost::any_cast<string>(m["RestoreStatus"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Snapshots"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshots = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SpriteSnapshots") != m.end() && !m["SpriteSnapshots"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpriteSnapshots"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpriteSnapshots"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spriteSnapshots = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeMode") != m.end() && !m["TranscodeMode"].empty()) {
      transcodeMode = make_shared<string>(boost::any_cast<string>(m["TranscodeMode"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaListVideo() = default;
};
class SearchMediaResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<SearchMediaResponseBodyMediaListAiData> aiData{};
  shared_ptr<SearchMediaResponseBodyMediaListAiRoughData> aiRoughData{};
  shared_ptr<SearchMediaResponseBodyMediaListAttachedMedia> attachedMedia{};
  shared_ptr<SearchMediaResponseBodyMediaListAudio> audio{};
  shared_ptr<string> creationTime{};
  shared_ptr<SearchMediaResponseBodyMediaListImage> image{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};
  shared_ptr<SearchMediaResponseBodyMediaListVideo> video{};

  SearchMediaResponseBodyMediaList() {}

  explicit SearchMediaResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiData) {
      res["AiData"] = aiData ? boost::any(aiData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (aiRoughData) {
      res["AiRoughData"] = aiRoughData ? boost::any(aiRoughData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (attachedMedia) {
      res["AttachedMedia"] = attachedMedia ? boost::any(attachedMedia->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (image) {
      res["Image"] = image ? boost::any(image->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiData") != m.end() && !m["AiData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AiData"].type()) {
        SearchMediaResponseBodyMediaListAiData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AiData"]));
        aiData = make_shared<SearchMediaResponseBodyMediaListAiData>(model1);
      }
    }
    if (m.find("AiRoughData") != m.end() && !m["AiRoughData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AiRoughData"].type()) {
        SearchMediaResponseBodyMediaListAiRoughData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AiRoughData"]));
        aiRoughData = make_shared<SearchMediaResponseBodyMediaListAiRoughData>(model1);
      }
    }
    if (m.find("AttachedMedia") != m.end() && !m["AttachedMedia"].empty()) {
      if (typeid(map<string, boost::any>) == m["AttachedMedia"].type()) {
        SearchMediaResponseBodyMediaListAttachedMedia model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AttachedMedia"]));
        attachedMedia = make_shared<SearchMediaResponseBodyMediaListAttachedMedia>(model1);
      }
    }
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SearchMediaResponseBodyMediaListAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SearchMediaResponseBodyMediaListAudio>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(map<string, boost::any>) == m["Image"].type()) {
        SearchMediaResponseBodyMediaListImage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Image"]));
        image = make_shared<SearchMediaResponseBodyMediaListImage>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SearchMediaResponseBodyMediaListVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SearchMediaResponseBodyMediaListVideo>(model1);
      }
    }
  }


  virtual ~SearchMediaResponseBodyMediaList() = default;
};
class SearchMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaResponseBodyMediaList>> mediaList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scrollToken{};
  shared_ptr<long> total{};

  SearchMediaResponseBody() {}

  explicit SearchMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scrollToken) {
      res["ScrollToken"] = boost::any(*scrollToken);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaList"].type()) {
        vector<SearchMediaResponseBodyMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaList = make_shared<vector<SearchMediaResponseBodyMediaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScrollToken") != m.end() && !m["ScrollToken"].empty()) {
      scrollToken = make_shared<string>(boost::any_cast<string>(m["ScrollToken"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchMediaResponseBody() = default;
};
class SearchMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchMediaResponseBody> body{};

  SearchMediaResponse() {}

  explicit SearchMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaResponse() = default;
};
class SetAuditSecurityIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> ips{};
  shared_ptr<string> operateMode{};
  shared_ptr<string> securityGroupName{};

  SetAuditSecurityIpRequest() {}

  explicit SetAuditSecurityIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ips) {
      res["Ips"] = boost::any(*ips);
    }
    if (operateMode) {
      res["OperateMode"] = boost::any(*operateMode);
    }
    if (securityGroupName) {
      res["SecurityGroupName"] = boost::any(*securityGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ips") != m.end() && !m["Ips"].empty()) {
      ips = make_shared<string>(boost::any_cast<string>(m["Ips"]));
    }
    if (m.find("OperateMode") != m.end() && !m["OperateMode"].empty()) {
      operateMode = make_shared<string>(boost::any_cast<string>(m["OperateMode"]));
    }
    if (m.find("SecurityGroupName") != m.end() && !m["SecurityGroupName"].empty()) {
      securityGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityGroupName"]));
    }
  }


  virtual ~SetAuditSecurityIpRequest() = default;
};
class SetAuditSecurityIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetAuditSecurityIpResponseBody() {}

  explicit SetAuditSecurityIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetAuditSecurityIpResponseBody() = default;
};
class SetAuditSecurityIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetAuditSecurityIpResponseBody> body{};

  SetAuditSecurityIpResponse() {}

  explicit SetAuditSecurityIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetAuditSecurityIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetAuditSecurityIpResponseBody>(model1);
      }
    }
  }


  virtual ~SetAuditSecurityIpResponse() = default;
};
class SetCrossdomainContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> resourceRealOwnerId{};
  shared_ptr<string> storageLocation{};

  SetCrossdomainContentRequest() {}

  explicit SetCrossdomainContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceRealOwnerId) {
      res["ResourceRealOwnerId"] = boost::any(*resourceRealOwnerId);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceRealOwnerId") != m.end() && !m["ResourceRealOwnerId"].empty()) {
      resourceRealOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceRealOwnerId"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
  }


  virtual ~SetCrossdomainContentRequest() = default;
};
class SetCrossdomainContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetCrossdomainContentResponseBody() {}

  explicit SetCrossdomainContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetCrossdomainContentResponseBody() = default;
};
class SetCrossdomainContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetCrossdomainContentResponseBody> body{};

  SetCrossdomainContentResponse() {}

  explicit SetCrossdomainContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetCrossdomainContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetCrossdomainContentResponseBody>(model1);
      }
    }
  }


  virtual ~SetCrossdomainContentResponse() = default;
};
class SetDefaultAITemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  SetDefaultAITemplateRequest() {}

  explicit SetDefaultAITemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SetDefaultAITemplateRequest() = default;
};
class SetDefaultAITemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  SetDefaultAITemplateResponseBody() {}

  explicit SetDefaultAITemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SetDefaultAITemplateResponseBody() = default;
};
class SetDefaultAITemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDefaultAITemplateResponseBody> body{};

  SetDefaultAITemplateResponse() {}

  explicit SetDefaultAITemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDefaultAITemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDefaultAITemplateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDefaultAITemplateResponse() = default;
};
class SetDefaultTranscodeTemplateGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> transcodeTemplateGroupId{};

  SetDefaultTranscodeTemplateGroupRequest() {}

  explicit SetDefaultTranscodeTemplateGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
  }


  virtual ~SetDefaultTranscodeTemplateGroupRequest() = default;
};
class SetDefaultTranscodeTemplateGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDefaultTranscodeTemplateGroupResponseBody() {}

  explicit SetDefaultTranscodeTemplateGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDefaultTranscodeTemplateGroupResponseBody() = default;
};
class SetDefaultTranscodeTemplateGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDefaultTranscodeTemplateGroupResponseBody> body{};

  SetDefaultTranscodeTemplateGroupResponse() {}

  explicit SetDefaultTranscodeTemplateGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDefaultTranscodeTemplateGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDefaultTranscodeTemplateGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SetDefaultTranscodeTemplateGroupResponse() = default;
};
class SetDefaultWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> watermarkId{};

  SetDefaultWatermarkRequest() {}

  explicit SetDefaultWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
  }


  virtual ~SetDefaultWatermarkRequest() = default;
};
class SetDefaultWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDefaultWatermarkResponseBody() {}

  explicit SetDefaultWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDefaultWatermarkResponseBody() = default;
};
class SetDefaultWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDefaultWatermarkResponseBody> body{};

  SetDefaultWatermarkResponse() {}

  explicit SetDefaultWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDefaultWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDefaultWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~SetDefaultWatermarkResponse() = default;
};
class SetEditingProjectMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> materialIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  SetEditingProjectMaterialsRequest() {}

  explicit SetEditingProjectMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialIds) {
      res["MaterialIds"] = boost::any(*materialIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialIds") != m.end() && !m["MaterialIds"].empty()) {
      materialIds = make_shared<string>(boost::any_cast<string>(m["MaterialIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~SetEditingProjectMaterialsRequest() = default;
};
class SetEditingProjectMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetEditingProjectMaterialsResponseBody() {}

  explicit SetEditingProjectMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetEditingProjectMaterialsResponseBody() = default;
};
class SetEditingProjectMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetEditingProjectMaterialsResponseBody> body{};

  SetEditingProjectMaterialsResponse() {}

  explicit SetEditingProjectMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetEditingProjectMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetEditingProjectMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~SetEditingProjectMaterialsResponse() = default;
};
class SetMessageCallbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> authKey{};
  shared_ptr<string> authSwitch{};
  shared_ptr<string> callbackType{};
  shared_ptr<string> callbackURL{};
  shared_ptr<string> eventTypeList{};
  shared_ptr<string> mnsEndpoint{};
  shared_ptr<string> mnsQueueName{};
  shared_ptr<string> ownerAccount{};

  SetMessageCallbackRequest() {}

  explicit SetMessageCallbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (authSwitch) {
      res["AuthSwitch"] = boost::any(*authSwitch);
    }
    if (callbackType) {
      res["CallbackType"] = boost::any(*callbackType);
    }
    if (callbackURL) {
      res["CallbackURL"] = boost::any(*callbackURL);
    }
    if (eventTypeList) {
      res["EventTypeList"] = boost::any(*eventTypeList);
    }
    if (mnsEndpoint) {
      res["MnsEndpoint"] = boost::any(*mnsEndpoint);
    }
    if (mnsQueueName) {
      res["MnsQueueName"] = boost::any(*mnsQueueName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("AuthSwitch") != m.end() && !m["AuthSwitch"].empty()) {
      authSwitch = make_shared<string>(boost::any_cast<string>(m["AuthSwitch"]));
    }
    if (m.find("CallbackType") != m.end() && !m["CallbackType"].empty()) {
      callbackType = make_shared<string>(boost::any_cast<string>(m["CallbackType"]));
    }
    if (m.find("CallbackURL") != m.end() && !m["CallbackURL"].empty()) {
      callbackURL = make_shared<string>(boost::any_cast<string>(m["CallbackURL"]));
    }
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      eventTypeList = make_shared<string>(boost::any_cast<string>(m["EventTypeList"]));
    }
    if (m.find("MnsEndpoint") != m.end() && !m["MnsEndpoint"].empty()) {
      mnsEndpoint = make_shared<string>(boost::any_cast<string>(m["MnsEndpoint"]));
    }
    if (m.find("MnsQueueName") != m.end() && !m["MnsQueueName"].empty()) {
      mnsQueueName = make_shared<string>(boost::any_cast<string>(m["MnsQueueName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~SetMessageCallbackRequest() = default;
};
class SetMessageCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetMessageCallbackResponseBody() {}

  explicit SetMessageCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetMessageCallbackResponseBody() = default;
};
class SetMessageCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetMessageCallbackResponseBody> body{};

  SetMessageCallbackResponse() {}

  explicit SetMessageCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetMessageCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetMessageCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~SetMessageCallbackResponse() = default;
};
class SetVodDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> securityToken{};

  SetVodDomainCertificateRequest() {}

  explicit SetVodDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetVodDomainCertificateRequest() = default;
};
class SetVodDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetVodDomainCertificateResponseBody() {}

  explicit SetVodDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetVodDomainCertificateResponseBody() = default;
};
class SetVodDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetVodDomainCertificateResponseBody> body{};

  SetVodDomainCertificateResponse() {}

  explicit SetVodDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetVodDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetVodDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetVodDomainCertificateResponse() = default;
};
class SubmitAIImageAuditJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaAuditConfiguration{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> templateId{};

  SubmitAIImageAuditJobRequest() {}

  explicit SubmitAIImageAuditJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaAuditConfiguration) {
      res["MediaAuditConfiguration"] = boost::any(*mediaAuditConfiguration);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaAuditConfiguration") != m.end() && !m["MediaAuditConfiguration"].empty()) {
      mediaAuditConfiguration = make_shared<string>(boost::any_cast<string>(m["MediaAuditConfiguration"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitAIImageAuditJobRequest() = default;
};
class SubmitAIImageAuditJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitAIImageAuditJobResponseBody() {}

  explicit SubmitAIImageAuditJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitAIImageAuditJobResponseBody() = default;
};
class SubmitAIImageAuditJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAIImageAuditJobResponseBody> body{};

  SubmitAIImageAuditJobResponse() {}

  explicit SubmitAIImageAuditJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAIImageAuditJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAIImageAuditJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAIImageAuditJobResponse() = default;
};
class SubmitAIImageJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIPipelineId{};
  shared_ptr<string> AITemplateId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> userData{};
  shared_ptr<string> videoId{};

  SubmitAIImageJobRequest() {}

  explicit SubmitAIImageJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIPipelineId) {
      res["AIPipelineId"] = boost::any(*AIPipelineId);
    }
    if (AITemplateId) {
      res["AITemplateId"] = boost::any(*AITemplateId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIPipelineId") != m.end() && !m["AIPipelineId"].empty()) {
      AIPipelineId = make_shared<string>(boost::any_cast<string>(m["AIPipelineId"]));
    }
    if (m.find("AITemplateId") != m.end() && !m["AITemplateId"].empty()) {
      AITemplateId = make_shared<string>(boost::any_cast<string>(m["AITemplateId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~SubmitAIImageJobRequest() = default;
};
class SubmitAIImageJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitAIImageJobResponseBody() {}

  explicit SubmitAIImageJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitAIImageJobResponseBody() = default;
};
class SubmitAIImageJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAIImageJobResponseBody> body{};

  SubmitAIImageJobResponse() {}

  explicit SubmitAIImageJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAIImageJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAIImageJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAIImageJobResponse() = default;
};
class SubmitAIJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> types{};
  shared_ptr<string> userData{};

  SubmitAIJobRequest() {}

  explicit SubmitAIJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      types = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAIJobRequest() = default;
};
class SubmitAIJobResponseBodyAIJobListAIJob : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> type{};

  SubmitAIJobResponseBodyAIJobListAIJob() {}

  explicit SubmitAIJobResponseBodyAIJobListAIJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitAIJobResponseBodyAIJobListAIJob() = default;
};
class SubmitAIJobResponseBodyAIJobList : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitAIJobResponseBodyAIJobListAIJob>> AIJob{};

  SubmitAIJobResponseBodyAIJobList() {}

  explicit SubmitAIJobResponseBodyAIJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIJob) {
      vector<boost::any> temp1;
      for(auto item1:*AIJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AIJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIJob") != m.end() && !m["AIJob"].empty()) {
      if (typeid(vector<boost::any>) == m["AIJob"].type()) {
        vector<SubmitAIJobResponseBodyAIJobListAIJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AIJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitAIJobResponseBodyAIJobListAIJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        AIJob = make_shared<vector<SubmitAIJobResponseBodyAIJobListAIJob>>(expect1);
      }
    }
  }


  virtual ~SubmitAIJobResponseBodyAIJobList() = default;
};
class SubmitAIJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitAIJobResponseBodyAIJobList> AIJobList{};
  shared_ptr<string> requestId{};

  SubmitAIJobResponseBody() {}

  explicit SubmitAIJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIJobList) {
      res["AIJobList"] = AIJobList ? boost::any(AIJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIJobList") != m.end() && !m["AIJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AIJobList"].type()) {
        SubmitAIJobResponseBodyAIJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AIJobList"]));
        AIJobList = make_shared<SubmitAIJobResponseBodyAIJobList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitAIJobResponseBody() = default;
};
class SubmitAIJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAIJobResponseBody> body{};

  SubmitAIJobResponse() {}

  explicit SubmitAIJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAIJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAIJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAIJobResponse() = default;
};
class SubmitAIMediaAuditJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaAuditConfiguration{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};

  SubmitAIMediaAuditJobRequest() {}

  explicit SubmitAIMediaAuditJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaAuditConfiguration) {
      res["MediaAuditConfiguration"] = boost::any(*mediaAuditConfiguration);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaAuditConfiguration") != m.end() && !m["MediaAuditConfiguration"].empty()) {
      mediaAuditConfiguration = make_shared<string>(boost::any_cast<string>(m["MediaAuditConfiguration"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAIMediaAuditJobRequest() = default;
};
class SubmitAIMediaAuditJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  SubmitAIMediaAuditJobResponseBody() {}

  explicit SubmitAIMediaAuditJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitAIMediaAuditJobResponseBody() = default;
};
class SubmitAIMediaAuditJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAIMediaAuditJobResponseBody> body{};

  SubmitAIMediaAuditJobResponse() {}

  explicit SubmitAIMediaAuditJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAIMediaAuditJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAIMediaAuditJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAIMediaAuditJobResponse() = default;
};
class SubmitDigitalWatermarkExtractJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> extractType{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  SubmitDigitalWatermarkExtractJobRequest() {}

  explicit SubmitDigitalWatermarkExtractJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extractType) {
      res["ExtractType"] = boost::any(*extractType);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtractType") != m.end() && !m["ExtractType"].empty()) {
      extractType = make_shared<string>(boost::any_cast<string>(m["ExtractType"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~SubmitDigitalWatermarkExtractJobRequest() = default;
};
class SubmitDigitalWatermarkExtractJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitDigitalWatermarkExtractJobResponseBody() {}

  explicit SubmitDigitalWatermarkExtractJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitDigitalWatermarkExtractJobResponseBody() = default;
};
class SubmitDigitalWatermarkExtractJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitDigitalWatermarkExtractJobResponseBody> body{};

  SubmitDigitalWatermarkExtractJobResponse() {}

  explicit SubmitDigitalWatermarkExtractJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitDigitalWatermarkExtractJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitDigitalWatermarkExtractJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitDigitalWatermarkExtractJobResponse() = default;
};
class SubmitDynamicImageJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> dynamicImageTemplateId{};
  shared_ptr<string> overrideParams{};
  shared_ptr<string> videoId{};

  SubmitDynamicImageJobRequest() {}

  explicit SubmitDynamicImageJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicImageTemplateId) {
      res["DynamicImageTemplateId"] = boost::any(*dynamicImageTemplateId);
    }
    if (overrideParams) {
      res["OverrideParams"] = boost::any(*overrideParams);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicImageTemplateId") != m.end() && !m["DynamicImageTemplateId"].empty()) {
      dynamicImageTemplateId = make_shared<string>(boost::any_cast<string>(m["DynamicImageTemplateId"]));
    }
    if (m.find("OverrideParams") != m.end() && !m["OverrideParams"].empty()) {
      overrideParams = make_shared<string>(boost::any_cast<string>(m["OverrideParams"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequest() = default;
};
class SubmitDynamicImageJobResponseBodyDynamicImageJob : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitDynamicImageJobResponseBodyDynamicImageJob() {}

  explicit SubmitDynamicImageJobResponseBodyDynamicImageJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitDynamicImageJobResponseBodyDynamicImageJob() = default;
};
class SubmitDynamicImageJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitDynamicImageJobResponseBodyDynamicImageJob> dynamicImageJob{};
  shared_ptr<string> requestId{};

  SubmitDynamicImageJobResponseBody() {}

  explicit SubmitDynamicImageJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicImageJob) {
      res["DynamicImageJob"] = dynamicImageJob ? boost::any(dynamicImageJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicImageJob") != m.end() && !m["DynamicImageJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["DynamicImageJob"].type()) {
        SubmitDynamicImageJobResponseBodyDynamicImageJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DynamicImageJob"]));
        dynamicImageJob = make_shared<SubmitDynamicImageJobResponseBodyDynamicImageJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitDynamicImageJobResponseBody() = default;
};
class SubmitDynamicImageJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitDynamicImageJobResponseBody> body{};

  SubmitDynamicImageJobResponse() {}

  explicit SubmitDynamicImageJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitDynamicImageJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitDynamicImageJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitDynamicImageJobResponse() = default;
};
class SubmitMediaDNADeleteJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};

  SubmitMediaDNADeleteJobRequest() {}

  explicit SubmitMediaDNADeleteJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
  }


  virtual ~SubmitMediaDNADeleteJobRequest() = default;
};
class SubmitMediaDNADeleteJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitMediaDNADeleteJobResponseBody() {}

  explicit SubmitMediaDNADeleteJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaDNADeleteJobResponseBody() = default;
};
class SubmitMediaDNADeleteJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaDNADeleteJobResponseBody> body{};

  SubmitMediaDNADeleteJobResponse() {}

  explicit SubmitMediaDNADeleteJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaDNADeleteJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaDNADeleteJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaDNADeleteJobResponse() = default;
};
class SubmitPreprocessJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> preprocessType{};
  shared_ptr<string> videoId{};

  SubmitPreprocessJobsRequest() {}

  explicit SubmitPreprocessJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preprocessType) {
      res["PreprocessType"] = boost::any(*preprocessType);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreprocessType") != m.end() && !m["PreprocessType"].empty()) {
      preprocessType = make_shared<string>(boost::any_cast<string>(m["PreprocessType"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~SubmitPreprocessJobsRequest() = default;
};
class SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob() {}

  explicit SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob() = default;
};
class SubmitPreprocessJobsResponseBodyPreprocessJobs : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob>> preprocessJob{};

  SubmitPreprocessJobsResponseBodyPreprocessJobs() {}

  explicit SubmitPreprocessJobsResponseBodyPreprocessJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preprocessJob) {
      vector<boost::any> temp1;
      for(auto item1:*preprocessJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreprocessJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreprocessJob") != m.end() && !m["PreprocessJob"].empty()) {
      if (typeid(vector<boost::any>) == m["PreprocessJob"].type()) {
        vector<SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreprocessJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preprocessJob = make_shared<vector<SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob>>(expect1);
      }
    }
  }


  virtual ~SubmitPreprocessJobsResponseBodyPreprocessJobs() = default;
};
class SubmitPreprocessJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitPreprocessJobsResponseBodyPreprocessJobs> preprocessJobs{};
  shared_ptr<string> requestId{};

  SubmitPreprocessJobsResponseBody() {}

  explicit SubmitPreprocessJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preprocessJobs) {
      res["PreprocessJobs"] = preprocessJobs ? boost::any(preprocessJobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreprocessJobs") != m.end() && !m["PreprocessJobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["PreprocessJobs"].type()) {
        SubmitPreprocessJobsResponseBodyPreprocessJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PreprocessJobs"]));
        preprocessJobs = make_shared<SubmitPreprocessJobsResponseBodyPreprocessJobs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitPreprocessJobsResponseBody() = default;
};
class SubmitPreprocessJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitPreprocessJobsResponseBody> body{};

  SubmitPreprocessJobsResponse() {}

  explicit SubmitPreprocessJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitPreprocessJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitPreprocessJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitPreprocessJobsResponse() = default;
};
class SubmitSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> height{};
  shared_ptr<long> interval{};
  shared_ptr<string> snapshotTemplateId{};
  shared_ptr<long> specifiedOffsetTime{};
  shared_ptr<vector<long>> specifiedOffsetTimes{};
  shared_ptr<string> spriteSnapshotConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> videoId{};
  shared_ptr<string> width{};

  SubmitSnapshotJobRequest() {}

  explicit SubmitSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (snapshotTemplateId) {
      res["SnapshotTemplateId"] = boost::any(*snapshotTemplateId);
    }
    if (specifiedOffsetTime) {
      res["SpecifiedOffsetTime"] = boost::any(*specifiedOffsetTime);
    }
    if (specifiedOffsetTimes) {
      res["SpecifiedOffsetTimes"] = boost::any(*specifiedOffsetTimes);
    }
    if (spriteSnapshotConfig) {
      res["SpriteSnapshotConfig"] = boost::any(*spriteSnapshotConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("SnapshotTemplateId") != m.end() && !m["SnapshotTemplateId"].empty()) {
      snapshotTemplateId = make_shared<string>(boost::any_cast<string>(m["SnapshotTemplateId"]));
    }
    if (m.find("SpecifiedOffsetTime") != m.end() && !m["SpecifiedOffsetTime"].empty()) {
      specifiedOffsetTime = make_shared<long>(boost::any_cast<long>(m["SpecifiedOffsetTime"]));
    }
    if (m.find("SpecifiedOffsetTimes") != m.end() && !m["SpecifiedOffsetTimes"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SpecifiedOffsetTimes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpecifiedOffsetTimes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      specifiedOffsetTimes = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SpriteSnapshotConfig") != m.end() && !m["SpriteSnapshotConfig"].empty()) {
      spriteSnapshotConfig = make_shared<string>(boost::any_cast<string>(m["SpriteSnapshotConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitSnapshotJobRequest() = default;
};
class SubmitSnapshotJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> height{};
  shared_ptr<long> interval{};
  shared_ptr<string> snapshotTemplateId{};
  shared_ptr<long> specifiedOffsetTime{};
  shared_ptr<string> specifiedOffsetTimesShrink{};
  shared_ptr<string> spriteSnapshotConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> videoId{};
  shared_ptr<string> width{};

  SubmitSnapshotJobShrinkRequest() {}

  explicit SubmitSnapshotJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (snapshotTemplateId) {
      res["SnapshotTemplateId"] = boost::any(*snapshotTemplateId);
    }
    if (specifiedOffsetTime) {
      res["SpecifiedOffsetTime"] = boost::any(*specifiedOffsetTime);
    }
    if (specifiedOffsetTimesShrink) {
      res["SpecifiedOffsetTimes"] = boost::any(*specifiedOffsetTimesShrink);
    }
    if (spriteSnapshotConfig) {
      res["SpriteSnapshotConfig"] = boost::any(*spriteSnapshotConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("SnapshotTemplateId") != m.end() && !m["SnapshotTemplateId"].empty()) {
      snapshotTemplateId = make_shared<string>(boost::any_cast<string>(m["SnapshotTemplateId"]));
    }
    if (m.find("SpecifiedOffsetTime") != m.end() && !m["SpecifiedOffsetTime"].empty()) {
      specifiedOffsetTime = make_shared<long>(boost::any_cast<long>(m["SpecifiedOffsetTime"]));
    }
    if (m.find("SpecifiedOffsetTimes") != m.end() && !m["SpecifiedOffsetTimes"].empty()) {
      specifiedOffsetTimesShrink = make_shared<string>(boost::any_cast<string>(m["SpecifiedOffsetTimes"]));
    }
    if (m.find("SpriteSnapshotConfig") != m.end() && !m["SpriteSnapshotConfig"].empty()) {
      spriteSnapshotConfig = make_shared<string>(boost::any_cast<string>(m["SpriteSnapshotConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitSnapshotJobShrinkRequest() = default;
};
class SubmitSnapshotJobResponseBodySnapshotJob : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitSnapshotJobResponseBodySnapshotJob() {}

  explicit SubmitSnapshotJobResponseBodySnapshotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBodySnapshotJob() = default;
};
class SubmitSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitSnapshotJobResponseBodySnapshotJob> snapshotJob{};

  SubmitSnapshotJobResponseBody() {}

  explicit SubmitSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotJob) {
      res["SnapshotJob"] = snapshotJob ? boost::any(snapshotJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotJob") != m.end() && !m["SnapshotJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotJob"].type()) {
        SubmitSnapshotJobResponseBodySnapshotJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotJob"]));
        snapshotJob = make_shared<SubmitSnapshotJobResponseBodySnapshotJob>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponseBody() = default;
};
class SubmitSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSnapshotJobResponseBody> body{};

  SubmitSnapshotJobResponse() {}

  explicit SubmitSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponse() = default;
};
class SubmitTranscodeJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> encryptConfig{};
  shared_ptr<string> overrideParams{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};
  shared_ptr<string> templateGroupId{};
  shared_ptr<string> userData{};
  shared_ptr<string> videoId{};

  SubmitTranscodeJobsRequest() {}

  explicit SubmitTranscodeJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryptConfig) {
      res["EncryptConfig"] = boost::any(*encryptConfig);
    }
    if (overrideParams) {
      res["OverrideParams"] = boost::any(*overrideParams);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (templateGroupId) {
      res["TemplateGroupId"] = boost::any(*templateGroupId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EncryptConfig") != m.end() && !m["EncryptConfig"].empty()) {
      encryptConfig = make_shared<string>(boost::any_cast<string>(m["EncryptConfig"]));
    }
    if (m.find("OverrideParams") != m.end() && !m["OverrideParams"].empty()) {
      overrideParams = make_shared<string>(boost::any_cast<string>(m["OverrideParams"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("TemplateGroupId") != m.end() && !m["TemplateGroupId"].empty()) {
      templateGroupId = make_shared<string>(boost::any_cast<string>(m["TemplateGroupId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~SubmitTranscodeJobsRequest() = default;
};
class SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob() {}

  explicit SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob() = default;
};
class SubmitTranscodeJobsResponseBodyTranscodeJobs : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob>> transcodeJob{};

  SubmitTranscodeJobsResponseBodyTranscodeJobs() {}

  explicit SubmitTranscodeJobsResponseBodyTranscodeJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeJob) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeJob") != m.end() && !m["TranscodeJob"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeJob"].type()) {
        vector<SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeJob = make_shared<vector<SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob>>(expect1);
      }
    }
  }


  virtual ~SubmitTranscodeJobsResponseBodyTranscodeJobs() = default;
};
class SubmitTranscodeJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitTranscodeJobsResponseBodyTranscodeJobs> transcodeJobs{};
  shared_ptr<string> transcodeTaskId{};

  SubmitTranscodeJobsResponseBody() {}

  explicit SubmitTranscodeJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeJobs) {
      res["TranscodeJobs"] = transcodeJobs ? boost::any(transcodeJobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transcodeTaskId) {
      res["TranscodeTaskId"] = boost::any(*transcodeTaskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeJobs") != m.end() && !m["TranscodeJobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeJobs"].type()) {
        SubmitTranscodeJobsResponseBodyTranscodeJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeJobs"]));
        transcodeJobs = make_shared<SubmitTranscodeJobsResponseBodyTranscodeJobs>(model1);
      }
    }
    if (m.find("TranscodeTaskId") != m.end() && !m["TranscodeTaskId"].empty()) {
      transcodeTaskId = make_shared<string>(boost::any_cast<string>(m["TranscodeTaskId"]));
    }
  }


  virtual ~SubmitTranscodeJobsResponseBody() = default;
};
class SubmitTranscodeJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitTranscodeJobsResponseBody> body{};

  SubmitTranscodeJobsResponse() {}

  explicit SubmitTranscodeJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTranscodeJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTranscodeJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobsResponse() = default;
};
class SubmitWorkflowJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> workflowId{};

  SubmitWorkflowJobRequest() {}

  explicit SubmitWorkflowJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
  }


  virtual ~SubmitWorkflowJobRequest() = default;
};
class SubmitWorkflowJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SubmitWorkflowJobResponseBody() {}

  explicit SubmitWorkflowJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitWorkflowJobResponseBody() = default;
};
class SubmitWorkflowJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitWorkflowJobResponseBody> body{};

  SubmitWorkflowJobResponse() {}

  explicit SubmitWorkflowJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitWorkflowJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitWorkflowJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitWorkflowJobResponse() = default;
};
class UpdateAITemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  UpdateAITemplateRequest() {}

  explicit UpdateAITemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~UpdateAITemplateRequest() = default;
};
class UpdateAITemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  UpdateAITemplateResponseBody() {}

  explicit UpdateAITemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateAITemplateResponseBody() = default;
};
class UpdateAITemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAITemplateResponseBody> body{};

  UpdateAITemplateResponse() {}

  explicit UpdateAITemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAITemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAITemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAITemplateResponse() = default;
};
class UpdateAppInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};

  UpdateAppInfoRequest() {}

  explicit UpdateAppInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateAppInfoRequest() = default;
};
class UpdateAppInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAppInfoResponseBody() {}

  explicit UpdateAppInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAppInfoResponseBody() = default;
};
class UpdateAppInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAppInfoResponseBody> body{};

  UpdateAppInfoResponse() {}

  explicit UpdateAppInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAppInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAppInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAppInfoResponse() = default;
};
class UpdateAttachedMediaInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> updateContent{};

  UpdateAttachedMediaInfosRequest() {}

  explicit UpdateAttachedMediaInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateContent) {
      res["UpdateContent"] = boost::any(*updateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateContent") != m.end() && !m["UpdateContent"].empty()) {
      updateContent = make_shared<string>(boost::any_cast<string>(m["UpdateContent"]));
    }
  }


  virtual ~UpdateAttachedMediaInfosRequest() = default;
};
class UpdateAttachedMediaInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nonExistMediaIds{};
  shared_ptr<string> requestId{};

  UpdateAttachedMediaInfosResponseBody() {}

  explicit UpdateAttachedMediaInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistMediaIds) {
      res["NonExistMediaIds"] = boost::any(*nonExistMediaIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistMediaIds") != m.end() && !m["NonExistMediaIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistMediaIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistMediaIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistMediaIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAttachedMediaInfosResponseBody() = default;
};
class UpdateAttachedMediaInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAttachedMediaInfosResponseBody> body{};

  UpdateAttachedMediaInfosResponse() {}

  explicit UpdateAttachedMediaInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAttachedMediaInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAttachedMediaInfosResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAttachedMediaInfosResponse() = default;
};
class UpdateCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};

  UpdateCategoryRequest() {}

  explicit UpdateCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
  }


  virtual ~UpdateCategoryRequest() = default;
};
class UpdateCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCategoryResponseBody() {}

  explicit UpdateCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCategoryResponseBody() = default;
};
class UpdateCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCategoryResponseBody> body{};

  UpdateCategoryResponse() {}

  explicit UpdateCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCategoryResponse() = default;
};
class UpdateEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<string> resourceOwnerId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  UpdateEditingProjectRequest() {}

  explicit UpdateEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateEditingProjectRequest() = default;
};
class UpdateEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateEditingProjectResponseBody() {}

  explicit UpdateEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEditingProjectResponseBody() = default;
};
class UpdateEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEditingProjectResponseBody> body{};

  UpdateEditingProjectResponse() {}

  explicit UpdateEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEditingProjectResponse() = default;
};
class UpdateImageInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> updateContent{};

  UpdateImageInfosRequest() {}

  explicit UpdateImageInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateContent) {
      res["UpdateContent"] = boost::any(*updateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateContent") != m.end() && !m["UpdateContent"].empty()) {
      updateContent = make_shared<string>(boost::any_cast<string>(m["UpdateContent"]));
    }
  }


  virtual ~UpdateImageInfosRequest() = default;
};
class UpdateImageInfosResponseBodyNonExistImageIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> imageId{};

  UpdateImageInfosResponseBodyNonExistImageIds() {}

  explicit UpdateImageInfosResponseBodyNonExistImageIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageId) {
      res["ImageId"] = boost::any(*imageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageId") != m.end() && !m["ImageId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateImageInfosResponseBodyNonExistImageIds() = default;
};
class UpdateImageInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateImageInfosResponseBodyNonExistImageIds> nonExistImageIds{};
  shared_ptr<string> requestId{};

  UpdateImageInfosResponseBody() {}

  explicit UpdateImageInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExistImageIds) {
      res["NonExistImageIds"] = nonExistImageIds ? boost::any(nonExistImageIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExistImageIds") != m.end() && !m["NonExistImageIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistImageIds"].type()) {
        UpdateImageInfosResponseBodyNonExistImageIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistImageIds"]));
        nonExistImageIds = make_shared<UpdateImageInfosResponseBodyNonExistImageIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateImageInfosResponseBody() = default;
};
class UpdateImageInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateImageInfosResponseBody> body{};

  UpdateImageInfosResponse() {}

  explicit UpdateImageInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateImageInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateImageInfosResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateImageInfosResponse() = default;
};
class UpdateMediaStorageClassRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allowUpdateWithoutTimeLimit{};
  shared_ptr<string> mediaIds{};
  shared_ptr<string> restoreTier{};
  shared_ptr<string> scope{};
  shared_ptr<string> storageClass{};

  UpdateMediaStorageClassRequest() {}

  explicit UpdateMediaStorageClassRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowUpdateWithoutTimeLimit) {
      res["AllowUpdateWithoutTimeLimit"] = boost::any(*allowUpdateWithoutTimeLimit);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (restoreTier) {
      res["RestoreTier"] = boost::any(*restoreTier);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowUpdateWithoutTimeLimit") != m.end() && !m["AllowUpdateWithoutTimeLimit"].empty()) {
      allowUpdateWithoutTimeLimit = make_shared<bool>(boost::any_cast<bool>(m["AllowUpdateWithoutTimeLimit"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("RestoreTier") != m.end() && !m["RestoreTier"].empty()) {
      restoreTier = make_shared<string>(boost::any_cast<string>(m["RestoreTier"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
  }


  virtual ~UpdateMediaStorageClassRequest() = default;
};
class UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> reason{};

  UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO() {}

  explicit UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO() = default;
};
class UpdateMediaStorageClassResponseBodyForbiddenList : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO>> mediaForbiddenReasonDTO{};

  UpdateMediaStorageClassResponseBodyForbiddenList() {}

  explicit UpdateMediaStorageClassResponseBodyForbiddenList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaForbiddenReasonDTO) {
      vector<boost::any> temp1;
      for(auto item1:*mediaForbiddenReasonDTO){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaForbiddenReasonDTO"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaForbiddenReasonDTO") != m.end() && !m["MediaForbiddenReasonDTO"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaForbiddenReasonDTO"].type()) {
        vector<UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaForbiddenReasonDTO"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaForbiddenReasonDTO = make_shared<vector<UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO>>(expect1);
      }
    }
  }


  virtual ~UpdateMediaStorageClassResponseBodyForbiddenList() = default;
};
class UpdateMediaStorageClassResponseBodyIgnoredList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> mediaId{};

  UpdateMediaStorageClassResponseBodyIgnoredList() {}

  explicit UpdateMediaStorageClassResponseBodyIgnoredList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediaId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediaId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediaId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateMediaStorageClassResponseBodyIgnoredList() = default;
};
class UpdateMediaStorageClassResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateMediaStorageClassResponseBodyForbiddenList> forbiddenList{};
  shared_ptr<UpdateMediaStorageClassResponseBodyIgnoredList> ignoredList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  UpdateMediaStorageClassResponseBody() {}

  explicit UpdateMediaStorageClassResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbiddenList) {
      res["ForbiddenList"] = forbiddenList ? boost::any(forbiddenList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ignoredList) {
      res["IgnoredList"] = ignoredList ? boost::any(ignoredList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbiddenList") != m.end() && !m["ForbiddenList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForbiddenList"].type()) {
        UpdateMediaStorageClassResponseBodyForbiddenList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForbiddenList"]));
        forbiddenList = make_shared<UpdateMediaStorageClassResponseBodyForbiddenList>(model1);
      }
    }
    if (m.find("IgnoredList") != m.end() && !m["IgnoredList"].empty()) {
      if (typeid(map<string, boost::any>) == m["IgnoredList"].type()) {
        UpdateMediaStorageClassResponseBodyIgnoredList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IgnoredList"]));
        ignoredList = make_shared<UpdateMediaStorageClassResponseBodyIgnoredList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateMediaStorageClassResponseBody() = default;
};
class UpdateMediaStorageClassResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaStorageClassResponseBody> body{};

  UpdateMediaStorageClassResponse() {}

  explicit UpdateMediaStorageClassResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaStorageClassResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaStorageClassResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaStorageClassResponse() = default;
};
class UpdateTranscodeTemplateGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> locked{};
  shared_ptr<string> name{};
  shared_ptr<string> transcodeTemplateGroupId{};
  shared_ptr<string> transcodeTemplateList{};

  UpdateTranscodeTemplateGroupRequest() {}

  explicit UpdateTranscodeTemplateGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locked) {
      res["Locked"] = boost::any(*locked);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    if (transcodeTemplateList) {
      res["TranscodeTemplateList"] = boost::any(*transcodeTemplateList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Locked") != m.end() && !m["Locked"].empty()) {
      locked = make_shared<string>(boost::any_cast<string>(m["Locked"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
    if (m.find("TranscodeTemplateList") != m.end() && !m["TranscodeTemplateList"].empty()) {
      transcodeTemplateList = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateList"]));
    }
  }


  virtual ~UpdateTranscodeTemplateGroupRequest() = default;
};
class UpdateTranscodeTemplateGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> transcodeTemplateGroupId{};

  UpdateTranscodeTemplateGroupResponseBody() {}

  explicit UpdateTranscodeTemplateGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeTemplateGroupId) {
      res["TranscodeTemplateGroupId"] = boost::any(*transcodeTemplateGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeTemplateGroupId") != m.end() && !m["TranscodeTemplateGroupId"].empty()) {
      transcodeTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["TranscodeTemplateGroupId"]));
    }
  }


  virtual ~UpdateTranscodeTemplateGroupResponseBody() = default;
};
class UpdateTranscodeTemplateGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTranscodeTemplateGroupResponseBody> body{};

  UpdateTranscodeTemplateGroupResponse() {}

  explicit UpdateTranscodeTemplateGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTranscodeTemplateGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTranscodeTemplateGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTranscodeTemplateGroupResponse() = default;
};
class UpdateVideoInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> videoId{};

  UpdateVideoInfoRequest() {}

  explicit UpdateVideoInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~UpdateVideoInfoRequest() = default;
};
class UpdateVideoInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateVideoInfoResponseBody() {}

  explicit UpdateVideoInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateVideoInfoResponseBody() = default;
};
class UpdateVideoInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateVideoInfoResponseBody> body{};

  UpdateVideoInfoResponse() {}

  explicit UpdateVideoInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVideoInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVideoInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVideoInfoResponse() = default;
};
class UpdateVideoInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> updateContent{};

  UpdateVideoInfosRequest() {}

  explicit UpdateVideoInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateContent) {
      res["UpdateContent"] = boost::any(*updateContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateContent") != m.end() && !m["UpdateContent"].empty()) {
      updateContent = make_shared<string>(boost::any_cast<string>(m["UpdateContent"]));
    }
  }


  virtual ~UpdateVideoInfosRequest() = default;
};
class UpdateVideoInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forbiddenVideoIds{};
  shared_ptr<vector<string>> nonExistVideoIds{};
  shared_ptr<string> requestId{};

  UpdateVideoInfosResponseBody() {}

  explicit UpdateVideoInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbiddenVideoIds) {
      res["ForbiddenVideoIds"] = boost::any(*forbiddenVideoIds);
    }
    if (nonExistVideoIds) {
      res["NonExistVideoIds"] = boost::any(*nonExistVideoIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbiddenVideoIds") != m.end() && !m["ForbiddenVideoIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForbiddenVideoIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForbiddenVideoIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forbiddenVideoIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NonExistVideoIds") != m.end() && !m["NonExistVideoIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExistVideoIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExistVideoIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExistVideoIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateVideoInfosResponseBody() = default;
};
class UpdateVideoInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateVideoInfosResponseBody> body{};

  UpdateVideoInfosResponse() {}

  explicit UpdateVideoInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVideoInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVideoInfosResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVideoInfosResponse() = default;
};
class UpdateVodDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<string> topLevelDomain{};

  UpdateVodDomainRequest() {}

  explicit UpdateVodDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~UpdateVodDomainRequest() = default;
};
class UpdateVodDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateVodDomainResponseBody() {}

  explicit UpdateVodDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateVodDomainResponseBody() = default;
};
class UpdateVodDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateVodDomainResponseBody> body{};

  UpdateVodDomainResponse() {}

  explicit UpdateVodDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVodDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVodDomainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVodDomainResponse() = default;
};
class UpdateVodTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> vodTemplateId{};

  UpdateVodTemplateRequest() {}

  explicit UpdateVodTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (vodTemplateId) {
      res["VodTemplateId"] = boost::any(*vodTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("VodTemplateId") != m.end() && !m["VodTemplateId"].empty()) {
      vodTemplateId = make_shared<string>(boost::any_cast<string>(m["VodTemplateId"]));
    }
  }


  virtual ~UpdateVodTemplateRequest() = default;
};
class UpdateVodTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vodTemplateId{};

  UpdateVodTemplateResponseBody() {}

  explicit UpdateVodTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vodTemplateId) {
      res["VodTemplateId"] = boost::any(*vodTemplateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VodTemplateId") != m.end() && !m["VodTemplateId"].empty()) {
      vodTemplateId = make_shared<string>(boost::any_cast<string>(m["VodTemplateId"]));
    }
  }


  virtual ~UpdateVodTemplateResponseBody() = default;
};
class UpdateVodTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateVodTemplateResponseBody> body{};

  UpdateVodTemplateResponse() {}

  explicit UpdateVodTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVodTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVodTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVodTemplateResponse() = default;
};
class UpdateWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> watermarkConfig{};
  shared_ptr<string> watermarkId{};

  UpdateWatermarkRequest() {}

  explicit UpdateWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (watermarkConfig) {
      res["WatermarkConfig"] = boost::any(*watermarkConfig);
    }
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("WatermarkConfig") != m.end() && !m["WatermarkConfig"].empty()) {
      watermarkConfig = make_shared<string>(boost::any_cast<string>(m["WatermarkConfig"]));
    }
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
  }


  virtual ~UpdateWatermarkRequest() = default;
};
class UpdateWatermarkResponseBodyWatermarkInfo : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> isDefault{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<string> watermarkConfig{};
  shared_ptr<string> watermarkId{};

  UpdateWatermarkResponseBodyWatermarkInfo() {}

  explicit UpdateWatermarkResponseBodyWatermarkInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (watermarkConfig) {
      res["WatermarkConfig"] = boost::any(*watermarkConfig);
    }
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<string>(boost::any_cast<string>(m["IsDefault"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WatermarkConfig") != m.end() && !m["WatermarkConfig"].empty()) {
      watermarkConfig = make_shared<string>(boost::any_cast<string>(m["WatermarkConfig"]));
    }
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
  }


  virtual ~UpdateWatermarkResponseBodyWatermarkInfo() = default;
};
class UpdateWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateWatermarkResponseBodyWatermarkInfo> watermarkInfo{};

  UpdateWatermarkResponseBody() {}

  explicit UpdateWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (watermarkInfo) {
      res["WatermarkInfo"] = watermarkInfo ? boost::any(watermarkInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WatermarkInfo") != m.end() && !m["WatermarkInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["WatermarkInfo"].type()) {
        UpdateWatermarkResponseBodyWatermarkInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WatermarkInfo"]));
        watermarkInfo = make_shared<UpdateWatermarkResponseBodyWatermarkInfo>(model1);
      }
    }
  }


  virtual ~UpdateWatermarkResponseBody() = default;
};
class UpdateWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWatermarkResponseBody> body{};

  UpdateWatermarkResponse() {}

  explicit UpdateWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWatermarkResponse() = default;
};
class UploadMediaByURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> templateGroupId{};
  shared_ptr<string> uploadMetadatas{};
  shared_ptr<string> uploadURLs{};
  shared_ptr<string> userData{};
  shared_ptr<string> workflowId{};

  UploadMediaByURLRequest() {}

  explicit UploadMediaByURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (templateGroupId) {
      res["TemplateGroupId"] = boost::any(*templateGroupId);
    }
    if (uploadMetadatas) {
      res["UploadMetadatas"] = boost::any(*uploadMetadatas);
    }
    if (uploadURLs) {
      res["UploadURLs"] = boost::any(*uploadURLs);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("TemplateGroupId") != m.end() && !m["TemplateGroupId"].empty()) {
      templateGroupId = make_shared<string>(boost::any_cast<string>(m["TemplateGroupId"]));
    }
    if (m.find("UploadMetadatas") != m.end() && !m["UploadMetadatas"].empty()) {
      uploadMetadatas = make_shared<string>(boost::any_cast<string>(m["UploadMetadatas"]));
    }
    if (m.find("UploadURLs") != m.end() && !m["UploadURLs"].empty()) {
      uploadURLs = make_shared<string>(boost::any_cast<string>(m["UploadURLs"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
  }


  virtual ~UploadMediaByURLRequest() = default;
};
class UploadMediaByURLResponseBodyUploadJobs : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> sourceURL{};

  UploadMediaByURLResponseBodyUploadJobs() {}

  explicit UploadMediaByURLResponseBodyUploadJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (sourceURL) {
      res["SourceURL"] = boost::any(*sourceURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SourceURL") != m.end() && !m["SourceURL"].empty()) {
      sourceURL = make_shared<string>(boost::any_cast<string>(m["SourceURL"]));
    }
  }


  virtual ~UploadMediaByURLResponseBodyUploadJobs() = default;
};
class UploadMediaByURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<UploadMediaByURLResponseBodyUploadJobs>> uploadJobs{};

  UploadMediaByURLResponseBody() {}

  explicit UploadMediaByURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadJobs) {
      vector<boost::any> temp1;
      for(auto item1:*uploadJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UploadJobs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadJobs") != m.end() && !m["UploadJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["UploadJobs"].type()) {
        vector<UploadMediaByURLResponseBodyUploadJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UploadJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UploadMediaByURLResponseBodyUploadJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uploadJobs = make_shared<vector<UploadMediaByURLResponseBodyUploadJobs>>(expect1);
      }
    }
  }


  virtual ~UploadMediaByURLResponseBody() = default;
};
class UploadMediaByURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadMediaByURLResponseBody> body{};

  UploadMediaByURLResponse() {}

  explicit UploadMediaByURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadMediaByURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadMediaByURLResponseBody>(model1);
      }
    }
  }


  virtual ~UploadMediaByURLResponse() = default;
};
class UploadStreamByURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> definition{};
  shared_ptr<string> fileExtension{};
  shared_ptr<string> HDRType{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> streamURL{};
  shared_ptr<string> userData{};

  UploadStreamByURLRequest() {}

  explicit UploadStreamByURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (fileExtension) {
      res["FileExtension"] = boost::any(*fileExtension);
    }
    if (HDRType) {
      res["HDRType"] = boost::any(*HDRType);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (streamURL) {
      res["StreamURL"] = boost::any(*streamURL);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("FileExtension") != m.end() && !m["FileExtension"].empty()) {
      fileExtension = make_shared<string>(boost::any_cast<string>(m["FileExtension"]));
    }
    if (m.find("HDRType") != m.end() && !m["HDRType"].empty()) {
      HDRType = make_shared<string>(boost::any_cast<string>(m["HDRType"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("StreamURL") != m.end() && !m["StreamURL"].empty()) {
      streamURL = make_shared<string>(boost::any_cast<string>(m["StreamURL"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~UploadStreamByURLRequest() = default;
};
class UploadStreamByURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileURL{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sourceURL{};
  shared_ptr<string> streamJobId{};

  UploadStreamByURLResponseBody() {}

  explicit UploadStreamByURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceURL) {
      res["SourceURL"] = boost::any(*sourceURL);
    }
    if (streamJobId) {
      res["StreamJobId"] = boost::any(*streamJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceURL") != m.end() && !m["SourceURL"].empty()) {
      sourceURL = make_shared<string>(boost::any_cast<string>(m["SourceURL"]));
    }
    if (m.find("StreamJobId") != m.end() && !m["StreamJobId"].empty()) {
      streamJobId = make_shared<string>(boost::any_cast<string>(m["StreamJobId"]));
    }
  }


  virtual ~UploadStreamByURLResponseBody() = default;
};
class UploadStreamByURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadStreamByURLResponseBody> body{};

  UploadStreamByURLResponse() {}

  explicit UploadStreamByURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadStreamByURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadStreamByURLResponseBody>(model1);
      }
    }
  }


  virtual ~UploadStreamByURLResponse() = default;
};
class VerifyVodDomainOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> verifyType{};

  VerifyVodDomainOwnerRequest() {}

  explicit VerifyVodDomainOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (verifyType) {
      res["VerifyType"] = boost::any(*verifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("VerifyType") != m.end() && !m["VerifyType"].empty()) {
      verifyType = make_shared<string>(boost::any_cast<string>(m["VerifyType"]));
    }
  }


  virtual ~VerifyVodDomainOwnerRequest() = default;
};
class VerifyVodDomainOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  VerifyVodDomainOwnerResponseBody() {}

  explicit VerifyVodDomainOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyVodDomainOwnerResponseBody() = default;
};
class VerifyVodDomainOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyVodDomainOwnerResponseBody> body{};

  VerifyVodDomainOwnerResponse() {}

  explicit VerifyVodDomainOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyVodDomainOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyVodDomainOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyVodDomainOwnerResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddAITemplateResponse addAITemplateWithOptions(shared_ptr<AddAITemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAITemplateResponse addAITemplate(shared_ptr<AddAITemplateRequest> request);
  AddCategoryResponse addCategoryWithOptions(shared_ptr<AddCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCategoryResponse addCategory(shared_ptr<AddCategoryRequest> request);
  AddEditingProjectResponse addEditingProjectWithOptions(shared_ptr<AddEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddEditingProjectResponse addEditingProject(shared_ptr<AddEditingProjectRequest> request);
  AddEditingProjectMaterialsResponse addEditingProjectMaterialsWithOptions(shared_ptr<AddEditingProjectMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddEditingProjectMaterialsResponse addEditingProjectMaterials(shared_ptr<AddEditingProjectMaterialsRequest> request);
  AddTranscodeTemplateGroupResponse addTranscodeTemplateGroupWithOptions(shared_ptr<AddTranscodeTemplateGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTranscodeTemplateGroupResponse addTranscodeTemplateGroup(shared_ptr<AddTranscodeTemplateGroupRequest> request);
  AddVodDomainResponse addVodDomainWithOptions(shared_ptr<AddVodDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddVodDomainResponse addVodDomain(shared_ptr<AddVodDomainRequest> request);
  AddVodStorageForAppResponse addVodStorageForAppWithOptions(shared_ptr<AddVodStorageForAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddVodStorageForAppResponse addVodStorageForApp(shared_ptr<AddVodStorageForAppRequest> request);
  AddVodTemplateResponse addVodTemplateWithOptions(shared_ptr<AddVodTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddVodTemplateResponse addVodTemplate(shared_ptr<AddVodTemplateRequest> request);
  AddWatermarkResponse addWatermarkWithOptions(shared_ptr<AddWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddWatermarkResponse addWatermark(shared_ptr<AddWatermarkRequest> request);
  AttachAppPolicyToIdentityResponse attachAppPolicyToIdentityWithOptions(shared_ptr<AttachAppPolicyToIdentityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachAppPolicyToIdentityResponse attachAppPolicyToIdentity(shared_ptr<AttachAppPolicyToIdentityRequest> request);
  BatchSetVodDomainConfigsResponse batchSetVodDomainConfigsWithOptions(shared_ptr<BatchSetVodDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetVodDomainConfigsResponse batchSetVodDomainConfigs(shared_ptr<BatchSetVodDomainConfigsRequest> request);
  BatchStartVodDomainResponse batchStartVodDomainWithOptions(shared_ptr<BatchStartVodDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStartVodDomainResponse batchStartVodDomain(shared_ptr<BatchStartVodDomainRequest> request);
  BatchStopVodDomainResponse batchStopVodDomainWithOptions(shared_ptr<BatchStopVodDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStopVodDomainResponse batchStopVodDomain(shared_ptr<BatchStopVodDomainRequest> request);
  CancelUrlUploadJobsResponse cancelUrlUploadJobsWithOptions(shared_ptr<CancelUrlUploadJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelUrlUploadJobsResponse cancelUrlUploadJobs(shared_ptr<CancelUrlUploadJobsRequest> request);
  CreateAppInfoResponse createAppInfoWithOptions(shared_ptr<CreateAppInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAppInfoResponse createAppInfo(shared_ptr<CreateAppInfoRequest> request);
  CreateAuditResponse createAuditWithOptions(shared_ptr<CreateAuditRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAuditResponse createAudit(shared_ptr<CreateAuditRequest> request);
  CreateUploadAttachedMediaResponse createUploadAttachedMediaWithOptions(shared_ptr<CreateUploadAttachedMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUploadAttachedMediaResponse createUploadAttachedMedia(shared_ptr<CreateUploadAttachedMediaRequest> request);
  CreateUploadImageResponse createUploadImageWithOptions(shared_ptr<CreateUploadImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUploadImageResponse createUploadImage(shared_ptr<CreateUploadImageRequest> request);
  CreateUploadVideoResponse createUploadVideoWithOptions(shared_ptr<CreateUploadVideoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUploadVideoResponse createUploadVideo(shared_ptr<CreateUploadVideoRequest> request);
  DecryptKMSDataKeyResponse decryptKMSDataKeyWithOptions(shared_ptr<DecryptKMSDataKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DecryptKMSDataKeyResponse decryptKMSDataKey(shared_ptr<DecryptKMSDataKeyRequest> request);
  DeleteAIImageInfosResponse deleteAIImageInfosWithOptions(shared_ptr<DeleteAIImageInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAIImageInfosResponse deleteAIImageInfos(shared_ptr<DeleteAIImageInfosRequest> request);
  DeleteAITemplateResponse deleteAITemplateWithOptions(shared_ptr<DeleteAITemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAITemplateResponse deleteAITemplate(shared_ptr<DeleteAITemplateRequest> request);
  DeleteAppInfoResponse deleteAppInfoWithOptions(shared_ptr<DeleteAppInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAppInfoResponse deleteAppInfo(shared_ptr<DeleteAppInfoRequest> request);
  DeleteAttachedMediaResponse deleteAttachedMediaWithOptions(shared_ptr<DeleteAttachedMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAttachedMediaResponse deleteAttachedMedia(shared_ptr<DeleteAttachedMediaRequest> request);
  DeleteCategoryResponse deleteCategoryWithOptions(shared_ptr<DeleteCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCategoryResponse deleteCategory(shared_ptr<DeleteCategoryRequest> request);
  DeleteDynamicImageResponse deleteDynamicImageWithOptions(shared_ptr<DeleteDynamicImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDynamicImageResponse deleteDynamicImage(shared_ptr<DeleteDynamicImageRequest> request);
  DeleteEditingProjectResponse deleteEditingProjectWithOptions(shared_ptr<DeleteEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEditingProjectResponse deleteEditingProject(shared_ptr<DeleteEditingProjectRequest> request);
  DeleteEditingProjectMaterialsResponse deleteEditingProjectMaterialsWithOptions(shared_ptr<DeleteEditingProjectMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEditingProjectMaterialsResponse deleteEditingProjectMaterials(shared_ptr<DeleteEditingProjectMaterialsRequest> request);
  DeleteImageResponse deleteImageWithOptions(shared_ptr<DeleteImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteImageResponse deleteImage(shared_ptr<DeleteImageRequest> request);
  DeleteMessageCallbackResponse deleteMessageCallbackWithOptions(shared_ptr<DeleteMessageCallbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMessageCallbackResponse deleteMessageCallback(shared_ptr<DeleteMessageCallbackRequest> request);
  DeleteMezzaninesResponse deleteMezzaninesWithOptions(shared_ptr<DeleteMezzaninesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMezzaninesResponse deleteMezzanines(shared_ptr<DeleteMezzaninesRequest> request);
  DeleteMultipartUploadResponse deleteMultipartUploadWithOptions(shared_ptr<DeleteMultipartUploadRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMultipartUploadResponse deleteMultipartUpload(shared_ptr<DeleteMultipartUploadRequest> request);
  DeleteStreamResponse deleteStreamWithOptions(shared_ptr<DeleteStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStreamResponse deleteStream(shared_ptr<DeleteStreamRequest> request);
  DeleteTranscodeTemplateGroupResponse deleteTranscodeTemplateGroupWithOptions(shared_ptr<DeleteTranscodeTemplateGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTranscodeTemplateGroupResponse deleteTranscodeTemplateGroup(shared_ptr<DeleteTranscodeTemplateGroupRequest> request);
  DeleteVideoResponse deleteVideoWithOptions(shared_ptr<DeleteVideoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVideoResponse deleteVideo(shared_ptr<DeleteVideoRequest> request);
  DeleteVodDomainResponse deleteVodDomainWithOptions(shared_ptr<DeleteVodDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVodDomainResponse deleteVodDomain(shared_ptr<DeleteVodDomainRequest> request);
  DeleteVodSpecificConfigResponse deleteVodSpecificConfigWithOptions(shared_ptr<DeleteVodSpecificConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVodSpecificConfigResponse deleteVodSpecificConfig(shared_ptr<DeleteVodSpecificConfigRequest> request);
  DeleteVodTemplateResponse deleteVodTemplateWithOptions(shared_ptr<DeleteVodTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVodTemplateResponse deleteVodTemplate(shared_ptr<DeleteVodTemplateRequest> request);
  DeleteWatermarkResponse deleteWatermarkWithOptions(shared_ptr<DeleteWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteWatermarkResponse deleteWatermark(shared_ptr<DeleteWatermarkRequest> request);
  DescribePlayTopVideosResponse describePlayTopVideosWithOptions(shared_ptr<DescribePlayTopVideosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayTopVideosResponse describePlayTopVideos(shared_ptr<DescribePlayTopVideosRequest> request);
  DescribePlayUserAvgResponse describePlayUserAvgWithOptions(shared_ptr<DescribePlayUserAvgRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayUserAvgResponse describePlayUserAvg(shared_ptr<DescribePlayUserAvgRequest> request);
  DescribePlayUserTotalResponse describePlayUserTotalWithOptions(shared_ptr<DescribePlayUserTotalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayUserTotalResponse describePlayUserTotal(shared_ptr<DescribePlayUserTotalRequest> request);
  DescribePlayVideoStatisResponse describePlayVideoStatisWithOptions(shared_ptr<DescribePlayVideoStatisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayVideoStatisResponse describePlayVideoStatis(shared_ptr<DescribePlayVideoStatisRequest> request);
  DescribeVodAIDataResponse describeVodAIDataWithOptions(shared_ptr<DescribeVodAIDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodAIDataResponse describeVodAIData(shared_ptr<DescribeVodAIDataRequest> request);
  DescribeVodCertificateListResponse describeVodCertificateListWithOptions(shared_ptr<DescribeVodCertificateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodCertificateListResponse describeVodCertificateList(shared_ptr<DescribeVodCertificateListRequest> request);
  DescribeVodDomainBpsDataResponse describeVodDomainBpsDataWithOptions(shared_ptr<DescribeVodDomainBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodDomainBpsDataResponse describeVodDomainBpsData(shared_ptr<DescribeVodDomainBpsDataRequest> request);
  DescribeVodDomainCertificateInfoResponse describeVodDomainCertificateInfoWithOptions(shared_ptr<DescribeVodDomainCertificateInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodDomainCertificateInfoResponse describeVodDomainCertificateInfo(shared_ptr<DescribeVodDomainCertificateInfoRequest> request);
  DescribeVodDomainConfigsResponse describeVodDomainConfigsWithOptions(shared_ptr<DescribeVodDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodDomainConfigsResponse describeVodDomainConfigs(shared_ptr<DescribeVodDomainConfigsRequest> request);
  DescribeVodDomainDetailResponse describeVodDomainDetailWithOptions(shared_ptr<DescribeVodDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodDomainDetailResponse describeVodDomainDetail(shared_ptr<DescribeVodDomainDetailRequest> request);
  DescribeVodDomainLogResponse describeVodDomainLogWithOptions(shared_ptr<DescribeVodDomainLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodDomainLogResponse describeVodDomainLog(shared_ptr<DescribeVodDomainLogRequest> request);
  DescribeVodDomainSrcBpsDataResponse describeVodDomainSrcBpsDataWithOptions(shared_ptr<DescribeVodDomainSrcBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodDomainSrcBpsDataResponse describeVodDomainSrcBpsData(shared_ptr<DescribeVodDomainSrcBpsDataRequest> request);
  DescribeVodDomainSrcTrafficDataResponse describeVodDomainSrcTrafficDataWithOptions(shared_ptr<DescribeVodDomainSrcTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodDomainSrcTrafficDataResponse describeVodDomainSrcTrafficData(shared_ptr<DescribeVodDomainSrcTrafficDataRequest> request);
  DescribeVodDomainTrafficDataResponse describeVodDomainTrafficDataWithOptions(shared_ptr<DescribeVodDomainTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodDomainTrafficDataResponse describeVodDomainTrafficData(shared_ptr<DescribeVodDomainTrafficDataRequest> request);
  DescribeVodDomainUsageDataResponse describeVodDomainUsageDataWithOptions(shared_ptr<DescribeVodDomainUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodDomainUsageDataResponse describeVodDomainUsageData(shared_ptr<DescribeVodDomainUsageDataRequest> request);
  DescribeVodRefreshQuotaResponse describeVodRefreshQuotaWithOptions(shared_ptr<DescribeVodRefreshQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodRefreshQuotaResponse describeVodRefreshQuota(shared_ptr<DescribeVodRefreshQuotaRequest> request);
  DescribeVodRefreshTasksResponse describeVodRefreshTasksWithOptions(shared_ptr<DescribeVodRefreshTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodRefreshTasksResponse describeVodRefreshTasks(shared_ptr<DescribeVodRefreshTasksRequest> request);
  DescribeVodStorageDataResponse describeVodStorageDataWithOptions(shared_ptr<DescribeVodStorageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodStorageDataResponse describeVodStorageData(shared_ptr<DescribeVodStorageDataRequest> request);
  DescribeVodTranscodeDataResponse describeVodTranscodeDataWithOptions(shared_ptr<DescribeVodTranscodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodTranscodeDataResponse describeVodTranscodeData(shared_ptr<DescribeVodTranscodeDataRequest> request);
  DescribeVodUserDomainsResponse describeVodUserDomainsWithOptions(shared_ptr<DescribeVodUserDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodUserDomainsResponse describeVodUserDomains(shared_ptr<DescribeVodUserDomainsRequest> request);
  DescribeVodVerifyContentResponse describeVodVerifyContentWithOptions(shared_ptr<DescribeVodVerifyContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVodVerifyContentResponse describeVodVerifyContent(shared_ptr<DescribeVodVerifyContentRequest> request);
  DetachAppPolicyFromIdentityResponse detachAppPolicyFromIdentityWithOptions(shared_ptr<DetachAppPolicyFromIdentityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachAppPolicyFromIdentityResponse detachAppPolicyFromIdentity(shared_ptr<DetachAppPolicyFromIdentityRequest> request);
  GenerateDownloadSecretKeyResponse generateDownloadSecretKeyWithOptions(shared_ptr<GenerateDownloadSecretKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateDownloadSecretKeyResponse generateDownloadSecretKey(shared_ptr<GenerateDownloadSecretKeyRequest> request);
  GenerateKMSDataKeyResponse generateKMSDataKeyWithOptions(shared_ptr<GenerateKMSDataKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateKMSDataKeyResponse generateKMSDataKey(shared_ptr<GenerateKMSDataKeyRequest> request);
  GetAIImageJobsResponse getAIImageJobsWithOptions(shared_ptr<GetAIImageJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAIImageJobsResponse getAIImageJobs(shared_ptr<GetAIImageJobsRequest> request);
  GetAIMediaAuditJobResponse getAIMediaAuditJobWithOptions(shared_ptr<GetAIMediaAuditJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAIMediaAuditJobResponse getAIMediaAuditJob(shared_ptr<GetAIMediaAuditJobRequest> request);
  GetAITemplateResponse getAITemplateWithOptions(shared_ptr<GetAITemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAITemplateResponse getAITemplate(shared_ptr<GetAITemplateRequest> request);
  GetAIVideoTagResultResponse getAIVideoTagResultWithOptions(shared_ptr<GetAIVideoTagResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAIVideoTagResultResponse getAIVideoTagResult(shared_ptr<GetAIVideoTagResultRequest> request);
  GetAppInfosResponse getAppInfosWithOptions(shared_ptr<GetAppInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAppInfosResponse getAppInfos(shared_ptr<GetAppInfosRequest> request);
  GetAttachedMediaInfoResponse getAttachedMediaInfoWithOptions(shared_ptr<GetAttachedMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAttachedMediaInfoResponse getAttachedMediaInfo(shared_ptr<GetAttachedMediaInfoRequest> request);
  GetAuditHistoryResponse getAuditHistoryWithOptions(shared_ptr<GetAuditHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAuditHistoryResponse getAuditHistory(shared_ptr<GetAuditHistoryRequest> request);
  GetCategoriesResponse getCategoriesWithOptions(shared_ptr<GetCategoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCategoriesResponse getCategories(shared_ptr<GetCategoriesRequest> request);
  GetDefaultAITemplateResponse getDefaultAITemplateWithOptions(shared_ptr<GetDefaultAITemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDefaultAITemplateResponse getDefaultAITemplate(shared_ptr<GetDefaultAITemplateRequest> request);
  GetDigitalWatermarkExtractResultResponse getDigitalWatermarkExtractResultWithOptions(shared_ptr<GetDigitalWatermarkExtractResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDigitalWatermarkExtractResultResponse getDigitalWatermarkExtractResult(shared_ptr<GetDigitalWatermarkExtractResultRequest> request);
  GetEditingProjectResponse getEditingProjectWithOptions(shared_ptr<GetEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEditingProjectResponse getEditingProject(shared_ptr<GetEditingProjectRequest> request);
  GetEditingProjectMaterialsResponse getEditingProjectMaterialsWithOptions(shared_ptr<GetEditingProjectMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEditingProjectMaterialsResponse getEditingProjectMaterials(shared_ptr<GetEditingProjectMaterialsRequest> request);
  GetImageInfoResponse getImageInfoWithOptions(shared_ptr<GetImageInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetImageInfoResponse getImageInfo(shared_ptr<GetImageInfoRequest> request);
  GetImageInfosResponse getImageInfosWithOptions(shared_ptr<GetImageInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetImageInfosResponse getImageInfos(shared_ptr<GetImageInfosRequest> request);
  GetMediaAuditAudioResultDetailResponse getMediaAuditAudioResultDetailWithOptions(shared_ptr<GetMediaAuditAudioResultDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaAuditAudioResultDetailResponse getMediaAuditAudioResultDetail(shared_ptr<GetMediaAuditAudioResultDetailRequest> request);
  GetMediaAuditResultResponse getMediaAuditResultWithOptions(shared_ptr<GetMediaAuditResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaAuditResultResponse getMediaAuditResult(shared_ptr<GetMediaAuditResultRequest> request);
  GetMediaAuditResultDetailResponse getMediaAuditResultDetailWithOptions(shared_ptr<GetMediaAuditResultDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaAuditResultDetailResponse getMediaAuditResultDetail(shared_ptr<GetMediaAuditResultDetailRequest> request);
  GetMediaAuditResultTimelineResponse getMediaAuditResultTimelineWithOptions(shared_ptr<GetMediaAuditResultTimelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaAuditResultTimelineResponse getMediaAuditResultTimeline(shared_ptr<GetMediaAuditResultTimelineRequest> request);
  GetMediaDNAResultResponse getMediaDNAResultWithOptions(shared_ptr<GetMediaDNAResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaDNAResultResponse getMediaDNAResult(shared_ptr<GetMediaDNAResultRequest> request);
  GetMediaRefreshJobsResponse getMediaRefreshJobsWithOptions(shared_ptr<GetMediaRefreshJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaRefreshJobsResponse getMediaRefreshJobs(shared_ptr<GetMediaRefreshJobsRequest> request);
  GetMessageCallbackResponse getMessageCallbackWithOptions(shared_ptr<GetMessageCallbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMessageCallbackResponse getMessageCallback(shared_ptr<GetMessageCallbackRequest> request);
  GetMezzanineInfoResponse getMezzanineInfoWithOptions(shared_ptr<GetMezzanineInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMezzanineInfoResponse getMezzanineInfo(shared_ptr<GetMezzanineInfoRequest> request);
  GetPlayInfoResponse getPlayInfoWithOptions(shared_ptr<GetPlayInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPlayInfoResponse getPlayInfo(shared_ptr<GetPlayInfoRequest> request);
  GetTranscodeSummaryResponse getTranscodeSummaryWithOptions(shared_ptr<GetTranscodeSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTranscodeSummaryResponse getTranscodeSummary(shared_ptr<GetTranscodeSummaryRequest> request);
  GetTranscodeTaskResponse getTranscodeTaskWithOptions(shared_ptr<GetTranscodeTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTranscodeTaskResponse getTranscodeTask(shared_ptr<GetTranscodeTaskRequest> request);
  GetTranscodeTemplateGroupResponse getTranscodeTemplateGroupWithOptions(shared_ptr<GetTranscodeTemplateGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTranscodeTemplateGroupResponse getTranscodeTemplateGroup(shared_ptr<GetTranscodeTemplateGroupRequest> request);
  GetURLUploadInfosResponse getURLUploadInfosWithOptions(shared_ptr<GetURLUploadInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetURLUploadInfosResponse getURLUploadInfos(shared_ptr<GetURLUploadInfosRequest> request);
  GetUploadDetailsResponse getUploadDetailsWithOptions(shared_ptr<GetUploadDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUploadDetailsResponse getUploadDetails(shared_ptr<GetUploadDetailsRequest> request);
  GetVideoInfoResponse getVideoInfoWithOptions(shared_ptr<GetVideoInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVideoInfoResponse getVideoInfo(shared_ptr<GetVideoInfoRequest> request);
  GetVideoInfosResponse getVideoInfosWithOptions(shared_ptr<GetVideoInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVideoInfosResponse getVideoInfos(shared_ptr<GetVideoInfosRequest> request);
  GetVideoListResponse getVideoListWithOptions(shared_ptr<GetVideoListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVideoListResponse getVideoList(shared_ptr<GetVideoListRequest> request);
  GetVideoPlayAuthResponse getVideoPlayAuthWithOptions(shared_ptr<GetVideoPlayAuthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVideoPlayAuthResponse getVideoPlayAuth(shared_ptr<GetVideoPlayAuthRequest> request);
  GetVodTemplateResponse getVodTemplateWithOptions(shared_ptr<GetVodTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVodTemplateResponse getVodTemplate(shared_ptr<GetVodTemplateRequest> request);
  GetWatermarkResponse getWatermarkWithOptions(shared_ptr<GetWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWatermarkResponse getWatermark(shared_ptr<GetWatermarkRequest> request);
  ListAIImageInfoResponse listAIImageInfoWithOptions(shared_ptr<ListAIImageInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAIImageInfoResponse listAIImageInfo(shared_ptr<ListAIImageInfoRequest> request);
  ListAIJobResponse listAIJobWithOptions(shared_ptr<ListAIJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAIJobResponse listAIJob(shared_ptr<ListAIJobRequest> request);
  ListAITemplateResponse listAITemplateWithOptions(shared_ptr<ListAITemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAITemplateResponse listAITemplate(shared_ptr<ListAITemplateRequest> request);
  ListAppInfoResponse listAppInfoWithOptions(shared_ptr<ListAppInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppInfoResponse listAppInfo(shared_ptr<ListAppInfoRequest> request);
  ListAppPoliciesForIdentityResponse listAppPoliciesForIdentityWithOptions(shared_ptr<ListAppPoliciesForIdentityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppPoliciesForIdentityResponse listAppPoliciesForIdentity(shared_ptr<ListAppPoliciesForIdentityRequest> request);
  ListAuditSecurityIpResponse listAuditSecurityIpWithOptions(shared_ptr<ListAuditSecurityIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAuditSecurityIpResponse listAuditSecurityIp(shared_ptr<ListAuditSecurityIpRequest> request);
  ListDynamicImageResponse listDynamicImageWithOptions(shared_ptr<ListDynamicImageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDynamicImageResponse listDynamicImage(shared_ptr<ListDynamicImageRequest> request);
  ListLiveRecordVideoResponse listLiveRecordVideoWithOptions(shared_ptr<ListLiveRecordVideoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRecordVideoResponse listLiveRecordVideo(shared_ptr<ListLiveRecordVideoRequest> request);
  ListSnapshotsResponse listSnapshotsWithOptions(shared_ptr<ListSnapshotsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSnapshotsResponse listSnapshots(shared_ptr<ListSnapshotsRequest> request);
  ListTranscodeTaskResponse listTranscodeTaskWithOptions(shared_ptr<ListTranscodeTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTranscodeTaskResponse listTranscodeTask(shared_ptr<ListTranscodeTaskRequest> request);
  ListTranscodeTemplateGroupResponse listTranscodeTemplateGroupWithOptions(shared_ptr<ListTranscodeTemplateGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTranscodeTemplateGroupResponse listTranscodeTemplateGroup(shared_ptr<ListTranscodeTemplateGroupRequest> request);
  ListVodTemplateResponse listVodTemplateWithOptions(shared_ptr<ListVodTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVodTemplateResponse listVodTemplate(shared_ptr<ListVodTemplateRequest> request);
  ListWatermarkResponse listWatermarkWithOptions(shared_ptr<ListWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWatermarkResponse listWatermark(shared_ptr<ListWatermarkRequest> request);
  MoveAppResourceResponse moveAppResourceWithOptions(shared_ptr<MoveAppResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveAppResourceResponse moveAppResource(shared_ptr<MoveAppResourceRequest> request);
  PreloadVodObjectCachesResponse preloadVodObjectCachesWithOptions(shared_ptr<PreloadVodObjectCachesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PreloadVodObjectCachesResponse preloadVodObjectCaches(shared_ptr<PreloadVodObjectCachesRequest> request);
  ProduceEditingProjectVideoResponse produceEditingProjectVideoWithOptions(shared_ptr<ProduceEditingProjectVideoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProduceEditingProjectVideoResponse produceEditingProjectVideo(shared_ptr<ProduceEditingProjectVideoRequest> request);
  RefreshMediaPlayUrlsResponse refreshMediaPlayUrlsWithOptions(shared_ptr<RefreshMediaPlayUrlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshMediaPlayUrlsResponse refreshMediaPlayUrls(shared_ptr<RefreshMediaPlayUrlsRequest> request);
  RefreshUploadVideoResponse refreshUploadVideoWithOptions(shared_ptr<RefreshUploadVideoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshUploadVideoResponse refreshUploadVideo(shared_ptr<RefreshUploadVideoRequest> request);
  RefreshVodObjectCachesResponse refreshVodObjectCachesWithOptions(shared_ptr<RefreshVodObjectCachesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshVodObjectCachesResponse refreshVodObjectCaches(shared_ptr<RefreshVodObjectCachesRequest> request);
  RegisterMediaResponse registerMediaWithOptions(shared_ptr<RegisterMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterMediaResponse registerMedia(shared_ptr<RegisterMediaRequest> request);
  RestoreMediaResponse restoreMediaWithOptions(shared_ptr<RestoreMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestoreMediaResponse restoreMedia(shared_ptr<RestoreMediaRequest> request);
  SearchEditingProjectResponse searchEditingProjectWithOptions(shared_ptr<SearchEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchEditingProjectResponse searchEditingProject(shared_ptr<SearchEditingProjectRequest> request);
  SearchMediaResponse searchMediaWithOptions(shared_ptr<SearchMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaResponse searchMedia(shared_ptr<SearchMediaRequest> request);
  SetAuditSecurityIpResponse setAuditSecurityIpWithOptions(shared_ptr<SetAuditSecurityIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetAuditSecurityIpResponse setAuditSecurityIp(shared_ptr<SetAuditSecurityIpRequest> request);
  SetCrossdomainContentResponse setCrossdomainContentWithOptions(shared_ptr<SetCrossdomainContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetCrossdomainContentResponse setCrossdomainContent(shared_ptr<SetCrossdomainContentRequest> request);
  SetDefaultAITemplateResponse setDefaultAITemplateWithOptions(shared_ptr<SetDefaultAITemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDefaultAITemplateResponse setDefaultAITemplate(shared_ptr<SetDefaultAITemplateRequest> request);
  SetDefaultTranscodeTemplateGroupResponse setDefaultTranscodeTemplateGroupWithOptions(shared_ptr<SetDefaultTranscodeTemplateGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDefaultTranscodeTemplateGroupResponse setDefaultTranscodeTemplateGroup(shared_ptr<SetDefaultTranscodeTemplateGroupRequest> request);
  SetDefaultWatermarkResponse setDefaultWatermarkWithOptions(shared_ptr<SetDefaultWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDefaultWatermarkResponse setDefaultWatermark(shared_ptr<SetDefaultWatermarkRequest> request);
  SetEditingProjectMaterialsResponse setEditingProjectMaterialsWithOptions(shared_ptr<SetEditingProjectMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetEditingProjectMaterialsResponse setEditingProjectMaterials(shared_ptr<SetEditingProjectMaterialsRequest> request);
  SetMessageCallbackResponse setMessageCallbackWithOptions(shared_ptr<SetMessageCallbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetMessageCallbackResponse setMessageCallback(shared_ptr<SetMessageCallbackRequest> request);
  SetVodDomainCertificateResponse setVodDomainCertificateWithOptions(shared_ptr<SetVodDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetVodDomainCertificateResponse setVodDomainCertificate(shared_ptr<SetVodDomainCertificateRequest> request);
  SubmitAIImageAuditJobResponse submitAIImageAuditJobWithOptions(shared_ptr<SubmitAIImageAuditJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAIImageAuditJobResponse submitAIImageAuditJob(shared_ptr<SubmitAIImageAuditJobRequest> request);
  SubmitAIImageJobResponse submitAIImageJobWithOptions(shared_ptr<SubmitAIImageJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAIImageJobResponse submitAIImageJob(shared_ptr<SubmitAIImageJobRequest> request);
  SubmitAIJobResponse submitAIJobWithOptions(shared_ptr<SubmitAIJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAIJobResponse submitAIJob(shared_ptr<SubmitAIJobRequest> request);
  SubmitAIMediaAuditJobResponse submitAIMediaAuditJobWithOptions(shared_ptr<SubmitAIMediaAuditJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAIMediaAuditJobResponse submitAIMediaAuditJob(shared_ptr<SubmitAIMediaAuditJobRequest> request);
  SubmitDigitalWatermarkExtractJobResponse submitDigitalWatermarkExtractJobWithOptions(shared_ptr<SubmitDigitalWatermarkExtractJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitDigitalWatermarkExtractJobResponse submitDigitalWatermarkExtractJob(shared_ptr<SubmitDigitalWatermarkExtractJobRequest> request);
  SubmitDynamicImageJobResponse submitDynamicImageJobWithOptions(shared_ptr<SubmitDynamicImageJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitDynamicImageJobResponse submitDynamicImageJob(shared_ptr<SubmitDynamicImageJobRequest> request);
  SubmitMediaDNADeleteJobResponse submitMediaDNADeleteJobWithOptions(shared_ptr<SubmitMediaDNADeleteJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaDNADeleteJobResponse submitMediaDNADeleteJob(shared_ptr<SubmitMediaDNADeleteJobRequest> request);
  SubmitPreprocessJobsResponse submitPreprocessJobsWithOptions(shared_ptr<SubmitPreprocessJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitPreprocessJobsResponse submitPreprocessJobs(shared_ptr<SubmitPreprocessJobsRequest> request);
  SubmitSnapshotJobResponse submitSnapshotJobWithOptions(shared_ptr<SubmitSnapshotJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSnapshotJobResponse submitSnapshotJob(shared_ptr<SubmitSnapshotJobRequest> request);
  SubmitTranscodeJobsResponse submitTranscodeJobsWithOptions(shared_ptr<SubmitTranscodeJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTranscodeJobsResponse submitTranscodeJobs(shared_ptr<SubmitTranscodeJobsRequest> request);
  SubmitWorkflowJobResponse submitWorkflowJobWithOptions(shared_ptr<SubmitWorkflowJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitWorkflowJobResponse submitWorkflowJob(shared_ptr<SubmitWorkflowJobRequest> request);
  UpdateAITemplateResponse updateAITemplateWithOptions(shared_ptr<UpdateAITemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAITemplateResponse updateAITemplate(shared_ptr<UpdateAITemplateRequest> request);
  UpdateAppInfoResponse updateAppInfoWithOptions(shared_ptr<UpdateAppInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAppInfoResponse updateAppInfo(shared_ptr<UpdateAppInfoRequest> request);
  UpdateAttachedMediaInfosResponse updateAttachedMediaInfosWithOptions(shared_ptr<UpdateAttachedMediaInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAttachedMediaInfosResponse updateAttachedMediaInfos(shared_ptr<UpdateAttachedMediaInfosRequest> request);
  UpdateCategoryResponse updateCategoryWithOptions(shared_ptr<UpdateCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCategoryResponse updateCategory(shared_ptr<UpdateCategoryRequest> request);
  UpdateEditingProjectResponse updateEditingProjectWithOptions(shared_ptr<UpdateEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEditingProjectResponse updateEditingProject(shared_ptr<UpdateEditingProjectRequest> request);
  UpdateImageInfosResponse updateImageInfosWithOptions(shared_ptr<UpdateImageInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateImageInfosResponse updateImageInfos(shared_ptr<UpdateImageInfosRequest> request);
  UpdateMediaStorageClassResponse updateMediaStorageClassWithOptions(shared_ptr<UpdateMediaStorageClassRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaStorageClassResponse updateMediaStorageClass(shared_ptr<UpdateMediaStorageClassRequest> request);
  UpdateTranscodeTemplateGroupResponse updateTranscodeTemplateGroupWithOptions(shared_ptr<UpdateTranscodeTemplateGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTranscodeTemplateGroupResponse updateTranscodeTemplateGroup(shared_ptr<UpdateTranscodeTemplateGroupRequest> request);
  UpdateVideoInfoResponse updateVideoInfoWithOptions(shared_ptr<UpdateVideoInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVideoInfoResponse updateVideoInfo(shared_ptr<UpdateVideoInfoRequest> request);
  UpdateVideoInfosResponse updateVideoInfosWithOptions(shared_ptr<UpdateVideoInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVideoInfosResponse updateVideoInfos(shared_ptr<UpdateVideoInfosRequest> request);
  UpdateVodDomainResponse updateVodDomainWithOptions(shared_ptr<UpdateVodDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVodDomainResponse updateVodDomain(shared_ptr<UpdateVodDomainRequest> request);
  UpdateVodTemplateResponse updateVodTemplateWithOptions(shared_ptr<UpdateVodTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVodTemplateResponse updateVodTemplate(shared_ptr<UpdateVodTemplateRequest> request);
  UpdateWatermarkResponse updateWatermarkWithOptions(shared_ptr<UpdateWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWatermarkResponse updateWatermark(shared_ptr<UpdateWatermarkRequest> request);
  UploadMediaByURLResponse uploadMediaByURLWithOptions(shared_ptr<UploadMediaByURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadMediaByURLResponse uploadMediaByURL(shared_ptr<UploadMediaByURLRequest> request);
  UploadStreamByURLResponse uploadStreamByURLWithOptions(shared_ptr<UploadStreamByURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadStreamByURLResponse uploadStreamByURL(shared_ptr<UploadStreamByURLRequest> request);
  VerifyVodDomainOwnerResponse verifyVodDomainOwnerWithOptions(shared_ptr<VerifyVodDomainOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyVodDomainOwnerResponse verifyVodDomainOwner(shared_ptr<VerifyVodDomainOwnerRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Vod20170321

#endif
