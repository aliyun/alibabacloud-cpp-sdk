// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DATAWORKS-PUBLIC20200518_H_
#define ALIBABACLOUD_DATAWORKS-PUBLIC20200518_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Dataworks-public20200518 {
class AbolishDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};

  AbolishDataServiceApiRequest() {}

  explicit AbolishDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
  }


  virtual ~AbolishDataServiceApiRequest() = default;
};
class AbolishDataServiceApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  AbolishDataServiceApiResponseBody() {}

  explicit AbolishDataServiceApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AbolishDataServiceApiResponseBody() = default;
};
class AbolishDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AbolishDataServiceApiResponseBody> body{};

  AbolishDataServiceApiResponse() {}

  explicit AbolishDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbolishDataServiceApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbolishDataServiceApiResponseBody>(model1);
      }
    }
  }


  virtual ~AbolishDataServiceApiResponse() = default;
};
class AddProjectMemberToRoleRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> roleCode{};
  shared_ptr<string> clientToken{};

  AddProjectMemberToRoleRequest() {}

  explicit AddProjectMemberToRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~AddProjectMemberToRoleRequest() = default;
};
class AddProjectMemberToRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddProjectMemberToRoleResponseBody() {}

  explicit AddProjectMemberToRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddProjectMemberToRoleResponseBody() = default;
};
class AddProjectMemberToRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddProjectMemberToRoleResponseBody> body{};

  AddProjectMemberToRoleResponse() {}

  explicit AddProjectMemberToRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddProjectMemberToRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddProjectMemberToRoleResponseBody>(model1);
      }
    }
  }


  virtual ~AddProjectMemberToRoleResponse() = default;
};
class AddToMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};
  shared_ptr<string> tableGuid{};

  AddToMetaCategoryRequest() {}

  explicit AddToMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~AddToMetaCategoryRequest() = default;
};
class AddToMetaCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  AddToMetaCategoryResponseBody() {}

  explicit AddToMetaCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddToMetaCategoryResponseBody() = default;
};
class AddToMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddToMetaCategoryResponseBody> body{};

  AddToMetaCategoryResponse() {}

  explicit AddToMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddToMetaCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddToMetaCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~AddToMetaCategoryResponse() = default;
};
class ApprovePermissionApplyOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> approveComment{};
  shared_ptr<long> approveAction{};

  ApprovePermissionApplyOrderRequest() {}

  explicit ApprovePermissionApplyOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (approveComment) {
      res["ApproveComment"] = boost::any(*approveComment);
    }
    if (approveAction) {
      res["ApproveAction"] = boost::any(*approveAction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("ApproveComment") != m.end() && !m["ApproveComment"].empty()) {
      approveComment = make_shared<string>(boost::any_cast<string>(m["ApproveComment"]));
    }
    if (m.find("ApproveAction") != m.end() && !m["ApproveAction"].empty()) {
      approveAction = make_shared<long>(boost::any_cast<long>(m["ApproveAction"]));
    }
  }


  virtual ~ApprovePermissionApplyOrderRequest() = default;
};
class ApprovePermissionApplyOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> approveSuccess{};
  shared_ptr<string> requestId{};

  ApprovePermissionApplyOrderResponseBody() {}

  explicit ApprovePermissionApplyOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approveSuccess) {
      res["ApproveSuccess"] = boost::any(*approveSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApproveSuccess") != m.end() && !m["ApproveSuccess"].empty()) {
      approveSuccess = make_shared<bool>(boost::any_cast<bool>(m["ApproveSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ApprovePermissionApplyOrderResponseBody() = default;
};
class ApprovePermissionApplyOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ApprovePermissionApplyOrderResponseBody> body{};

  ApprovePermissionApplyOrderResponse() {}

  explicit ApprovePermissionApplyOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApprovePermissionApplyOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApprovePermissionApplyOrderResponseBody>(model1);
      }
    }
  }


  virtual ~ApprovePermissionApplyOrderResponse() = default;
};
class CheckFileDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkerInstanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> checkDetailUrl{};

  CheckFileDeploymentRequest() {}

  explicit CheckFileDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkerInstanceId) {
      res["CheckerInstanceId"] = boost::any(*checkerInstanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (checkDetailUrl) {
      res["CheckDetailUrl"] = boost::any(*checkDetailUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckerInstanceId") != m.end() && !m["CheckerInstanceId"].empty()) {
      checkerInstanceId = make_shared<string>(boost::any_cast<string>(m["CheckerInstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CheckDetailUrl") != m.end() && !m["CheckDetailUrl"].empty()) {
      checkDetailUrl = make_shared<string>(boost::any_cast<string>(m["CheckDetailUrl"]));
    }
  }


  virtual ~CheckFileDeploymentRequest() = default;
};
class CheckFileDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CheckFileDeploymentResponseBody() {}

  explicit CheckFileDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckFileDeploymentResponseBody() = default;
};
class CheckFileDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckFileDeploymentResponseBody> body{};

  CheckFileDeploymentResponse() {}

  explicit CheckFileDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckFileDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckFileDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~CheckFileDeploymentResponse() = default;
};
class CheckMetaPartitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> partition{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  CheckMetaPartitionRequest() {}

  explicit CheckMetaPartitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (partition) {
      res["Partition"] = boost::any(*partition);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Partition") != m.end() && !m["Partition"].empty()) {
      partition = make_shared<string>(boost::any_cast<string>(m["Partition"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~CheckMetaPartitionRequest() = default;
};
class CheckMetaPartitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  CheckMetaPartitionResponseBody() {}

  explicit CheckMetaPartitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckMetaPartitionResponseBody() = default;
};
class CheckMetaPartitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckMetaPartitionResponseBody> body{};

  CheckMetaPartitionResponse() {}

  explicit CheckMetaPartitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckMetaPartitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckMetaPartitionResponseBody>(model1);
      }
    }
  }


  virtual ~CheckMetaPartitionResponse() = default;
};
class CheckMetaTableRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  CheckMetaTableRequest() {}

  explicit CheckMetaTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~CheckMetaTableRequest() = default;
};
class CheckMetaTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};

  CheckMetaTableResponseBody() {}

  explicit CheckMetaTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckMetaTableResponseBody() = default;
};
class CheckMetaTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckMetaTableResponseBody> body{};

  CheckMetaTableResponse() {}

  explicit CheckMetaTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckMetaTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckMetaTableResponseBody>(model1);
      }
    }
  }


  virtual ~CheckMetaTableResponse() = default;
};
class CreateBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> businessName{};
  shared_ptr<string> description{};
  shared_ptr<string> owner{};
  shared_ptr<string> useType{};

  CreateBusinessRequest() {}

  explicit CreateBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~CreateBusinessRequest() = default;
};
class CreateBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<long> businessId{};

  CreateBusinessResponseBody() {}

  explicit CreateBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~CreateBusinessResponseBody() = default;
};
class CreateBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateBusinessResponseBody> body{};

  CreateBusinessResponse() {}

  explicit CreateBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBusinessResponse() = default;
};
class CreateConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> connectionType{};
  shared_ptr<string> subType{};
  shared_ptr<long> envType{};
  shared_ptr<string> content{};

  CreateConnectionRequest() {}

  explicit CreateConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (connectionType) {
      res["ConnectionType"] = boost::any(*connectionType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ConnectionType") != m.end() && !m["ConnectionType"].empty()) {
      connectionType = make_shared<string>(boost::any_cast<string>(m["ConnectionType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~CreateConnectionRequest() = default;
};
class CreateConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateConnectionResponseBody() {}

  explicit CreateConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateConnectionResponseBody() = default;
};
class CreateConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateConnectionResponseBody> body{};

  CreateConnectionResponse() {}

  explicit CreateConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConnectionResponse() = default;
};
class CreateDagComplementRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> startBizDate{};
  shared_ptr<string> name{};
  shared_ptr<long> rootNodeId{};
  shared_ptr<string> includeNodeIds{};
  shared_ptr<string> excludeNodeIds{};
  shared_ptr<string> bizBeginTime{};
  shared_ptr<string> bizEndTime{};
  shared_ptr<bool> parallelism{};
  shared_ptr<string> endBizDate{};
  shared_ptr<string> nodeParams{};

  CreateDagComplementRequest() {}

  explicit CreateDagComplementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (startBizDate) {
      res["StartBizDate"] = boost::any(*startBizDate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (includeNodeIds) {
      res["IncludeNodeIds"] = boost::any(*includeNodeIds);
    }
    if (excludeNodeIds) {
      res["ExcludeNodeIds"] = boost::any(*excludeNodeIds);
    }
    if (bizBeginTime) {
      res["BizBeginTime"] = boost::any(*bizBeginTime);
    }
    if (bizEndTime) {
      res["BizEndTime"] = boost::any(*bizEndTime);
    }
    if (parallelism) {
      res["Parallelism"] = boost::any(*parallelism);
    }
    if (endBizDate) {
      res["EndBizDate"] = boost::any(*endBizDate);
    }
    if (nodeParams) {
      res["NodeParams"] = boost::any(*nodeParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("StartBizDate") != m.end() && !m["StartBizDate"].empty()) {
      startBizDate = make_shared<string>(boost::any_cast<string>(m["StartBizDate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<long>(boost::any_cast<long>(m["RootNodeId"]));
    }
    if (m.find("IncludeNodeIds") != m.end() && !m["IncludeNodeIds"].empty()) {
      includeNodeIds = make_shared<string>(boost::any_cast<string>(m["IncludeNodeIds"]));
    }
    if (m.find("ExcludeNodeIds") != m.end() && !m["ExcludeNodeIds"].empty()) {
      excludeNodeIds = make_shared<string>(boost::any_cast<string>(m["ExcludeNodeIds"]));
    }
    if (m.find("BizBeginTime") != m.end() && !m["BizBeginTime"].empty()) {
      bizBeginTime = make_shared<string>(boost::any_cast<string>(m["BizBeginTime"]));
    }
    if (m.find("BizEndTime") != m.end() && !m["BizEndTime"].empty()) {
      bizEndTime = make_shared<string>(boost::any_cast<string>(m["BizEndTime"]));
    }
    if (m.find("Parallelism") != m.end() && !m["Parallelism"].empty()) {
      parallelism = make_shared<bool>(boost::any_cast<bool>(m["Parallelism"]));
    }
    if (m.find("EndBizDate") != m.end() && !m["EndBizDate"].empty()) {
      endBizDate = make_shared<string>(boost::any_cast<string>(m["EndBizDate"]));
    }
    if (m.find("NodeParams") != m.end() && !m["NodeParams"].empty()) {
      nodeParams = make_shared<string>(boost::any_cast<string>(m["NodeParams"]));
    }
  }


  virtual ~CreateDagComplementRequest() = default;
};
class CreateDagComplementResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<vector<long>> data{};

  CreateDagComplementResponseBody() {}

  explicit CreateDagComplementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      data = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateDagComplementResponseBody() = default;
};
class CreateDagComplementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDagComplementResponseBody> body{};

  CreateDagComplementResponse() {}

  explicit CreateDagComplementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDagComplementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDagComplementResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDagComplementResponse() = default;
};
class CreateDagTestRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> bizdate{};
  shared_ptr<string> name{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeParams{};

  CreateDagTestRequest() {}

  explicit CreateDagTestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeParams) {
      res["NodeParams"] = boost::any(*nodeParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeParams") != m.end() && !m["NodeParams"].empty()) {
      nodeParams = make_shared<string>(boost::any_cast<string>(m["NodeParams"]));
    }
  }


  virtual ~CreateDagTestRequest() = default;
};
class CreateDagTestResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  CreateDagTestResponseBody() {}

  explicit CreateDagTestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDagTestResponseBody() = default;
};
class CreateDagTestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDagTestResponseBody> body{};

  CreateDagTestResponse() {}

  explicit CreateDagTestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDagTestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDagTestResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDagTestResponse() = default;
};
class CreateDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> apiMode{};
  shared_ptr<long> requestMethod{};
  shared_ptr<long> responseContentType{};
  shared_ptr<long> timeout{};
  shared_ptr<long> visibleRange{};
  shared_ptr<string> protocols{};
  shared_ptr<string> wizardDetails{};
  shared_ptr<string> scriptDetails{};
  shared_ptr<string> registrationDetails{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> apiDescription{};
  shared_ptr<long> folderId{};

  CreateDataServiceApiRequest() {}

  explicit CreateDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (apiMode) {
      res["ApiMode"] = boost::any(*apiMode);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (wizardDetails) {
      res["WizardDetails"] = boost::any(*wizardDetails);
    }
    if (scriptDetails) {
      res["ScriptDetails"] = boost::any(*scriptDetails);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = boost::any(*registrationDetails);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (apiDescription) {
      res["ApiDescription"] = boost::any(*apiDescription);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ApiMode") != m.end() && !m["ApiMode"].empty()) {
      apiMode = make_shared<long>(boost::any_cast<long>(m["ApiMode"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<long>(boost::any_cast<long>(m["RequestMethod"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<long>(boost::any_cast<long>(m["ResponseContentType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<long>(boost::any_cast<long>(m["VisibleRange"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      protocols = make_shared<string>(boost::any_cast<string>(m["Protocols"]));
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      wizardDetails = make_shared<string>(boost::any_cast<string>(m["WizardDetails"]));
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      scriptDetails = make_shared<string>(boost::any_cast<string>(m["ScriptDetails"]));
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      registrationDetails = make_shared<string>(boost::any_cast<string>(m["RegistrationDetails"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("ApiDescription") != m.end() && !m["ApiDescription"].empty()) {
      apiDescription = make_shared<string>(boost::any_cast<string>(m["ApiDescription"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
  }


  virtual ~CreateDataServiceApiRequest() = default;
};
class CreateDataServiceApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  CreateDataServiceApiResponseBody() {}

  explicit CreateDataServiceApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataServiceApiResponseBody() = default;
};
class CreateDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDataServiceApiResponseBody> body{};

  CreateDataServiceApiResponse() {}

  explicit CreateDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataServiceApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataServiceApiResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataServiceApiResponse() = default;
};
class CreateDataServiceApiAuthorityRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};
  shared_ptr<long> authorizedProjectId{};
  shared_ptr<long> endTime{};

  CreateDataServiceApiAuthorityRequest() {}

  explicit CreateDataServiceApiAuthorityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (authorizedProjectId) {
      res["AuthorizedProjectId"] = boost::any(*authorizedProjectId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("AuthorizedProjectId") != m.end() && !m["AuthorizedProjectId"].empty()) {
      authorizedProjectId = make_shared<long>(boost::any_cast<long>(m["AuthorizedProjectId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~CreateDataServiceApiAuthorityRequest() = default;
};
class CreateDataServiceApiAuthorityResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};

  CreateDataServiceApiAuthorityResponseBody() {}

  explicit CreateDataServiceApiAuthorityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataServiceApiAuthorityResponseBody() = default;
};
class CreateDataServiceApiAuthorityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDataServiceApiAuthorityResponseBody> body{};

  CreateDataServiceApiAuthorityResponse() {}

  explicit CreateDataServiceApiAuthorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataServiceApiAuthorityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataServiceApiAuthorityResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataServiceApiAuthorityResponse() = default;
};
class CreateDataServiceFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> folderName{};
  shared_ptr<long> parentId{};
  shared_ptr<string> groupId{};

  CreateDataServiceFolderRequest() {}

  explicit CreateDataServiceFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~CreateDataServiceFolderRequest() = default;
};
class CreateDataServiceFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> folderId{};
  shared_ptr<string> requestId{};

  CreateDataServiceFolderResponseBody() {}

  explicit CreateDataServiceFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataServiceFolderResponseBody() = default;
};
class CreateDataServiceFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDataServiceFolderResponseBody> body{};

  CreateDataServiceFolderResponse() {}

  explicit CreateDataServiceFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataServiceFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataServiceFolderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataServiceFolderResponse() = default;
};
class CreateDataServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> apiGatewayGroupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> description{};

  CreateDataServiceGroupRequest() {}

  explicit CreateDataServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiGatewayGroupId) {
      res["ApiGatewayGroupId"] = boost::any(*apiGatewayGroupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiGatewayGroupId") != m.end() && !m["ApiGatewayGroupId"].empty()) {
      apiGatewayGroupId = make_shared<string>(boost::any_cast<string>(m["ApiGatewayGroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateDataServiceGroupRequest() = default;
};
class CreateDataServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};

  CreateDataServiceGroupResponseBody() {}

  explicit CreateDataServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDataServiceGroupResponseBody() = default;
};
class CreateDataServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDataServiceGroupResponseBody> body{};

  CreateDataServiceGroupResponse() {}

  explicit CreateDataServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataServiceGroupResponse() = default;
};
class CreateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> subType{};
  shared_ptr<long> envType{};
  shared_ptr<string> content{};

  CreateDataSourceRequest() {}

  explicit CreateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~CreateDataSourceRequest() = default;
};
class CreateDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataSourceResponseBody() {}

  explicit CreateDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataSourceResponseBody() = default;
};
class CreateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDataSourceResponseBody> body{};

  CreateDataSourceResponse() {}

  explicit CreateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataSourceResponse() = default;
};
class CreateFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileDescription{};
  shared_ptr<long> fileType{};
  shared_ptr<string> owner{};
  shared_ptr<string> content{};
  shared_ptr<long> autoRerunTimes{};
  shared_ptr<long> autoRerunIntervalMillis{};
  shared_ptr<string> rerunMode{};
  shared_ptr<bool> stop{};
  shared_ptr<string> paraValue{};
  shared_ptr<long> startEffectDate{};
  shared_ptr<long> endEffectDate{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> cycleType{};
  shared_ptr<string> dependentType{};
  shared_ptr<string> dependentNodeIdList{};
  shared_ptr<string> inputList{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> resourceGroupIdentifier{};
  shared_ptr<long> resourceGroupId{};
  shared_ptr<string> connectionName{};
  shared_ptr<bool> autoParsing{};

  CreateFileRequest() {}

  explicit CreateFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (autoRerunTimes) {
      res["AutoRerunTimes"] = boost::any(*autoRerunTimes);
    }
    if (autoRerunIntervalMillis) {
      res["AutoRerunIntervalMillis"] = boost::any(*autoRerunIntervalMillis);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (stop) {
      res["Stop"] = boost::any(*stop);
    }
    if (paraValue) {
      res["ParaValue"] = boost::any(*paraValue);
    }
    if (startEffectDate) {
      res["StartEffectDate"] = boost::any(*startEffectDate);
    }
    if (endEffectDate) {
      res["EndEffectDate"] = boost::any(*endEffectDate);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (cycleType) {
      res["CycleType"] = boost::any(*cycleType);
    }
    if (dependentType) {
      res["DependentType"] = boost::any(*dependentType);
    }
    if (dependentNodeIdList) {
      res["DependentNodeIdList"] = boost::any(*dependentNodeIdList);
    }
    if (inputList) {
      res["InputList"] = boost::any(*inputList);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("AutoRerunTimes") != m.end() && !m["AutoRerunTimes"].empty()) {
      autoRerunTimes = make_shared<long>(boost::any_cast<long>(m["AutoRerunTimes"]));
    }
    if (m.find("AutoRerunIntervalMillis") != m.end() && !m["AutoRerunIntervalMillis"].empty()) {
      autoRerunIntervalMillis = make_shared<long>(boost::any_cast<long>(m["AutoRerunIntervalMillis"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("Stop") != m.end() && !m["Stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["Stop"]));
    }
    if (m.find("ParaValue") != m.end() && !m["ParaValue"].empty()) {
      paraValue = make_shared<string>(boost::any_cast<string>(m["ParaValue"]));
    }
    if (m.find("StartEffectDate") != m.end() && !m["StartEffectDate"].empty()) {
      startEffectDate = make_shared<long>(boost::any_cast<long>(m["StartEffectDate"]));
    }
    if (m.find("EndEffectDate") != m.end() && !m["EndEffectDate"].empty()) {
      endEffectDate = make_shared<long>(boost::any_cast<long>(m["EndEffectDate"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("CycleType") != m.end() && !m["CycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["CycleType"]));
    }
    if (m.find("DependentType") != m.end() && !m["DependentType"].empty()) {
      dependentType = make_shared<string>(boost::any_cast<string>(m["DependentType"]));
    }
    if (m.find("DependentNodeIdList") != m.end() && !m["DependentNodeIdList"].empty()) {
      dependentNodeIdList = make_shared<string>(boost::any_cast<string>(m["DependentNodeIdList"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      inputList = make_shared<string>(boost::any_cast<string>(m["InputList"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<long>(boost::any_cast<long>(m["ResourceGroupId"]));
    }
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
  }


  virtual ~CreateFileRequest() = default;
};
class CreateFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  CreateFileResponseBody() {}

  explicit CreateFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~CreateFileResponseBody() = default;
};
class CreateFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFileResponseBody> body{};

  CreateFileResponse() {}

  explicit CreateFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFileResponse() = default;
};
class CreateFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> folderPath{};

  CreateFolderRequest() {}

  explicit CreateFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
  }


  virtual ~CreateFolderRequest() = default;
};
class CreateFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  CreateFolderResponseBody() {}

  explicit CreateFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~CreateFolderResponseBody() = default;
};
class CreateFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFolderResponseBody> body{};

  CreateFolderResponse() {}

  explicit CreateFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFolderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFolderResponse() = default;
};
class CreateImportMigrationRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> packageType{};
  shared_ptr<string> packageFile{};
  shared_ptr<string> resourceGroupMap{};
  shared_ptr<string> workspaceMap{};
  shared_ptr<string> calculateEngineMap{};
  shared_ptr<string> commitRule{};
  shared_ptr<string> description{};

  CreateImportMigrationRequest() {}

  explicit CreateImportMigrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (packageFile) {
      res["PackageFile"] = boost::any(*packageFile);
    }
    if (resourceGroupMap) {
      res["ResourceGroupMap"] = boost::any(*resourceGroupMap);
    }
    if (workspaceMap) {
      res["WorkspaceMap"] = boost::any(*workspaceMap);
    }
    if (calculateEngineMap) {
      res["CalculateEngineMap"] = boost::any(*calculateEngineMap);
    }
    if (commitRule) {
      res["CommitRule"] = boost::any(*commitRule);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("PackageFile") != m.end() && !m["PackageFile"].empty()) {
      packageFile = make_shared<string>(boost::any_cast<string>(m["PackageFile"]));
    }
    if (m.find("ResourceGroupMap") != m.end() && !m["ResourceGroupMap"].empty()) {
      resourceGroupMap = make_shared<string>(boost::any_cast<string>(m["ResourceGroupMap"]));
    }
    if (m.find("WorkspaceMap") != m.end() && !m["WorkspaceMap"].empty()) {
      workspaceMap = make_shared<string>(boost::any_cast<string>(m["WorkspaceMap"]));
    }
    if (m.find("CalculateEngineMap") != m.end() && !m["CalculateEngineMap"].empty()) {
      calculateEngineMap = make_shared<string>(boost::any_cast<string>(m["CalculateEngineMap"]));
    }
    if (m.find("CommitRule") != m.end() && !m["CommitRule"].empty()) {
      commitRule = make_shared<string>(boost::any_cast<string>(m["CommitRule"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateImportMigrationRequest() = default;
};
class CreateImportMigrationAdvanceRequest : public Darabonba::Model {
public:
  shared_ptr<Darabonba::Stream> packageFileObject{};
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> packageType{};
  shared_ptr<string> resourceGroupMap{};
  shared_ptr<string> workspaceMap{};
  shared_ptr<string> calculateEngineMap{};
  shared_ptr<string> commitRule{};
  shared_ptr<string> description{};

  CreateImportMigrationAdvanceRequest() {}

  explicit CreateImportMigrationAdvanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!packageFileObject) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("packageFileObject is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageFileObject) {
      res["PackageFileObject"] = boost::any(*packageFileObject);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (packageType) {
      res["PackageType"] = boost::any(*packageType);
    }
    if (resourceGroupMap) {
      res["ResourceGroupMap"] = boost::any(*resourceGroupMap);
    }
    if (workspaceMap) {
      res["WorkspaceMap"] = boost::any(*workspaceMap);
    }
    if (calculateEngineMap) {
      res["CalculateEngineMap"] = boost::any(*calculateEngineMap);
    }
    if (commitRule) {
      res["CommitRule"] = boost::any(*commitRule);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageFileObject") != m.end() && !m["PackageFileObject"].empty()) {
      packageFileObject = make_shared<Darabonba::Stream>(boost::any_cast<Darabonba::Stream>(m["PackageFileObject"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PackageType") != m.end() && !m["PackageType"].empty()) {
      packageType = make_shared<string>(boost::any_cast<string>(m["PackageType"]));
    }
    if (m.find("ResourceGroupMap") != m.end() && !m["ResourceGroupMap"].empty()) {
      resourceGroupMap = make_shared<string>(boost::any_cast<string>(m["ResourceGroupMap"]));
    }
    if (m.find("WorkspaceMap") != m.end() && !m["WorkspaceMap"].empty()) {
      workspaceMap = make_shared<string>(boost::any_cast<string>(m["WorkspaceMap"]));
    }
    if (m.find("CalculateEngineMap") != m.end() && !m["CalculateEngineMap"].empty()) {
      calculateEngineMap = make_shared<string>(boost::any_cast<string>(m["CalculateEngineMap"]));
    }
    if (m.find("CommitRule") != m.end() && !m["CommitRule"].empty()) {
      commitRule = make_shared<string>(boost::any_cast<string>(m["CommitRule"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateImportMigrationAdvanceRequest() = default;
};
class CreateImportMigrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  CreateImportMigrationResponseBody() {}

  explicit CreateImportMigrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateImportMigrationResponseBody() = default;
};
class CreateImportMigrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateImportMigrationResponseBody> body{};

  CreateImportMigrationResponse() {}

  explicit CreateImportMigrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImportMigrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImportMigrationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImportMigrationResponse() = default;
};
class CreateManualDagRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> projectName{};
  shared_ptr<string> flowName{};
  shared_ptr<string> bizDate{};
  shared_ptr<string> nodeParameters{};
  shared_ptr<string> dagParameters{};

  CreateManualDagRequest() {}

  explicit CreateManualDagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (nodeParameters) {
      res["NodeParameters"] = boost::any(*nodeParameters);
    }
    if (dagParameters) {
      res["DagParameters"] = boost::any(*dagParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("NodeParameters") != m.end() && !m["NodeParameters"].empty()) {
      nodeParameters = make_shared<string>(boost::any_cast<string>(m["NodeParameters"]));
    }
    if (m.find("DagParameters") != m.end() && !m["DagParameters"].empty()) {
      dagParameters = make_shared<string>(boost::any_cast<string>(m["DagParameters"]));
    }
  }


  virtual ~CreateManualDagRequest() = default;
};
class CreateManualDagResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> requestId{};

  CreateManualDagResponseBody() {}

  explicit CreateManualDagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateManualDagResponseBody() = default;
};
class CreateManualDagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateManualDagResponseBody> body{};

  CreateManualDagResponse() {}

  explicit CreateManualDagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateManualDagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateManualDagResponseBody>(model1);
      }
    }
  }


  virtual ~CreateManualDagResponse() = default;
};
class CreateMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> comment{};
  shared_ptr<long> parentId{};

  CreateMetaCategoryRequest() {}

  explicit CreateMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~CreateMetaCategoryRequest() = default;
};
class CreateMetaCategoryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};

  CreateMetaCategoryResponseBodyData() {}

  explicit CreateMetaCategoryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
  }


  virtual ~CreateMetaCategoryResponseBodyData() = default;
};
class CreateMetaCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<CreateMetaCategoryResponseBodyData> data{};

  CreateMetaCategoryResponseBody() {}

  explicit CreateMetaCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateMetaCategoryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateMetaCategoryResponseBodyData>(model1);
      }
    }
  }


  virtual ~CreateMetaCategoryResponseBody() = default;
};
class CreateMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateMetaCategoryResponseBody> body{};

  CreateMetaCategoryResponse() {}

  explicit CreateMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMetaCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMetaCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMetaCategoryResponse() = default;
};
class CreatePermissionApplyOrderRequestApplyObjectColumnMetaList : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  CreatePermissionApplyOrderRequestApplyObjectColumnMetaList() {}

  explicit CreatePermissionApplyOrderRequestApplyObjectColumnMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreatePermissionApplyOrderRequestApplyObjectColumnMetaList() = default;
};
class CreatePermissionApplyOrderRequestApplyObject : public Darabonba::Model {
public:
  shared_ptr<string> actions{};
  shared_ptr<vector<CreatePermissionApplyOrderRequestApplyObjectColumnMetaList>> columnMetaList{};
  shared_ptr<string> name{};

  CreatePermissionApplyOrderRequestApplyObject() {}

  explicit CreatePermissionApplyOrderRequestApplyObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      res["Actions"] = boost::any(*actions);
    }
    if (columnMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*columnMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnMetaList"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      actions = make_shared<string>(boost::any_cast<string>(m["Actions"]));
    }
    if (m.find("ColumnMetaList") != m.end() && !m["ColumnMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnMetaList"].type()) {
        vector<CreatePermissionApplyOrderRequestApplyObjectColumnMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePermissionApplyOrderRequestApplyObjectColumnMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnMetaList = make_shared<vector<CreatePermissionApplyOrderRequestApplyObjectColumnMetaList>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreatePermissionApplyOrderRequestApplyObject() = default;
};
class CreatePermissionApplyOrderRequest : public Darabonba::Model {
public:
  shared_ptr<string> applyUserIds{};
  shared_ptr<long> deadline{};
  shared_ptr<string> applyReason{};
  shared_ptr<string> maxComputeProjectName{};
  shared_ptr<long> workspaceId{};
  shared_ptr<long> orderType{};
  shared_ptr<string> engineType{};
  shared_ptr<vector<CreatePermissionApplyOrderRequestApplyObject>> applyObject{};

  CreatePermissionApplyOrderRequest() {}

  explicit CreatePermissionApplyOrderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyUserIds) {
      res["ApplyUserIds"] = boost::any(*applyUserIds);
    }
    if (deadline) {
      res["Deadline"] = boost::any(*deadline);
    }
    if (applyReason) {
      res["ApplyReason"] = boost::any(*applyReason);
    }
    if (maxComputeProjectName) {
      res["MaxComputeProjectName"] = boost::any(*maxComputeProjectName);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (engineType) {
      res["EngineType"] = boost::any(*engineType);
    }
    if (applyObject) {
      vector<boost::any> temp1;
      for(auto item1:*applyObject){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyObject"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyUserIds") != m.end() && !m["ApplyUserIds"].empty()) {
      applyUserIds = make_shared<string>(boost::any_cast<string>(m["ApplyUserIds"]));
    }
    if (m.find("Deadline") != m.end() && !m["Deadline"].empty()) {
      deadline = make_shared<long>(boost::any_cast<long>(m["Deadline"]));
    }
    if (m.find("ApplyReason") != m.end() && !m["ApplyReason"].empty()) {
      applyReason = make_shared<string>(boost::any_cast<string>(m["ApplyReason"]));
    }
    if (m.find("MaxComputeProjectName") != m.end() && !m["MaxComputeProjectName"].empty()) {
      maxComputeProjectName = make_shared<string>(boost::any_cast<string>(m["MaxComputeProjectName"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<long>(boost::any_cast<long>(m["WorkspaceId"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<long>(boost::any_cast<long>(m["OrderType"]));
    }
    if (m.find("EngineType") != m.end() && !m["EngineType"].empty()) {
      engineType = make_shared<string>(boost::any_cast<string>(m["EngineType"]));
    }
    if (m.find("ApplyObject") != m.end() && !m["ApplyObject"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyObject"].type()) {
        vector<CreatePermissionApplyOrderRequestApplyObject> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyObject"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePermissionApplyOrderRequestApplyObject model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyObject = make_shared<vector<CreatePermissionApplyOrderRequestApplyObject>>(expect1);
      }
    }
  }


  virtual ~CreatePermissionApplyOrderRequest() = default;
};
class CreatePermissionApplyOrderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> flowId{};

  CreatePermissionApplyOrderResponseBody() {}

  explicit CreatePermissionApplyOrderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FlowId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FlowId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      flowId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreatePermissionApplyOrderResponseBody() = default;
};
class CreatePermissionApplyOrderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreatePermissionApplyOrderResponseBody> body{};

  CreatePermissionApplyOrderResponse() {}

  explicit CreatePermissionApplyOrderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePermissionApplyOrderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePermissionApplyOrderResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePermissionApplyOrderResponse() = default;
};
class CreateProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> roleCode{};

  CreateProjectMemberRequest() {}

  explicit CreateProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
  }


  virtual ~CreateProjectMemberRequest() = default;
};
class CreateProjectMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateProjectMemberResponseBody() {}

  explicit CreateProjectMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProjectMemberResponseBody() = default;
};
class CreateProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateProjectMemberResponseBody> body{};

  CreateProjectMemberResponse() {}

  explicit CreateProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectMemberResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectMemberResponse() = default;
};
class CreateQualityEntityRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> envType{};
  shared_ptr<string> matchExpression{};
  shared_ptr<long> entityLevel{};

  CreateQualityEntityRequest() {}

  explicit CreateQualityEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (entityLevel) {
      res["EntityLevel"] = boost::any(*entityLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("EntityLevel") != m.end() && !m["EntityLevel"].empty()) {
      entityLevel = make_shared<long>(boost::any_cast<long>(m["EntityLevel"]));
    }
  }


  virtual ~CreateQualityEntityRequest() = default;
};
class CreateQualityEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  CreateQualityEntityResponseBody() {}

  explicit CreateQualityEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~CreateQualityEntityResponseBody() = default;
};
class CreateQualityEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateQualityEntityResponseBody> body{};

  CreateQualityEntityResponse() {}

  explicit CreateQualityEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateQualityEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateQualityEntityResponseBody>(model1);
      }
    }
  }


  virtual ~CreateQualityEntityResponse() = default;
};
class CreateQualityFollowerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> follower{};
  shared_ptr<long> alarmMode{};
  shared_ptr<long> entityId{};

  CreateQualityFollowerRequest() {}

  explicit CreateQualityFollowerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (follower) {
      res["Follower"] = boost::any(*follower);
    }
    if (alarmMode) {
      res["AlarmMode"] = boost::any(*alarmMode);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Follower") != m.end() && !m["Follower"].empty()) {
      follower = make_shared<string>(boost::any_cast<string>(m["Follower"]));
    }
    if (m.find("AlarmMode") != m.end() && !m["AlarmMode"].empty()) {
      alarmMode = make_shared<long>(boost::any_cast<long>(m["AlarmMode"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
  }


  virtual ~CreateQualityFollowerRequest() = default;
};
class CreateQualityFollowerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  CreateQualityFollowerResponseBody() {}

  explicit CreateQualityFollowerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateQualityFollowerResponseBody() = default;
};
class CreateQualityFollowerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateQualityFollowerResponseBody> body{};

  CreateQualityFollowerResponse() {}

  explicit CreateQualityFollowerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateQualityFollowerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateQualityFollowerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateQualityFollowerResponse() = default;
};
class CreateQualityRelativeNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<string> matchExpression{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> targetNodeProjectName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> targetNodeProjectId{};

  CreateQualityRelativeNodeRequest() {}

  explicit CreateQualityRelativeNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (targetNodeProjectName) {
      res["TargetNodeProjectName"] = boost::any(*targetNodeProjectName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (targetNodeProjectId) {
      res["TargetNodeProjectId"] = boost::any(*targetNodeProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TargetNodeProjectName") != m.end() && !m["TargetNodeProjectName"].empty()) {
      targetNodeProjectName = make_shared<string>(boost::any_cast<string>(m["TargetNodeProjectName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TargetNodeProjectId") != m.end() && !m["TargetNodeProjectId"].empty()) {
      targetNodeProjectId = make_shared<long>(boost::any_cast<long>(m["TargetNodeProjectId"]));
    }
  }


  virtual ~CreateQualityRelativeNodeRequest() = default;
};
class CreateQualityRelativeNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  CreateQualityRelativeNodeResponseBody() {}

  explicit CreateQualityRelativeNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~CreateQualityRelativeNodeResponseBody() = default;
};
class CreateQualityRelativeNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateQualityRelativeNodeResponseBody> body{};

  CreateQualityRelativeNodeResponse() {}

  explicit CreateQualityRelativeNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateQualityRelativeNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateQualityRelativeNodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateQualityRelativeNodeResponse() = default;
};
class CreateQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> blockType{};
  shared_ptr<long> entityId{};
  shared_ptr<string> comment{};
  shared_ptr<long> checker{};
  shared_ptr<string> expectValue{};
  shared_ptr<string> trend{};
  shared_ptr<string> methodName{};
  shared_ptr<string> operator_{};
  shared_ptr<string> projectName{};
  shared_ptr<string> property{};
  shared_ptr<string> propertyType{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> whereCondition{};
  shared_ptr<string> criticalThreshold{};
  shared_ptr<string> warningThreshold{};
  shared_ptr<long> templateId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> predictType{};

  CreateQualityRuleRequest() {}

  explicit CreateQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (checker) {
      res["Checker"] = boost::any(*checker);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (propertyType) {
      res["PropertyType"] = boost::any(*propertyType);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (whereCondition) {
      res["WhereCondition"] = boost::any(*whereCondition);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (predictType) {
      res["PredictType"] = boost::any(*predictType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<long>(boost::any_cast<long>(m["BlockType"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Checker") != m.end() && !m["Checker"].empty()) {
      checker = make_shared<long>(boost::any_cast<long>(m["Checker"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<string>(boost::any_cast<string>(m["ExpectValue"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("PropertyType") != m.end() && !m["PropertyType"].empty()) {
      propertyType = make_shared<string>(boost::any_cast<string>(m["PropertyType"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("WhereCondition") != m.end() && !m["WhereCondition"].empty()) {
      whereCondition = make_shared<string>(boost::any_cast<string>(m["WhereCondition"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<string>(boost::any_cast<string>(m["CriticalThreshold"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<string>(boost::any_cast<string>(m["WarningThreshold"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("PredictType") != m.end() && !m["PredictType"].empty()) {
      predictType = make_shared<long>(boost::any_cast<long>(m["PredictType"]));
    }
  }


  virtual ~CreateQualityRuleRequest() = default;
};
class CreateQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  CreateQualityRuleResponseBody() {}

  explicit CreateQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateQualityRuleResponseBody() = default;
};
class CreateQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateQualityRuleResponseBody> body{};

  CreateQualityRuleResponse() {}

  explicit CreateQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateQualityRuleResponse() = default;
};
class CreateRemindRequest : public Darabonba::Model {
public:
  shared_ptr<string> remindName{};
  shared_ptr<string> dndEnd{};
  shared_ptr<string> remindUnit{};
  shared_ptr<string> nodeIds{};
  shared_ptr<string> baselineIds{};
  shared_ptr<long> projectId{};
  shared_ptr<string> bizProcessIds{};
  shared_ptr<string> remindType{};
  shared_ptr<long> maxAlertTimes{};
  shared_ptr<long> alertInterval{};
  shared_ptr<string> detail{};
  shared_ptr<string> alertUnit{};
  shared_ptr<string> alertMethods{};
  shared_ptr<string> alertTargets{};
  shared_ptr<string> robotUrls{};

  CreateRemindRequest() {}

  explicit CreateRemindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindName) {
      res["RemindName"] = boost::any(*remindName);
    }
    if (dndEnd) {
      res["DndEnd"] = boost::any(*dndEnd);
    }
    if (remindUnit) {
      res["RemindUnit"] = boost::any(*remindUnit);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (baselineIds) {
      res["BaselineIds"] = boost::any(*baselineIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (bizProcessIds) {
      res["BizProcessIds"] = boost::any(*bizProcessIds);
    }
    if (remindType) {
      res["RemindType"] = boost::any(*remindType);
    }
    if (maxAlertTimes) {
      res["MaxAlertTimes"] = boost::any(*maxAlertTimes);
    }
    if (alertInterval) {
      res["AlertInterval"] = boost::any(*alertInterval);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (alertUnit) {
      res["AlertUnit"] = boost::any(*alertUnit);
    }
    if (alertMethods) {
      res["AlertMethods"] = boost::any(*alertMethods);
    }
    if (alertTargets) {
      res["AlertTargets"] = boost::any(*alertTargets);
    }
    if (robotUrls) {
      res["RobotUrls"] = boost::any(*robotUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindName") != m.end() && !m["RemindName"].empty()) {
      remindName = make_shared<string>(boost::any_cast<string>(m["RemindName"]));
    }
    if (m.find("DndEnd") != m.end() && !m["DndEnd"].empty()) {
      dndEnd = make_shared<string>(boost::any_cast<string>(m["DndEnd"]));
    }
    if (m.find("RemindUnit") != m.end() && !m["RemindUnit"].empty()) {
      remindUnit = make_shared<string>(boost::any_cast<string>(m["RemindUnit"]));
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      nodeIds = make_shared<string>(boost::any_cast<string>(m["NodeIds"]));
    }
    if (m.find("BaselineIds") != m.end() && !m["BaselineIds"].empty()) {
      baselineIds = make_shared<string>(boost::any_cast<string>(m["BaselineIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BizProcessIds") != m.end() && !m["BizProcessIds"].empty()) {
      bizProcessIds = make_shared<string>(boost::any_cast<string>(m["BizProcessIds"]));
    }
    if (m.find("RemindType") != m.end() && !m["RemindType"].empty()) {
      remindType = make_shared<string>(boost::any_cast<string>(m["RemindType"]));
    }
    if (m.find("MaxAlertTimes") != m.end() && !m["MaxAlertTimes"].empty()) {
      maxAlertTimes = make_shared<long>(boost::any_cast<long>(m["MaxAlertTimes"]));
    }
    if (m.find("AlertInterval") != m.end() && !m["AlertInterval"].empty()) {
      alertInterval = make_shared<long>(boost::any_cast<long>(m["AlertInterval"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("AlertUnit") != m.end() && !m["AlertUnit"].empty()) {
      alertUnit = make_shared<string>(boost::any_cast<string>(m["AlertUnit"]));
    }
    if (m.find("AlertMethods") != m.end() && !m["AlertMethods"].empty()) {
      alertMethods = make_shared<string>(boost::any_cast<string>(m["AlertMethods"]));
    }
    if (m.find("AlertTargets") != m.end() && !m["AlertTargets"].empty()) {
      alertTargets = make_shared<string>(boost::any_cast<string>(m["AlertTargets"]));
    }
    if (m.find("RobotUrls") != m.end() && !m["RobotUrls"].empty()) {
      robotUrls = make_shared<string>(boost::any_cast<string>(m["RobotUrls"]));
    }
  }


  virtual ~CreateRemindRequest() = default;
};
class CreateRemindResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  CreateRemindResponseBody() {}

  explicit CreateRemindResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~CreateRemindResponseBody() = default;
};
class CreateRemindResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateRemindResponseBody> body{};

  CreateRemindResponse() {}

  explicit CreateRemindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRemindResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRemindResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRemindResponse() = default;
};
class CreateTableRequestColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnNameCn{};
  shared_ptr<string> columnName{};
  shared_ptr<string> comment{};
  shared_ptr<string> columnType{};
  shared_ptr<long> seqNumber{};
  shared_ptr<long> length{};
  shared_ptr<bool> isPartitionCol{};

  CreateTableRequestColumns() {}

  explicit CreateTableRequestColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnNameCn) {
      res["ColumnNameCn"] = boost::any(*columnNameCn);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (seqNumber) {
      res["SeqNumber"] = boost::any(*seqNumber);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (isPartitionCol) {
      res["IsPartitionCol"] = boost::any(*isPartitionCol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnNameCn") != m.end() && !m["ColumnNameCn"].empty()) {
      columnNameCn = make_shared<string>(boost::any_cast<string>(m["ColumnNameCn"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("SeqNumber") != m.end() && !m["SeqNumber"].empty()) {
      seqNumber = make_shared<long>(boost::any_cast<long>(m["SeqNumber"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("IsPartitionCol") != m.end() && !m["IsPartitionCol"].empty()) {
      isPartitionCol = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionCol"]));
    }
  }


  virtual ~CreateTableRequestColumns() = default;
};
class CreateTableRequestThemes : public Darabonba::Model {
public:
  shared_ptr<long> themeId{};
  shared_ptr<long> themeLevel{};

  CreateTableRequestThemes() {}

  explicit CreateTableRequestThemes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    if (themeLevel) {
      res["ThemeLevel"] = boost::any(*themeLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
    if (m.find("ThemeLevel") != m.end() && !m["ThemeLevel"].empty()) {
      themeLevel = make_shared<long>(boost::any_cast<long>(m["ThemeLevel"]));
    }
  }


  virtual ~CreateTableRequestThemes() = default;
};
class CreateTableRequest : public Darabonba::Model {
public:
  shared_ptr<long> isView{};
  shared_ptr<long> visibility{};
  shared_ptr<long> lifeCycle{};
  shared_ptr<long> categoryId{};
  shared_ptr<long> logicalLevelId{};
  shared_ptr<long> physicsLevelId{};
  shared_ptr<string> externalTableType{};
  shared_ptr<string> location{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> endpoint{};
  shared_ptr<long> envType{};
  shared_ptr<string> appGuid{};
  shared_ptr<string> comment{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> hasPart{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateTableRequestColumns>> columns{};
  shared_ptr<vector<CreateTableRequestThemes>> themes{};

  CreateTableRequest() {}

  explicit CreateTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isView) {
      res["IsView"] = boost::any(*isView);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (lifeCycle) {
      res["LifeCycle"] = boost::any(*lifeCycle);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (logicalLevelId) {
      res["LogicalLevelId"] = boost::any(*logicalLevelId);
    }
    if (physicsLevelId) {
      res["PhysicsLevelId"] = boost::any(*physicsLevelId);
    }
    if (externalTableType) {
      res["ExternalTableType"] = boost::any(*externalTableType);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (hasPart) {
      res["HasPart"] = boost::any(*hasPart);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (themes) {
      vector<boost::any> temp1;
      for(auto item1:*themes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Themes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsView") != m.end() && !m["IsView"].empty()) {
      isView = make_shared<long>(boost::any_cast<long>(m["IsView"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<long>(boost::any_cast<long>(m["Visibility"]));
    }
    if (m.find("LifeCycle") != m.end() && !m["LifeCycle"].empty()) {
      lifeCycle = make_shared<long>(boost::any_cast<long>(m["LifeCycle"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("LogicalLevelId") != m.end() && !m["LogicalLevelId"].empty()) {
      logicalLevelId = make_shared<long>(boost::any_cast<long>(m["LogicalLevelId"]));
    }
    if (m.find("PhysicsLevelId") != m.end() && !m["PhysicsLevelId"].empty()) {
      physicsLevelId = make_shared<long>(boost::any_cast<long>(m["PhysicsLevelId"]));
    }
    if (m.find("ExternalTableType") != m.end() && !m["ExternalTableType"].empty()) {
      externalTableType = make_shared<string>(boost::any_cast<string>(m["ExternalTableType"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("HasPart") != m.end() && !m["HasPart"].empty()) {
      hasPart = make_shared<long>(boost::any_cast<long>(m["HasPart"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<CreateTableRequestColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTableRequestColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<CreateTableRequestColumns>>(expect1);
      }
    }
    if (m.find("Themes") != m.end() && !m["Themes"].empty()) {
      if (typeid(vector<boost::any>) == m["Themes"].type()) {
        vector<CreateTableRequestThemes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Themes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTableRequestThemes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        themes = make_shared<vector<CreateTableRequestThemes>>(expect1);
      }
    }
  }


  virtual ~CreateTableRequest() = default;
};
class CreateTableResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};

  CreateTableResponseBodyTaskInfo() {}

  explicit CreateTableResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~CreateTableResponseBodyTaskInfo() = default;
};
class CreateTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateTableResponseBodyTaskInfo> taskInfo{};

  CreateTableResponseBody() {}

  explicit CreateTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        CreateTableResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<CreateTableResponseBodyTaskInfo>(model1);
      }
    }
  }


  virtual ~CreateTableResponseBody() = default;
};
class CreateTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateTableResponseBody> body{};

  CreateTableResponse() {}

  explicit CreateTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTableResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTableResponse() = default;
};
class CreateTableLevelRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> levelType{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};

  CreateTableLevelRequest() {}

  explicit CreateTableLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (levelType) {
      res["LevelType"] = boost::any(*levelType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("LevelType") != m.end() && !m["LevelType"].empty()) {
      levelType = make_shared<long>(boost::any_cast<long>(m["LevelType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateTableLevelRequest() = default;
};
class CreateTableLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<long> levelId{};

  CreateTableLevelResponseBody() {}

  explicit CreateTableLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
  }


  virtual ~CreateTableLevelResponseBody() = default;
};
class CreateTableLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateTableLevelResponseBody> body{};

  CreateTableLevelResponse() {}

  explicit CreateTableLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTableLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTableLevelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTableLevelResponse() = default;
};
class CreateTableThemeRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> level{};
  shared_ptr<string> name{};
  shared_ptr<long> parentId{};

  CreateTableThemeRequest() {}

  explicit CreateTableThemeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~CreateTableThemeRequest() = default;
};
class CreateTableThemeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<long> themeId{};

  CreateTableThemeResponseBody() {}

  explicit CreateTableThemeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
  }


  virtual ~CreateTableThemeResponseBody() = default;
};
class CreateTableThemeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateTableThemeResponseBody> body{};

  CreateTableThemeResponse() {}

  explicit CreateTableThemeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTableThemeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTableThemeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTableThemeResponse() = default;
};
class CreateUdfFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> functionType{};
  shared_ptr<string> className{};
  shared_ptr<string> resources{};
  shared_ptr<string> udfDescription{};
  shared_ptr<string> cmdDescription{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> returnValue{};
  shared_ptr<string> example{};
  shared_ptr<string> projectIdentifier{};

  CreateUdfFileRequest() {}

  explicit CreateUdfFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (functionType) {
      res["FunctionType"] = boost::any(*functionType);
    }
    if (className) {
      res["ClassName"] = boost::any(*className);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (udfDescription) {
      res["UdfDescription"] = boost::any(*udfDescription);
    }
    if (cmdDescription) {
      res["CmdDescription"] = boost::any(*cmdDescription);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (returnValue) {
      res["ReturnValue"] = boost::any(*returnValue);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FunctionType") != m.end() && !m["FunctionType"].empty()) {
      functionType = make_shared<string>(boost::any_cast<string>(m["FunctionType"]));
    }
    if (m.find("ClassName") != m.end() && !m["ClassName"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["ClassName"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("UdfDescription") != m.end() && !m["UdfDescription"].empty()) {
      udfDescription = make_shared<string>(boost::any_cast<string>(m["UdfDescription"]));
    }
    if (m.find("CmdDescription") != m.end() && !m["CmdDescription"].empty()) {
      cmdDescription = make_shared<string>(boost::any_cast<string>(m["CmdDescription"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ReturnValue") != m.end() && !m["ReturnValue"].empty()) {
      returnValue = make_shared<string>(boost::any_cast<string>(m["ReturnValue"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
  }


  virtual ~CreateUdfFileRequest() = default;
};
class CreateUdfFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  CreateUdfFileResponseBody() {}

  explicit CreateUdfFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~CreateUdfFileResponseBody() = default;
};
class CreateUdfFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateUdfFileResponseBody> body{};

  CreateUdfFileResponse() {}

  explicit CreateUdfFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUdfFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUdfFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUdfFileResponse() = default;
};
class CreateViewRequestViewColumn : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> comment{};

  CreateViewRequestViewColumn() {}

  explicit CreateViewRequestViewColumn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
  }


  virtual ~CreateViewRequestViewColumn() = default;
};
class CreateViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> viewName{};
  shared_ptr<string> selectColumn{};
  shared_ptr<string> selectTableName{};
  shared_ptr<string> selectWhere{};
  shared_ptr<string> selectSQL{};
  shared_ptr<string> appGuid{};
  shared_ptr<string> comment{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateViewRequestViewColumn>> viewColumn{};

  CreateViewRequest() {}

  explicit CreateViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (viewName) {
      res["ViewName"] = boost::any(*viewName);
    }
    if (selectColumn) {
      res["SelectColumn"] = boost::any(*selectColumn);
    }
    if (selectTableName) {
      res["SelectTableName"] = boost::any(*selectTableName);
    }
    if (selectWhere) {
      res["SelectWhere"] = boost::any(*selectWhere);
    }
    if (selectSQL) {
      res["SelectSQL"] = boost::any(*selectSQL);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (viewColumn) {
      vector<boost::any> temp1;
      for(auto item1:*viewColumn){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewColumn"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ViewName") != m.end() && !m["ViewName"].empty()) {
      viewName = make_shared<string>(boost::any_cast<string>(m["ViewName"]));
    }
    if (m.find("SelectColumn") != m.end() && !m["SelectColumn"].empty()) {
      selectColumn = make_shared<string>(boost::any_cast<string>(m["SelectColumn"]));
    }
    if (m.find("SelectTableName") != m.end() && !m["SelectTableName"].empty()) {
      selectTableName = make_shared<string>(boost::any_cast<string>(m["SelectTableName"]));
    }
    if (m.find("SelectWhere") != m.end() && !m["SelectWhere"].empty()) {
      selectWhere = make_shared<string>(boost::any_cast<string>(m["SelectWhere"]));
    }
    if (m.find("SelectSQL") != m.end() && !m["SelectSQL"].empty()) {
      selectSQL = make_shared<string>(boost::any_cast<string>(m["SelectSQL"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ViewColumn") != m.end() && !m["ViewColumn"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewColumn"].type()) {
        vector<CreateViewRequestViewColumn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewColumn"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateViewRequestViewColumn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewColumn = make_shared<vector<CreateViewRequestViewColumn>>(expect1);
      }
    }
  }


  virtual ~CreateViewRequest() = default;
};
class CreateViewResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};

  CreateViewResponseBodyTaskInfo() {}

  explicit CreateViewResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~CreateViewResponseBodyTaskInfo() = default;
};
class CreateViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateViewResponseBodyTaskInfo> taskInfo{};

  CreateViewResponseBody() {}

  explicit CreateViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        CreateViewResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<CreateViewResponseBodyTaskInfo>(model1);
      }
    }
  }


  virtual ~CreateViewResponseBody() = default;
};
class CreateViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateViewResponseBody> body{};

  CreateViewResponse() {}

  explicit CreateViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateViewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateViewResponse() = default;
};
class DeleteBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> businessId{};

  DeleteBusinessRequest() {}

  explicit DeleteBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~DeleteBusinessRequest() = default;
};
class DeleteBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteBusinessResponseBody() {}

  explicit DeleteBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteBusinessResponseBody() = default;
};
class DeleteBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteBusinessResponseBody> body{};

  DeleteBusinessResponse() {}

  explicit DeleteBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBusinessResponse() = default;
};
class DeleteConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<long> connectionId{};

  DeleteConnectionRequest() {}

  explicit DeleteConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~DeleteConnectionRequest() = default;
};
class DeleteConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteConnectionResponseBody() {}

  explicit DeleteConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteConnectionResponseBody() = default;
};
class DeleteConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteConnectionResponseBody> body{};

  DeleteConnectionResponse() {}

  explicit DeleteConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConnectionResponse() = default;
};
class DeleteDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};

  DeleteDataServiceApiRequest() {}

  explicit DeleteDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
  }


  virtual ~DeleteDataServiceApiRequest() = default;
};
class DeleteDataServiceApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteDataServiceApiResponseBody() {}

  explicit DeleteDataServiceApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataServiceApiResponseBody() = default;
};
class DeleteDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDataServiceApiResponseBody> body{};

  DeleteDataServiceApiResponse() {}

  explicit DeleteDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataServiceApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataServiceApiResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataServiceApiResponse() = default;
};
class DeleteDataServiceApiAuthorityRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};
  shared_ptr<long> authorizedProjectId{};

  DeleteDataServiceApiAuthorityRequest() {}

  explicit DeleteDataServiceApiAuthorityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (authorizedProjectId) {
      res["AuthorizedProjectId"] = boost::any(*authorizedProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("AuthorizedProjectId") != m.end() && !m["AuthorizedProjectId"].empty()) {
      authorizedProjectId = make_shared<long>(boost::any_cast<long>(m["AuthorizedProjectId"]));
    }
  }


  virtual ~DeleteDataServiceApiAuthorityRequest() = default;
};
class DeleteDataServiceApiAuthorityResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};

  DeleteDataServiceApiAuthorityResponseBody() {}

  explicit DeleteDataServiceApiAuthorityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDataServiceApiAuthorityResponseBody() = default;
};
class DeleteDataServiceApiAuthorityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDataServiceApiAuthorityResponseBody> body{};

  DeleteDataServiceApiAuthorityResponse() {}

  explicit DeleteDataServiceApiAuthorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataServiceApiAuthorityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataServiceApiAuthorityResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataServiceApiAuthorityResponse() = default;
};
class DeleteDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> dataSourceId{};

  DeleteDataSourceRequest() {}

  explicit DeleteDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
  }


  virtual ~DeleteDataSourceRequest() = default;
};
class DeleteDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataSourceResponseBody() {}

  explicit DeleteDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataSourceResponseBody() = default;
};
class DeleteDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDataSourceResponseBody> body{};

  DeleteDataSourceResponse() {}

  explicit DeleteDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataSourceResponse() = default;
};
class DeleteFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileId{};

  DeleteFileRequest() {}

  explicit DeleteFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~DeleteFileRequest() = default;
};
class DeleteFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteFileResponseBody() {}

  explicit DeleteFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteFileResponseBody() = default;
};
class DeleteFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFileResponseBody> body{};

  DeleteFileResponse() {}

  explicit DeleteFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFileResponse() = default;
};
class DeleteFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> folderId{};

  DeleteFolderRequest() {}

  explicit DeleteFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
  }


  virtual ~DeleteFolderRequest() = default;
};
class DeleteFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteFolderResponseBody() {}

  explicit DeleteFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteFolderResponseBody() = default;
};
class DeleteFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFolderResponseBody> body{};

  DeleteFolderResponse() {}

  explicit DeleteFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFolderResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFolderResponse() = default;
};
class DeleteFromMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};
  shared_ptr<string> tableGuid{};

  DeleteFromMetaCategoryRequest() {}

  explicit DeleteFromMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~DeleteFromMetaCategoryRequest() = default;
};
class DeleteFromMetaCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteFromMetaCategoryResponseBody() {}

  explicit DeleteFromMetaCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteFromMetaCategoryResponseBody() = default;
};
class DeleteFromMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFromMetaCategoryResponseBody> body{};

  DeleteFromMetaCategoryResponse() {}

  explicit DeleteFromMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFromMetaCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFromMetaCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFromMetaCategoryResponse() = default;
};
class DeleteMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> categoryId{};

  DeleteMetaCategoryRequest() {}

  explicit DeleteMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
  }


  virtual ~DeleteMetaCategoryRequest() = default;
};
class DeleteMetaCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteMetaCategoryResponseBody() {}

  explicit DeleteMetaCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMetaCategoryResponseBody() = default;
};
class DeleteMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteMetaCategoryResponseBody> body{};

  DeleteMetaCategoryResponse() {}

  explicit DeleteMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMetaCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMetaCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMetaCategoryResponse() = default;
};
class DeleteProjectMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};

  DeleteProjectMemberRequest() {}

  explicit DeleteProjectMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DeleteProjectMemberRequest() = default;
};
class DeleteProjectMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProjectMemberResponseBody() {}

  explicit DeleteProjectMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteProjectMemberResponseBody() = default;
};
class DeleteProjectMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteProjectMemberResponseBody> body{};

  DeleteProjectMemberResponse() {}

  explicit DeleteProjectMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProjectMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProjectMemberResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProjectMemberResponse() = default;
};
class DeleteQualityEntityRequest : public Darabonba::Model {
public:
  shared_ptr<long> entityId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> envType{};

  DeleteQualityEntityRequest() {}

  explicit DeleteQualityEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
  }


  virtual ~DeleteQualityEntityRequest() = default;
};
class DeleteQualityEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  DeleteQualityEntityResponseBody() {}

  explicit DeleteQualityEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~DeleteQualityEntityResponseBody() = default;
};
class DeleteQualityEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteQualityEntityResponseBody> body{};

  DeleteQualityEntityResponse() {}

  explicit DeleteQualityEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteQualityEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteQualityEntityResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteQualityEntityResponse() = default;
};
class DeleteQualityFollowerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> followerId{};

  DeleteQualityFollowerRequest() {}

  explicit DeleteQualityFollowerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (followerId) {
      res["FollowerId"] = boost::any(*followerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("FollowerId") != m.end() && !m["FollowerId"].empty()) {
      followerId = make_shared<long>(boost::any_cast<long>(m["FollowerId"]));
    }
  }


  virtual ~DeleteQualityFollowerRequest() = default;
};
class DeleteQualityFollowerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteQualityFollowerResponseBody() {}

  explicit DeleteQualityFollowerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteQualityFollowerResponseBody() = default;
};
class DeleteQualityFollowerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteQualityFollowerResponseBody> body{};

  DeleteQualityFollowerResponse() {}

  explicit DeleteQualityFollowerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteQualityFollowerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteQualityFollowerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteQualityFollowerResponse() = default;
};
class DeleteQualityRelativeNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> envType{};
  shared_ptr<string> matchExpression{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> targetNodeProjectName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> targetNodeProjectId{};

  DeleteQualityRelativeNodeRequest() {}

  explicit DeleteQualityRelativeNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (targetNodeProjectName) {
      res["TargetNodeProjectName"] = boost::any(*targetNodeProjectName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (targetNodeProjectId) {
      res["TargetNodeProjectId"] = boost::any(*targetNodeProjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TargetNodeProjectName") != m.end() && !m["TargetNodeProjectName"].empty()) {
      targetNodeProjectName = make_shared<string>(boost::any_cast<string>(m["TargetNodeProjectName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TargetNodeProjectId") != m.end() && !m["TargetNodeProjectId"].empty()) {
      targetNodeProjectId = make_shared<long>(boost::any_cast<long>(m["TargetNodeProjectId"]));
    }
  }


  virtual ~DeleteQualityRelativeNodeRequest() = default;
};
class DeleteQualityRelativeNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  DeleteQualityRelativeNodeResponseBody() {}

  explicit DeleteQualityRelativeNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~DeleteQualityRelativeNodeResponseBody() = default;
};
class DeleteQualityRelativeNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteQualityRelativeNodeResponseBody> body{};

  DeleteQualityRelativeNodeResponse() {}

  explicit DeleteQualityRelativeNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteQualityRelativeNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteQualityRelativeNodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteQualityRelativeNodeResponse() = default;
};
class DeleteQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> ruleId{};

  DeleteQualityRuleRequest() {}

  explicit DeleteQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DeleteQualityRuleRequest() = default;
};
class DeleteQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  DeleteQualityRuleResponseBody() {}

  explicit DeleteQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteQualityRuleResponseBody() = default;
};
class DeleteQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteQualityRuleResponseBody> body{};

  DeleteQualityRuleResponse() {}

  explicit DeleteQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteQualityRuleResponse() = default;
};
class DeleteRemindRequest : public Darabonba::Model {
public:
  shared_ptr<long> remindId{};

  DeleteRemindRequest() {}

  explicit DeleteRemindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
  }


  virtual ~DeleteRemindRequest() = default;
};
class DeleteRemindResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  DeleteRemindResponseBody() {}

  explicit DeleteRemindResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~DeleteRemindResponseBody() = default;
};
class DeleteRemindResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRemindResponseBody> body{};

  DeleteRemindResponse() {}

  explicit DeleteRemindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRemindResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRemindResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRemindResponse() = default;
};
class DeleteTableRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> tableName{};
  shared_ptr<long> envType{};
  shared_ptr<string> appGuid{};

  DeleteTableRequest() {}

  explicit DeleteTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
  }


  virtual ~DeleteTableRequest() = default;
};
class DeleteTableResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};

  DeleteTableResponseBodyTaskInfo() {}

  explicit DeleteTableResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DeleteTableResponseBodyTaskInfo() = default;
};
class DeleteTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteTableResponseBodyTaskInfo> taskInfo{};

  DeleteTableResponseBody() {}

  explicit DeleteTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        DeleteTableResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<DeleteTableResponseBodyTaskInfo>(model1);
      }
    }
  }


  virtual ~DeleteTableResponseBody() = default;
};
class DeleteTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteTableResponseBody> body{};

  DeleteTableResponse() {}

  explicit DeleteTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTableResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTableResponse() = default;
};
class DeleteTableLevelRequest : public Darabonba::Model {
public:
  shared_ptr<long> levelId{};
  shared_ptr<long> projectId{};

  DeleteTableLevelRequest() {}

  explicit DeleteTableLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteTableLevelRequest() = default;
};
class DeleteTableLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> deleteResult{};
  shared_ptr<string> requestId{};

  DeleteTableLevelResponseBody() {}

  explicit DeleteTableLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteResult) {
      res["DeleteResult"] = boost::any(*deleteResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteResult") != m.end() && !m["DeleteResult"].empty()) {
      deleteResult = make_shared<bool>(boost::any_cast<bool>(m["DeleteResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTableLevelResponseBody() = default;
};
class DeleteTableLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteTableLevelResponseBody> body{};

  DeleteTableLevelResponse() {}

  explicit DeleteTableLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTableLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTableLevelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTableLevelResponse() = default;
};
class DeleteTableThemeRequest : public Darabonba::Model {
public:
  shared_ptr<long> themeId{};
  shared_ptr<long> projectId{};

  DeleteTableThemeRequest() {}

  explicit DeleteTableThemeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteTableThemeRequest() = default;
};
class DeleteTableThemeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<bool> deleteResult{};

  DeleteTableThemeResponseBody() {}

  explicit DeleteTableThemeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (deleteResult) {
      res["DeleteResult"] = boost::any(*deleteResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("DeleteResult") != m.end() && !m["DeleteResult"].empty()) {
      deleteResult = make_shared<bool>(boost::any_cast<bool>(m["DeleteResult"]));
    }
  }


  virtual ~DeleteTableThemeResponseBody() = default;
};
class DeleteTableThemeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteTableThemeResponseBody> body{};

  DeleteTableThemeResponse() {}

  explicit DeleteTableThemeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTableThemeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTableThemeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTableThemeResponse() = default;
};
class DeleteViewRequest : public Darabonba::Model {
public:
  shared_ptr<string> viewName{};
  shared_ptr<string> appGuid{};

  DeleteViewRequest() {}

  explicit DeleteViewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (viewName) {
      res["ViewName"] = boost::any(*viewName);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ViewName") != m.end() && !m["ViewName"].empty()) {
      viewName = make_shared<string>(boost::any_cast<string>(m["ViewName"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
  }


  virtual ~DeleteViewRequest() = default;
};
class DeleteViewResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};

  DeleteViewResponseBodyTaskInfo() {}

  explicit DeleteViewResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DeleteViewResponseBodyTaskInfo() = default;
};
class DeleteViewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteViewResponseBodyTaskInfo> taskInfo{};

  DeleteViewResponseBody() {}

  explicit DeleteViewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        DeleteViewResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<DeleteViewResponseBodyTaskInfo>(model1);
      }
    }
  }


  virtual ~DeleteViewResponseBody() = default;
};
class DeleteViewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteViewResponseBody> body{};

  DeleteViewResponse() {}

  explicit DeleteViewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteViewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteViewResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteViewResponse() = default;
};
class DeployFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileId{};
  shared_ptr<string> comment{};
  shared_ptr<long> nodeId{};

  DeployFileRequest() {}

  explicit DeployFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~DeployFileRequest() = default;
};
class DeployFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  DeployFileResponseBody() {}

  explicit DeployFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~DeployFileResponseBody() = default;
};
class DeployFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeployFileResponseBody> body{};

  DeployFileResponse() {}

  explicit DeployFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeployFileResponse() = default;
};
class DesensitizeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> sceneCode{};

  DesensitizeDataRequest() {}

  explicit DesensitizeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (sceneCode) {
      res["SceneCode"] = boost::any(*sceneCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("SceneCode") != m.end() && !m["SceneCode"].empty()) {
      sceneCode = make_shared<string>(boost::any_cast<string>(m["SceneCode"]));
    }
  }


  virtual ~DesensitizeDataRequest() = default;
};
class DesensitizeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> desensitizeData{};
  shared_ptr<string> requestId{};

  DesensitizeDataResponseBody() {}

  explicit DesensitizeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desensitizeData) {
      res["DesensitizeData"] = boost::any(*desensitizeData);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DesensitizeData") != m.end() && !m["DesensitizeData"].empty()) {
      desensitizeData = make_shared<string>(boost::any_cast<string>(m["DesensitizeData"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DesensitizeDataResponseBody() = default;
};
class DesensitizeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DesensitizeDataResponseBody> body{};

  DesensitizeDataResponse() {}

  explicit DesensitizeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DesensitizeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DesensitizeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DesensitizeDataResponse() = default;
};
class EstablishRelationTableToBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> businessId{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> folderId{};

  EstablishRelationTableToBusinessRequest() {}

  explicit EstablishRelationTableToBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<string>(boost::any_cast<string>(m["BusinessId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
  }


  virtual ~EstablishRelationTableToBusinessRequest() = default;
};
class EstablishRelationTableToBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  EstablishRelationTableToBusinessResponseBody() {}

  explicit EstablishRelationTableToBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~EstablishRelationTableToBusinessResponseBody() = default;
};
class EstablishRelationTableToBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EstablishRelationTableToBusinessResponseBody> body{};

  EstablishRelationTableToBusinessResponse() {}

  explicit EstablishRelationTableToBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EstablishRelationTableToBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EstablishRelationTableToBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~EstablishRelationTableToBusinessResponse() = default;
};
class ExportDISyncTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> taskParam{};

  ExportDISyncTasksRequest() {}

  explicit ExportDISyncTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
  }


  virtual ~ExportDISyncTasksRequest() = default;
};
class ExportDISyncTasksResponseBodyTaskDetail : public Darabonba::Model {
public:
  shared_ptr<string> realTimeSolution{};

  ExportDISyncTasksResponseBodyTaskDetail() {}

  explicit ExportDISyncTasksResponseBodyTaskDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeSolution) {
      res["RealTimeSolution"] = boost::any(*realTimeSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeSolution") != m.end() && !m["RealTimeSolution"].empty()) {
      realTimeSolution = make_shared<string>(boost::any_cast<string>(m["RealTimeSolution"]));
    }
  }


  virtual ~ExportDISyncTasksResponseBodyTaskDetail() = default;
};
class ExportDISyncTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<ExportDISyncTasksResponseBodyTaskDetail> taskDetail{};

  ExportDISyncTasksResponseBody() {}

  explicit ExportDISyncTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskDetail) {
      res["TaskDetail"] = taskDetail ? boost::any(taskDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskDetail") != m.end() && !m["TaskDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskDetail"].type()) {
        ExportDISyncTasksResponseBodyTaskDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskDetail"]));
        taskDetail = make_shared<ExportDISyncTasksResponseBodyTaskDetail>(model1);
      }
    }
  }


  virtual ~ExportDISyncTasksResponseBody() = default;
};
class ExportDISyncTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExportDISyncTasksResponseBody> body{};

  ExportDISyncTasksResponse() {}

  explicit ExportDISyncTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportDISyncTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportDISyncTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ExportDISyncTasksResponse() = default;
};
class GetBaselineConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};

  GetBaselineConfigRequest() {}

  explicit GetBaselineConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
  }


  virtual ~GetBaselineConfigRequest() = default;
};
class GetBaselineConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> hourSlaDetail{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<long> priority{};
  shared_ptr<long> slaMinu{};
  shared_ptr<long> slaHour{};
  shared_ptr<long> baselineId{};
  shared_ptr<string> baselineName{};
  shared_ptr<string> hourExpDetail{};
  shared_ptr<bool> useFlag{};
  shared_ptr<long> expHour{};
  shared_ptr<string> baselineType{};
  shared_ptr<long> expMinu{};

  GetBaselineConfigResponseBodyData() {}

  explicit GetBaselineConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hourSlaDetail) {
      res["HourSlaDetail"] = boost::any(*hourSlaDetail);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (slaMinu) {
      res["SlaMinu"] = boost::any(*slaMinu);
    }
    if (slaHour) {
      res["SlaHour"] = boost::any(*slaHour);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (hourExpDetail) {
      res["HourExpDetail"] = boost::any(*hourExpDetail);
    }
    if (useFlag) {
      res["UseFlag"] = boost::any(*useFlag);
    }
    if (expHour) {
      res["ExpHour"] = boost::any(*expHour);
    }
    if (baselineType) {
      res["BaselineType"] = boost::any(*baselineType);
    }
    if (expMinu) {
      res["ExpMinu"] = boost::any(*expMinu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HourSlaDetail") != m.end() && !m["HourSlaDetail"].empty()) {
      hourSlaDetail = make_shared<string>(boost::any_cast<string>(m["HourSlaDetail"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SlaMinu") != m.end() && !m["SlaMinu"].empty()) {
      slaMinu = make_shared<long>(boost::any_cast<long>(m["SlaMinu"]));
    }
    if (m.find("SlaHour") != m.end() && !m["SlaHour"].empty()) {
      slaHour = make_shared<long>(boost::any_cast<long>(m["SlaHour"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("HourExpDetail") != m.end() && !m["HourExpDetail"].empty()) {
      hourExpDetail = make_shared<string>(boost::any_cast<string>(m["HourExpDetail"]));
    }
    if (m.find("UseFlag") != m.end() && !m["UseFlag"].empty()) {
      useFlag = make_shared<bool>(boost::any_cast<bool>(m["UseFlag"]));
    }
    if (m.find("ExpHour") != m.end() && !m["ExpHour"].empty()) {
      expHour = make_shared<long>(boost::any_cast<long>(m["ExpHour"]));
    }
    if (m.find("BaselineType") != m.end() && !m["BaselineType"].empty()) {
      baselineType = make_shared<string>(boost::any_cast<string>(m["BaselineType"]));
    }
    if (m.find("ExpMinu") != m.end() && !m["ExpMinu"].empty()) {
      expMinu = make_shared<long>(boost::any_cast<long>(m["ExpMinu"]));
    }
  }


  virtual ~GetBaselineConfigResponseBodyData() = default;
};
class GetBaselineConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetBaselineConfigResponseBodyData> data{};

  GetBaselineConfigResponseBody() {}

  explicit GetBaselineConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBaselineConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBaselineConfigResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetBaselineConfigResponseBody() = default;
};
class GetBaselineConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetBaselineConfigResponseBody> body{};

  GetBaselineConfigResponse() {}

  explicit GetBaselineConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBaselineConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBaselineConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetBaselineConfigResponse() = default;
};
class GetBaselineKeyPathRequest : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<string> bizdate{};
  shared_ptr<long> inGroupId{};

  GetBaselineKeyPathRequest() {}

  explicit GetBaselineKeyPathRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<long>(boost::any_cast<long>(m["InGroupId"]));
    }
  }


  virtual ~GetBaselineKeyPathRequest() = default;
};
class GetBaselineKeyPathResponseBodyDataRuns : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> absTime{};
  shared_ptr<long> beginRunningTime{};
  shared_ptr<long> cycTime{};
  shared_ptr<string> owner{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> projectId{};
  shared_ptr<long> beginCast{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> endCast{};
  shared_ptr<long> beginWaitResTime{};
  shared_ptr<long> inGroupId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> beginWaitTimeTime{};
  shared_ptr<long> nodeId{};

  GetBaselineKeyPathResponseBodyDataRuns() {}

  explicit GetBaselineKeyPathResponseBodyDataRuns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (absTime) {
      res["AbsTime"] = boost::any(*absTime);
    }
    if (beginRunningTime) {
      res["BeginRunningTime"] = boost::any(*beginRunningTime);
    }
    if (cycTime) {
      res["CycTime"] = boost::any(*cycTime);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (beginCast) {
      res["BeginCast"] = boost::any(*beginCast);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (endCast) {
      res["EndCast"] = boost::any(*endCast);
    }
    if (beginWaitResTime) {
      res["BeginWaitResTime"] = boost::any(*beginWaitResTime);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (beginWaitTimeTime) {
      res["BeginWaitTimeTime"] = boost::any(*beginWaitTimeTime);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("AbsTime") != m.end() && !m["AbsTime"].empty()) {
      absTime = make_shared<long>(boost::any_cast<long>(m["AbsTime"]));
    }
    if (m.find("BeginRunningTime") != m.end() && !m["BeginRunningTime"].empty()) {
      beginRunningTime = make_shared<long>(boost::any_cast<long>(m["BeginRunningTime"]));
    }
    if (m.find("CycTime") != m.end() && !m["CycTime"].empty()) {
      cycTime = make_shared<long>(boost::any_cast<long>(m["CycTime"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BeginCast") != m.end() && !m["BeginCast"].empty()) {
      beginCast = make_shared<long>(boost::any_cast<long>(m["BeginCast"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("EndCast") != m.end() && !m["EndCast"].empty()) {
      endCast = make_shared<long>(boost::any_cast<long>(m["EndCast"]));
    }
    if (m.find("BeginWaitResTime") != m.end() && !m["BeginWaitResTime"].empty()) {
      beginWaitResTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitResTime"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<long>(boost::any_cast<long>(m["InGroupId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("BeginWaitTimeTime") != m.end() && !m["BeginWaitTimeTime"].empty()) {
      beginWaitTimeTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitTimeTime"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetBaselineKeyPathResponseBodyDataRuns() = default;
};
class GetBaselineKeyPathResponseBodyDataTopics : public Darabonba::Model {
public:
  shared_ptr<long> topicName{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> topicId{};
  shared_ptr<long> addTime{};

  GetBaselineKeyPathResponseBodyDataTopics() {}

  explicit GetBaselineKeyPathResponseBodyDataTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (addTime) {
      res["AddTime"] = boost::any(*addTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<long>(boost::any_cast<long>(m["TopicName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("AddTime") != m.end() && !m["AddTime"].empty()) {
      addTime = make_shared<long>(boost::any_cast<long>(m["AddTime"]));
    }
  }


  virtual ~GetBaselineKeyPathResponseBodyDataTopics() = default;
};
class GetBaselineKeyPathResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> projectId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> prgType{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> inGroupId{};
  shared_ptr<vector<GetBaselineKeyPathResponseBodyDataRuns>> runs{};
  shared_ptr<vector<GetBaselineKeyPathResponseBodyDataTopics>> topics{};

  GetBaselineKeyPathResponseBodyData() {}

  explicit GetBaselineKeyPathResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (prgType) {
      res["PrgType"] = boost::any(*prgType);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    if (runs) {
      vector<boost::any> temp1;
      for(auto item1:*runs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Runs"] = boost::any(temp1);
    }
    if (topics) {
      vector<boost::any> temp1;
      for(auto item1:*topics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Topics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("PrgType") != m.end() && !m["PrgType"].empty()) {
      prgType = make_shared<long>(boost::any_cast<long>(m["PrgType"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<long>(boost::any_cast<long>(m["InGroupId"]));
    }
    if (m.find("Runs") != m.end() && !m["Runs"].empty()) {
      if (typeid(vector<boost::any>) == m["Runs"].type()) {
        vector<GetBaselineKeyPathResponseBodyDataRuns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Runs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBaselineKeyPathResponseBodyDataRuns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        runs = make_shared<vector<GetBaselineKeyPathResponseBodyDataRuns>>(expect1);
      }
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<GetBaselineKeyPathResponseBodyDataTopics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Topics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBaselineKeyPathResponseBodyDataTopics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topics = make_shared<vector<GetBaselineKeyPathResponseBodyDataTopics>>(expect1);
      }
    }
  }


  virtual ~GetBaselineKeyPathResponseBodyData() = default;
};
class GetBaselineKeyPathResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetBaselineKeyPathResponseBodyData>> data{};

  GetBaselineKeyPathResponseBody() {}

  explicit GetBaselineKeyPathResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetBaselineKeyPathResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBaselineKeyPathResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetBaselineKeyPathResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~GetBaselineKeyPathResponseBody() = default;
};
class GetBaselineKeyPathResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetBaselineKeyPathResponseBody> body{};

  GetBaselineKeyPathResponse() {}

  explicit GetBaselineKeyPathResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBaselineKeyPathResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBaselineKeyPathResponseBody>(model1);
      }
    }
  }


  virtual ~GetBaselineKeyPathResponse() = default;
};
class GetBaselineStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};
  shared_ptr<string> bizdate{};
  shared_ptr<long> inGroupId{};

  GetBaselineStatusRequest() {}

  explicit GetBaselineStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<long>(boost::any_cast<long>(m["InGroupId"]));
    }
  }


  virtual ~GetBaselineStatusRequest() = default;
};
class GetBaselineStatusResponseBodyDataLastInstance : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> owner{};
  shared_ptr<long> finishTime{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> projectId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> endCast{};
  shared_ptr<long> nodeId{};

  GetBaselineStatusResponseBodyDataLastInstance() {}

  explicit GetBaselineStatusResponseBodyDataLastInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (endCast) {
      res["EndCast"] = boost::any(*endCast);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("EndCast") != m.end() && !m["EndCast"].empty()) {
      endCast = make_shared<long>(boost::any_cast<long>(m["EndCast"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetBaselineStatusResponseBodyDataLastInstance() = default;
};
class GetBaselineStatusResponseBodyDataBlockInstance : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> owner{};
  shared_ptr<long> finishTime{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> projectId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> endCast{};
  shared_ptr<long> nodeId{};

  GetBaselineStatusResponseBodyDataBlockInstance() {}

  explicit GetBaselineStatusResponseBodyDataBlockInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (endCast) {
      res["EndCast"] = boost::any(*endCast);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("EndCast") != m.end() && !m["EndCast"].empty()) {
      endCast = make_shared<long>(boost::any_cast<long>(m["EndCast"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetBaselineStatusResponseBodyDataBlockInstance() = default;
};
class GetBaselineStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> owner{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> projectId{};
  shared_ptr<long> priority{};
  shared_ptr<long> endCast{};
  shared_ptr<long> inGroupId{};
  shared_ptr<string> baselineName{};
  shared_ptr<long> baselineId{};
  shared_ptr<string> finishStatus{};
  shared_ptr<long> bizdate{};
  shared_ptr<double> buffer{};
  shared_ptr<long> slaTime{};
  shared_ptr<long> expTime{};
  shared_ptr<GetBaselineStatusResponseBodyDataLastInstance> lastInstance{};
  shared_ptr<GetBaselineStatusResponseBodyDataBlockInstance> blockInstance{};

  GetBaselineStatusResponseBodyData() {}

  explicit GetBaselineStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (endCast) {
      res["EndCast"] = boost::any(*endCast);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (finishStatus) {
      res["FinishStatus"] = boost::any(*finishStatus);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (buffer) {
      res["Buffer"] = boost::any(*buffer);
    }
    if (slaTime) {
      res["SlaTime"] = boost::any(*slaTime);
    }
    if (expTime) {
      res["ExpTime"] = boost::any(*expTime);
    }
    if (lastInstance) {
      res["LastInstance"] = lastInstance ? boost::any(lastInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (blockInstance) {
      res["BlockInstance"] = blockInstance ? boost::any(blockInstance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("EndCast") != m.end() && !m["EndCast"].empty()) {
      endCast = make_shared<long>(boost::any_cast<long>(m["EndCast"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<long>(boost::any_cast<long>(m["InGroupId"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("FinishStatus") != m.end() && !m["FinishStatus"].empty()) {
      finishStatus = make_shared<string>(boost::any_cast<string>(m["FinishStatus"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Buffer") != m.end() && !m["Buffer"].empty()) {
      buffer = make_shared<double>(boost::any_cast<double>(m["Buffer"]));
    }
    if (m.find("SlaTime") != m.end() && !m["SlaTime"].empty()) {
      slaTime = make_shared<long>(boost::any_cast<long>(m["SlaTime"]));
    }
    if (m.find("ExpTime") != m.end() && !m["ExpTime"].empty()) {
      expTime = make_shared<long>(boost::any_cast<long>(m["ExpTime"]));
    }
    if (m.find("LastInstance") != m.end() && !m["LastInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["LastInstance"].type()) {
        GetBaselineStatusResponseBodyDataLastInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LastInstance"]));
        lastInstance = make_shared<GetBaselineStatusResponseBodyDataLastInstance>(model1);
      }
    }
    if (m.find("BlockInstance") != m.end() && !m["BlockInstance"].empty()) {
      if (typeid(map<string, boost::any>) == m["BlockInstance"].type()) {
        GetBaselineStatusResponseBodyDataBlockInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BlockInstance"]));
        blockInstance = make_shared<GetBaselineStatusResponseBodyDataBlockInstance>(model1);
      }
    }
  }


  virtual ~GetBaselineStatusResponseBodyData() = default;
};
class GetBaselineStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetBaselineStatusResponseBodyData> data{};

  GetBaselineStatusResponseBody() {}

  explicit GetBaselineStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBaselineStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBaselineStatusResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetBaselineStatusResponseBody() = default;
};
class GetBaselineStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetBaselineStatusResponseBody> body{};

  GetBaselineStatusResponse() {}

  explicit GetBaselineStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBaselineStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBaselineStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetBaselineStatusResponse() = default;
};
class GetBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> businessId{};

  GetBusinessRequest() {}

  explicit GetBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~GetBusinessRequest() = default;
};
class GetBusinessResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> description{};
  shared_ptr<string> projectId{};
  shared_ptr<long> businessId{};
  shared_ptr<string> businessName{};
  shared_ptr<string> useType{};

  GetBusinessResponseBodyData() {}

  explicit GetBusinessResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~GetBusinessResponseBodyData() = default;
};
class GetBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetBusinessResponseBodyData> data{};

  GetBusinessResponseBody() {}

  explicit GetBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBusinessResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBusinessResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetBusinessResponseBody() = default;
};
class GetBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetBusinessResponseBody> body{};

  GetBusinessResponse() {}

  explicit GetBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~GetBusinessResponse() = default;
};
class GetDagRequest : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> projectEnv{};

  GetDagRequest() {}

  explicit GetDagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetDagRequest() = default;
};
class GetDagResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> projectId{};
  shared_ptr<long> dagId{};
  shared_ptr<long> gmtdate{};
  shared_ptr<long> startTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> bizdate{};
  shared_ptr<string> name{};
  shared_ptr<long> modifyTime{};

  GetDagResponseBodyData() {}

  explicit GetDagResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (gmtdate) {
      res["Gmtdate"] = boost::any(*gmtdate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Gmtdate") != m.end() && !m["Gmtdate"].empty()) {
      gmtdate = make_shared<long>(boost::any_cast<long>(m["Gmtdate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
  }


  virtual ~GetDagResponseBodyData() = default;
};
class GetDagResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetDagResponseBodyData> data{};

  GetDagResponseBody() {}

  explicit GetDagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDagResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDagResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetDagResponseBody() = default;
};
class GetDagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDagResponseBody> body{};

  GetDagResponse() {}

  explicit GetDagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDagResponseBody>(model1);
      }
    }
  }


  virtual ~GetDagResponse() = default;
};
class GetDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};

  GetDataServiceApiRequest() {}

  explicit GetDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
  }


  virtual ~GetDataServiceApiRequest() = default;
};
class GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorSolution{};

  GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes() {}

  explicit GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes() = default;
};
class GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};

  GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters() {}

  explicit GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters() = default;
};
class GetDataServiceApiResponseBodyDataRegistrationDetails : public Darabonba::Model {
public:
  shared_ptr<string> serviceHost{};
  shared_ptr<long> serviceContentType{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<string> failedResultSample{};
  shared_ptr<string> serviceRequestBodyDescription{};
  shared_ptr<vector<GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes>> registrationErrorCodes{};
  shared_ptr<vector<GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters>> registrationRequestParameters{};

  GetDataServiceApiResponseBodyDataRegistrationDetails() {}

  explicit GetDataServiceApiResponseBodyDataRegistrationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceHost) {
      res["ServiceHost"] = boost::any(*serviceHost);
    }
    if (serviceContentType) {
      res["ServiceContentType"] = boost::any(*serviceContentType);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (serviceRequestBodyDescription) {
      res["ServiceRequestBodyDescription"] = boost::any(*serviceRequestBodyDescription);
    }
    if (registrationErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*registrationErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationErrorCodes"] = boost::any(temp1);
    }
    if (registrationRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*registrationRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationRequestParameters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceHost") != m.end() && !m["ServiceHost"].empty()) {
      serviceHost = make_shared<string>(boost::any_cast<string>(m["ServiceHost"]));
    }
    if (m.find("ServiceContentType") != m.end() && !m["ServiceContentType"].empty()) {
      serviceContentType = make_shared<long>(boost::any_cast<long>(m["ServiceContentType"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("ServiceRequestBodyDescription") != m.end() && !m["ServiceRequestBodyDescription"].empty()) {
      serviceRequestBodyDescription = make_shared<string>(boost::any_cast<string>(m["ServiceRequestBodyDescription"]));
    }
    if (m.find("RegistrationErrorCodes") != m.end() && !m["RegistrationErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationErrorCodes"].type()) {
        vector<GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationErrorCodes = make_shared<vector<GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes>>(expect1);
      }
    }
    if (m.find("RegistrationRequestParameters") != m.end() && !m["RegistrationRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationRequestParameters"].type()) {
        vector<GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationRequestParameters = make_shared<vector<GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters>>(expect1);
      }
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataRegistrationDetails() = default;
};
class GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};

  GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters() {}

  explicit GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters() = default;
};
class GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> columnName{};
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> exampleValue{};

  GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters() {}

  explicit GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters() = default;
};
class GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<long> connectionId{};

  GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection() {}

  explicit GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection() = default;
};
class GetDataServiceApiResponseBodyDataScriptDetails : public Darabonba::Model {
public:
  shared_ptr<string> script{};
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<vector<GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters>> scriptRequestParameters{};
  shared_ptr<vector<GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters>> scriptResponseParameters{};
  shared_ptr<GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection> scriptConnection{};

  GetDataServiceApiResponseBodyDataScriptDetails() {}

  explicit GetDataServiceApiResponseBodyDataScriptDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (scriptRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptRequestParameters"] = boost::any(temp1);
    }
    if (scriptResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptResponseParameters"] = boost::any(temp1);
    }
    if (scriptConnection) {
      res["ScriptConnection"] = scriptConnection ? boost::any(scriptConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("ScriptRequestParameters") != m.end() && !m["ScriptRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptRequestParameters"].type()) {
        vector<GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptRequestParameters = make_shared<vector<GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters>>(expect1);
      }
    }
    if (m.find("ScriptResponseParameters") != m.end() && !m["ScriptResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptResponseParameters"].type()) {
        vector<GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptResponseParameters = make_shared<vector<GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters>>(expect1);
      }
    }
    if (m.find("ScriptConnection") != m.end() && !m["ScriptConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptConnection"].type()) {
        GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptConnection"]));
        scriptConnection = make_shared<GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection>(model1);
      }
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataScriptDetails() = default;
};
class GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};

  GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters() {}

  explicit GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters() = default;
};
class GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> columnName{};
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> exampleValue{};

  GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters() {}

  explicit GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters() = default;
};
class GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<long> connectionId{};

  GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection() {}

  explicit GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection() = default;
};
class GetDataServiceApiResponseBodyDataWizardDetails : public Darabonba::Model {
public:
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<vector<GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters>> wizardRequestParameters{};
  shared_ptr<vector<GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters>> wizardResponseParameters{};
  shared_ptr<GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection> wizardConnection{};

  GetDataServiceApiResponseBodyDataWizardDetails() {}

  explicit GetDataServiceApiResponseBodyDataWizardDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (wizardRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardRequestParameters"] = boost::any(temp1);
    }
    if (wizardResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardResponseParameters"] = boost::any(temp1);
    }
    if (wizardConnection) {
      res["WizardConnection"] = wizardConnection ? boost::any(wizardConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("WizardRequestParameters") != m.end() && !m["WizardRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardRequestParameters"].type()) {
        vector<GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardRequestParameters = make_shared<vector<GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters>>(expect1);
      }
    }
    if (m.find("WizardResponseParameters") != m.end() && !m["WizardResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardResponseParameters"].type()) {
        vector<GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardResponseParameters = make_shared<vector<GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters>>(expect1);
      }
    }
    if (m.find("WizardConnection") != m.end() && !m["WizardConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardConnection"].type()) {
        GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardConnection"]));
        wizardConnection = make_shared<GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection>(model1);
      }
    }
  }


  virtual ~GetDataServiceApiResponseBodyDataWizardDetails() = default;
};
class GetDataServiceApiResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> timeout{};
  shared_ptr<long> status{};
  shared_ptr<long> apiId{};
  shared_ptr<long> apiMode{};
  shared_ptr<long> projectId{};
  shared_ptr<long> responseContentType{};
  shared_ptr<string> creatorId{};
  shared_ptr<long> visibleRange{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> description{};
  shared_ptr<long> folderId{};
  shared_ptr<long> requestMethod{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> apiName{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiPath{};
  shared_ptr<vector<long>> protocols{};
  shared_ptr<GetDataServiceApiResponseBodyDataRegistrationDetails> registrationDetails{};
  shared_ptr<GetDataServiceApiResponseBodyDataScriptDetails> scriptDetails{};
  shared_ptr<GetDataServiceApiResponseBodyDataWizardDetails> wizardDetails{};

  GetDataServiceApiResponseBodyData() {}

  explicit GetDataServiceApiResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMode) {
      res["ApiMode"] = boost::any(*apiMode);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = registrationDetails ? boost::any(registrationDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptDetails) {
      res["ScriptDetails"] = scriptDetails ? boost::any(scriptDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wizardDetails) {
      res["WizardDetails"] = wizardDetails ? boost::any(wizardDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiMode") != m.end() && !m["ApiMode"].empty()) {
      apiMode = make_shared<long>(boost::any_cast<long>(m["ApiMode"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<long>(boost::any_cast<long>(m["ResponseContentType"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<long>(boost::any_cast<long>(m["VisibleRange"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<long>(boost::any_cast<long>(m["RequestMethod"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      protocols = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegistrationDetails"].type()) {
        GetDataServiceApiResponseBodyDataRegistrationDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegistrationDetails"]));
        registrationDetails = make_shared<GetDataServiceApiResponseBodyDataRegistrationDetails>(model1);
      }
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptDetails"].type()) {
        GetDataServiceApiResponseBodyDataScriptDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptDetails"]));
        scriptDetails = make_shared<GetDataServiceApiResponseBodyDataScriptDetails>(model1);
      }
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardDetails"].type()) {
        GetDataServiceApiResponseBodyDataWizardDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardDetails"]));
        wizardDetails = make_shared<GetDataServiceApiResponseBodyDataWizardDetails>(model1);
      }
    }
  }


  virtual ~GetDataServiceApiResponseBodyData() = default;
};
class GetDataServiceApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetDataServiceApiResponseBodyData> data{};

  GetDataServiceApiResponseBody() {}

  explicit GetDataServiceApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataServiceApiResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataServiceApiResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetDataServiceApiResponseBody() = default;
};
class GetDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDataServiceApiResponseBody> body{};

  GetDataServiceApiResponse() {}

  explicit GetDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataServiceApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataServiceApiResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataServiceApiResponse() = default;
};
class GetDataServiceApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> applicationId{};

  GetDataServiceApplicationRequest() {}

  explicit GetDataServiceApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<long>(boost::any_cast<long>(m["ApplicationId"]));
    }
  }


  virtual ~GetDataServiceApplicationRequest() = default;
};
class GetDataServiceApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> applicationCode{};
  shared_ptr<string> applicationKey{};
  shared_ptr<string> applicationSecret{};
  shared_ptr<long> projectId{};
  shared_ptr<string> applicationName{};
  shared_ptr<long> applicationId{};

  GetDataServiceApplicationResponseBodyData() {}

  explicit GetDataServiceApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationCode) {
      res["ApplicationCode"] = boost::any(*applicationCode);
    }
    if (applicationKey) {
      res["ApplicationKey"] = boost::any(*applicationKey);
    }
    if (applicationSecret) {
      res["ApplicationSecret"] = boost::any(*applicationSecret);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationCode") != m.end() && !m["ApplicationCode"].empty()) {
      applicationCode = make_shared<string>(boost::any_cast<string>(m["ApplicationCode"]));
    }
    if (m.find("ApplicationKey") != m.end() && !m["ApplicationKey"].empty()) {
      applicationKey = make_shared<string>(boost::any_cast<string>(m["ApplicationKey"]));
    }
    if (m.find("ApplicationSecret") != m.end() && !m["ApplicationSecret"].empty()) {
      applicationSecret = make_shared<string>(boost::any_cast<string>(m["ApplicationSecret"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<long>(boost::any_cast<long>(m["ApplicationId"]));
    }
  }


  virtual ~GetDataServiceApplicationResponseBodyData() = default;
};
class GetDataServiceApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetDataServiceApplicationResponseBodyData> data{};

  GetDataServiceApplicationResponseBody() {}

  explicit GetDataServiceApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataServiceApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataServiceApplicationResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetDataServiceApplicationResponseBody() = default;
};
class GetDataServiceApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDataServiceApplicationResponseBody> body{};

  GetDataServiceApplicationResponse() {}

  explicit GetDataServiceApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataServiceApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataServiceApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataServiceApplicationResponse() = default;
};
class GetDataServiceFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> folderId{};

  GetDataServiceFolderRequest() {}

  explicit GetDataServiceFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
  }


  virtual ~GetDataServiceFolderRequest() = default;
};
class GetDataServiceFolderResponseBodyFolder : public Darabonba::Model {
public:
  shared_ptr<long> parentId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> groupId{};
  shared_ptr<long> folderId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> folderName{};
  shared_ptr<string> createdTime{};
  shared_ptr<long> tenantId{};

  GetDataServiceFolderResponseBodyFolder() {}

  explicit GetDataServiceFolderResponseBodyFolder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~GetDataServiceFolderResponseBodyFolder() = default;
};
class GetDataServiceFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetDataServiceFolderResponseBodyFolder> folder{};

  GetDataServiceFolderResponseBody() {}

  explicit GetDataServiceFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (folder) {
      res["Folder"] = folder ? boost::any(folder->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Folder") != m.end() && !m["Folder"].empty()) {
      if (typeid(map<string, boost::any>) == m["Folder"].type()) {
        GetDataServiceFolderResponseBodyFolder model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Folder"]));
        folder = make_shared<GetDataServiceFolderResponseBodyFolder>(model1);
      }
    }
  }


  virtual ~GetDataServiceFolderResponseBody() = default;
};
class GetDataServiceFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDataServiceFolderResponseBody> body{};

  GetDataServiceFolderResponse() {}

  explicit GetDataServiceFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataServiceFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataServiceFolderResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataServiceFolderResponse() = default;
};
class GetDataServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> groupId{};

  GetDataServiceGroupRequest() {}

  explicit GetDataServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~GetDataServiceGroupRequest() = default;
};
class GetDataServiceGroupResponseBodyGroup : public Darabonba::Model {
public:
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> apiGatewayGroupId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> createdTime{};
  shared_ptr<long> tenantId{};

  GetDataServiceGroupResponseBodyGroup() {}

  explicit GetDataServiceGroupResponseBodyGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiGatewayGroupId) {
      res["ApiGatewayGroupId"] = boost::any(*apiGatewayGroupId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiGatewayGroupId") != m.end() && !m["ApiGatewayGroupId"].empty()) {
      apiGatewayGroupId = make_shared<string>(boost::any_cast<string>(m["ApiGatewayGroupId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~GetDataServiceGroupResponseBodyGroup() = default;
};
class GetDataServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetDataServiceGroupResponseBodyGroup> group{};

  GetDataServiceGroupResponseBody() {}

  explicit GetDataServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (group) {
      res["Group"] = group ? boost::any(group->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      if (typeid(map<string, boost::any>) == m["Group"].type()) {
        GetDataServiceGroupResponseBodyGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Group"]));
        group = make_shared<GetDataServiceGroupResponseBodyGroup>(model1);
      }
    }
  }


  virtual ~GetDataServiceGroupResponseBody() = default;
};
class GetDataServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDataServiceGroupResponseBody> body{};

  GetDataServiceGroupResponse() {}

  explicit GetDataServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataServiceGroupResponse() = default;
};
class GetDataServicePublishedApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<long> apiId{};

  GetDataServicePublishedApiRequest() {}

  explicit GetDataServicePublishedApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
  }


  virtual ~GetDataServicePublishedApiRequest() = default;
};
class GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorSolution{};

  GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes() {}

  explicit GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes() = default;
};
class GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<string> exampleValue{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<bool> isRequiredParameter{};

  GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters() {}

  explicit GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters() = default;
};
class GetDataServicePublishedApiResponseBodyDataRegistrationDetails : public Darabonba::Model {
public:
  shared_ptr<string> serviceHost{};
  shared_ptr<long> serviceContentType{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<string> failedResultSample{};
  shared_ptr<string> serviceRequestBodyDescription{};
  shared_ptr<vector<GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes>> registrationErrorCodes{};
  shared_ptr<vector<GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters>> registrationRequestParameters{};

  GetDataServicePublishedApiResponseBodyDataRegistrationDetails() {}

  explicit GetDataServicePublishedApiResponseBodyDataRegistrationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceHost) {
      res["ServiceHost"] = boost::any(*serviceHost);
    }
    if (serviceContentType) {
      res["ServiceContentType"] = boost::any(*serviceContentType);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (serviceRequestBodyDescription) {
      res["ServiceRequestBodyDescription"] = boost::any(*serviceRequestBodyDescription);
    }
    if (registrationErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*registrationErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationErrorCodes"] = boost::any(temp1);
    }
    if (registrationRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*registrationRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationRequestParameters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceHost") != m.end() && !m["ServiceHost"].empty()) {
      serviceHost = make_shared<string>(boost::any_cast<string>(m["ServiceHost"]));
    }
    if (m.find("ServiceContentType") != m.end() && !m["ServiceContentType"].empty()) {
      serviceContentType = make_shared<long>(boost::any_cast<long>(m["ServiceContentType"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("ServiceRequestBodyDescription") != m.end() && !m["ServiceRequestBodyDescription"].empty()) {
      serviceRequestBodyDescription = make_shared<string>(boost::any_cast<string>(m["ServiceRequestBodyDescription"]));
    }
    if (m.find("RegistrationErrorCodes") != m.end() && !m["RegistrationErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationErrorCodes"].type()) {
        vector<GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationErrorCodes = make_shared<vector<GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes>>(expect1);
      }
    }
    if (m.find("RegistrationRequestParameters") != m.end() && !m["RegistrationRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationRequestParameters"].type()) {
        vector<GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationRequestParameters = make_shared<vector<GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters>>(expect1);
      }
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataRegistrationDetails() = default;
};
class GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorSolution{};

  GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes() {}

  explicit GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes() = default;
};
class GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<string> exampleValue{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<bool> isRequiredParameter{};

  GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters() {}

  explicit GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters() = default;
};
class GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> exampleValue{};
  shared_ptr<long> parameterDataType{};

  GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters() {}

  explicit GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters() = default;
};
class GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<long> connectionId{};

  GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection() {}

  explicit GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection() = default;
};
class GetDataServicePublishedApiResponseBodyDataScriptDetails : public Darabonba::Model {
public:
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<string> failedResultSample{};
  shared_ptr<string> script{};
  shared_ptr<vector<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes>> scriptErrorCodes{};
  shared_ptr<vector<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters>> scriptRequestParameters{};
  shared_ptr<vector<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters>> scriptResponseParameters{};
  shared_ptr<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection> scriptConnection{};

  GetDataServicePublishedApiResponseBodyDataScriptDetails() {}

  explicit GetDataServicePublishedApiResponseBodyDataScriptDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (scriptErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*scriptErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptErrorCodes"] = boost::any(temp1);
    }
    if (scriptRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptRequestParameters"] = boost::any(temp1);
    }
    if (scriptResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptResponseParameters"] = boost::any(temp1);
    }
    if (scriptConnection) {
      res["ScriptConnection"] = scriptConnection ? boost::any(scriptConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("ScriptErrorCodes") != m.end() && !m["ScriptErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptErrorCodes"].type()) {
        vector<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptErrorCodes = make_shared<vector<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes>>(expect1);
      }
    }
    if (m.find("ScriptRequestParameters") != m.end() && !m["ScriptRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptRequestParameters"].type()) {
        vector<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptRequestParameters = make_shared<vector<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters>>(expect1);
      }
    }
    if (m.find("ScriptResponseParameters") != m.end() && !m["ScriptResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptResponseParameters"].type()) {
        vector<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptResponseParameters = make_shared<vector<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters>>(expect1);
      }
    }
    if (m.find("ScriptConnection") != m.end() && !m["ScriptConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptConnection"].type()) {
        GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptConnection"]));
        scriptConnection = make_shared<GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection>(model1);
      }
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataScriptDetails() = default;
};
class GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorSolution{};

  GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes() {}

  explicit GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes() = default;
};
class GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<string> exampleValue{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<bool> isRequiredParameter{};

  GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters() {}

  explicit GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters() = default;
};
class GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> exampleValue{};
  shared_ptr<long> parameterDataType{};

  GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters() {}

  explicit GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters() = default;
};
class GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<long> connectionId{};

  GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection() {}

  explicit GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection() = default;
};
class GetDataServicePublishedApiResponseBodyDataWizardDetails : public Darabonba::Model {
public:
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<string> failedResultSample{};
  shared_ptr<vector<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes>> wizardErrorCodes{};
  shared_ptr<vector<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters>> wizardRequestParameters{};
  shared_ptr<vector<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters>> wizardResponseParameters{};
  shared_ptr<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection> wizardConnection{};

  GetDataServicePublishedApiResponseBodyDataWizardDetails() {}

  explicit GetDataServicePublishedApiResponseBodyDataWizardDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (wizardErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*wizardErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardErrorCodes"] = boost::any(temp1);
    }
    if (wizardRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardRequestParameters"] = boost::any(temp1);
    }
    if (wizardResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardResponseParameters"] = boost::any(temp1);
    }
    if (wizardConnection) {
      res["WizardConnection"] = wizardConnection ? boost::any(wizardConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("WizardErrorCodes") != m.end() && !m["WizardErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardErrorCodes"].type()) {
        vector<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardErrorCodes = make_shared<vector<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes>>(expect1);
      }
    }
    if (m.find("WizardRequestParameters") != m.end() && !m["WizardRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardRequestParameters"].type()) {
        vector<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardRequestParameters = make_shared<vector<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters>>(expect1);
      }
    }
    if (m.find("WizardResponseParameters") != m.end() && !m["WizardResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardResponseParameters"].type()) {
        vector<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardResponseParameters = make_shared<vector<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters>>(expect1);
      }
    }
    if (m.find("WizardConnection") != m.end() && !m["WizardConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardConnection"].type()) {
        GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardConnection"]));
        wizardConnection = make_shared<GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection>(model1);
      }
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyDataWizardDetails() = default;
};
class GetDataServicePublishedApiResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> timeout{};
  shared_ptr<long> status{};
  shared_ptr<long> apiId{};
  shared_ptr<long> apiMode{};
  shared_ptr<long> projectId{};
  shared_ptr<long> responseContentType{};
  shared_ptr<string> creatorId{};
  shared_ptr<long> visibleRange{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> description{};
  shared_ptr<long> requestMethod{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> apiName{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiPath{};
  shared_ptr<vector<long>> protocols{};
  shared_ptr<GetDataServicePublishedApiResponseBodyDataRegistrationDetails> registrationDetails{};
  shared_ptr<GetDataServicePublishedApiResponseBodyDataScriptDetails> scriptDetails{};
  shared_ptr<GetDataServicePublishedApiResponseBodyDataWizardDetails> wizardDetails{};

  GetDataServicePublishedApiResponseBodyData() {}

  explicit GetDataServicePublishedApiResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMode) {
      res["ApiMode"] = boost::any(*apiMode);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = registrationDetails ? boost::any(registrationDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptDetails) {
      res["ScriptDetails"] = scriptDetails ? boost::any(scriptDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wizardDetails) {
      res["WizardDetails"] = wizardDetails ? boost::any(wizardDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiMode") != m.end() && !m["ApiMode"].empty()) {
      apiMode = make_shared<long>(boost::any_cast<long>(m["ApiMode"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<long>(boost::any_cast<long>(m["ResponseContentType"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<long>(boost::any_cast<long>(m["VisibleRange"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<long>(boost::any_cast<long>(m["RequestMethod"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      protocols = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegistrationDetails"].type()) {
        GetDataServicePublishedApiResponseBodyDataRegistrationDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegistrationDetails"]));
        registrationDetails = make_shared<GetDataServicePublishedApiResponseBodyDataRegistrationDetails>(model1);
      }
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptDetails"].type()) {
        GetDataServicePublishedApiResponseBodyDataScriptDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptDetails"]));
        scriptDetails = make_shared<GetDataServicePublishedApiResponseBodyDataScriptDetails>(model1);
      }
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardDetails"].type()) {
        GetDataServicePublishedApiResponseBodyDataWizardDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardDetails"]));
        wizardDetails = make_shared<GetDataServicePublishedApiResponseBodyDataWizardDetails>(model1);
      }
    }
  }


  virtual ~GetDataServicePublishedApiResponseBodyData() = default;
};
class GetDataServicePublishedApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetDataServicePublishedApiResponseBodyData> data{};

  GetDataServicePublishedApiResponseBody() {}

  explicit GetDataServicePublishedApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataServicePublishedApiResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataServicePublishedApiResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetDataServicePublishedApiResponseBody() = default;
};
class GetDataServicePublishedApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDataServicePublishedApiResponseBody> body{};

  GetDataServicePublishedApiResponse() {}

  explicit GetDataServicePublishedApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataServicePublishedApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataServicePublishedApiResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataServicePublishedApiResponse() = default;
};
class GetDDLJobStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  GetDDLJobStatusRequest() {}

  explicit GetDDLJobStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetDDLJobStatusRequest() = default;
};
class GetDDLJobStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};

  GetDDLJobStatusResponseBodyData() {}

  explicit GetDDLJobStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~GetDDLJobStatusResponseBodyData() = default;
};
class GetDDLJobStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetDDLJobStatusResponseBodyData> data{};

  GetDDLJobStatusResponseBody() {}

  explicit GetDDLJobStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDDLJobStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDDLJobStatusResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetDDLJobStatusResponseBody() = default;
};
class GetDDLJobStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDDLJobStatusResponseBody> body{};

  GetDDLJobStatusResponse() {}

  explicit GetDDLJobStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDDLJobStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDDLJobStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetDDLJobStatusResponse() = default;
};
class GetDeploymentRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> deploymentId{};

  GetDeploymentRequest() {}

  explicit GetDeploymentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (deploymentId) {
      res["DeploymentId"] = boost::any(*deploymentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("DeploymentId") != m.end() && !m["DeploymentId"].empty()) {
      deploymentId = make_shared<long>(boost::any_cast<long>(m["DeploymentId"]));
    }
  }


  virtual ~GetDeploymentRequest() = default;
};
class GetDeploymentResponseBodyDataDeployment : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> fromEnvironment{};
  shared_ptr<long> toEnvironment{};
  shared_ptr<long> createTime{};
  shared_ptr<string> handlerId{};
  shared_ptr<string> creatorId{};
  shared_ptr<long> executeTime{};
  shared_ptr<string> name{};

  GetDeploymentResponseBodyDataDeployment() {}

  explicit GetDeploymentResponseBodyDataDeployment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (fromEnvironment) {
      res["FromEnvironment"] = boost::any(*fromEnvironment);
    }
    if (toEnvironment) {
      res["ToEnvironment"] = boost::any(*toEnvironment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (handlerId) {
      res["HandlerId"] = boost::any(*handlerId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FromEnvironment") != m.end() && !m["FromEnvironment"].empty()) {
      fromEnvironment = make_shared<long>(boost::any_cast<long>(m["FromEnvironment"]));
    }
    if (m.find("ToEnvironment") != m.end() && !m["ToEnvironment"].empty()) {
      toEnvironment = make_shared<long>(boost::any_cast<long>(m["ToEnvironment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("HandlerId") != m.end() && !m["HandlerId"].empty()) {
      handlerId = make_shared<string>(boost::any_cast<string>(m["HandlerId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<long>(boost::any_cast<long>(m["ExecuteTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetDeploymentResponseBodyDataDeployment() = default;
};
class GetDeploymentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDeploymentResponseBodyDataDeployment> deployment{};

  GetDeploymentResponseBodyData() {}

  explicit GetDeploymentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployment) {
      res["Deployment"] = deployment ? boost::any(deployment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deployment") != m.end() && !m["Deployment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deployment"].type()) {
        GetDeploymentResponseBodyDataDeployment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deployment"]));
        deployment = make_shared<GetDeploymentResponseBodyDataDeployment>(model1);
      }
    }
  }


  virtual ~GetDeploymentResponseBodyData() = default;
};
class GetDeploymentResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetDeploymentResponseBodyData> data{};

  GetDeploymentResponseBody() {}

  explicit GetDeploymentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDeploymentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDeploymentResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetDeploymentResponseBody() = default;
};
class GetDeploymentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDeploymentResponseBody> body{};

  GetDeploymentResponse() {}

  explicit GetDeploymentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeploymentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeploymentResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeploymentResponse() = default;
};
class GetFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileId{};

  GetFileRequest() {}

  explicit GetFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~GetFileRequest() = default;
};
class GetFileResponseBodyDataFile : public Darabonba::Model {
public:
  shared_ptr<long> commitStatus{};
  shared_ptr<bool> autoParsing{};
  shared_ptr<string> owner{};
  shared_ptr<long> createTime{};
  shared_ptr<long> fileType{};
  shared_ptr<long> currentVersion{};
  shared_ptr<long> bizId{};
  shared_ptr<string> lastEditUser{};
  shared_ptr<string> fileName{};
  shared_ptr<string> connectionName{};
  shared_ptr<string> useType{};
  shared_ptr<string> fileFolderId{};
  shared_ptr<long> parentId{};
  shared_ptr<string> createUser{};
  shared_ptr<bool> isMaxCompute{};
  shared_ptr<long> businessId{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> deletedStatus{};
  shared_ptr<long> lastEditTime{};
  shared_ptr<string> content{};
  shared_ptr<long> nodeId{};

  GetFileResponseBodyDataFile() {}

  explicit GetFileResponseBodyDataFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitStatus) {
      res["CommitStatus"] = boost::any(*commitStatus);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lastEditUser) {
      res["LastEditUser"] = boost::any(*lastEditUser);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    if (fileFolderId) {
      res["FileFolderId"] = boost::any(*fileFolderId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (isMaxCompute) {
      res["IsMaxCompute"] = boost::any(*isMaxCompute);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (deletedStatus) {
      res["DeletedStatus"] = boost::any(*deletedStatus);
    }
    if (lastEditTime) {
      res["LastEditTime"] = boost::any(*lastEditTime);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommitStatus") != m.end() && !m["CommitStatus"].empty()) {
      commitStatus = make_shared<long>(boost::any_cast<long>(m["CommitStatus"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<long>(boost::any_cast<long>(m["CurrentVersion"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<long>(boost::any_cast<long>(m["BizId"]));
    }
    if (m.find("LastEditUser") != m.end() && !m["LastEditUser"].empty()) {
      lastEditUser = make_shared<string>(boost::any_cast<string>(m["LastEditUser"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
    if (m.find("FileFolderId") != m.end() && !m["FileFolderId"].empty()) {
      fileFolderId = make_shared<string>(boost::any_cast<string>(m["FileFolderId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("IsMaxCompute") != m.end() && !m["IsMaxCompute"].empty()) {
      isMaxCompute = make_shared<bool>(boost::any_cast<bool>(m["IsMaxCompute"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("DeletedStatus") != m.end() && !m["DeletedStatus"].empty()) {
      deletedStatus = make_shared<string>(boost::any_cast<string>(m["DeletedStatus"]));
    }
    if (m.find("LastEditTime") != m.end() && !m["LastEditTime"].empty()) {
      lastEditTime = make_shared<long>(boost::any_cast<long>(m["LastEditTime"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetFileResponseBodyDataFile() = default;
};
class GetFileResponseBodyDataNodeConfigurationInputList : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> parseType{};

  GetFileResponseBodyDataNodeConfigurationInputList() {}

  explicit GetFileResponseBodyDataNodeConfigurationInputList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (parseType) {
      res["ParseType"] = boost::any(*parseType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("ParseType") != m.end() && !m["ParseType"].empty()) {
      parseType = make_shared<string>(boost::any_cast<string>(m["ParseType"]));
    }
  }


  virtual ~GetFileResponseBodyDataNodeConfigurationInputList() = default;
};
class GetFileResponseBodyDataNodeConfigurationOutputList : public Darabonba::Model {
public:
  shared_ptr<string> refTableName{};
  shared_ptr<string> output{};

  GetFileResponseBodyDataNodeConfigurationOutputList() {}

  explicit GetFileResponseBodyDataNodeConfigurationOutputList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refTableName) {
      res["RefTableName"] = boost::any(*refTableName);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RefTableName") != m.end() && !m["RefTableName"].empty()) {
      refTableName = make_shared<string>(boost::any_cast<string>(m["RefTableName"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
  }


  virtual ~GetFileResponseBodyDataNodeConfigurationOutputList() = default;
};
class GetFileResponseBodyDataNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> rerunMode{};
  shared_ptr<bool> stop{};
  shared_ptr<string> paraValue{};
  shared_ptr<long> startEffectDate{};
  shared_ptr<long> endEffectDate{};
  shared_ptr<string> cycleType{};
  shared_ptr<string> dependentNodeIdList{};
  shared_ptr<long> resourceGroupId{};
  shared_ptr<string> dependentType{};
  shared_ptr<long> autoRerunTimes{};
  shared_ptr<long> autoRerunIntervalMillis{};
  shared_ptr<string> cronExpress{};
  shared_ptr<vector<GetFileResponseBodyDataNodeConfigurationInputList>> inputList{};
  shared_ptr<vector<GetFileResponseBodyDataNodeConfigurationOutputList>> outputList{};

  GetFileResponseBodyDataNodeConfiguration() {}

  explicit GetFileResponseBodyDataNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (stop) {
      res["Stop"] = boost::any(*stop);
    }
    if (paraValue) {
      res["ParaValue"] = boost::any(*paraValue);
    }
    if (startEffectDate) {
      res["StartEffectDate"] = boost::any(*startEffectDate);
    }
    if (endEffectDate) {
      res["EndEffectDate"] = boost::any(*endEffectDate);
    }
    if (cycleType) {
      res["CycleType"] = boost::any(*cycleType);
    }
    if (dependentNodeIdList) {
      res["DependentNodeIdList"] = boost::any(*dependentNodeIdList);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (dependentType) {
      res["DependentType"] = boost::any(*dependentType);
    }
    if (autoRerunTimes) {
      res["AutoRerunTimes"] = boost::any(*autoRerunTimes);
    }
    if (autoRerunIntervalMillis) {
      res["AutoRerunIntervalMillis"] = boost::any(*autoRerunIntervalMillis);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (inputList) {
      vector<boost::any> temp1;
      for(auto item1:*inputList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputList"] = boost::any(temp1);
    }
    if (outputList) {
      vector<boost::any> temp1;
      for(auto item1:*outputList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("Stop") != m.end() && !m["Stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["Stop"]));
    }
    if (m.find("ParaValue") != m.end() && !m["ParaValue"].empty()) {
      paraValue = make_shared<string>(boost::any_cast<string>(m["ParaValue"]));
    }
    if (m.find("StartEffectDate") != m.end() && !m["StartEffectDate"].empty()) {
      startEffectDate = make_shared<long>(boost::any_cast<long>(m["StartEffectDate"]));
    }
    if (m.find("EndEffectDate") != m.end() && !m["EndEffectDate"].empty()) {
      endEffectDate = make_shared<long>(boost::any_cast<long>(m["EndEffectDate"]));
    }
    if (m.find("CycleType") != m.end() && !m["CycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["CycleType"]));
    }
    if (m.find("DependentNodeIdList") != m.end() && !m["DependentNodeIdList"].empty()) {
      dependentNodeIdList = make_shared<string>(boost::any_cast<string>(m["DependentNodeIdList"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<long>(boost::any_cast<long>(m["ResourceGroupId"]));
    }
    if (m.find("DependentType") != m.end() && !m["DependentType"].empty()) {
      dependentType = make_shared<string>(boost::any_cast<string>(m["DependentType"]));
    }
    if (m.find("AutoRerunTimes") != m.end() && !m["AutoRerunTimes"].empty()) {
      autoRerunTimes = make_shared<long>(boost::any_cast<long>(m["AutoRerunTimes"]));
    }
    if (m.find("AutoRerunIntervalMillis") != m.end() && !m["AutoRerunIntervalMillis"].empty()) {
      autoRerunIntervalMillis = make_shared<long>(boost::any_cast<long>(m["AutoRerunIntervalMillis"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      if (typeid(vector<boost::any>) == m["InputList"].type()) {
        vector<GetFileResponseBodyDataNodeConfigurationInputList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileResponseBodyDataNodeConfigurationInputList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputList = make_shared<vector<GetFileResponseBodyDataNodeConfigurationInputList>>(expect1);
      }
    }
    if (m.find("OutputList") != m.end() && !m["OutputList"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputList"].type()) {
        vector<GetFileResponseBodyDataNodeConfigurationOutputList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileResponseBodyDataNodeConfigurationOutputList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputList = make_shared<vector<GetFileResponseBodyDataNodeConfigurationOutputList>>(expect1);
      }
    }
  }


  virtual ~GetFileResponseBodyDataNodeConfiguration() = default;
};
class GetFileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetFileResponseBodyDataFile> file{};
  shared_ptr<GetFileResponseBodyDataNodeConfiguration> nodeConfiguration{};

  GetFileResponseBodyData() {}

  explicit GetFileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeConfiguration) {
      res["NodeConfiguration"] = nodeConfiguration ? boost::any(nodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetFileResponseBodyDataFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetFileResponseBodyDataFile>(model1);
      }
    }
    if (m.find("NodeConfiguration") != m.end() && !m["NodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeConfiguration"].type()) {
        GetFileResponseBodyDataNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeConfiguration"]));
        nodeConfiguration = make_shared<GetFileResponseBodyDataNodeConfiguration>(model1);
      }
    }
  }


  virtual ~GetFileResponseBodyData() = default;
};
class GetFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetFileResponseBodyData> data{};

  GetFileResponseBody() {}

  explicit GetFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFileResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetFileResponseBody() = default;
};
class GetFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetFileResponseBody> body{};

  GetFileResponse() {}

  explicit GetFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileResponse() = default;
};
class GetFileTypeStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectEnv{};

  GetFileTypeStatisticRequest() {}

  explicit GetFileTypeStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetFileTypeStatisticRequest() = default;
};
class GetFileTypeStatisticResponseBodyProgramTypeAndCounts : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> programType{};

  GetFileTypeStatisticResponseBodyProgramTypeAndCounts() {}

  explicit GetFileTypeStatisticResponseBodyProgramTypeAndCounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
  }


  virtual ~GetFileTypeStatisticResponseBodyProgramTypeAndCounts() = default;
};
class GetFileTypeStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetFileTypeStatisticResponseBodyProgramTypeAndCounts>> programTypeAndCounts{};

  GetFileTypeStatisticResponseBody() {}

  explicit GetFileTypeStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (programTypeAndCounts) {
      vector<boost::any> temp1;
      for(auto item1:*programTypeAndCounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProgramTypeAndCounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProgramTypeAndCounts") != m.end() && !m["ProgramTypeAndCounts"].empty()) {
      if (typeid(vector<boost::any>) == m["ProgramTypeAndCounts"].type()) {
        vector<GetFileTypeStatisticResponseBodyProgramTypeAndCounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProgramTypeAndCounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetFileTypeStatisticResponseBodyProgramTypeAndCounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programTypeAndCounts = make_shared<vector<GetFileTypeStatisticResponseBodyProgramTypeAndCounts>>(expect1);
      }
    }
  }


  virtual ~GetFileTypeStatisticResponseBody() = default;
};
class GetFileTypeStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetFileTypeStatisticResponseBody> body{};

  GetFileTypeStatisticResponse() {}

  explicit GetFileTypeStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileTypeStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileTypeStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileTypeStatisticResponse() = default;
};
class GetFileVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileVersion{};

  GetFileVersionRequest() {}

  explicit GetFileVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<long>(boost::any_cast<long>(m["FileVersion"]));
    }
  }


  virtual ~GetFileVersionRequest() = default;
};
class GetFileVersionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileContent{};
  shared_ptr<bool> isCurrentProd{};
  shared_ptr<string> status{};
  shared_ptr<string> nodeContent{};
  shared_ptr<string> commitUser{};
  shared_ptr<string> comment{};
  shared_ptr<string> filePropertyContent{};
  shared_ptr<string> fileName{};
  shared_ptr<string> useType{};
  shared_ptr<string> changeType{};
  shared_ptr<long> fileVersion{};
  shared_ptr<long> commitTime{};
  shared_ptr<long> nodeId{};

  GetFileVersionResponseBodyData() {}

  explicit GetFileVersionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileContent) {
      res["FileContent"] = boost::any(*fileContent);
    }
    if (isCurrentProd) {
      res["IsCurrentProd"] = boost::any(*isCurrentProd);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (commitUser) {
      res["CommitUser"] = boost::any(*commitUser);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (filePropertyContent) {
      res["FilePropertyContent"] = boost::any(*filePropertyContent);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    if (commitTime) {
      res["CommitTime"] = boost::any(*commitTime);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileContent") != m.end() && !m["FileContent"].empty()) {
      fileContent = make_shared<string>(boost::any_cast<string>(m["FileContent"]));
    }
    if (m.find("IsCurrentProd") != m.end() && !m["IsCurrentProd"].empty()) {
      isCurrentProd = make_shared<bool>(boost::any_cast<bool>(m["IsCurrentProd"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("CommitUser") != m.end() && !m["CommitUser"].empty()) {
      commitUser = make_shared<string>(boost::any_cast<string>(m["CommitUser"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("FilePropertyContent") != m.end() && !m["FilePropertyContent"].empty()) {
      filePropertyContent = make_shared<string>(boost::any_cast<string>(m["FilePropertyContent"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<long>(boost::any_cast<long>(m["FileVersion"]));
    }
    if (m.find("CommitTime") != m.end() && !m["CommitTime"].empty()) {
      commitTime = make_shared<long>(boost::any_cast<long>(m["CommitTime"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetFileVersionResponseBodyData() = default;
};
class GetFileVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetFileVersionResponseBodyData> data{};

  GetFileVersionResponseBody() {}

  explicit GetFileVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFileVersionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFileVersionResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetFileVersionResponseBody() = default;
};
class GetFileVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetFileVersionResponseBody> body{};

  GetFileVersionResponse() {}

  explicit GetFileVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileVersionResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileVersionResponse() = default;
};
class GetFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> folderId{};
  shared_ptr<string> folderPath{};

  GetFolderRequest() {}

  explicit GetFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
  }


  virtual ~GetFolderRequest() = default;
};
class GetFolderResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> folderPath{};
  shared_ptr<string> folderId{};

  GetFolderResponseBodyData() {}

  explicit GetFolderResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
  }


  virtual ~GetFolderResponseBodyData() = default;
};
class GetFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetFolderResponseBodyData> data{};

  GetFolderResponseBody() {}

  explicit GetFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetFolderResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetFolderResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetFolderResponseBody() = default;
};
class GetFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetFolderResponseBody> body{};

  GetFolderResponse() {}

  explicit GetFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFolderResponseBody>(model1);
      }
    }
  }


  virtual ~GetFolderResponse() = default;
};
class GetInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  GetInstanceRequest() {}

  explicit GetInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetInstanceRequest() = default;
};
class GetInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> cycTime{};
  shared_ptr<long> beginRunningTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> dagId{};
  shared_ptr<long> priority{};
  shared_ptr<string> taskType{};
  shared_ptr<string> paramValues{};
  shared_ptr<string> connection{};
  shared_ptr<long> baselineId{};
  shared_ptr<long> dqcType{};
  shared_ptr<string> dagType{};
  shared_ptr<long> taskRerunTime{};
  shared_ptr<long> modifyTime{};
  shared_ptr<bool> repeatability{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> beginWaitResTime{};
  shared_ptr<long> relatedFlowId{};
  shared_ptr<long> bizdate{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> beginWaitTimeTime{};
  shared_ptr<string> dqcDescription{};
  shared_ptr<long> nodeId{};

  GetInstanceResponseBodyData() {}

  explicit GetInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (cycTime) {
      res["CycTime"] = boost::any(*cycTime);
    }
    if (beginRunningTime) {
      res["BeginRunningTime"] = boost::any(*beginRunningTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (connection) {
      res["Connection"] = boost::any(*connection);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (dqcType) {
      res["DqcType"] = boost::any(*dqcType);
    }
    if (dagType) {
      res["DagType"] = boost::any(*dagType);
    }
    if (taskRerunTime) {
      res["TaskRerunTime"] = boost::any(*taskRerunTime);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (beginWaitResTime) {
      res["BeginWaitResTime"] = boost::any(*beginWaitResTime);
    }
    if (relatedFlowId) {
      res["RelatedFlowId"] = boost::any(*relatedFlowId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (beginWaitTimeTime) {
      res["BeginWaitTimeTime"] = boost::any(*beginWaitTimeTime);
    }
    if (dqcDescription) {
      res["DqcDescription"] = boost::any(*dqcDescription);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CycTime") != m.end() && !m["CycTime"].empty()) {
      cycTime = make_shared<long>(boost::any_cast<long>(m["CycTime"]));
    }
    if (m.find("BeginRunningTime") != m.end() && !m["BeginRunningTime"].empty()) {
      beginRunningTime = make_shared<long>(boost::any_cast<long>(m["BeginRunningTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("Connection") != m.end() && !m["Connection"].empty()) {
      connection = make_shared<string>(boost::any_cast<string>(m["Connection"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("DqcType") != m.end() && !m["DqcType"].empty()) {
      dqcType = make_shared<long>(boost::any_cast<long>(m["DqcType"]));
    }
    if (m.find("DagType") != m.end() && !m["DagType"].empty()) {
      dagType = make_shared<string>(boost::any_cast<string>(m["DagType"]));
    }
    if (m.find("TaskRerunTime") != m.end() && !m["TaskRerunTime"].empty()) {
      taskRerunTime = make_shared<long>(boost::any_cast<long>(m["TaskRerunTime"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("BeginWaitResTime") != m.end() && !m["BeginWaitResTime"].empty()) {
      beginWaitResTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitResTime"]));
    }
    if (m.find("RelatedFlowId") != m.end() && !m["RelatedFlowId"].empty()) {
      relatedFlowId = make_shared<long>(boost::any_cast<long>(m["RelatedFlowId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("BeginWaitTimeTime") != m.end() && !m["BeginWaitTimeTime"].empty()) {
      beginWaitTimeTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitTimeTime"]));
    }
    if (m.find("DqcDescription") != m.end() && !m["DqcDescription"].empty()) {
      dqcDescription = make_shared<string>(boost::any_cast<string>(m["DqcDescription"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetInstanceResponseBodyData() = default;
};
class GetInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetInstanceResponseBodyData> data{};

  GetInstanceResponseBody() {}

  explicit GetInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInstanceResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetInstanceResponseBody() = default;
};
class GetInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceResponseBody> body{};

  GetInstanceResponse() {}

  explicit GetInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceResponse() = default;
};
class GetInstanceConsumeTimeRankRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> bizdate{};

  GetInstanceConsumeTimeRankRequest() {}

  explicit GetInstanceConsumeTimeRankRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
  }


  virtual ~GetInstanceConsumeTimeRankRequest() = default;
};
class GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> prgType{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> consumed{};

  GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank() {}

  explicit GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (prgType) {
      res["PrgType"] = boost::any(*prgType);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (consumed) {
      res["Consumed"] = boost::any(*consumed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("PrgType") != m.end() && !m["PrgType"].empty()) {
      prgType = make_shared<long>(boost::any_cast<long>(m["PrgType"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Consumed") != m.end() && !m["Consumed"].empty()) {
      consumed = make_shared<long>(boost::any_cast<long>(m["Consumed"]));
    }
  }


  virtual ~GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank() = default;
};
class GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<vector<GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank>> consumeTimeRank{};

  GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank() {}

  explicit GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (consumeTimeRank) {
      vector<boost::any> temp1;
      for(auto item1:*consumeTimeRank){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumeTimeRank"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("ConsumeTimeRank") != m.end() && !m["ConsumeTimeRank"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumeTimeRank"].type()) {
        vector<GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumeTimeRank"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumeTimeRank = make_shared<vector<GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank>>(expect1);
      }
    }
  }


  virtual ~GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank() = default;
};
class GetInstanceConsumeTimeRankResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank> instanceConsumeTimeRank{};

  GetInstanceConsumeTimeRankResponseBody() {}

  explicit GetInstanceConsumeTimeRankResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceConsumeTimeRank) {
      res["InstanceConsumeTimeRank"] = instanceConsumeTimeRank ? boost::any(instanceConsumeTimeRank->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceConsumeTimeRank") != m.end() && !m["InstanceConsumeTimeRank"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceConsumeTimeRank"].type()) {
        GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceConsumeTimeRank"]));
        instanceConsumeTimeRank = make_shared<GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank>(model1);
      }
    }
  }


  virtual ~GetInstanceConsumeTimeRankResponseBody() = default;
};
class GetInstanceConsumeTimeRankResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceConsumeTimeRankResponseBody> body{};

  GetInstanceConsumeTimeRankResponse() {}

  explicit GetInstanceConsumeTimeRankResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceConsumeTimeRankResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceConsumeTimeRankResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceConsumeTimeRankResponse() = default;
};
class GetInstanceCountTrendRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> beginDate{};
  shared_ptr<string> endDate{};

  GetInstanceCountTrendRequest() {}

  explicit GetInstanceCountTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (beginDate) {
      res["BeginDate"] = boost::any(*beginDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BeginDate") != m.end() && !m["BeginDate"].empty()) {
      beginDate = make_shared<string>(boost::any_cast<string>(m["BeginDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
  }


  virtual ~GetInstanceCountTrendRequest() = default;
};
class GetInstanceCountTrendResponseBodyInstanceCounts : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<long> count{};

  GetInstanceCountTrendResponseBodyInstanceCounts() {}

  explicit GetInstanceCountTrendResponseBodyInstanceCounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["Date"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetInstanceCountTrendResponseBodyInstanceCounts() = default;
};
class GetInstanceCountTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetInstanceCountTrendResponseBodyInstanceCounts>> instanceCounts{};

  GetInstanceCountTrendResponseBody() {}

  explicit GetInstanceCountTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceCounts) {
      vector<boost::any> temp1;
      for(auto item1:*instanceCounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceCounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceCounts") != m.end() && !m["InstanceCounts"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceCounts"].type()) {
        vector<GetInstanceCountTrendResponseBodyInstanceCounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceCounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceCountTrendResponseBodyInstanceCounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceCounts = make_shared<vector<GetInstanceCountTrendResponseBodyInstanceCounts>>(expect1);
      }
    }
  }


  virtual ~GetInstanceCountTrendResponseBody() = default;
};
class GetInstanceCountTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceCountTrendResponseBody> body{};

  GetInstanceCountTrendResponse() {}

  explicit GetInstanceCountTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceCountTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceCountTrendResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceCountTrendResponse() = default;
};
class GetInstanceErrorRankRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  GetInstanceErrorRankRequest() {}

  explicit GetInstanceErrorRankRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetInstanceErrorRankRequest() = default;
};
class GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> projectId{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> count{};
  shared_ptr<long> prgType{};

  GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank() {}

  explicit GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (prgType) {
      res["PrgType"] = boost::any(*prgType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("PrgType") != m.end() && !m["PrgType"].empty()) {
      prgType = make_shared<long>(boost::any_cast<long>(m["PrgType"]));
    }
  }


  virtual ~GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank() = default;
};
class GetInstanceErrorRankResponseBodyInstanceErrorRank : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<vector<GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank>> errorRank{};

  GetInstanceErrorRankResponseBodyInstanceErrorRank() {}

  explicit GetInstanceErrorRankResponseBodyInstanceErrorRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (errorRank) {
      vector<boost::any> temp1;
      for(auto item1:*errorRank){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorRank"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("ErrorRank") != m.end() && !m["ErrorRank"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorRank"].type()) {
        vector<GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorRank"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorRank = make_shared<vector<GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank>>(expect1);
      }
    }
  }


  virtual ~GetInstanceErrorRankResponseBodyInstanceErrorRank() = default;
};
class GetInstanceErrorRankResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetInstanceErrorRankResponseBodyInstanceErrorRank> instanceErrorRank{};

  GetInstanceErrorRankResponseBody() {}

  explicit GetInstanceErrorRankResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceErrorRank) {
      res["InstanceErrorRank"] = instanceErrorRank ? boost::any(instanceErrorRank->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceErrorRank") != m.end() && !m["InstanceErrorRank"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorRank"].type()) {
        GetInstanceErrorRankResponseBodyInstanceErrorRank model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorRank"]));
        instanceErrorRank = make_shared<GetInstanceErrorRankResponseBodyInstanceErrorRank>(model1);
      }
    }
  }


  virtual ~GetInstanceErrorRankResponseBody() = default;
};
class GetInstanceErrorRankResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceErrorRankResponseBody> body{};

  GetInstanceErrorRankResponse() {}

  explicit GetInstanceErrorRankResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceErrorRankResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceErrorRankResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceErrorRankResponse() = default;
};
class GetInstanceLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  GetInstanceLogRequest() {}

  explicit GetInstanceLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetInstanceLogRequest() = default;
};
class GetInstanceLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  GetInstanceLogResponseBody() {}

  explicit GetInstanceLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInstanceLogResponseBody() = default;
};
class GetInstanceLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceLogResponseBody> body{};

  GetInstanceLogResponse() {}

  explicit GetInstanceLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceLogResponse() = default;
};
class GetInstanceStatusCountRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectEnv{};
  shared_ptr<string> bizDate{};

  GetInstanceStatusCountRequest() {}

  explicit GetInstanceStatusCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
  }


  virtual ~GetInstanceStatusCountRequest() = default;
};
class GetInstanceStatusCountResponseBodyStatusCount : public Darabonba::Model {
public:
  shared_ptr<long> failureCount{};
  shared_ptr<long> waitTimeCount{};
  shared_ptr<long> runningCount{};
  shared_ptr<long> successCount{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> notRunCount{};
  shared_ptr<long> waitResCount{};

  GetInstanceStatusCountResponseBodyStatusCount() {}

  explicit GetInstanceStatusCountResponseBodyStatusCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failureCount) {
      res["FailureCount"] = boost::any(*failureCount);
    }
    if (waitTimeCount) {
      res["WaitTimeCount"] = boost::any(*waitTimeCount);
    }
    if (runningCount) {
      res["RunningCount"] = boost::any(*runningCount);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (notRunCount) {
      res["NotRunCount"] = boost::any(*notRunCount);
    }
    if (waitResCount) {
      res["WaitResCount"] = boost::any(*waitResCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailureCount") != m.end() && !m["FailureCount"].empty()) {
      failureCount = make_shared<long>(boost::any_cast<long>(m["FailureCount"]));
    }
    if (m.find("WaitTimeCount") != m.end() && !m["WaitTimeCount"].empty()) {
      waitTimeCount = make_shared<long>(boost::any_cast<long>(m["WaitTimeCount"]));
    }
    if (m.find("RunningCount") != m.end() && !m["RunningCount"].empty()) {
      runningCount = make_shared<long>(boost::any_cast<long>(m["RunningCount"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NotRunCount") != m.end() && !m["NotRunCount"].empty()) {
      notRunCount = make_shared<long>(boost::any_cast<long>(m["NotRunCount"]));
    }
    if (m.find("WaitResCount") != m.end() && !m["WaitResCount"].empty()) {
      waitResCount = make_shared<long>(boost::any_cast<long>(m["WaitResCount"]));
    }
  }


  virtual ~GetInstanceStatusCountResponseBodyStatusCount() = default;
};
class GetInstanceStatusCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetInstanceStatusCountResponseBodyStatusCount> statusCount{};

  GetInstanceStatusCountResponseBody() {}

  explicit GetInstanceStatusCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCount) {
      res["StatusCount"] = statusCount ? boost::any(statusCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCount") != m.end() && !m["StatusCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatusCount"].type()) {
        GetInstanceStatusCountResponseBodyStatusCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatusCount"]));
        statusCount = make_shared<GetInstanceStatusCountResponseBodyStatusCount>(model1);
      }
    }
  }


  virtual ~GetInstanceStatusCountResponseBody() = default;
};
class GetInstanceStatusCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceStatusCountResponseBody> body{};

  GetInstanceStatusCountResponse() {}

  explicit GetInstanceStatusCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceStatusCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceStatusCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceStatusCountResponse() = default;
};
class GetInstanceStatusStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectEnv{};
  shared_ptr<string> bizDate{};

  GetInstanceStatusStatisticRequest() {}

  explicit GetInstanceStatusStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
  }


  virtual ~GetInstanceStatusStatisticRequest() = default;
};
class GetInstanceStatusStatisticResponseBodyStatusCount : public Darabonba::Model {
public:
  shared_ptr<long> failureCount{};
  shared_ptr<long> waitTimeCount{};
  shared_ptr<long> runningCount{};
  shared_ptr<long> successCount{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> notRunCount{};
  shared_ptr<long> waitResCount{};

  GetInstanceStatusStatisticResponseBodyStatusCount() {}

  explicit GetInstanceStatusStatisticResponseBodyStatusCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failureCount) {
      res["FailureCount"] = boost::any(*failureCount);
    }
    if (waitTimeCount) {
      res["WaitTimeCount"] = boost::any(*waitTimeCount);
    }
    if (runningCount) {
      res["RunningCount"] = boost::any(*runningCount);
    }
    if (successCount) {
      res["SuccessCount"] = boost::any(*successCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (notRunCount) {
      res["NotRunCount"] = boost::any(*notRunCount);
    }
    if (waitResCount) {
      res["WaitResCount"] = boost::any(*waitResCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailureCount") != m.end() && !m["FailureCount"].empty()) {
      failureCount = make_shared<long>(boost::any_cast<long>(m["FailureCount"]));
    }
    if (m.find("WaitTimeCount") != m.end() && !m["WaitTimeCount"].empty()) {
      waitTimeCount = make_shared<long>(boost::any_cast<long>(m["WaitTimeCount"]));
    }
    if (m.find("RunningCount") != m.end() && !m["RunningCount"].empty()) {
      runningCount = make_shared<long>(boost::any_cast<long>(m["RunningCount"]));
    }
    if (m.find("SuccessCount") != m.end() && !m["SuccessCount"].empty()) {
      successCount = make_shared<long>(boost::any_cast<long>(m["SuccessCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NotRunCount") != m.end() && !m["NotRunCount"].empty()) {
      notRunCount = make_shared<long>(boost::any_cast<long>(m["NotRunCount"]));
    }
    if (m.find("WaitResCount") != m.end() && !m["WaitResCount"].empty()) {
      waitResCount = make_shared<long>(boost::any_cast<long>(m["WaitResCount"]));
    }
  }


  virtual ~GetInstanceStatusStatisticResponseBodyStatusCount() = default;
};
class GetInstanceStatusStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetInstanceStatusStatisticResponseBodyStatusCount> statusCount{};

  GetInstanceStatusStatisticResponseBody() {}

  explicit GetInstanceStatusStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCount) {
      res["StatusCount"] = statusCount ? boost::any(statusCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCount") != m.end() && !m["StatusCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatusCount"].type()) {
        GetInstanceStatusStatisticResponseBodyStatusCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatusCount"]));
        statusCount = make_shared<GetInstanceStatusStatisticResponseBodyStatusCount>(model1);
      }
    }
  }


  virtual ~GetInstanceStatusStatisticResponseBody() = default;
};
class GetInstanceStatusStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceStatusStatisticResponseBody> body{};

  GetInstanceStatusStatisticResponse() {}

  explicit GetInstanceStatusStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceStatusStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceStatusStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceStatusStatisticResponse() = default;
};
class GetManualDagInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> projectName{};
  shared_ptr<string> dagId{};

  GetManualDagInstancesRequest() {}

  explicit GetManualDagInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<string>(boost::any_cast<string>(m["DagId"]));
    }
  }


  virtual ~GetManualDagInstancesRequest() = default;
};
class GetManualDagInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> beginRunningTime{};
  shared_ptr<long> bizDate{};
  shared_ptr<long> cycTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> dagId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> beginWaitResTime{};
  shared_ptr<string> taskType{};
  shared_ptr<string> paramValues{};
  shared_ptr<string> dagType{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> beginWaitTimeTime{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> modifyTime{};

  GetManualDagInstancesResponseBodyInstances() {}

  explicit GetManualDagInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (beginRunningTime) {
      res["BeginRunningTime"] = boost::any(*beginRunningTime);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (cycTime) {
      res["CycTime"] = boost::any(*cycTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (beginWaitResTime) {
      res["BeginWaitResTime"] = boost::any(*beginWaitResTime);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (dagType) {
      res["DagType"] = boost::any(*dagType);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (beginWaitTimeTime) {
      res["BeginWaitTimeTime"] = boost::any(*beginWaitTimeTime);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("BeginRunningTime") != m.end() && !m["BeginRunningTime"].empty()) {
      beginRunningTime = make_shared<long>(boost::any_cast<long>(m["BeginRunningTime"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("CycTime") != m.end() && !m["CycTime"].empty()) {
      cycTime = make_shared<long>(boost::any_cast<long>(m["CycTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("BeginWaitResTime") != m.end() && !m["BeginWaitResTime"].empty()) {
      beginWaitResTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitResTime"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("DagType") != m.end() && !m["DagType"].empty()) {
      dagType = make_shared<string>(boost::any_cast<string>(m["DagType"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("BeginWaitTimeTime") != m.end() && !m["BeginWaitTimeTime"].empty()) {
      beginWaitTimeTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitTimeTime"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
  }


  virtual ~GetManualDagInstancesResponseBodyInstances() = default;
};
class GetManualDagInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetManualDagInstancesResponseBodyInstances>> instances{};

  GetManualDagInstancesResponseBody() {}

  explicit GetManualDagInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<GetManualDagInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetManualDagInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<GetManualDagInstancesResponseBodyInstances>>(expect1);
      }
    }
  }


  virtual ~GetManualDagInstancesResponseBody() = default;
};
class GetManualDagInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetManualDagInstancesResponseBody> body{};

  GetManualDagInstancesResponse() {}

  explicit GetManualDagInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetManualDagInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetManualDagInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~GetManualDagInstancesResponse() = default;
};
class GetMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> parentCategoryId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  GetMetaCategoryRequest() {}

  explicit GetMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentCategoryId) {
      res["ParentCategoryId"] = boost::any(*parentCategoryId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentCategoryId") != m.end() && !m["ParentCategoryId"].empty()) {
      parentCategoryId = make_shared<long>(boost::any_cast<long>(m["ParentCategoryId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetMetaCategoryRequest() = default;
};
class GetMetaCategoryResponseBodyDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<long> depth{};
  shared_ptr<string> comment{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> categoryId{};
  shared_ptr<string> lastOperatorId{};
  shared_ptr<string> name{};
  shared_ptr<long> parentCategoryId{};
  shared_ptr<string> ownerId{};

  GetMetaCategoryResponseBodyDataDataEntityList() {}

  explicit GetMetaCategoryResponseBodyDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (depth) {
      res["Depth"] = boost::any(*depth);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (lastOperatorId) {
      res["LastOperatorId"] = boost::any(*lastOperatorId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentCategoryId) {
      res["ParentCategoryId"] = boost::any(*parentCategoryId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Depth") != m.end() && !m["Depth"].empty()) {
      depth = make_shared<long>(boost::any_cast<long>(m["Depth"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("LastOperatorId") != m.end() && !m["LastOperatorId"].empty()) {
      lastOperatorId = make_shared<string>(boost::any_cast<string>(m["LastOperatorId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentCategoryId") != m.end() && !m["ParentCategoryId"].empty()) {
      parentCategoryId = make_shared<long>(boost::any_cast<long>(m["ParentCategoryId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
  }


  virtual ~GetMetaCategoryResponseBodyDataDataEntityList() = default;
};
class GetMetaCategoryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaCategoryResponseBodyDataDataEntityList>> dataEntityList{};

  GetMetaCategoryResponseBodyData() {}

  explicit GetMetaCategoryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaCategoryResponseBodyDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaCategoryResponseBodyDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaCategoryResponseBodyDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaCategoryResponseBodyData() = default;
};
class GetMetaCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaCategoryResponseBodyData> data{};

  GetMetaCategoryResponseBody() {}

  explicit GetMetaCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaCategoryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaCategoryResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaCategoryResponseBody() = default;
};
class GetMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaCategoryResponseBody> body{};

  GetMetaCategoryResponse() {}

  explicit GetMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaCategoryResponse() = default;
};
class GetMetaColumnLineageRequest : public Darabonba::Model {
public:
  shared_ptr<string> columnGuid{};
  shared_ptr<string> direction{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> columnName{};
  shared_ptr<string> dataSourceType{};

  GetMetaColumnLineageRequest() {}

  explicit GetMetaColumnLineageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnGuid) {
      res["ColumnGuid"] = boost::any(*columnGuid);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnGuid") != m.end() && !m["ColumnGuid"].empty()) {
      columnGuid = make_shared<string>(boost::any_cast<string>(m["ColumnGuid"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaColumnLineageRequest() = default;
};
class GetMetaColumnLineageResponseBodyDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> columnGuid{};
  shared_ptr<string> columnName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> clusterId{};

  GetMetaColumnLineageResponseBodyDataDataEntityList() {}

  explicit GetMetaColumnLineageResponseBodyDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnGuid) {
      res["ColumnGuid"] = boost::any(*columnGuid);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnGuid") != m.end() && !m["ColumnGuid"].empty()) {
      columnGuid = make_shared<string>(boost::any_cast<string>(m["ColumnGuid"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
  }


  virtual ~GetMetaColumnLineageResponseBodyDataDataEntityList() = default;
};
class GetMetaColumnLineageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaColumnLineageResponseBodyDataDataEntityList>> dataEntityList{};

  GetMetaColumnLineageResponseBodyData() {}

  explicit GetMetaColumnLineageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaColumnLineageResponseBodyDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaColumnLineageResponseBodyDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaColumnLineageResponseBodyDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaColumnLineageResponseBodyData() = default;
};
class GetMetaColumnLineageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaColumnLineageResponseBodyData> data{};

  GetMetaColumnLineageResponseBody() {}

  explicit GetMetaColumnLineageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaColumnLineageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaColumnLineageResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaColumnLineageResponseBody() = default;
};
class GetMetaColumnLineageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaColumnLineageResponseBody> body{};

  GetMetaColumnLineageResponse() {}

  explicit GetMetaColumnLineageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaColumnLineageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaColumnLineageResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaColumnLineageResponse() = default;
};
class GetMetaDBInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> appGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> dataSourceType{};

  GetMetaDBInfoRequest() {}

  explicit GetMetaDBInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaDBInfoRequest() = default;
};
class GetMetaDBInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> comment{};
  shared_ptr<long> createTime{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> appGuid{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> envType{};
  shared_ptr<string> projectNameCn{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> clusterBizId{};
  shared_ptr<string> name{};
  shared_ptr<string> location{};
  shared_ptr<long> tenantId{};
  shared_ptr<long> modifyTime{};

  GetMetaDBInfoResponseBodyData() {}

  explicit GetMetaDBInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (projectNameCn) {
      res["ProjectNameCn"] = boost::any(*projectNameCn);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (clusterBizId) {
      res["ClusterBizId"] = boost::any(*clusterBizId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("ProjectNameCn") != m.end() && !m["ProjectNameCn"].empty()) {
      projectNameCn = make_shared<string>(boost::any_cast<string>(m["ProjectNameCn"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("ClusterBizId") != m.end() && !m["ClusterBizId"].empty()) {
      clusterBizId = make_shared<string>(boost::any_cast<string>(m["ClusterBizId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
  }


  virtual ~GetMetaDBInfoResponseBodyData() = default;
};
class GetMetaDBInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMetaDBInfoResponseBodyData> data{};

  GetMetaDBInfoResponseBody() {}

  explicit GetMetaDBInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaDBInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaDBInfoResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaDBInfoResponseBody() = default;
};
class GetMetaDBInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaDBInfoResponseBody> body{};

  GetMetaDBInfoResponse() {}

  explicit GetMetaDBInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaDBInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaDBInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaDBInfoResponse() = default;
};
class GetMetaDBTableListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> appGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> dataSourceType{};

  GetMetaDBTableListRequest() {}

  explicit GetMetaDBTableListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaDBTableListRequest() = default;
};
class GetMetaDBTableListResponseBodyDataTableEntityList : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> databaseName{};

  GetMetaDBTableListResponseBodyDataTableEntityList() {}

  explicit GetMetaDBTableListResponseBodyDataTableEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
  }


  virtual ~GetMetaDBTableListResponseBodyDataTableEntityList() = default;
};
class GetMetaDBTableListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaDBTableListResponseBodyDataTableEntityList>> tableEntityList{};

  GetMetaDBTableListResponseBodyData() {}

  explicit GetMetaDBTableListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (tableEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*tableEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TableEntityList") != m.end() && !m["TableEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableEntityList"].type()) {
        vector<GetMetaDBTableListResponseBodyDataTableEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaDBTableListResponseBodyDataTableEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableEntityList = make_shared<vector<GetMetaDBTableListResponseBodyDataTableEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaDBTableListResponseBodyData() = default;
};
class GetMetaDBTableListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMetaDBTableListResponseBodyData> data{};

  GetMetaDBTableListResponseBody() {}

  explicit GetMetaDBTableListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaDBTableListResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaDBTableListResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaDBTableListResponseBody() = default;
};
class GetMetaDBTableListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaDBTableListResponseBody> body{};

  GetMetaDBTableListResponse() {}

  explicit GetMetaDBTableListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaDBTableListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaDBTableListResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaDBTableListResponse() = default;
};
class GetMetaTableBasicInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<bool> extension{};

  GetMetaTableBasicInfoRequest() {}

  explicit GetMetaTableBasicInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<bool>(boost::any_cast<bool>(m["Extension"]));
    }
  }


  virtual ~GetMetaTableBasicInfoRequest() = default;
};
class GetMetaTableBasicInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<long> favoriteCount{};
  shared_ptr<string> comment{};
  shared_ptr<long> createTime{};
  shared_ptr<long> projectId{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> envType{};
  shared_ptr<string> databaseName{};
  shared_ptr<long> isVisible{};
  shared_ptr<string> tableGuid{};
  shared_ptr<long> readCount{};
  shared_ptr<string> clusterId{};
  shared_ptr<bool> isPartitionTable{};
  shared_ptr<bool> isView{};
  shared_ptr<long> lifeCycle{};
  shared_ptr<string> projectName{};
  shared_ptr<long> viewCount{};
  shared_ptr<long> lastAccessTime{};
  shared_ptr<long> dataSize{};
  shared_ptr<long> lastModifyTime{};
  shared_ptr<long> lastDdlTime{};
  shared_ptr<string> partitionKeys{};
  shared_ptr<string> location{};
  shared_ptr<string> caption{};
  shared_ptr<long> tenantId{};

  GetMetaTableBasicInfoResponseBodyData() {}

  explicit GetMetaTableBasicInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (favoriteCount) {
      res["FavoriteCount"] = boost::any(*favoriteCount);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (isVisible) {
      res["IsVisible"] = boost::any(*isVisible);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (readCount) {
      res["ReadCount"] = boost::any(*readCount);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (isPartitionTable) {
      res["IsPartitionTable"] = boost::any(*isPartitionTable);
    }
    if (isView) {
      res["IsView"] = boost::any(*isView);
    }
    if (lifeCycle) {
      res["LifeCycle"] = boost::any(*lifeCycle);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (viewCount) {
      res["ViewCount"] = boost::any(*viewCount);
    }
    if (lastAccessTime) {
      res["LastAccessTime"] = boost::any(*lastAccessTime);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (lastModifyTime) {
      res["LastModifyTime"] = boost::any(*lastModifyTime);
    }
    if (lastDdlTime) {
      res["LastDdlTime"] = boost::any(*lastDdlTime);
    }
    if (partitionKeys) {
      res["PartitionKeys"] = boost::any(*partitionKeys);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (caption) {
      res["Caption"] = boost::any(*caption);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("FavoriteCount") != m.end() && !m["FavoriteCount"].empty()) {
      favoriteCount = make_shared<long>(boost::any_cast<long>(m["FavoriteCount"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("IsVisible") != m.end() && !m["IsVisible"].empty()) {
      isVisible = make_shared<long>(boost::any_cast<long>(m["IsVisible"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("ReadCount") != m.end() && !m["ReadCount"].empty()) {
      readCount = make_shared<long>(boost::any_cast<long>(m["ReadCount"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("IsPartitionTable") != m.end() && !m["IsPartitionTable"].empty()) {
      isPartitionTable = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionTable"]));
    }
    if (m.find("IsView") != m.end() && !m["IsView"].empty()) {
      isView = make_shared<bool>(boost::any_cast<bool>(m["IsView"]));
    }
    if (m.find("LifeCycle") != m.end() && !m["LifeCycle"].empty()) {
      lifeCycle = make_shared<long>(boost::any_cast<long>(m["LifeCycle"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ViewCount") != m.end() && !m["ViewCount"].empty()) {
      viewCount = make_shared<long>(boost::any_cast<long>(m["ViewCount"]));
    }
    if (m.find("LastAccessTime") != m.end() && !m["LastAccessTime"].empty()) {
      lastAccessTime = make_shared<long>(boost::any_cast<long>(m["LastAccessTime"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<long>(boost::any_cast<long>(m["DataSize"]));
    }
    if (m.find("LastModifyTime") != m.end() && !m["LastModifyTime"].empty()) {
      lastModifyTime = make_shared<long>(boost::any_cast<long>(m["LastModifyTime"]));
    }
    if (m.find("LastDdlTime") != m.end() && !m["LastDdlTime"].empty()) {
      lastDdlTime = make_shared<long>(boost::any_cast<long>(m["LastDdlTime"]));
    }
    if (m.find("PartitionKeys") != m.end() && !m["PartitionKeys"].empty()) {
      partitionKeys = make_shared<string>(boost::any_cast<string>(m["PartitionKeys"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Caption") != m.end() && !m["Caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["Caption"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~GetMetaTableBasicInfoResponseBodyData() = default;
};
class GetMetaTableBasicInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTableBasicInfoResponseBodyData> data{};

  GetMetaTableBasicInfoResponseBody() {}

  explicit GetMetaTableBasicInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableBasicInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableBasicInfoResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaTableBasicInfoResponseBody() = default;
};
class GetMetaTableBasicInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaTableBasicInfoResponseBody> body{};

  GetMetaTableBasicInfoResponse() {}

  explicit GetMetaTableBasicInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableBasicInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableBasicInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableBasicInfoResponse() = default;
};
class GetMetaTableChangeLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> changeType{};
  shared_ptr<string> objectType{};
  shared_ptr<string> startDate{};
  shared_ptr<string> endDate{};

  GetMetaTableChangeLogRequest() {}

  explicit GetMetaTableChangeLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
  }


  virtual ~GetMetaTableChangeLogRequest() = default;
};
class GetMetaTableChangeLogResponseBodyDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> objectType{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> createTime{};
  shared_ptr<string> changeContent{};
  shared_ptr<string> operator_{};
  shared_ptr<string> changeType{};

  GetMetaTableChangeLogResponseBodyDataDataEntityList() {}

  explicit GetMetaTableChangeLogResponseBodyDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (changeContent) {
      res["ChangeContent"] = boost::any(*changeContent);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ChangeContent") != m.end() && !m["ChangeContent"].empty()) {
      changeContent = make_shared<string>(boost::any_cast<string>(m["ChangeContent"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
  }


  virtual ~GetMetaTableChangeLogResponseBodyDataDataEntityList() = default;
};
class GetMetaTableChangeLogResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaTableChangeLogResponseBodyDataDataEntityList>> dataEntityList{};

  GetMetaTableChangeLogResponseBodyData() {}

  explicit GetMetaTableChangeLogResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaTableChangeLogResponseBodyDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableChangeLogResponseBodyDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaTableChangeLogResponseBodyDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableChangeLogResponseBodyData() = default;
};
class GetMetaTableChangeLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTableChangeLogResponseBodyData> data{};

  GetMetaTableChangeLogResponseBody() {}

  explicit GetMetaTableChangeLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableChangeLogResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableChangeLogResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaTableChangeLogResponseBody() = default;
};
class GetMetaTableChangeLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaTableChangeLogResponseBody> body{};

  GetMetaTableChangeLogResponse() {}

  explicit GetMetaTableChangeLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableChangeLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableChangeLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableChangeLogResponse() = default;
};
class GetMetaTableColumnRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  GetMetaTableColumnRequest() {}

  explicit GetMetaTableColumnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaTableColumnRequest() = default;
};
class GetMetaTableColumnResponseBodyDataColumnList : public Darabonba::Model {
public:
  shared_ptr<string> columnGuid{};
  shared_ptr<string> columnName{};
  shared_ptr<bool> isPartitionColumn{};
  shared_ptr<string> comment{};
  shared_ptr<string> columnType{};
  shared_ptr<bool> isPrimaryKey{};
  shared_ptr<long> position{};
  shared_ptr<string> caption{};
  shared_ptr<bool> isForeignKey{};

  GetMetaTableColumnResponseBodyDataColumnList() {}

  explicit GetMetaTableColumnResponseBodyDataColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnGuid) {
      res["ColumnGuid"] = boost::any(*columnGuid);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (isPartitionColumn) {
      res["IsPartitionColumn"] = boost::any(*isPartitionColumn);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (isPrimaryKey) {
      res["IsPrimaryKey"] = boost::any(*isPrimaryKey);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (caption) {
      res["Caption"] = boost::any(*caption);
    }
    if (isForeignKey) {
      res["IsForeignKey"] = boost::any(*isForeignKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnGuid") != m.end() && !m["ColumnGuid"].empty()) {
      columnGuid = make_shared<string>(boost::any_cast<string>(m["ColumnGuid"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("IsPartitionColumn") != m.end() && !m["IsPartitionColumn"].empty()) {
      isPartitionColumn = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionColumn"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("IsPrimaryKey") != m.end() && !m["IsPrimaryKey"].empty()) {
      isPrimaryKey = make_shared<bool>(boost::any_cast<bool>(m["IsPrimaryKey"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("Caption") != m.end() && !m["Caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["Caption"]));
    }
    if (m.find("IsForeignKey") != m.end() && !m["IsForeignKey"].empty()) {
      isForeignKey = make_shared<bool>(boost::any_cast<bool>(m["IsForeignKey"]));
    }
  }


  virtual ~GetMetaTableColumnResponseBodyDataColumnList() = default;
};
class GetMetaTableColumnResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaTableColumnResponseBodyDataColumnList>> columnList{};

  GetMetaTableColumnResponseBodyData() {}

  explicit GetMetaTableColumnResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (columnList) {
      vector<boost::any> temp1;
      for(auto item1:*columnList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnList"].type()) {
        vector<GetMetaTableColumnResponseBodyDataColumnList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableColumnResponseBodyDataColumnList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnList = make_shared<vector<GetMetaTableColumnResponseBodyDataColumnList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableColumnResponseBodyData() = default;
};
class GetMetaTableColumnResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTableColumnResponseBodyData> data{};

  GetMetaTableColumnResponseBody() {}

  explicit GetMetaTableColumnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableColumnResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableColumnResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaTableColumnResponseBody() = default;
};
class GetMetaTableColumnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaTableColumnResponseBody> body{};

  GetMetaTableColumnResponse() {}

  explicit GetMetaTableColumnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableColumnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableColumnResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableColumnResponse() = default;
};
class GetMetaTableFullInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  GetMetaTableFullInfoRequest() {}

  explicit GetMetaTableFullInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaTableFullInfoRequest() = default;
};
class GetMetaTableFullInfoResponseBodyDataColumnList : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> columnGuid{};
  shared_ptr<bool> isPartitionColumn{};
  shared_ptr<string> comment{};
  shared_ptr<string> columnType{};
  shared_ptr<bool> isPrimaryKey{};
  shared_ptr<long> position{};
  shared_ptr<string> caption{};
  shared_ptr<bool> isForeignKey{};

  GetMetaTableFullInfoResponseBodyDataColumnList() {}

  explicit GetMetaTableFullInfoResponseBodyDataColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnGuid) {
      res["ColumnGuid"] = boost::any(*columnGuid);
    }
    if (isPartitionColumn) {
      res["IsPartitionColumn"] = boost::any(*isPartitionColumn);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (isPrimaryKey) {
      res["IsPrimaryKey"] = boost::any(*isPrimaryKey);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (caption) {
      res["Caption"] = boost::any(*caption);
    }
    if (isForeignKey) {
      res["IsForeignKey"] = boost::any(*isForeignKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnGuid") != m.end() && !m["ColumnGuid"].empty()) {
      columnGuid = make_shared<string>(boost::any_cast<string>(m["ColumnGuid"]));
    }
    if (m.find("IsPartitionColumn") != m.end() && !m["IsPartitionColumn"].empty()) {
      isPartitionColumn = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionColumn"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("IsPrimaryKey") != m.end() && !m["IsPrimaryKey"].empty()) {
      isPrimaryKey = make_shared<bool>(boost::any_cast<bool>(m["IsPrimaryKey"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("Caption") != m.end() && !m["Caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["Caption"]));
    }
    if (m.find("IsForeignKey") != m.end() && !m["IsForeignKey"].empty()) {
      isForeignKey = make_shared<bool>(boost::any_cast<bool>(m["IsForeignKey"]));
    }
  }


  virtual ~GetMetaTableFullInfoResponseBodyDataColumnList() = default;
};
class GetMetaTableFullInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> comment{};
  shared_ptr<long> lifeCycle{};
  shared_ptr<long> createTime{};
  shared_ptr<string> projectName{};
  shared_ptr<long> projectId{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> envType{};
  shared_ptr<long> lastAccessTime{};
  shared_ptr<long> dataSize{};
  shared_ptr<long> lastModifyTime{};
  shared_ptr<string> databaseName{};
  shared_ptr<long> isVisible{};
  shared_ptr<long> totalColumnCount{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> partitionKeys{};
  shared_ptr<long> lastDdlTime{};
  shared_ptr<string> location{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> tenantId{};
  shared_ptr<vector<GetMetaTableFullInfoResponseBodyDataColumnList>> columnList{};

  GetMetaTableFullInfoResponseBodyData() {}

  explicit GetMetaTableFullInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (lifeCycle) {
      res["LifeCycle"] = boost::any(*lifeCycle);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (lastAccessTime) {
      res["LastAccessTime"] = boost::any(*lastAccessTime);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (lastModifyTime) {
      res["LastModifyTime"] = boost::any(*lastModifyTime);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (isVisible) {
      res["IsVisible"] = boost::any(*isVisible);
    }
    if (totalColumnCount) {
      res["TotalColumnCount"] = boost::any(*totalColumnCount);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (partitionKeys) {
      res["PartitionKeys"] = boost::any(*partitionKeys);
    }
    if (lastDdlTime) {
      res["LastDdlTime"] = boost::any(*lastDdlTime);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (columnList) {
      vector<boost::any> temp1;
      for(auto item1:*columnList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("LifeCycle") != m.end() && !m["LifeCycle"].empty()) {
      lifeCycle = make_shared<long>(boost::any_cast<long>(m["LifeCycle"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("LastAccessTime") != m.end() && !m["LastAccessTime"].empty()) {
      lastAccessTime = make_shared<long>(boost::any_cast<long>(m["LastAccessTime"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<long>(boost::any_cast<long>(m["DataSize"]));
    }
    if (m.find("LastModifyTime") != m.end() && !m["LastModifyTime"].empty()) {
      lastModifyTime = make_shared<long>(boost::any_cast<long>(m["LastModifyTime"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("IsVisible") != m.end() && !m["IsVisible"].empty()) {
      isVisible = make_shared<long>(boost::any_cast<long>(m["IsVisible"]));
    }
    if (m.find("TotalColumnCount") != m.end() && !m["TotalColumnCount"].empty()) {
      totalColumnCount = make_shared<long>(boost::any_cast<long>(m["TotalColumnCount"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("PartitionKeys") != m.end() && !m["PartitionKeys"].empty()) {
      partitionKeys = make_shared<string>(boost::any_cast<string>(m["PartitionKeys"]));
    }
    if (m.find("LastDdlTime") != m.end() && !m["LastDdlTime"].empty()) {
      lastDdlTime = make_shared<long>(boost::any_cast<long>(m["LastDdlTime"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnList"].type()) {
        vector<GetMetaTableFullInfoResponseBodyDataColumnList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableFullInfoResponseBodyDataColumnList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnList = make_shared<vector<GetMetaTableFullInfoResponseBodyDataColumnList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableFullInfoResponseBodyData() = default;
};
class GetMetaTableFullInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTableFullInfoResponseBodyData> data{};

  GetMetaTableFullInfoResponseBody() {}

  explicit GetMetaTableFullInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableFullInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableFullInfoResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaTableFullInfoResponseBody() = default;
};
class GetMetaTableFullInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaTableFullInfoResponseBody> body{};

  GetMetaTableFullInfoResponse() {}

  explicit GetMetaTableFullInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableFullInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableFullInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableFullInfoResponse() = default;
};
class GetMetaTableIntroWikiRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<long> wikiVersion{};

  GetMetaTableIntroWikiRequest() {}

  explicit GetMetaTableIntroWikiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (wikiVersion) {
      res["WikiVersion"] = boost::any(*wikiVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("WikiVersion") != m.end() && !m["WikiVersion"].empty()) {
      wikiVersion = make_shared<long>(boost::any_cast<long>(m["WikiVersion"]));
    }
  }


  virtual ~GetMetaTableIntroWikiRequest() = default;
};
class GetMetaTableIntroWikiResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> version{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> content{};
  shared_ptr<string> creator{};

  GetMetaTableIntroWikiResponseBodyData() {}

  explicit GetMetaTableIntroWikiResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
  }


  virtual ~GetMetaTableIntroWikiResponseBodyData() = default;
};
class GetMetaTableIntroWikiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTableIntroWikiResponseBodyData> data{};

  GetMetaTableIntroWikiResponseBody() {}

  explicit GetMetaTableIntroWikiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableIntroWikiResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableIntroWikiResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaTableIntroWikiResponseBody() = default;
};
class GetMetaTableIntroWikiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaTableIntroWikiResponseBody> body{};

  GetMetaTableIntroWikiResponse() {}

  explicit GetMetaTableIntroWikiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableIntroWikiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableIntroWikiResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableIntroWikiResponse() = default;
};
class GetMetaTableLineageRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> direction{};
  shared_ptr<string> nextPrimaryKey{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  GetMetaTableLineageRequest() {}

  explicit GetMetaTableLineageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (nextPrimaryKey) {
      res["NextPrimaryKey"] = boost::any(*nextPrimaryKey);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("NextPrimaryKey") != m.end() && !m["NextPrimaryKey"].empty()) {
      nextPrimaryKey = make_shared<string>(boost::any_cast<string>(m["NextPrimaryKey"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaTableLineageRequest() = default;
};
class GetMetaTableLineageResponseBodyDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> tableGuid{};

  GetMetaTableLineageResponseBodyDataDataEntityList() {}

  explicit GetMetaTableLineageResponseBodyDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~GetMetaTableLineageResponseBodyDataDataEntityList() = default;
};
class GetMetaTableLineageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> nextPrimaryKey{};
  shared_ptr<bool> hasNext{};
  shared_ptr<vector<GetMetaTableLineageResponseBodyDataDataEntityList>> dataEntityList{};

  GetMetaTableLineageResponseBodyData() {}

  explicit GetMetaTableLineageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextPrimaryKey) {
      res["NextPrimaryKey"] = boost::any(*nextPrimaryKey);
    }
    if (hasNext) {
      res["HasNext"] = boost::any(*hasNext);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextPrimaryKey") != m.end() && !m["NextPrimaryKey"].empty()) {
      nextPrimaryKey = make_shared<string>(boost::any_cast<string>(m["NextPrimaryKey"]));
    }
    if (m.find("HasNext") != m.end() && !m["HasNext"].empty()) {
      hasNext = make_shared<bool>(boost::any_cast<bool>(m["HasNext"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaTableLineageResponseBodyDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableLineageResponseBodyDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaTableLineageResponseBodyDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableLineageResponseBodyData() = default;
};
class GetMetaTableLineageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTableLineageResponseBodyData> data{};

  GetMetaTableLineageResponseBody() {}

  explicit GetMetaTableLineageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableLineageResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableLineageResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaTableLineageResponseBody() = default;
};
class GetMetaTableLineageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaTableLineageResponseBody> body{};

  GetMetaTableLineageResponse() {}

  explicit GetMetaTableLineageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableLineageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableLineageResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableLineageResponse() = default;
};
class GetMetaTableListByCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> categoryId{};

  GetMetaTableListByCategoryRequest() {}

  explicit GetMetaTableListByCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
  }


  virtual ~GetMetaTableListByCategoryRequest() = default;
};
class GetMetaTableListByCategoryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<string>> tableGuidList{};

  GetMetaTableListByCategoryResponseBodyData() {}

  explicit GetMetaTableListByCategoryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (tableGuidList) {
      res["TableGuidList"] = boost::any(*tableGuidList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TableGuidList") != m.end() && !m["TableGuidList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableGuidList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableGuidList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableGuidList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetMetaTableListByCategoryResponseBodyData() = default;
};
class GetMetaTableListByCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTableListByCategoryResponseBodyData> data{};

  GetMetaTableListByCategoryResponseBody() {}

  explicit GetMetaTableListByCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableListByCategoryResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableListByCategoryResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaTableListByCategoryResponseBody() = default;
};
class GetMetaTableListByCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaTableListByCategoryResponseBody> body{};

  GetMetaTableListByCategoryResponse() {}

  explicit GetMetaTableListByCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableListByCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableListByCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableListByCategoryResponse() = default;
};
class GetMetaTableOutputRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> startDate{};
  shared_ptr<string> endDate{};

  GetMetaTableOutputRequest() {}

  explicit GetMetaTableOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
  }


  virtual ~GetMetaTableOutputRequest() = default;
};
class GetMetaTableOutputResponseBodyDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> taskInstanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<long> projectId{};
  shared_ptr<string> waitTime{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> taskId{};

  GetMetaTableOutputResponseBodyDataDataEntityList() {}

  explicit GetMetaTableOutputResponseBodyDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (taskInstanceId) {
      res["TaskInstanceId"] = boost::any(*taskInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (waitTime) {
      res["WaitTime"] = boost::any(*waitTime);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("TaskInstanceId") != m.end() && !m["TaskInstanceId"].empty()) {
      taskInstanceId = make_shared<long>(boost::any_cast<long>(m["TaskInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("WaitTime") != m.end() && !m["WaitTime"].empty()) {
      waitTime = make_shared<string>(boost::any_cast<string>(m["WaitTime"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetMetaTableOutputResponseBodyDataDataEntityList() = default;
};
class GetMetaTableOutputResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaTableOutputResponseBodyDataDataEntityList>> dataEntityList{};

  GetMetaTableOutputResponseBodyData() {}

  explicit GetMetaTableOutputResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaTableOutputResponseBodyDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableOutputResponseBodyDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaTableOutputResponseBodyDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableOutputResponseBodyData() = default;
};
class GetMetaTableOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTableOutputResponseBodyData> data{};

  GetMetaTableOutputResponseBody() {}

  explicit GetMetaTableOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTableOutputResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTableOutputResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaTableOutputResponseBody() = default;
};
class GetMetaTableOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaTableOutputResponseBody> body{};

  GetMetaTableOutputResponse() {}

  explicit GetMetaTableOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableOutputResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableOutputResponse() = default;
};
class GetMetaTablePartitionRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> dataSourceType{};

  GetMetaTablePartitionRequest() {}

  explicit GetMetaTablePartitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaTablePartitionRequest() = default;
};
class GetMetaTablePartitionResponseBodyDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> partitionPath{};
  shared_ptr<long> dataSize{};
  shared_ptr<string> partitionName{};
  shared_ptr<string> comment{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> recordCount{};
  shared_ptr<string> partitionType{};
  shared_ptr<string> partitionGuid{};
  shared_ptr<string> partitionLocation{};
  shared_ptr<string> tableGuid{};

  GetMetaTablePartitionResponseBodyDataDataEntityList() {}

  explicit GetMetaTablePartitionResponseBodyDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (partitionPath) {
      res["PartitionPath"] = boost::any(*partitionPath);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (partitionName) {
      res["PartitionName"] = boost::any(*partitionName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (recordCount) {
      res["RecordCount"] = boost::any(*recordCount);
    }
    if (partitionType) {
      res["PartitionType"] = boost::any(*partitionType);
    }
    if (partitionGuid) {
      res["PartitionGuid"] = boost::any(*partitionGuid);
    }
    if (partitionLocation) {
      res["PartitionLocation"] = boost::any(*partitionLocation);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PartitionPath") != m.end() && !m["PartitionPath"].empty()) {
      partitionPath = make_shared<string>(boost::any_cast<string>(m["PartitionPath"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<long>(boost::any_cast<long>(m["DataSize"]));
    }
    if (m.find("PartitionName") != m.end() && !m["PartitionName"].empty()) {
      partitionName = make_shared<string>(boost::any_cast<string>(m["PartitionName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("RecordCount") != m.end() && !m["RecordCount"].empty()) {
      recordCount = make_shared<long>(boost::any_cast<long>(m["RecordCount"]));
    }
    if (m.find("PartitionType") != m.end() && !m["PartitionType"].empty()) {
      partitionType = make_shared<string>(boost::any_cast<string>(m["PartitionType"]));
    }
    if (m.find("PartitionGuid") != m.end() && !m["PartitionGuid"].empty()) {
      partitionGuid = make_shared<string>(boost::any_cast<string>(m["PartitionGuid"]));
    }
    if (m.find("PartitionLocation") != m.end() && !m["PartitionLocation"].empty()) {
      partitionLocation = make_shared<string>(boost::any_cast<string>(m["PartitionLocation"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
  }


  virtual ~GetMetaTablePartitionResponseBodyDataDataEntityList() = default;
};
class GetMetaTablePartitionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetMetaTablePartitionResponseBodyDataDataEntityList>> dataEntityList{};

  GetMetaTablePartitionResponseBodyData() {}

  explicit GetMetaTablePartitionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<GetMetaTablePartitionResponseBodyDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTablePartitionResponseBodyDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<GetMetaTablePartitionResponseBodyDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~GetMetaTablePartitionResponseBodyData() = default;
};
class GetMetaTablePartitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTablePartitionResponseBodyData> data{};

  GetMetaTablePartitionResponseBody() {}

  explicit GetMetaTablePartitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMetaTablePartitionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMetaTablePartitionResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetMetaTablePartitionResponseBody() = default;
};
class GetMetaTablePartitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaTablePartitionResponseBody> body{};

  GetMetaTablePartitionResponse() {}

  explicit GetMetaTablePartitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTablePartitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTablePartitionResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTablePartitionResponse() = default;
};
class GetMetaTableThemeLevelRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> dataSourceType{};

  GetMetaTableThemeLevelRequest() {}

  explicit GetMetaTableThemeLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~GetMetaTableThemeLevelRequest() = default;
};
class GetMetaTableThemeLevelResponseBodyEntityTheme : public Darabonba::Model {
public:
  shared_ptr<long> parentId{};
  shared_ptr<string> name{};
  shared_ptr<long> themeId{};
  shared_ptr<long> level{};

  GetMetaTableThemeLevelResponseBodyEntityTheme() {}

  explicit GetMetaTableThemeLevelResponseBodyEntityTheme(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
  }


  virtual ~GetMetaTableThemeLevelResponseBodyEntityTheme() = default;
};
class GetMetaTableThemeLevelResponseBodyEntityLevel : public Darabonba::Model {
public:
  shared_ptr<long> type{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> levelId{};

  GetMetaTableThemeLevelResponseBodyEntityLevel() {}

  explicit GetMetaTableThemeLevelResponseBodyEntityLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
  }


  virtual ~GetMetaTableThemeLevelResponseBodyEntityLevel() = default;
};
class GetMetaTableThemeLevelResponseBodyEntity : public Darabonba::Model {
public:
  shared_ptr<vector<GetMetaTableThemeLevelResponseBodyEntityTheme>> theme{};
  shared_ptr<vector<GetMetaTableThemeLevelResponseBodyEntityLevel>> level{};

  GetMetaTableThemeLevelResponseBodyEntity() {}

  explicit GetMetaTableThemeLevelResponseBodyEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (theme) {
      vector<boost::any> temp1;
      for(auto item1:*theme){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Theme"] = boost::any(temp1);
    }
    if (level) {
      vector<boost::any> temp1;
      for(auto item1:*level){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Level"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Theme") != m.end() && !m["Theme"].empty()) {
      if (typeid(vector<boost::any>) == m["Theme"].type()) {
        vector<GetMetaTableThemeLevelResponseBodyEntityTheme> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Theme"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableThemeLevelResponseBodyEntityTheme model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        theme = make_shared<vector<GetMetaTableThemeLevelResponseBodyEntityTheme>>(expect1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      if (typeid(vector<boost::any>) == m["Level"].type()) {
        vector<GetMetaTableThemeLevelResponseBodyEntityLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Level"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMetaTableThemeLevelResponseBodyEntityLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        level = make_shared<vector<GetMetaTableThemeLevelResponseBodyEntityLevel>>(expect1);
      }
    }
  }


  virtual ~GetMetaTableThemeLevelResponseBodyEntity() = default;
};
class GetMetaTableThemeLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<GetMetaTableThemeLevelResponseBodyEntity> entity{};

  GetMetaTableThemeLevelResponseBody() {}

  explicit GetMetaTableThemeLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (entity) {
      res["Entity"] = entity ? boost::any(entity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Entity") != m.end() && !m["Entity"].empty()) {
      if (typeid(map<string, boost::any>) == m["Entity"].type()) {
        GetMetaTableThemeLevelResponseBodyEntity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Entity"]));
        entity = make_shared<GetMetaTableThemeLevelResponseBodyEntity>(model1);
      }
    }
  }


  virtual ~GetMetaTableThemeLevelResponseBody() = default;
};
class GetMetaTableThemeLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMetaTableThemeLevelResponseBody> body{};

  GetMetaTableThemeLevelResponse() {}

  explicit GetMetaTableThemeLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMetaTableThemeLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMetaTableThemeLevelResponseBody>(model1);
      }
    }
  }


  virtual ~GetMetaTableThemeLevelResponse() = default;
};
class GetMigrationProcessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> migrationId{};

  GetMigrationProcessRequest() {}

  explicit GetMigrationProcessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (migrationId) {
      res["MigrationId"] = boost::any(*migrationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("MigrationId") != m.end() && !m["MigrationId"].empty()) {
      migrationId = make_shared<long>(boost::any_cast<long>(m["MigrationId"]));
    }
  }


  virtual ~GetMigrationProcessRequest() = default;
};
class GetMigrationProcessResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> taskStatus{};
  shared_ptr<string> taskName{};

  GetMigrationProcessResponseBodyData() {}

  explicit GetMigrationProcessResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~GetMigrationProcessResponseBodyData() = default;
};
class GetMigrationProcessResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<vector<GetMigrationProcessResponseBodyData>> data{};

  GetMigrationProcessResponseBody() {}

  explicit GetMigrationProcessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetMigrationProcessResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMigrationProcessResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetMigrationProcessResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~GetMigrationProcessResponseBody() = default;
};
class GetMigrationProcessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetMigrationProcessResponseBody> body{};

  GetMigrationProcessResponse() {}

  explicit GetMigrationProcessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMigrationProcessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMigrationProcessResponseBody>(model1);
      }
    }
  }


  virtual ~GetMigrationProcessResponse() = default;
};
class GetNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> projectEnv{};

  GetNodeRequest() {}

  explicit GetNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetNodeRequest() = default;
};
class GetNodeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> schedulerType{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<string> repeatability{};
  shared_ptr<long> projectId{};
  shared_ptr<string> programType{};
  shared_ptr<long> priority{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> connection{};
  shared_ptr<string> paramValues{};
  shared_ptr<long> relatedFlowId{};
  shared_ptr<long> dqcType{};
  shared_ptr<long> baselineId{};
  shared_ptr<string> description{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> resGroupName{};
  shared_ptr<string> dqcDescription{};
  shared_ptr<string> cronExpress{};
  shared_ptr<long> nodeId{};

  GetNodeResponseBodyData() {}

  explicit GetNodeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (connection) {
      res["Connection"] = boost::any(*connection);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (relatedFlowId) {
      res["RelatedFlowId"] = boost::any(*relatedFlowId);
    }
    if (dqcType) {
      res["DqcType"] = boost::any(*dqcType);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (resGroupName) {
      res["ResGroupName"] = boost::any(*resGroupName);
    }
    if (dqcDescription) {
      res["DqcDescription"] = boost::any(*dqcDescription);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<string>(boost::any_cast<string>(m["Repeatability"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Connection") != m.end() && !m["Connection"].empty()) {
      connection = make_shared<string>(boost::any_cast<string>(m["Connection"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("RelatedFlowId") != m.end() && !m["RelatedFlowId"].empty()) {
      relatedFlowId = make_shared<long>(boost::any_cast<long>(m["RelatedFlowId"]));
    }
    if (m.find("DqcType") != m.end() && !m["DqcType"].empty()) {
      dqcType = make_shared<long>(boost::any_cast<long>(m["DqcType"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ResGroupName") != m.end() && !m["ResGroupName"].empty()) {
      resGroupName = make_shared<string>(boost::any_cast<string>(m["ResGroupName"]));
    }
    if (m.find("DqcDescription") != m.end() && !m["DqcDescription"].empty()) {
      dqcDescription = make_shared<string>(boost::any_cast<string>(m["DqcDescription"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetNodeResponseBodyData() = default;
};
class GetNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetNodeResponseBodyData> data{};

  GetNodeResponseBody() {}

  explicit GetNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetNodeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetNodeResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetNodeResponseBody() = default;
};
class GetNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetNodeResponseBody> body{};

  GetNodeResponse() {}

  explicit GetNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeResponse() = default;
};
class GetNodeChildrenRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<long> nodeId{};

  GetNodeChildrenRequest() {}

  explicit GetNodeChildrenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetNodeChildrenRequest() = default;
};
class GetNodeChildrenResponseBodyDataNodes : public Darabonba::Model {
public:
  shared_ptr<string> schedulerType{};
  shared_ptr<long> baselineId{};
  shared_ptr<bool> repeatability{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> projectId{};
  shared_ptr<string> programType{};
  shared_ptr<long> priority{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> cronExpress{};
  shared_ptr<long> nodeId{};

  GetNodeChildrenResponseBodyDataNodes() {}

  explicit GetNodeChildrenResponseBodyDataNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetNodeChildrenResponseBodyDataNodes() = default;
};
class GetNodeChildrenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetNodeChildrenResponseBodyDataNodes>> nodes{};

  GetNodeChildrenResponseBodyData() {}

  explicit GetNodeChildrenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<GetNodeChildrenResponseBodyDataNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeChildrenResponseBodyDataNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<GetNodeChildrenResponseBodyDataNodes>>(expect1);
      }
    }
  }


  virtual ~GetNodeChildrenResponseBodyData() = default;
};
class GetNodeChildrenResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetNodeChildrenResponseBodyData> data{};

  GetNodeChildrenResponseBody() {}

  explicit GetNodeChildrenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetNodeChildrenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetNodeChildrenResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetNodeChildrenResponseBody() = default;
};
class GetNodeChildrenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetNodeChildrenResponseBody> body{};

  GetNodeChildrenResponse() {}

  explicit GetNodeChildrenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeChildrenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeChildrenResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeChildrenResponse() = default;
};
class GetNodeCodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> projectEnv{};

  GetNodeCodeRequest() {}

  explicit GetNodeCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~GetNodeCodeRequest() = default;
};
class GetNodeCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  GetNodeCodeResponseBody() {}

  explicit GetNodeCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~GetNodeCodeResponseBody() = default;
};
class GetNodeCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetNodeCodeResponseBody> body{};

  GetNodeCodeResponse() {}

  explicit GetNodeCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeCodeResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeCodeResponse() = default;
};
class GetNodeOnBaselineRequest : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};

  GetNodeOnBaselineRequest() {}

  explicit GetNodeOnBaselineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
  }


  virtual ~GetNodeOnBaselineRequest() = default;
};
class GetNodeOnBaselineResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};

  GetNodeOnBaselineResponseBodyData() {}

  explicit GetNodeOnBaselineResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetNodeOnBaselineResponseBodyData() = default;
};
class GetNodeOnBaselineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> success{};
  shared_ptr<vector<GetNodeOnBaselineResponseBodyData>> data{};

  GetNodeOnBaselineResponseBody() {}

  explicit GetNodeOnBaselineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetNodeOnBaselineResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeOnBaselineResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetNodeOnBaselineResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~GetNodeOnBaselineResponseBody() = default;
};
class GetNodeOnBaselineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetNodeOnBaselineResponseBody> body{};

  GetNodeOnBaselineResponse() {}

  explicit GetNodeOnBaselineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeOnBaselineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeOnBaselineResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeOnBaselineResponse() = default;
};
class GetNodeParentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<long> nodeId{};

  GetNodeParentsRequest() {}

  explicit GetNodeParentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetNodeParentsRequest() = default;
};
class GetNodeParentsResponseBodyDataNodes : public Darabonba::Model {
public:
  shared_ptr<string> schedulerType{};
  shared_ptr<long> baselineId{};
  shared_ptr<bool> repeatability{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> projectId{};
  shared_ptr<string> programType{};
  shared_ptr<long> priority{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> cronExpress{};
  shared_ptr<long> nodeId{};

  GetNodeParentsResponseBodyDataNodes() {}

  explicit GetNodeParentsResponseBodyDataNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetNodeParentsResponseBodyDataNodes() = default;
};
class GetNodeParentsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetNodeParentsResponseBodyDataNodes>> nodes{};

  GetNodeParentsResponseBodyData() {}

  explicit GetNodeParentsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<GetNodeParentsResponseBodyDataNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeParentsResponseBodyDataNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<GetNodeParentsResponseBodyDataNodes>>(expect1);
      }
    }
  }


  virtual ~GetNodeParentsResponseBodyData() = default;
};
class GetNodeParentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetNodeParentsResponseBodyData> data{};

  GetNodeParentsResponseBody() {}

  explicit GetNodeParentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetNodeParentsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetNodeParentsResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetNodeParentsResponseBody() = default;
};
class GetNodeParentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetNodeParentsResponseBody> body{};

  GetNodeParentsResponse() {}

  explicit GetNodeParentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeParentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeParentsResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeParentsResponse() = default;
};
class GetNodeTypeListInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> keyword{};
  shared_ptr<string> locale{};

  GetNodeTypeListInfoRequest() {}

  explicit GetNodeTypeListInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (locale) {
      res["Locale"] = boost::any(*locale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Locale") != m.end() && !m["Locale"].empty()) {
      locale = make_shared<string>(boost::any_cast<string>(m["Locale"]));
    }
  }


  virtual ~GetNodeTypeListInfoRequest() = default;
};
class GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo : public Darabonba::Model {
public:
  shared_ptr<string> nodeTypeName{};
  shared_ptr<long> nodeType{};

  GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo() {}

  explicit GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeTypeName) {
      res["NodeTypeName"] = boost::any(*nodeTypeName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeTypeName") != m.end() && !m["NodeTypeName"].empty()) {
      nodeTypeName = make_shared<string>(boost::any_cast<string>(m["NodeTypeName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
  }


  virtual ~GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo() = default;
};
class GetNodeTypeListInfoResponseBodyNodeTypeInfoList : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo>> nodeTypeInfo{};

  GetNodeTypeListInfoResponseBodyNodeTypeInfoList() {}

  explicit GetNodeTypeListInfoResponseBodyNodeTypeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nodeTypeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*nodeTypeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeTypeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NodeTypeInfo") != m.end() && !m["NodeTypeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeTypeInfo"].type()) {
        vector<GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeTypeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeTypeInfo = make_shared<vector<GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo>>(expect1);
      }
    }
  }


  virtual ~GetNodeTypeListInfoResponseBodyNodeTypeInfoList() = default;
};
class GetNodeTypeListInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetNodeTypeListInfoResponseBodyNodeTypeInfoList> nodeTypeInfoList{};

  GetNodeTypeListInfoResponseBody() {}

  explicit GetNodeTypeListInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nodeTypeInfoList) {
      res["NodeTypeInfoList"] = nodeTypeInfoList ? boost::any(nodeTypeInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NodeTypeInfoList") != m.end() && !m["NodeTypeInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeTypeInfoList"].type()) {
        GetNodeTypeListInfoResponseBodyNodeTypeInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeTypeInfoList"]));
        nodeTypeInfoList = make_shared<GetNodeTypeListInfoResponseBodyNodeTypeInfoList>(model1);
      }
    }
  }


  virtual ~GetNodeTypeListInfoResponseBody() = default;
};
class GetNodeTypeListInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetNodeTypeListInfoResponseBody> body{};

  GetNodeTypeListInfoResponse() {}

  explicit GetNodeTypeListInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeTypeListInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeTypeListInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeTypeListInfoResponse() = default;
};
class GetOpRiskDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNo{};
  shared_ptr<string> name{};
  shared_ptr<string> date{};
  shared_ptr<string> riskType{};

  GetOpRiskDataRequest() {}

  explicit GetOpRiskDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (riskType) {
      res["RiskType"] = boost::any(*riskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("RiskType") != m.end() && !m["RiskType"].empty()) {
      riskType = make_shared<string>(boost::any_cast<string>(m["RiskType"]));
    }
  }


  virtual ~GetOpRiskDataRequest() = default;
};
class GetOpRiskDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> riskData{};
  shared_ptr<string> requestId{};

  GetOpRiskDataResponseBody() {}

  explicit GetOpRiskDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (riskData) {
      res["RiskData"] = boost::any(*riskData);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RiskData") != m.end() && !m["RiskData"].empty()) {
      riskData = make_shared<string>(boost::any_cast<string>(m["RiskData"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOpRiskDataResponseBody() = default;
};
class GetOpRiskDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetOpRiskDataResponseBody> body{};

  GetOpRiskDataResponse() {}

  explicit GetOpRiskDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOpRiskDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOpRiskDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetOpRiskDataResponse() = default;
};
class GetOpSensitiveDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNo{};
  shared_ptr<string> date{};
  shared_ptr<string> opType{};

  GetOpSensitiveDataRequest() {}

  explicit GetOpSensitiveDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (opType) {
      res["OpType"] = boost::any(*opType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["Date"]));
    }
    if (m.find("OpType") != m.end() && !m["OpType"].empty()) {
      opType = make_shared<string>(boost::any_cast<string>(m["OpType"]));
    }
  }


  virtual ~GetOpSensitiveDataRequest() = default;
};
class GetOpSensitiveDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> opSensitiveData{};
  shared_ptr<string> requestId{};

  GetOpSensitiveDataResponseBody() {}

  explicit GetOpSensitiveDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opSensitiveData) {
      res["OpSensitiveData"] = boost::any(*opSensitiveData);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpSensitiveData") != m.end() && !m["OpSensitiveData"].empty()) {
      opSensitiveData = make_shared<string>(boost::any_cast<string>(m["OpSensitiveData"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOpSensitiveDataResponseBody() = default;
};
class GetOpSensitiveDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetOpSensitiveDataResponseBody> body{};

  GetOpSensitiveDataResponse() {}

  explicit GetOpSensitiveDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOpSensitiveDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOpSensitiveDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetOpSensitiveDataResponse() = default;
};
class GetPermissionApplyOrderDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};

  GetPermissionApplyOrderDetailRequest() {}

  explicit GetPermissionApplyOrderDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~GetPermissionApplyOrderDetailRequest() = default;
};
class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList : public Darabonba::Model {
public:
  shared_ptr<string> baseId{};

  GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList() {}

  explicit GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseId) {
      res["BaseId"] = boost::any(*baseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseId") != m.end() && !m["BaseId"].empty()) {
      baseId = make_shared<string>(boost::any_cast<string>(m["BaseId"]));
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList() = default;
};
class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList : public Darabonba::Model {
public:
  shared_ptr<long> granteeType{};
  shared_ptr<long> granteeTypeSub{};
  shared_ptr<string> granteeName{};
  shared_ptr<string> granteeId{};

  GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList() {}

  explicit GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (granteeType) {
      res["GranteeType"] = boost::any(*granteeType);
    }
    if (granteeTypeSub) {
      res["GranteeTypeSub"] = boost::any(*granteeTypeSub);
    }
    if (granteeName) {
      res["GranteeName"] = boost::any(*granteeName);
    }
    if (granteeId) {
      res["GranteeId"] = boost::any(*granteeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GranteeType") != m.end() && !m["GranteeType"].empty()) {
      granteeType = make_shared<long>(boost::any_cast<long>(m["GranteeType"]));
    }
    if (m.find("GranteeTypeSub") != m.end() && !m["GranteeTypeSub"].empty()) {
      granteeTypeSub = make_shared<long>(boost::any_cast<long>(m["GranteeTypeSub"]));
    }
    if (m.find("GranteeName") != m.end() && !m["GranteeName"].empty()) {
      granteeName = make_shared<string>(boost::any_cast<string>(m["GranteeName"]));
    }
    if (m.find("GranteeId") != m.end() && !m["GranteeId"].empty()) {
      granteeId = make_shared<string>(boost::any_cast<string>(m["GranteeId"]));
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList() = default;
};
class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> columnComment{};

  GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList() {}

  explicit GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnComment) {
      res["ColumnComment"] = boost::any(*columnComment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnComment") != m.end() && !m["ColumnComment"].empty()) {
      columnComment = make_shared<string>(boost::any_cast<string>(m["ColumnComment"]));
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList() = default;
};
class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList : public Darabonba::Model {
public:
  shared_ptr<string> objectName{};
  shared_ptr<vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList>> columnMetaList{};

  GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList() {}

  explicit GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (columnMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*columnMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnMetaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("ColumnMetaList") != m.end() && !m["ColumnMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnMetaList"].type()) {
        vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnMetaList = make_shared<vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList>>(expect1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList() = default;
};
class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta : public Darabonba::Model {
public:
  shared_ptr<string> maxComputeProjectName{};
  shared_ptr<long> workspaceId{};
  shared_ptr<vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList>> objectMetaList{};

  GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta() {}

  explicit GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxComputeProjectName) {
      res["MaxComputeProjectName"] = boost::any(*maxComputeProjectName);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (objectMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*objectMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ObjectMetaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxComputeProjectName") != m.end() && !m["MaxComputeProjectName"].empty()) {
      maxComputeProjectName = make_shared<string>(boost::any_cast<string>(m["MaxComputeProjectName"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<long>(boost::any_cast<long>(m["WorkspaceId"]));
    }
    if (m.find("ObjectMetaList") != m.end() && !m["ObjectMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["ObjectMetaList"].type()) {
        vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ObjectMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        objectMetaList = make_shared<vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList>>(expect1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta() = default;
};
class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent : public Darabonba::Model {
public:
  shared_ptr<string> applyReason{};
  shared_ptr<long> deadline{};
  shared_ptr<long> orderType{};
  shared_ptr<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta> projectMeta{};

  GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent() {}

  explicit GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyReason) {
      res["ApplyReason"] = boost::any(*applyReason);
    }
    if (deadline) {
      res["Deadline"] = boost::any(*deadline);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (projectMeta) {
      res["ProjectMeta"] = projectMeta ? boost::any(projectMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyReason") != m.end() && !m["ApplyReason"].empty()) {
      applyReason = make_shared<string>(boost::any_cast<string>(m["ApplyReason"]));
    }
    if (m.find("Deadline") != m.end() && !m["Deadline"].empty()) {
      deadline = make_shared<long>(boost::any_cast<long>(m["Deadline"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<long>(boost::any_cast<long>(m["OrderType"]));
    }
    if (m.find("ProjectMeta") != m.end() && !m["ProjectMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectMeta"].type()) {
        GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectMeta"]));
        projectMeta = make_shared<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta>(model1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent() = default;
};
class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail : public Darabonba::Model {
public:
  shared_ptr<string> applyBaseId{};
  shared_ptr<long> applyTimestamp{};
  shared_ptr<string> flowId{};
  shared_ptr<long> flowStatus{};
  shared_ptr<vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList>> approveAccountList{};
  shared_ptr<vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList>> granteeObjectList{};
  shared_ptr<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent> approveContent{};

  GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail() {}

  explicit GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyBaseId) {
      res["ApplyBaseId"] = boost::any(*applyBaseId);
    }
    if (applyTimestamp) {
      res["ApplyTimestamp"] = boost::any(*applyTimestamp);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowStatus) {
      res["FlowStatus"] = boost::any(*flowStatus);
    }
    if (approveAccountList) {
      vector<boost::any> temp1;
      for(auto item1:*approveAccountList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApproveAccountList"] = boost::any(temp1);
    }
    if (granteeObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*granteeObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GranteeObjectList"] = boost::any(temp1);
    }
    if (approveContent) {
      res["ApproveContent"] = approveContent ? boost::any(approveContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyBaseId") != m.end() && !m["ApplyBaseId"].empty()) {
      applyBaseId = make_shared<string>(boost::any_cast<string>(m["ApplyBaseId"]));
    }
    if (m.find("ApplyTimestamp") != m.end() && !m["ApplyTimestamp"].empty()) {
      applyTimestamp = make_shared<long>(boost::any_cast<long>(m["ApplyTimestamp"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowStatus") != m.end() && !m["FlowStatus"].empty()) {
      flowStatus = make_shared<long>(boost::any_cast<long>(m["FlowStatus"]));
    }
    if (m.find("ApproveAccountList") != m.end() && !m["ApproveAccountList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApproveAccountList"].type()) {
        vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApproveAccountList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        approveAccountList = make_shared<vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList>>(expect1);
      }
    }
    if (m.find("GranteeObjectList") != m.end() && !m["GranteeObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["GranteeObjectList"].type()) {
        vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GranteeObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        granteeObjectList = make_shared<vector<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList>>(expect1);
      }
    }
    if (m.find("ApproveContent") != m.end() && !m["ApproveContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApproveContent"].type()) {
        GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApproveContent"]));
        approveContent = make_shared<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent>(model1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail() = default;
};
class GetPermissionApplyOrderDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail> applyOrderDetail{};

  GetPermissionApplyOrderDetailResponseBody() {}

  explicit GetPermissionApplyOrderDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (applyOrderDetail) {
      res["ApplyOrderDetail"] = applyOrderDetail ? boost::any(applyOrderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ApplyOrderDetail") != m.end() && !m["ApplyOrderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplyOrderDetail"].type()) {
        GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplyOrderDetail"]));
        applyOrderDetail = make_shared<GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail>(model1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponseBody() = default;
};
class GetPermissionApplyOrderDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetPermissionApplyOrderDetailResponseBody> body{};

  GetPermissionApplyOrderDetailResponse() {}

  explicit GetPermissionApplyOrderDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPermissionApplyOrderDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPermissionApplyOrderDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetPermissionApplyOrderDetailResponse() = default;
};
class GetProjectRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  GetProjectRequest() {}

  explicit GetProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetProjectRequest() = default;
};
class GetProjectResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> maxFlowNode{};
  shared_ptr<long> projectId{};
  shared_ptr<long> isAllowDownload{};
  shared_ptr<long> projectMode{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> prodStorageQuota{};
  shared_ptr<string> projectDescription{};
  shared_ptr<long> developmentType{};
  shared_ptr<long> tablePrivacyMode{};
  shared_ptr<string> defaultDiResourceGroupIdentifier{};
  shared_ptr<long> schedulerMaxRetryTimes{};
  shared_ptr<long> protectedMode{};
  shared_ptr<long> schedulerRetryInterval{};
  shared_ptr<string> appkey{};
  shared_ptr<string> devStorageQuota{};
  shared_ptr<string> residentArea{};
  shared_ptr<long> isDefault{};
  shared_ptr<long> destination{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<bool> disableDevelopment{};
  shared_ptr<string> projectOwnerBaseId{};
  shared_ptr<bool> baseProject{};
  shared_ptr<bool> useProxyOdpsAccount{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> tenantId{};
  shared_ptr<vector<string>> envTypes{};

  GetProjectResponseBodyData() {}

  explicit GetProjectResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (maxFlowNode) {
      res["MaxFlowNode"] = boost::any(*maxFlowNode);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (isAllowDownload) {
      res["IsAllowDownload"] = boost::any(*isAllowDownload);
    }
    if (projectMode) {
      res["ProjectMode"] = boost::any(*projectMode);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (prodStorageQuota) {
      res["ProdStorageQuota"] = boost::any(*prodStorageQuota);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (developmentType) {
      res["DevelopmentType"] = boost::any(*developmentType);
    }
    if (tablePrivacyMode) {
      res["TablePrivacyMode"] = boost::any(*tablePrivacyMode);
    }
    if (defaultDiResourceGroupIdentifier) {
      res["DefaultDiResourceGroupIdentifier"] = boost::any(*defaultDiResourceGroupIdentifier);
    }
    if (schedulerMaxRetryTimes) {
      res["SchedulerMaxRetryTimes"] = boost::any(*schedulerMaxRetryTimes);
    }
    if (protectedMode) {
      res["ProtectedMode"] = boost::any(*protectedMode);
    }
    if (schedulerRetryInterval) {
      res["SchedulerRetryInterval"] = boost::any(*schedulerRetryInterval);
    }
    if (appkey) {
      res["Appkey"] = boost::any(*appkey);
    }
    if (devStorageQuota) {
      res["DevStorageQuota"] = boost::any(*devStorageQuota);
    }
    if (residentArea) {
      res["ResidentArea"] = boost::any(*residentArea);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (disableDevelopment) {
      res["DisableDevelopment"] = boost::any(*disableDevelopment);
    }
    if (projectOwnerBaseId) {
      res["ProjectOwnerBaseId"] = boost::any(*projectOwnerBaseId);
    }
    if (baseProject) {
      res["BaseProject"] = boost::any(*baseProject);
    }
    if (useProxyOdpsAccount) {
      res["UseProxyOdpsAccount"] = boost::any(*useProxyOdpsAccount);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (envTypes) {
      res["EnvTypes"] = boost::any(*envTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("MaxFlowNode") != m.end() && !m["MaxFlowNode"].empty()) {
      maxFlowNode = make_shared<long>(boost::any_cast<long>(m["MaxFlowNode"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("IsAllowDownload") != m.end() && !m["IsAllowDownload"].empty()) {
      isAllowDownload = make_shared<long>(boost::any_cast<long>(m["IsAllowDownload"]));
    }
    if (m.find("ProjectMode") != m.end() && !m["ProjectMode"].empty()) {
      projectMode = make_shared<long>(boost::any_cast<long>(m["ProjectMode"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ProdStorageQuota") != m.end() && !m["ProdStorageQuota"].empty()) {
      prodStorageQuota = make_shared<string>(boost::any_cast<string>(m["ProdStorageQuota"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("DevelopmentType") != m.end() && !m["DevelopmentType"].empty()) {
      developmentType = make_shared<long>(boost::any_cast<long>(m["DevelopmentType"]));
    }
    if (m.find("TablePrivacyMode") != m.end() && !m["TablePrivacyMode"].empty()) {
      tablePrivacyMode = make_shared<long>(boost::any_cast<long>(m["TablePrivacyMode"]));
    }
    if (m.find("DefaultDiResourceGroupIdentifier") != m.end() && !m["DefaultDiResourceGroupIdentifier"].empty()) {
      defaultDiResourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["DefaultDiResourceGroupIdentifier"]));
    }
    if (m.find("SchedulerMaxRetryTimes") != m.end() && !m["SchedulerMaxRetryTimes"].empty()) {
      schedulerMaxRetryTimes = make_shared<long>(boost::any_cast<long>(m["SchedulerMaxRetryTimes"]));
    }
    if (m.find("ProtectedMode") != m.end() && !m["ProtectedMode"].empty()) {
      protectedMode = make_shared<long>(boost::any_cast<long>(m["ProtectedMode"]));
    }
    if (m.find("SchedulerRetryInterval") != m.end() && !m["SchedulerRetryInterval"].empty()) {
      schedulerRetryInterval = make_shared<long>(boost::any_cast<long>(m["SchedulerRetryInterval"]));
    }
    if (m.find("Appkey") != m.end() && !m["Appkey"].empty()) {
      appkey = make_shared<string>(boost::any_cast<string>(m["Appkey"]));
    }
    if (m.find("DevStorageQuota") != m.end() && !m["DevStorageQuota"].empty()) {
      devStorageQuota = make_shared<string>(boost::any_cast<string>(m["DevStorageQuota"]));
    }
    if (m.find("ResidentArea") != m.end() && !m["ResidentArea"].empty()) {
      residentArea = make_shared<string>(boost::any_cast<string>(m["ResidentArea"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<long>(boost::any_cast<long>(m["IsDefault"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<long>(boost::any_cast<long>(m["Destination"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("DisableDevelopment") != m.end() && !m["DisableDevelopment"].empty()) {
      disableDevelopment = make_shared<bool>(boost::any_cast<bool>(m["DisableDevelopment"]));
    }
    if (m.find("ProjectOwnerBaseId") != m.end() && !m["ProjectOwnerBaseId"].empty()) {
      projectOwnerBaseId = make_shared<string>(boost::any_cast<string>(m["ProjectOwnerBaseId"]));
    }
    if (m.find("BaseProject") != m.end() && !m["BaseProject"].empty()) {
      baseProject = make_shared<bool>(boost::any_cast<bool>(m["BaseProject"]));
    }
    if (m.find("UseProxyOdpsAccount") != m.end() && !m["UseProxyOdpsAccount"].empty()) {
      useProxyOdpsAccount = make_shared<bool>(boost::any_cast<bool>(m["UseProxyOdpsAccount"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("EnvTypes") != m.end() && !m["EnvTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnvTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnvTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      envTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetProjectResponseBodyData() = default;
};
class GetProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetProjectResponseBodyData> data{};

  GetProjectResponseBody() {}

  explicit GetProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetProjectResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetProjectResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetProjectResponseBody() = default;
};
class GetProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetProjectResponseBody> body{};

  GetProjectResponse() {}

  explicit GetProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectResponse() = default;
};
class GetProjectDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  GetProjectDetailRequest() {}

  explicit GetProjectDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetProjectDetailRequest() = default;
};
class GetProjectDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> residentArea{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> projectName{};
  shared_ptr<long> isAllowDownload{};
  shared_ptr<long> projectMode{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> projectOwnerBaseId{};
  shared_ptr<long> developmentType{};
  shared_ptr<string> defaultDiResourceGroupIdentifier{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> schedulerMaxRetryTimes{};
  shared_ptr<long> protectedMode{};
  shared_ptr<long> tenantId{};
  shared_ptr<long> schedulerRetryInterval{};
  shared_ptr<vector<string>> envTypes{};

  GetProjectDetailResponseBodyData() {}

  explicit GetProjectDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (residentArea) {
      res["ResidentArea"] = boost::any(*residentArea);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (isAllowDownload) {
      res["IsAllowDownload"] = boost::any(*isAllowDownload);
    }
    if (projectMode) {
      res["ProjectMode"] = boost::any(*projectMode);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (projectOwnerBaseId) {
      res["ProjectOwnerBaseId"] = boost::any(*projectOwnerBaseId);
    }
    if (developmentType) {
      res["DevelopmentType"] = boost::any(*developmentType);
    }
    if (defaultDiResourceGroupIdentifier) {
      res["DefaultDiResourceGroupIdentifier"] = boost::any(*defaultDiResourceGroupIdentifier);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (schedulerMaxRetryTimes) {
      res["SchedulerMaxRetryTimes"] = boost::any(*schedulerMaxRetryTimes);
    }
    if (protectedMode) {
      res["ProtectedMode"] = boost::any(*protectedMode);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (schedulerRetryInterval) {
      res["SchedulerRetryInterval"] = boost::any(*schedulerRetryInterval);
    }
    if (envTypes) {
      res["EnvTypes"] = boost::any(*envTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ResidentArea") != m.end() && !m["ResidentArea"].empty()) {
      residentArea = make_shared<string>(boost::any_cast<string>(m["ResidentArea"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("IsAllowDownload") != m.end() && !m["IsAllowDownload"].empty()) {
      isAllowDownload = make_shared<long>(boost::any_cast<long>(m["IsAllowDownload"]));
    }
    if (m.find("ProjectMode") != m.end() && !m["ProjectMode"].empty()) {
      projectMode = make_shared<long>(boost::any_cast<long>(m["ProjectMode"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ProjectOwnerBaseId") != m.end() && !m["ProjectOwnerBaseId"].empty()) {
      projectOwnerBaseId = make_shared<string>(boost::any_cast<string>(m["ProjectOwnerBaseId"]));
    }
    if (m.find("DevelopmentType") != m.end() && !m["DevelopmentType"].empty()) {
      developmentType = make_shared<long>(boost::any_cast<long>(m["DevelopmentType"]));
    }
    if (m.find("DefaultDiResourceGroupIdentifier") != m.end() && !m["DefaultDiResourceGroupIdentifier"].empty()) {
      defaultDiResourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["DefaultDiResourceGroupIdentifier"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("SchedulerMaxRetryTimes") != m.end() && !m["SchedulerMaxRetryTimes"].empty()) {
      schedulerMaxRetryTimes = make_shared<long>(boost::any_cast<long>(m["SchedulerMaxRetryTimes"]));
    }
    if (m.find("ProtectedMode") != m.end() && !m["ProtectedMode"].empty()) {
      protectedMode = make_shared<long>(boost::any_cast<long>(m["ProtectedMode"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("SchedulerRetryInterval") != m.end() && !m["SchedulerRetryInterval"].empty()) {
      schedulerRetryInterval = make_shared<long>(boost::any_cast<long>(m["SchedulerRetryInterval"]));
    }
    if (m.find("EnvTypes") != m.end() && !m["EnvTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EnvTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EnvTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      envTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetProjectDetailResponseBodyData() = default;
};
class GetProjectDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetProjectDetailResponseBodyData> data{};

  GetProjectDetailResponseBody() {}

  explicit GetProjectDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetProjectDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetProjectDetailResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetProjectDetailResponseBody() = default;
};
class GetProjectDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetProjectDetailResponseBody> body{};

  GetProjectDetailResponse() {}

  explicit GetProjectDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectDetailResponse() = default;
};
class GetQualityEntityRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> envType{};
  shared_ptr<string> matchExpression{};

  GetQualityEntityRequest() {}

  explicit GetQualityEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
  }


  virtual ~GetQualityEntityRequest() = default;
};
class GetQualityEntityResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> relativeNode{};
  shared_ptr<string> onDutyAccountName{};
  shared_ptr<long> task{};
  shared_ptr<string> tableName{};
  shared_ptr<string> followers{};
  shared_ptr<string> onDuty{};
  shared_ptr<string> matchExpression{};
  shared_ptr<long> createTime{};
  shared_ptr<string> projectName{};
  shared_ptr<bool> hasRelativeNode{};
  shared_ptr<string> envType{};
  shared_ptr<long> entityLevel{};
  shared_ptr<string> modifyUser{};
  shared_ptr<long> sql{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};

  GetQualityEntityResponseBodyData() {}

  explicit GetQualityEntityResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relativeNode) {
      res["RelativeNode"] = boost::any(*relativeNode);
    }
    if (onDutyAccountName) {
      res["OnDutyAccountName"] = boost::any(*onDutyAccountName);
    }
    if (task) {
      res["Task"] = boost::any(*task);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (followers) {
      res["Followers"] = boost::any(*followers);
    }
    if (onDuty) {
      res["OnDuty"] = boost::any(*onDuty);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (hasRelativeNode) {
      res["HasRelativeNode"] = boost::any(*hasRelativeNode);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (entityLevel) {
      res["EntityLevel"] = boost::any(*entityLevel);
    }
    if (modifyUser) {
      res["ModifyUser"] = boost::any(*modifyUser);
    }
    if (sql) {
      res["Sql"] = boost::any(*sql);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelativeNode") != m.end() && !m["RelativeNode"].empty()) {
      relativeNode = make_shared<string>(boost::any_cast<string>(m["RelativeNode"]));
    }
    if (m.find("OnDutyAccountName") != m.end() && !m["OnDutyAccountName"].empty()) {
      onDutyAccountName = make_shared<string>(boost::any_cast<string>(m["OnDutyAccountName"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      task = make_shared<long>(boost::any_cast<long>(m["Task"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Followers") != m.end() && !m["Followers"].empty()) {
      followers = make_shared<string>(boost::any_cast<string>(m["Followers"]));
    }
    if (m.find("OnDuty") != m.end() && !m["OnDuty"].empty()) {
      onDuty = make_shared<string>(boost::any_cast<string>(m["OnDuty"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("HasRelativeNode") != m.end() && !m["HasRelativeNode"].empty()) {
      hasRelativeNode = make_shared<bool>(boost::any_cast<bool>(m["HasRelativeNode"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("EntityLevel") != m.end() && !m["EntityLevel"].empty()) {
      entityLevel = make_shared<long>(boost::any_cast<long>(m["EntityLevel"]));
    }
    if (m.find("ModifyUser") != m.end() && !m["ModifyUser"].empty()) {
      modifyUser = make_shared<string>(boost::any_cast<string>(m["ModifyUser"]));
    }
    if (m.find("Sql") != m.end() && !m["Sql"].empty()) {
      sql = make_shared<long>(boost::any_cast<long>(m["Sql"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
  }


  virtual ~GetQualityEntityResponseBodyData() = default;
};
class GetQualityEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetQualityEntityResponseBodyData>> data{};

  GetQualityEntityResponseBody() {}

  explicit GetQualityEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetQualityEntityResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQualityEntityResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetQualityEntityResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~GetQualityEntityResponseBody() = default;
};
class GetQualityEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetQualityEntityResponseBody> body{};

  GetQualityEntityResponse() {}

  explicit GetQualityEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQualityEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQualityEntityResponseBody>(model1);
      }
    }
  }


  virtual ~GetQualityEntityResponse() = default;
};
class GetQualityFollowerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> entityId{};

  GetQualityFollowerRequest() {}

  explicit GetQualityFollowerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
  }


  virtual ~GetQualityFollowerRequest() = default;
};
class GetQualityFollowerResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> followerAccountName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> alarmMode{};
  shared_ptr<string> entityId{};
  shared_ptr<string> projectName{};
  shared_ptr<long> id{};
  shared_ptr<string> follower{};

  GetQualityFollowerResponseBodyData() {}

  explicit GetQualityFollowerResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (followerAccountName) {
      res["FollowerAccountName"] = boost::any(*followerAccountName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (alarmMode) {
      res["AlarmMode"] = boost::any(*alarmMode);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (follower) {
      res["Follower"] = boost::any(*follower);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FollowerAccountName") != m.end() && !m["FollowerAccountName"].empty()) {
      followerAccountName = make_shared<string>(boost::any_cast<string>(m["FollowerAccountName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("AlarmMode") != m.end() && !m["AlarmMode"].empty()) {
      alarmMode = make_shared<long>(boost::any_cast<long>(m["AlarmMode"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Follower") != m.end() && !m["Follower"].empty()) {
      follower = make_shared<string>(boost::any_cast<string>(m["Follower"]));
    }
  }


  virtual ~GetQualityFollowerResponseBodyData() = default;
};
class GetQualityFollowerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<vector<GetQualityFollowerResponseBodyData>> data{};

  GetQualityFollowerResponseBody() {}

  explicit GetQualityFollowerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetQualityFollowerResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQualityFollowerResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetQualityFollowerResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~GetQualityFollowerResponseBody() = default;
};
class GetQualityFollowerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetQualityFollowerResponseBody> body{};

  GetQualityFollowerResponse() {}

  explicit GetQualityFollowerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQualityFollowerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQualityFollowerResponseBody>(model1);
      }
    }
  }


  virtual ~GetQualityFollowerResponse() = default;
};
class GetQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};
  shared_ptr<string> projectName{};

  GetQualityRuleRequest() {}

  explicit GetQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~GetQualityRuleRequest() = default;
};
class GetQualityRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> blockType{};
  shared_ptr<string> onDutyAccountName{};
  shared_ptr<string> warningThreshold{};
  shared_ptr<string> property{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> comment{};
  shared_ptr<string> onDuty{};
  shared_ptr<long> checker{};
  shared_ptr<bool> fixCheck{};
  shared_ptr<long> methodId{};
  shared_ptr<string> criticalThreshold{};
  shared_ptr<long> predictType{};
  shared_ptr<string> templateName{};
  shared_ptr<string> checkerName{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> methodName{};
  shared_ptr<long> entityId{};
  shared_ptr<string> whereCondition{};
  shared_ptr<string> operator_{};
  shared_ptr<string> expectValue{};
  shared_ptr<string> trend{};
  shared_ptr<long> templateId{};
  shared_ptr<long> id{};

  GetQualityRuleResponseBodyData() {}

  explicit GetQualityRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (onDutyAccountName) {
      res["OnDutyAccountName"] = boost::any(*onDutyAccountName);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (onDuty) {
      res["OnDuty"] = boost::any(*onDuty);
    }
    if (checker) {
      res["Checker"] = boost::any(*checker);
    }
    if (fixCheck) {
      res["FixCheck"] = boost::any(*fixCheck);
    }
    if (methodId) {
      res["MethodId"] = boost::any(*methodId);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (predictType) {
      res["PredictType"] = boost::any(*predictType);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (checkerName) {
      res["CheckerName"] = boost::any(*checkerName);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (whereCondition) {
      res["WhereCondition"] = boost::any(*whereCondition);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<long>(boost::any_cast<long>(m["BlockType"]));
    }
    if (m.find("OnDutyAccountName") != m.end() && !m["OnDutyAccountName"].empty()) {
      onDutyAccountName = make_shared<string>(boost::any_cast<string>(m["OnDutyAccountName"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<string>(boost::any_cast<string>(m["WarningThreshold"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("OnDuty") != m.end() && !m["OnDuty"].empty()) {
      onDuty = make_shared<string>(boost::any_cast<string>(m["OnDuty"]));
    }
    if (m.find("Checker") != m.end() && !m["Checker"].empty()) {
      checker = make_shared<long>(boost::any_cast<long>(m["Checker"]));
    }
    if (m.find("FixCheck") != m.end() && !m["FixCheck"].empty()) {
      fixCheck = make_shared<bool>(boost::any_cast<bool>(m["FixCheck"]));
    }
    if (m.find("MethodId") != m.end() && !m["MethodId"].empty()) {
      methodId = make_shared<long>(boost::any_cast<long>(m["MethodId"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<string>(boost::any_cast<string>(m["CriticalThreshold"]));
    }
    if (m.find("PredictType") != m.end() && !m["PredictType"].empty()) {
      predictType = make_shared<long>(boost::any_cast<long>(m["PredictType"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("CheckerName") != m.end() && !m["CheckerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["CheckerName"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("WhereCondition") != m.end() && !m["WhereCondition"].empty()) {
      whereCondition = make_shared<string>(boost::any_cast<string>(m["WhereCondition"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<string>(boost::any_cast<string>(m["ExpectValue"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetQualityRuleResponseBodyData() = default;
};
class GetQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetQualityRuleResponseBodyData> data{};

  GetQualityRuleResponseBody() {}

  explicit GetQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetQualityRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetQualityRuleResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetQualityRuleResponseBody() = default;
};
class GetQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetQualityRuleResponseBody> body{};

  GetQualityRuleResponse() {}

  explicit GetQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetQualityRuleResponse() = default;
};
class GetRemindRequest : public Darabonba::Model {
public:
  shared_ptr<long> remindId{};

  GetRemindRequest() {}

  explicit GetRemindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
  }


  virtual ~GetRemindRequest() = default;
};
class GetRemindResponseBodyDataRobots : public Darabonba::Model {
public:
  shared_ptr<string> webUrl{};
  shared_ptr<bool> atAll{};

  GetRemindResponseBodyDataRobots() {}

  explicit GetRemindResponseBodyDataRobots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (webUrl) {
      res["WebUrl"] = boost::any(*webUrl);
    }
    if (atAll) {
      res["AtAll"] = boost::any(*atAll);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WebUrl") != m.end() && !m["WebUrl"].empty()) {
      webUrl = make_shared<string>(boost::any_cast<string>(m["WebUrl"]));
    }
    if (m.find("AtAll") != m.end() && !m["AtAll"].empty()) {
      atAll = make_shared<bool>(boost::any_cast<bool>(m["AtAll"]));
    }
  }


  virtual ~GetRemindResponseBodyDataRobots() = default;
};
class GetRemindResponseBodyDataNodes : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};

  GetRemindResponseBodyDataNodes() {}

  explicit GetRemindResponseBodyDataNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetRemindResponseBodyDataNodes() = default;
};
class GetRemindResponseBodyDataBaselines : public Darabonba::Model {
public:
  shared_ptr<string> baselineName{};
  shared_ptr<long> baselineId{};

  GetRemindResponseBodyDataBaselines() {}

  explicit GetRemindResponseBodyDataBaselines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
  }


  virtual ~GetRemindResponseBodyDataBaselines() = default;
};
class GetRemindResponseBodyDataProjects : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  GetRemindResponseBodyDataProjects() {}

  explicit GetRemindResponseBodyDataProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetRemindResponseBodyDataProjects() = default;
};
class GetRemindResponseBodyDataBizProcesses : public Darabonba::Model {
public:
  shared_ptr<string> bizProcessName{};
  shared_ptr<long> bizId{};

  GetRemindResponseBodyDataBizProcesses() {}

  explicit GetRemindResponseBodyDataBizProcesses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizProcessName) {
      res["BizProcessName"] = boost::any(*bizProcessName);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizProcessName") != m.end() && !m["BizProcessName"].empty()) {
      bizProcessName = make_shared<string>(boost::any_cast<string>(m["BizProcessName"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<long>(boost::any_cast<long>(m["BizId"]));
    }
  }


  virtual ~GetRemindResponseBodyDataBizProcesses() = default;
};
class GetRemindResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> maxAlertTimes{};
  shared_ptr<string> remindUnit{};
  shared_ptr<long> alertInterval{};
  shared_ptr<bool> useflag{};
  shared_ptr<string> founder{};
  shared_ptr<long> remindId{};
  shared_ptr<string> dndEnd{};
  shared_ptr<string> remindType{};
  shared_ptr<string> alertUnit{};
  shared_ptr<string> dndStart{};
  shared_ptr<string> remindName{};
  shared_ptr<string> detail{};
  shared_ptr<vector<GetRemindResponseBodyDataRobots>> robots{};
  shared_ptr<vector<GetRemindResponseBodyDataNodes>> nodes{};
  shared_ptr<vector<GetRemindResponseBodyDataBaselines>> baselines{};
  shared_ptr<vector<GetRemindResponseBodyDataProjects>> projects{};
  shared_ptr<vector<GetRemindResponseBodyDataBizProcesses>> bizProcesses{};
  shared_ptr<vector<string>> alertTargets{};
  shared_ptr<vector<string>> alertMethods{};

  GetRemindResponseBodyData() {}

  explicit GetRemindResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxAlertTimes) {
      res["MaxAlertTimes"] = boost::any(*maxAlertTimes);
    }
    if (remindUnit) {
      res["RemindUnit"] = boost::any(*remindUnit);
    }
    if (alertInterval) {
      res["AlertInterval"] = boost::any(*alertInterval);
    }
    if (useflag) {
      res["Useflag"] = boost::any(*useflag);
    }
    if (founder) {
      res["Founder"] = boost::any(*founder);
    }
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    if (dndEnd) {
      res["DndEnd"] = boost::any(*dndEnd);
    }
    if (remindType) {
      res["RemindType"] = boost::any(*remindType);
    }
    if (alertUnit) {
      res["AlertUnit"] = boost::any(*alertUnit);
    }
    if (dndStart) {
      res["DndStart"] = boost::any(*dndStart);
    }
    if (remindName) {
      res["RemindName"] = boost::any(*remindName);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (robots) {
      vector<boost::any> temp1;
      for(auto item1:*robots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Robots"] = boost::any(temp1);
    }
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (baselines) {
      vector<boost::any> temp1;
      for(auto item1:*baselines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Baselines"] = boost::any(temp1);
    }
    if (projects) {
      vector<boost::any> temp1;
      for(auto item1:*projects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Projects"] = boost::any(temp1);
    }
    if (bizProcesses) {
      vector<boost::any> temp1;
      for(auto item1:*bizProcesses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BizProcesses"] = boost::any(temp1);
    }
    if (alertTargets) {
      res["AlertTargets"] = boost::any(*alertTargets);
    }
    if (alertMethods) {
      res["AlertMethods"] = boost::any(*alertMethods);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxAlertTimes") != m.end() && !m["MaxAlertTimes"].empty()) {
      maxAlertTimes = make_shared<long>(boost::any_cast<long>(m["MaxAlertTimes"]));
    }
    if (m.find("RemindUnit") != m.end() && !m["RemindUnit"].empty()) {
      remindUnit = make_shared<string>(boost::any_cast<string>(m["RemindUnit"]));
    }
    if (m.find("AlertInterval") != m.end() && !m["AlertInterval"].empty()) {
      alertInterval = make_shared<long>(boost::any_cast<long>(m["AlertInterval"]));
    }
    if (m.find("Useflag") != m.end() && !m["Useflag"].empty()) {
      useflag = make_shared<bool>(boost::any_cast<bool>(m["Useflag"]));
    }
    if (m.find("Founder") != m.end() && !m["Founder"].empty()) {
      founder = make_shared<string>(boost::any_cast<string>(m["Founder"]));
    }
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
    if (m.find("DndEnd") != m.end() && !m["DndEnd"].empty()) {
      dndEnd = make_shared<string>(boost::any_cast<string>(m["DndEnd"]));
    }
    if (m.find("RemindType") != m.end() && !m["RemindType"].empty()) {
      remindType = make_shared<string>(boost::any_cast<string>(m["RemindType"]));
    }
    if (m.find("AlertUnit") != m.end() && !m["AlertUnit"].empty()) {
      alertUnit = make_shared<string>(boost::any_cast<string>(m["AlertUnit"]));
    }
    if (m.find("DndStart") != m.end() && !m["DndStart"].empty()) {
      dndStart = make_shared<string>(boost::any_cast<string>(m["DndStart"]));
    }
    if (m.find("RemindName") != m.end() && !m["RemindName"].empty()) {
      remindName = make_shared<string>(boost::any_cast<string>(m["RemindName"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("Robots") != m.end() && !m["Robots"].empty()) {
      if (typeid(vector<boost::any>) == m["Robots"].type()) {
        vector<GetRemindResponseBodyDataRobots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Robots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemindResponseBodyDataRobots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        robots = make_shared<vector<GetRemindResponseBodyDataRobots>>(expect1);
      }
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<GetRemindResponseBodyDataNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemindResponseBodyDataNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<GetRemindResponseBodyDataNodes>>(expect1);
      }
    }
    if (m.find("Baselines") != m.end() && !m["Baselines"].empty()) {
      if (typeid(vector<boost::any>) == m["Baselines"].type()) {
        vector<GetRemindResponseBodyDataBaselines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Baselines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemindResponseBodyDataBaselines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselines = make_shared<vector<GetRemindResponseBodyDataBaselines>>(expect1);
      }
    }
    if (m.find("Projects") != m.end() && !m["Projects"].empty()) {
      if (typeid(vector<boost::any>) == m["Projects"].type()) {
        vector<GetRemindResponseBodyDataProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Projects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemindResponseBodyDataProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projects = make_shared<vector<GetRemindResponseBodyDataProjects>>(expect1);
      }
    }
    if (m.find("BizProcesses") != m.end() && !m["BizProcesses"].empty()) {
      if (typeid(vector<boost::any>) == m["BizProcesses"].type()) {
        vector<GetRemindResponseBodyDataBizProcesses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BizProcesses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRemindResponseBodyDataBizProcesses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bizProcesses = make_shared<vector<GetRemindResponseBodyDataBizProcesses>>(expect1);
      }
    }
    if (m.find("AlertTargets") != m.end() && !m["AlertTargets"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertTargets"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertTargets"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertTargets = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AlertMethods") != m.end() && !m["AlertMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertMethods = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRemindResponseBodyData() = default;
};
class GetRemindResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetRemindResponseBodyData> data{};

  GetRemindResponseBody() {}

  explicit GetRemindResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRemindResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRemindResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetRemindResponseBody() = default;
};
class GetRemindResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetRemindResponseBody> body{};

  GetRemindResponse() {}

  explicit GetRemindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRemindResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRemindResponseBody>(model1);
      }
    }
  }


  virtual ~GetRemindResponse() = default;
};
class GetSensitiveDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNo{};
  shared_ptr<string> name{};

  GetSensitiveDataRequest() {}

  explicit GetSensitiveDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetSensitiveDataRequest() = default;
};
class GetSensitiveDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> sensitiveData{};
  shared_ptr<string> requestId{};

  GetSensitiveDataResponseBody() {}

  explicit GetSensitiveDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sensitiveData) {
      res["SensitiveData"] = boost::any(*sensitiveData);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SensitiveData") != m.end() && !m["SensitiveData"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SensitiveData"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      sensitiveData = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSensitiveDataResponseBody() = default;
};
class GetSensitiveDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSensitiveDataResponseBody> body{};

  GetSensitiveDataResponse() {}

  explicit GetSensitiveDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSensitiveDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSensitiveDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetSensitiveDataResponse() = default;
};
class GetSuccessInstanceTrendRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  GetSuccessInstanceTrendRequest() {}

  explicit GetSuccessInstanceTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetSuccessInstanceTrendRequest() = default;
};
class GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend : public Darabonba::Model {
public:
  shared_ptr<string> timePoint{};
  shared_ptr<long> count{};

  GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend() {}

  explicit GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend() = default;
};
class GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend : public Darabonba::Model {
public:
  shared_ptr<string> timePoint{};
  shared_ptr<long> count{};

  GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend() {}

  explicit GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend() = default;
};
class GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend : public Darabonba::Model {
public:
  shared_ptr<string> timePoint{};
  shared_ptr<long> count{};

  GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend() {}

  explicit GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend() = default;
};
class GetSuccessInstanceTrendResponseBodyInstanceStatusTrend : public Darabonba::Model {
public:
  shared_ptr<vector<GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend>> todayTrend{};
  shared_ptr<vector<GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend>> yesterdayTrend{};
  shared_ptr<vector<GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend>> avgTrend{};

  GetSuccessInstanceTrendResponseBodyInstanceStatusTrend() {}

  explicit GetSuccessInstanceTrendResponseBodyInstanceStatusTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (todayTrend) {
      vector<boost::any> temp1;
      for(auto item1:*todayTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TodayTrend"] = boost::any(temp1);
    }
    if (yesterdayTrend) {
      vector<boost::any> temp1;
      for(auto item1:*yesterdayTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["YesterdayTrend"] = boost::any(temp1);
    }
    if (avgTrend) {
      vector<boost::any> temp1;
      for(auto item1:*avgTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvgTrend"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TodayTrend") != m.end() && !m["TodayTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["TodayTrend"].type()) {
        vector<GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TodayTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        todayTrend = make_shared<vector<GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend>>(expect1);
      }
    }
    if (m.find("YesterdayTrend") != m.end() && !m["YesterdayTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["YesterdayTrend"].type()) {
        vector<GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["YesterdayTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        yesterdayTrend = make_shared<vector<GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend>>(expect1);
      }
    }
    if (m.find("AvgTrend") != m.end() && !m["AvgTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["AvgTrend"].type()) {
        vector<GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvgTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        avgTrend = make_shared<vector<GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend>>(expect1);
      }
    }
  }


  virtual ~GetSuccessInstanceTrendResponseBodyInstanceStatusTrend() = default;
};
class GetSuccessInstanceTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSuccessInstanceTrendResponseBodyInstanceStatusTrend> instanceStatusTrend{};

  GetSuccessInstanceTrendResponseBody() {}

  explicit GetSuccessInstanceTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceStatusTrend) {
      res["InstanceStatusTrend"] = instanceStatusTrend ? boost::any(instanceStatusTrend->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceStatusTrend") != m.end() && !m["InstanceStatusTrend"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceStatusTrend"].type()) {
        GetSuccessInstanceTrendResponseBodyInstanceStatusTrend model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceStatusTrend"]));
        instanceStatusTrend = make_shared<GetSuccessInstanceTrendResponseBodyInstanceStatusTrend>(model1);
      }
    }
  }


  virtual ~GetSuccessInstanceTrendResponseBody() = default;
};
class GetSuccessInstanceTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSuccessInstanceTrendResponseBody> body{};

  GetSuccessInstanceTrendResponse() {}

  explicit GetSuccessInstanceTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSuccessInstanceTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSuccessInstanceTrendResponseBody>(model1);
      }
    }
  }


  virtual ~GetSuccessInstanceTrendResponse() = default;
};
class GetTopicRequest : public Darabonba::Model {
public:
  shared_ptr<long> topicId{};

  GetTopicRequest() {}

  explicit GetTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
  }


  virtual ~GetTopicRequest() = default;
};
class GetTopicResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> topicName{};
  shared_ptr<string> baselineStatus{};
  shared_ptr<long> projectId{};
  shared_ptr<long> nextAlertTime{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> fixTime{};
  shared_ptr<long> baselineInGroupId{};
  shared_ptr<long> baselineBuffer{};
  shared_ptr<string> topicType{};
  shared_ptr<string> topicStatus{};
  shared_ptr<long> happenTime{};
  shared_ptr<long> dealTime{};
  shared_ptr<string> dealUser{};
  shared_ptr<string> baselineName{};
  shared_ptr<long> baselineId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> alertTime{};
  shared_ptr<long> buffer{};
  shared_ptr<string> assigner{};
  shared_ptr<long> topicId{};
  shared_ptr<long> addTime{};
  shared_ptr<long> nodeId{};

  GetTopicResponseBodyData() {}

  explicit GetTopicResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    if (baselineStatus) {
      res["BaselineStatus"] = boost::any(*baselineStatus);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (nextAlertTime) {
      res["NextAlertTime"] = boost::any(*nextAlertTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (fixTime) {
      res["FixTime"] = boost::any(*fixTime);
    }
    if (baselineInGroupId) {
      res["BaselineInGroupId"] = boost::any(*baselineInGroupId);
    }
    if (baselineBuffer) {
      res["BaselineBuffer"] = boost::any(*baselineBuffer);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (topicStatus) {
      res["TopicStatus"] = boost::any(*topicStatus);
    }
    if (happenTime) {
      res["HappenTime"] = boost::any(*happenTime);
    }
    if (dealTime) {
      res["DealTime"] = boost::any(*dealTime);
    }
    if (dealUser) {
      res["DealUser"] = boost::any(*dealUser);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (alertTime) {
      res["AlertTime"] = boost::any(*alertTime);
    }
    if (buffer) {
      res["Buffer"] = boost::any(*buffer);
    }
    if (assigner) {
      res["Assigner"] = boost::any(*assigner);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (addTime) {
      res["AddTime"] = boost::any(*addTime);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<string>(boost::any_cast<string>(m["TopicName"]));
    }
    if (m.find("BaselineStatus") != m.end() && !m["BaselineStatus"].empty()) {
      baselineStatus = make_shared<string>(boost::any_cast<string>(m["BaselineStatus"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("NextAlertTime") != m.end() && !m["NextAlertTime"].empty()) {
      nextAlertTime = make_shared<long>(boost::any_cast<long>(m["NextAlertTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("FixTime") != m.end() && !m["FixTime"].empty()) {
      fixTime = make_shared<long>(boost::any_cast<long>(m["FixTime"]));
    }
    if (m.find("BaselineInGroupId") != m.end() && !m["BaselineInGroupId"].empty()) {
      baselineInGroupId = make_shared<long>(boost::any_cast<long>(m["BaselineInGroupId"]));
    }
    if (m.find("BaselineBuffer") != m.end() && !m["BaselineBuffer"].empty()) {
      baselineBuffer = make_shared<long>(boost::any_cast<long>(m["BaselineBuffer"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<string>(boost::any_cast<string>(m["TopicType"]));
    }
    if (m.find("TopicStatus") != m.end() && !m["TopicStatus"].empty()) {
      topicStatus = make_shared<string>(boost::any_cast<string>(m["TopicStatus"]));
    }
    if (m.find("HappenTime") != m.end() && !m["HappenTime"].empty()) {
      happenTime = make_shared<long>(boost::any_cast<long>(m["HappenTime"]));
    }
    if (m.find("DealTime") != m.end() && !m["DealTime"].empty()) {
      dealTime = make_shared<long>(boost::any_cast<long>(m["DealTime"]));
    }
    if (m.find("DealUser") != m.end() && !m["DealUser"].empty()) {
      dealUser = make_shared<string>(boost::any_cast<string>(m["DealUser"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("AlertTime") != m.end() && !m["AlertTime"].empty()) {
      alertTime = make_shared<long>(boost::any_cast<long>(m["AlertTime"]));
    }
    if (m.find("Buffer") != m.end() && !m["Buffer"].empty()) {
      buffer = make_shared<long>(boost::any_cast<long>(m["Buffer"]));
    }
    if (m.find("Assigner") != m.end() && !m["Assigner"].empty()) {
      assigner = make_shared<string>(boost::any_cast<string>(m["Assigner"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("AddTime") != m.end() && !m["AddTime"].empty()) {
      addTime = make_shared<long>(boost::any_cast<long>(m["AddTime"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~GetTopicResponseBodyData() = default;
};
class GetTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetTopicResponseBodyData> data{};

  GetTopicResponseBody() {}

  explicit GetTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTopicResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTopicResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetTopicResponseBody() = default;
};
class GetTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetTopicResponseBody> body{};

  GetTopicResponse() {}

  explicit GetTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTopicResponseBody>(model1);
      }
    }
  }


  virtual ~GetTopicResponse() = default;
};
class GetTopicInfluenceRequest : public Darabonba::Model {
public:
  shared_ptr<long> topicId{};

  GetTopicInfluenceRequest() {}

  explicit GetTopicInfluenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
  }


  virtual ~GetTopicInfluenceRequest() = default;
};
class GetTopicInfluenceResponseBodyDataInfluences : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> owner{};
  shared_ptr<string> baselineName{};
  shared_ptr<long> baselineId{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> buffer{};
  shared_ptr<long> projectId{};
  shared_ptr<long> priority{};
  shared_ptr<long> inGroupId{};

  GetTopicInfluenceResponseBodyDataInfluences() {}

  explicit GetTopicInfluenceResponseBodyDataInfluences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (buffer) {
      res["Buffer"] = boost::any(*buffer);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Buffer") != m.end() && !m["Buffer"].empty()) {
      buffer = make_shared<long>(boost::any_cast<long>(m["Buffer"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<long>(boost::any_cast<long>(m["InGroupId"]));
    }
  }


  virtual ~GetTopicInfluenceResponseBodyDataInfluences() = default;
};
class GetTopicInfluenceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> topicId{};
  shared_ptr<vector<GetTopicInfluenceResponseBodyDataInfluences>> influences{};

  GetTopicInfluenceResponseBodyData() {}

  explicit GetTopicInfluenceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (influences) {
      vector<boost::any> temp1;
      for(auto item1:*influences){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Influences"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("Influences") != m.end() && !m["Influences"].empty()) {
      if (typeid(vector<boost::any>) == m["Influences"].type()) {
        vector<GetTopicInfluenceResponseBodyDataInfluences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Influences"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicInfluenceResponseBodyDataInfluences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        influences = make_shared<vector<GetTopicInfluenceResponseBodyDataInfluences>>(expect1);
      }
    }
  }


  virtual ~GetTopicInfluenceResponseBodyData() = default;
};
class GetTopicInfluenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<GetTopicInfluenceResponseBodyData> data{};

  GetTopicInfluenceResponseBody() {}

  explicit GetTopicInfluenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTopicInfluenceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTopicInfluenceResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetTopicInfluenceResponseBody() = default;
};
class GetTopicInfluenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetTopicInfluenceResponseBody> body{};

  GetTopicInfluenceResponse() {}

  explicit GetTopicInfluenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTopicInfluenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTopicInfluenceResponseBody>(model1);
      }
    }
  }


  virtual ~GetTopicInfluenceResponse() = default;
};
class ImportDISyncTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> taskContent{};
  shared_ptr<string> taskParam{};

  ImportDISyncTasksRequest() {}

  explicit ImportDISyncTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskContent) {
      res["TaskContent"] = boost::any(*taskContent);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskContent") != m.end() && !m["TaskContent"].empty()) {
      taskContent = make_shared<string>(boost::any_cast<string>(m["TaskContent"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
  }


  virtual ~ImportDISyncTasksRequest() = default;
};
class ImportDISyncTasksResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<long> taskId{};

  ImportDISyncTasksResponseBodyTaskInfo() {}

  explicit ImportDISyncTasksResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~ImportDISyncTasksResponseBodyTaskInfo() = default;
};
class ImportDISyncTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<ImportDISyncTasksResponseBodyTaskInfo> taskInfo{};

  ImportDISyncTasksResponseBody() {}

  explicit ImportDISyncTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        ImportDISyncTasksResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<ImportDISyncTasksResponseBodyTaskInfo>(model1);
      }
    }
  }


  virtual ~ImportDISyncTasksResponseBody() = default;
};
class ImportDISyncTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ImportDISyncTasksResponseBody> body{};

  ImportDISyncTasksResponse() {}

  explicit ImportDISyncTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportDISyncTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportDISyncTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ImportDISyncTasksResponse() = default;
};
class ListAlertMessagesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> beginTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> remindId{};
  shared_ptr<string> alertMethods{};
  shared_ptr<string> alertUser{};
  shared_ptr<string> alertRuleTypes{};

  ListAlertMessagesRequest() {}

  explicit ListAlertMessagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    if (alertMethods) {
      res["AlertMethods"] = boost::any(*alertMethods);
    }
    if (alertUser) {
      res["AlertUser"] = boost::any(*alertUser);
    }
    if (alertRuleTypes) {
      res["AlertRuleTypes"] = boost::any(*alertRuleTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
    if (m.find("AlertMethods") != m.end() && !m["AlertMethods"].empty()) {
      alertMethods = make_shared<string>(boost::any_cast<string>(m["AlertMethods"]));
    }
    if (m.find("AlertUser") != m.end() && !m["AlertUser"].empty()) {
      alertUser = make_shared<string>(boost::any_cast<string>(m["AlertUser"]));
    }
    if (m.find("AlertRuleTypes") != m.end() && !m["AlertRuleTypes"].empty()) {
      alertRuleTypes = make_shared<string>(boost::any_cast<string>(m["AlertRuleTypes"]));
    }
  }


  virtual ~ListAlertMessagesRequest() = default;
};
class ListAlertMessagesResponseBodyDataAlertMessagesInstances : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};

  ListAlertMessagesResponseBodyDataAlertMessagesInstances() {}

  explicit ListAlertMessagesResponseBodyDataAlertMessagesInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListAlertMessagesResponseBodyDataAlertMessagesInstances() = default;
};
class ListAlertMessagesResponseBodyDataAlertMessagesTopics : public Darabonba::Model {
public:
  shared_ptr<string> topicName{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> topicId{};
  shared_ptr<string> topicOwner{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> topicStatus{};

  ListAlertMessagesResponseBodyDataAlertMessagesTopics() {}

  explicit ListAlertMessagesResponseBodyDataAlertMessagesTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (topicOwner) {
      res["TopicOwner"] = boost::any(*topicOwner);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (topicStatus) {
      res["TopicStatus"] = boost::any(*topicStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<string>(boost::any_cast<string>(m["TopicName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("TopicOwner") != m.end() && !m["TopicOwner"].empty()) {
      topicOwner = make_shared<string>(boost::any_cast<string>(m["TopicOwner"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("TopicStatus") != m.end() && !m["TopicStatus"].empty()) {
      topicStatus = make_shared<string>(boost::any_cast<string>(m["TopicStatus"]));
    }
  }


  virtual ~ListAlertMessagesResponseBodyDataAlertMessagesTopics() = default;
};
class ListAlertMessagesResponseBodyDataAlertMessagesNodes : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};

  ListAlertMessagesResponseBodyDataAlertMessagesNodes() {}

  explicit ListAlertMessagesResponseBodyDataAlertMessagesNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListAlertMessagesResponseBodyDataAlertMessagesNodes() = default;
};
class ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> baselineOwner{};
  shared_ptr<long> baselineId{};
  shared_ptr<string> baselineName{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> projectId{};
  shared_ptr<long> inGroupId{};

  ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert() {}

  explicit ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (baselineOwner) {
      res["BaselineOwner"] = boost::any(*baselineOwner);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("BaselineOwner") != m.end() && !m["BaselineOwner"].empty()) {
      baselineOwner = make_shared<string>(boost::any_cast<string>(m["BaselineOwner"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<long>(boost::any_cast<long>(m["InGroupId"]));
    }
  }


  virtual ~ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert() = default;
};
class ListAlertMessagesResponseBodyDataAlertMessages : public Darabonba::Model {
public:
  shared_ptr<long> remindId{};
  shared_ptr<string> alertMessageStatus{};
  shared_ptr<string> alertUser{};
  shared_ptr<long> alertTime{};
  shared_ptr<string> alertMethod{};
  shared_ptr<string> source{};
  shared_ptr<string> content{};
  shared_ptr<string> remindName{};
  shared_ptr<long> alertId{};
  shared_ptr<vector<ListAlertMessagesResponseBodyDataAlertMessagesInstances>> instances{};
  shared_ptr<vector<ListAlertMessagesResponseBodyDataAlertMessagesTopics>> topics{};
  shared_ptr<vector<ListAlertMessagesResponseBodyDataAlertMessagesNodes>> nodes{};
  shared_ptr<ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert> slaAlert{};

  ListAlertMessagesResponseBodyDataAlertMessages() {}

  explicit ListAlertMessagesResponseBodyDataAlertMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    if (alertMessageStatus) {
      res["AlertMessageStatus"] = boost::any(*alertMessageStatus);
    }
    if (alertUser) {
      res["AlertUser"] = boost::any(*alertUser);
    }
    if (alertTime) {
      res["AlertTime"] = boost::any(*alertTime);
    }
    if (alertMethod) {
      res["AlertMethod"] = boost::any(*alertMethod);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (remindName) {
      res["RemindName"] = boost::any(*remindName);
    }
    if (alertId) {
      res["AlertId"] = boost::any(*alertId);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (topics) {
      vector<boost::any> temp1;
      for(auto item1:*topics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Topics"] = boost::any(temp1);
    }
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (slaAlert) {
      res["SlaAlert"] = slaAlert ? boost::any(slaAlert->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
    if (m.find("AlertMessageStatus") != m.end() && !m["AlertMessageStatus"].empty()) {
      alertMessageStatus = make_shared<string>(boost::any_cast<string>(m["AlertMessageStatus"]));
    }
    if (m.find("AlertUser") != m.end() && !m["AlertUser"].empty()) {
      alertUser = make_shared<string>(boost::any_cast<string>(m["AlertUser"]));
    }
    if (m.find("AlertTime") != m.end() && !m["AlertTime"].empty()) {
      alertTime = make_shared<long>(boost::any_cast<long>(m["AlertTime"]));
    }
    if (m.find("AlertMethod") != m.end() && !m["AlertMethod"].empty()) {
      alertMethod = make_shared<string>(boost::any_cast<string>(m["AlertMethod"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RemindName") != m.end() && !m["RemindName"].empty()) {
      remindName = make_shared<string>(boost::any_cast<string>(m["RemindName"]));
    }
    if (m.find("AlertId") != m.end() && !m["AlertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["AlertId"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListAlertMessagesResponseBodyDataAlertMessagesInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertMessagesResponseBodyDataAlertMessagesInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListAlertMessagesResponseBodyDataAlertMessagesInstances>>(expect1);
      }
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<ListAlertMessagesResponseBodyDataAlertMessagesTopics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Topics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertMessagesResponseBodyDataAlertMessagesTopics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topics = make_shared<vector<ListAlertMessagesResponseBodyDataAlertMessagesTopics>>(expect1);
      }
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<ListAlertMessagesResponseBodyDataAlertMessagesNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertMessagesResponseBodyDataAlertMessagesNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<ListAlertMessagesResponseBodyDataAlertMessagesNodes>>(expect1);
      }
    }
    if (m.find("SlaAlert") != m.end() && !m["SlaAlert"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlaAlert"].type()) {
        ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlaAlert"]));
        slaAlert = make_shared<ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert>(model1);
      }
    }
  }


  virtual ~ListAlertMessagesResponseBodyDataAlertMessages() = default;
};
class ListAlertMessagesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> totalCount{};
  shared_ptr<vector<ListAlertMessagesResponseBodyDataAlertMessages>> alertMessages{};

  ListAlertMessagesResponseBodyData() {}

  explicit ListAlertMessagesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (alertMessages) {
      vector<boost::any> temp1;
      for(auto item1:*alertMessages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertMessages"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
    if (m.find("AlertMessages") != m.end() && !m["AlertMessages"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertMessages"].type()) {
        vector<ListAlertMessagesResponseBodyDataAlertMessages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertMessages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertMessagesResponseBodyDataAlertMessages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertMessages = make_shared<vector<ListAlertMessagesResponseBodyDataAlertMessages>>(expect1);
      }
    }
  }


  virtual ~ListAlertMessagesResponseBodyData() = default;
};
class ListAlertMessagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListAlertMessagesResponseBodyData> data{};

  ListAlertMessagesResponseBody() {}

  explicit ListAlertMessagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAlertMessagesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAlertMessagesResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListAlertMessagesResponseBody() = default;
};
class ListAlertMessagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAlertMessagesResponseBody> body{};

  ListAlertMessagesResponse() {}

  explicit ListAlertMessagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertMessagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertMessagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertMessagesResponse() = default;
};
class ListBaselineConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> priority{};
  shared_ptr<bool> useflag{};
  shared_ptr<string> baselineTypes{};
  shared_ptr<string> searchText{};

  ListBaselineConfigsRequest() {}

  explicit ListBaselineConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (useflag) {
      res["Useflag"] = boost::any(*useflag);
    }
    if (baselineTypes) {
      res["BaselineTypes"] = boost::any(*baselineTypes);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Useflag") != m.end() && !m["Useflag"].empty()) {
      useflag = make_shared<bool>(boost::any_cast<bool>(m["Useflag"]));
    }
    if (m.find("BaselineTypes") != m.end() && !m["BaselineTypes"].empty()) {
      baselineTypes = make_shared<string>(boost::any_cast<string>(m["BaselineTypes"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
  }


  virtual ~ListBaselineConfigsRequest() = default;
};
class ListBaselineConfigsResponseBodyDataBaselines : public Darabonba::Model {
public:
  shared_ptr<string> hourSlaDetail{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<long> priority{};
  shared_ptr<long> slaMinu{};
  shared_ptr<long> slaHour{};
  shared_ptr<long> baselineId{};
  shared_ptr<string> baselineName{};
  shared_ptr<string> hourExpDetail{};
  shared_ptr<bool> useFlag{};
  shared_ptr<long> expHour{};
  shared_ptr<string> baselineType{};
  shared_ptr<long> expMinu{};

  ListBaselineConfigsResponseBodyDataBaselines() {}

  explicit ListBaselineConfigsResponseBodyDataBaselines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hourSlaDetail) {
      res["HourSlaDetail"] = boost::any(*hourSlaDetail);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (slaMinu) {
      res["SlaMinu"] = boost::any(*slaMinu);
    }
    if (slaHour) {
      res["SlaHour"] = boost::any(*slaHour);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (hourExpDetail) {
      res["HourExpDetail"] = boost::any(*hourExpDetail);
    }
    if (useFlag) {
      res["UseFlag"] = boost::any(*useFlag);
    }
    if (expHour) {
      res["ExpHour"] = boost::any(*expHour);
    }
    if (baselineType) {
      res["BaselineType"] = boost::any(*baselineType);
    }
    if (expMinu) {
      res["ExpMinu"] = boost::any(*expMinu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HourSlaDetail") != m.end() && !m["HourSlaDetail"].empty()) {
      hourSlaDetail = make_shared<string>(boost::any_cast<string>(m["HourSlaDetail"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SlaMinu") != m.end() && !m["SlaMinu"].empty()) {
      slaMinu = make_shared<long>(boost::any_cast<long>(m["SlaMinu"]));
    }
    if (m.find("SlaHour") != m.end() && !m["SlaHour"].empty()) {
      slaHour = make_shared<long>(boost::any_cast<long>(m["SlaHour"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("HourExpDetail") != m.end() && !m["HourExpDetail"].empty()) {
      hourExpDetail = make_shared<string>(boost::any_cast<string>(m["HourExpDetail"]));
    }
    if (m.find("UseFlag") != m.end() && !m["UseFlag"].empty()) {
      useFlag = make_shared<bool>(boost::any_cast<bool>(m["UseFlag"]));
    }
    if (m.find("ExpHour") != m.end() && !m["ExpHour"].empty()) {
      expHour = make_shared<long>(boost::any_cast<long>(m["ExpHour"]));
    }
    if (m.find("BaselineType") != m.end() && !m["BaselineType"].empty()) {
      baselineType = make_shared<string>(boost::any_cast<string>(m["BaselineType"]));
    }
    if (m.find("ExpMinu") != m.end() && !m["ExpMinu"].empty()) {
      expMinu = make_shared<long>(boost::any_cast<long>(m["ExpMinu"]));
    }
  }


  virtual ~ListBaselineConfigsResponseBodyDataBaselines() = default;
};
class ListBaselineConfigsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListBaselineConfigsResponseBodyDataBaselines>> baselines{};

  ListBaselineConfigsResponseBodyData() {}

  explicit ListBaselineConfigsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (baselines) {
      vector<boost::any> temp1;
      for(auto item1:*baselines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Baselines"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Baselines") != m.end() && !m["Baselines"].empty()) {
      if (typeid(vector<boost::any>) == m["Baselines"].type()) {
        vector<ListBaselineConfigsResponseBodyDataBaselines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Baselines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBaselineConfigsResponseBodyDataBaselines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselines = make_shared<vector<ListBaselineConfigsResponseBodyDataBaselines>>(expect1);
      }
    }
  }


  virtual ~ListBaselineConfigsResponseBodyData() = default;
};
class ListBaselineConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListBaselineConfigsResponseBodyData> data{};

  ListBaselineConfigsResponseBody() {}

  explicit ListBaselineConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListBaselineConfigsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListBaselineConfigsResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListBaselineConfigsResponseBody() = default;
};
class ListBaselineConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListBaselineConfigsResponseBody> body{};

  ListBaselineConfigsResponse() {}

  explicit ListBaselineConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBaselineConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBaselineConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBaselineConfigsResponse() = default;
};
class ListBaselineStatusesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> bizdate{};
  shared_ptr<string> priority{};
  shared_ptr<string> searchText{};
  shared_ptr<string> owner{};
  shared_ptr<long> topicId{};
  shared_ptr<string> finishStatus{};
  shared_ptr<string> status{};
  shared_ptr<string> baselineTypes{};

  ListBaselineStatusesRequest() {}

  explicit ListBaselineStatusesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (finishStatus) {
      res["FinishStatus"] = boost::any(*finishStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (baselineTypes) {
      res["BaselineTypes"] = boost::any(*baselineTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("FinishStatus") != m.end() && !m["FinishStatus"].empty()) {
      finishStatus = make_shared<string>(boost::any_cast<string>(m["FinishStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("BaselineTypes") != m.end() && !m["BaselineTypes"].empty()) {
      baselineTypes = make_shared<string>(boost::any_cast<string>(m["BaselineTypes"]));
    }
  }


  virtual ~ListBaselineStatusesRequest() = default;
};
class ListBaselineStatusesResponseBodyDataBaselineStatuses : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> owner{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> projectId{};
  shared_ptr<long> priority{};
  shared_ptr<long> endCast{};
  shared_ptr<long> inGroupId{};
  shared_ptr<string> baselineName{};
  shared_ptr<long> baselineId{};
  shared_ptr<string> finishStatus{};
  shared_ptr<long> bizdate{};
  shared_ptr<long> buffer{};
  shared_ptr<long> slaTime{};
  shared_ptr<long> expTime{};

  ListBaselineStatusesResponseBodyDataBaselineStatuses() {}

  explicit ListBaselineStatusesResponseBodyDataBaselineStatuses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (endCast) {
      res["EndCast"] = boost::any(*endCast);
    }
    if (inGroupId) {
      res["InGroupId"] = boost::any(*inGroupId);
    }
    if (baselineName) {
      res["BaselineName"] = boost::any(*baselineName);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (finishStatus) {
      res["FinishStatus"] = boost::any(*finishStatus);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (buffer) {
      res["Buffer"] = boost::any(*buffer);
    }
    if (slaTime) {
      res["SlaTime"] = boost::any(*slaTime);
    }
    if (expTime) {
      res["ExpTime"] = boost::any(*expTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("EndCast") != m.end() && !m["EndCast"].empty()) {
      endCast = make_shared<long>(boost::any_cast<long>(m["EndCast"]));
    }
    if (m.find("InGroupId") != m.end() && !m["InGroupId"].empty()) {
      inGroupId = make_shared<long>(boost::any_cast<long>(m["InGroupId"]));
    }
    if (m.find("BaselineName") != m.end() && !m["BaselineName"].empty()) {
      baselineName = make_shared<string>(boost::any_cast<string>(m["BaselineName"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("FinishStatus") != m.end() && !m["FinishStatus"].empty()) {
      finishStatus = make_shared<string>(boost::any_cast<string>(m["FinishStatus"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("Buffer") != m.end() && !m["Buffer"].empty()) {
      buffer = make_shared<long>(boost::any_cast<long>(m["Buffer"]));
    }
    if (m.find("SlaTime") != m.end() && !m["SlaTime"].empty()) {
      slaTime = make_shared<long>(boost::any_cast<long>(m["SlaTime"]));
    }
    if (m.find("ExpTime") != m.end() && !m["ExpTime"].empty()) {
      expTime = make_shared<long>(boost::any_cast<long>(m["ExpTime"]));
    }
  }


  virtual ~ListBaselineStatusesResponseBodyDataBaselineStatuses() = default;
};
class ListBaselineStatusesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListBaselineStatusesResponseBodyDataBaselineStatuses>> baselineStatuses{};

  ListBaselineStatusesResponseBodyData() {}

  explicit ListBaselineStatusesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (baselineStatuses) {
      vector<boost::any> temp1;
      for(auto item1:*baselineStatuses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaselineStatuses"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("BaselineStatuses") != m.end() && !m["BaselineStatuses"].empty()) {
      if (typeid(vector<boost::any>) == m["BaselineStatuses"].type()) {
        vector<ListBaselineStatusesResponseBodyDataBaselineStatuses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaselineStatuses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBaselineStatusesResponseBodyDataBaselineStatuses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baselineStatuses = make_shared<vector<ListBaselineStatusesResponseBodyDataBaselineStatuses>>(expect1);
      }
    }
  }


  virtual ~ListBaselineStatusesResponseBodyData() = default;
};
class ListBaselineStatusesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListBaselineStatusesResponseBodyData> data{};

  ListBaselineStatusesResponseBody() {}

  explicit ListBaselineStatusesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListBaselineStatusesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListBaselineStatusesResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListBaselineStatusesResponseBody() = default;
};
class ListBaselineStatusesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListBaselineStatusesResponseBody> body{};

  ListBaselineStatusesResponse() {}

  explicit ListBaselineStatusesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBaselineStatusesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBaselineStatusesResponseBody>(model1);
      }
    }
  }


  virtual ~ListBaselineStatusesResponse() = default;
};
class ListBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> keyword{};

  ListBusinessRequest() {}

  explicit ListBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
  }


  virtual ~ListBusinessRequest() = default;
};
class ListBusinessResponseBodyDataBusiness : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> description{};
  shared_ptr<long> projectId{};
  shared_ptr<long> businessId{};
  shared_ptr<string> businessName{};
  shared_ptr<string> useType{};

  ListBusinessResponseBodyDataBusiness() {}

  explicit ListBusinessResponseBodyDataBusiness(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
  }


  virtual ~ListBusinessResponseBodyDataBusiness() = default;
};
class ListBusinessResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListBusinessResponseBodyDataBusiness>> business{};

  ListBusinessResponseBodyData() {}

  explicit ListBusinessResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (business) {
      vector<boost::any> temp1;
      for(auto item1:*business){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Business"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Business") != m.end() && !m["Business"].empty()) {
      if (typeid(vector<boost::any>) == m["Business"].type()) {
        vector<ListBusinessResponseBodyDataBusiness> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Business"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBusinessResponseBodyDataBusiness model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        business = make_shared<vector<ListBusinessResponseBodyDataBusiness>>(expect1);
      }
    }
  }


  virtual ~ListBusinessResponseBodyData() = default;
};
class ListBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListBusinessResponseBodyData> data{};

  ListBusinessResponseBody() {}

  explicit ListBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListBusinessResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListBusinessResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListBusinessResponseBody() = default;
};
class ListBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListBusinessResponseBody> body{};

  ListBusinessResponse() {}

  explicit ListBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~ListBusinessResponse() = default;
};
class ListCalcEnginesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> calcEngineType{};
  shared_ptr<string> envType{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  ListCalcEnginesRequest() {}

  explicit ListCalcEnginesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (calcEngineType) {
      res["CalcEngineType"] = boost::any(*calcEngineType);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CalcEngineType") != m.end() && !m["CalcEngineType"].empty()) {
      calcEngineType = make_shared<string>(boost::any_cast<string>(m["CalcEngineType"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~ListCalcEnginesRequest() = default;
};
class ListCalcEnginesResponseBodyDataCalcEngines : public Darabonba::Model {
public:
  shared_ptr<string> bindingProjectName{};
  shared_ptr<bool> isDefault{};
  shared_ptr<long> engineId{};
  shared_ptr<string> dwRegion{};
  shared_ptr<string> taskAuthType{};
  shared_ptr<string> calcEngineType{};
  shared_ptr<map<string, boost::any>> engineInfo{};
  shared_ptr<string> envType{};
  shared_ptr<string> region{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> bindingProjectId{};
  shared_ptr<string> name{};
  shared_ptr<long> tenantId{};

  ListCalcEnginesResponseBodyDataCalcEngines() {}

  explicit ListCalcEnginesResponseBodyDataCalcEngines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindingProjectName) {
      res["BindingProjectName"] = boost::any(*bindingProjectName);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (engineId) {
      res["EngineId"] = boost::any(*engineId);
    }
    if (dwRegion) {
      res["DwRegion"] = boost::any(*dwRegion);
    }
    if (taskAuthType) {
      res["TaskAuthType"] = boost::any(*taskAuthType);
    }
    if (calcEngineType) {
      res["CalcEngineType"] = boost::any(*calcEngineType);
    }
    if (engineInfo) {
      res["EngineInfo"] = boost::any(*engineInfo);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (bindingProjectId) {
      res["BindingProjectId"] = boost::any(*bindingProjectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindingProjectName") != m.end() && !m["BindingProjectName"].empty()) {
      bindingProjectName = make_shared<string>(boost::any_cast<string>(m["BindingProjectName"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("EngineId") != m.end() && !m["EngineId"].empty()) {
      engineId = make_shared<long>(boost::any_cast<long>(m["EngineId"]));
    }
    if (m.find("DwRegion") != m.end() && !m["DwRegion"].empty()) {
      dwRegion = make_shared<string>(boost::any_cast<string>(m["DwRegion"]));
    }
    if (m.find("TaskAuthType") != m.end() && !m["TaskAuthType"].empty()) {
      taskAuthType = make_shared<string>(boost::any_cast<string>(m["TaskAuthType"]));
    }
    if (m.find("CalcEngineType") != m.end() && !m["CalcEngineType"].empty()) {
      calcEngineType = make_shared<string>(boost::any_cast<string>(m["CalcEngineType"]));
    }
    if (m.find("EngineInfo") != m.end() && !m["EngineInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["EngineInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      engineInfo = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<string>(boost::any_cast<string>(m["EnvType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("BindingProjectId") != m.end() && !m["BindingProjectId"].empty()) {
      bindingProjectId = make_shared<long>(boost::any_cast<long>(m["BindingProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListCalcEnginesResponseBodyDataCalcEngines() = default;
};
class ListCalcEnginesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListCalcEnginesResponseBodyDataCalcEngines>> calcEngines{};

  ListCalcEnginesResponseBodyData() {}

  explicit ListCalcEnginesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (calcEngines) {
      vector<boost::any> temp1;
      for(auto item1:*calcEngines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CalcEngines"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("CalcEngines") != m.end() && !m["CalcEngines"].empty()) {
      if (typeid(vector<boost::any>) == m["CalcEngines"].type()) {
        vector<ListCalcEnginesResponseBodyDataCalcEngines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CalcEngines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCalcEnginesResponseBodyDataCalcEngines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        calcEngines = make_shared<vector<ListCalcEnginesResponseBodyDataCalcEngines>>(expect1);
      }
    }
  }


  virtual ~ListCalcEnginesResponseBodyData() = default;
};
class ListCalcEnginesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListCalcEnginesResponseBodyData> data{};

  ListCalcEnginesResponseBody() {}

  explicit ListCalcEnginesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCalcEnginesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCalcEnginesResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListCalcEnginesResponseBody() = default;
};
class ListCalcEnginesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCalcEnginesResponseBody> body{};

  ListCalcEnginesResponse() {}

  explicit ListCalcEnginesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCalcEnginesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCalcEnginesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCalcEnginesResponse() = default;
};
class ListConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> connectionType{};
  shared_ptr<string> subType{};
  shared_ptr<string> status{};
  shared_ptr<long> envType{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  ListConnectionsRequest() {}

  explicit ListConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (connectionType) {
      res["ConnectionType"] = boost::any(*connectionType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ConnectionType") != m.end() && !m["ConnectionType"].empty()) {
      connectionType = make_shared<string>(boost::any_cast<string>(m["ConnectionType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~ListConnectionsRequest() = default;
};
class ListConnectionsResponseBodyDataConnections : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> connectionType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> subType{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> envType{};
  shared_ptr<long> connectStatus{};
  shared_ptr<long> sequence{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<bool> defaultEngine{};
  shared_ptr<bool> shared{};
  shared_ptr<string> operator_{};
  shared_ptr<string> name{};
  shared_ptr<string> content{};
  shared_ptr<long> id{};
  shared_ptr<long> bindingCalcEngineId{};
  shared_ptr<long> tenantId{};

  ListConnectionsResponseBodyDataConnections() {}

  explicit ListConnectionsResponseBodyDataConnections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (connectionType) {
      res["ConnectionType"] = boost::any(*connectionType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (connectStatus) {
      res["ConnectStatus"] = boost::any(*connectStatus);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (defaultEngine) {
      res["DefaultEngine"] = boost::any(*defaultEngine);
    }
    if (shared) {
      res["Shared"] = boost::any(*shared);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (bindingCalcEngineId) {
      res["BindingCalcEngineId"] = boost::any(*bindingCalcEngineId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ConnectionType") != m.end() && !m["ConnectionType"].empty()) {
      connectionType = make_shared<string>(boost::any_cast<string>(m["ConnectionType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("ConnectStatus") != m.end() && !m["ConnectStatus"].empty()) {
      connectStatus = make_shared<long>(boost::any_cast<long>(m["ConnectStatus"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<long>(boost::any_cast<long>(m["Sequence"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("DefaultEngine") != m.end() && !m["DefaultEngine"].empty()) {
      defaultEngine = make_shared<bool>(boost::any_cast<bool>(m["DefaultEngine"]));
    }
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      shared = make_shared<bool>(boost::any_cast<bool>(m["Shared"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("BindingCalcEngineId") != m.end() && !m["BindingCalcEngineId"].empty()) {
      bindingCalcEngineId = make_shared<long>(boost::any_cast<long>(m["BindingCalcEngineId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListConnectionsResponseBodyDataConnections() = default;
};
class ListConnectionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListConnectionsResponseBodyDataConnections>> connections{};

  ListConnectionsResponseBodyData() {}

  explicit ListConnectionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (connections) {
      vector<boost::any> temp1;
      for(auto item1:*connections){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Connections"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Connections") != m.end() && !m["Connections"].empty()) {
      if (typeid(vector<boost::any>) == m["Connections"].type()) {
        vector<ListConnectionsResponseBodyDataConnections> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Connections"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConnectionsResponseBodyDataConnections model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        connections = make_shared<vector<ListConnectionsResponseBodyDataConnections>>(expect1);
      }
    }
  }


  virtual ~ListConnectionsResponseBodyData() = default;
};
class ListConnectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListConnectionsResponseBodyData> data{};

  ListConnectionsResponseBody() {}

  explicit ListConnectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListConnectionsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListConnectionsResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListConnectionsResponseBody() = default;
};
class ListConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListConnectionsResponseBody> body{};

  ListConnectionsResponse() {}

  explicit ListConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConnectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConnectionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListConnectionsResponse() = default;
};
class ListDataServiceApiAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiNameKeyword{};

  ListDataServiceApiAuthoritiesRequest() {}

  explicit ListDataServiceApiAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiNameKeyword) {
      res["ApiNameKeyword"] = boost::any(*apiNameKeyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiNameKeyword") != m.end() && !m["ApiNameKeyword"].empty()) {
      apiNameKeyword = make_shared<string>(boost::any_cast<string>(m["ApiNameKeyword"]));
    }
  }


  virtual ~ListDataServiceApiAuthoritiesRequest() = default;
};
class ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> createdTime{};
  shared_ptr<long> projectId{};

  ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords() {}

  explicit ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords() = default;
};
class ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList : public Darabonba::Model {
public:
  shared_ptr<long> apiStatus{};
  shared_ptr<long> apiId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> groupId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> apiName{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiPath{};
  shared_ptr<vector<ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords>> authorizationRecords{};

  ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList() {}

  explicit ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (authorizationRecords) {
      vector<boost::any> temp1;
      for(auto item1:*authorizationRecords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizationRecords"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<long>(boost::any_cast<long>(m["ApiStatus"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("AuthorizationRecords") != m.end() && !m["AuthorizationRecords"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizationRecords"].type()) {
        vector<ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizationRecords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizationRecords = make_shared<vector<ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList() = default;
};
class ListDataServiceApiAuthoritiesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList>> apiAuthorizationList{};

  ListDataServiceApiAuthoritiesResponseBodyData() {}

  explicit ListDataServiceApiAuthoritiesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (apiAuthorizationList) {
      vector<boost::any> temp1;
      for(auto item1:*apiAuthorizationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiAuthorizationList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ApiAuthorizationList") != m.end() && !m["ApiAuthorizationList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiAuthorizationList"].type()) {
        vector<ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiAuthorizationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiAuthorizationList = make_shared<vector<ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceApiAuthoritiesResponseBodyData() = default;
};
class ListDataServiceApiAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<ListDataServiceApiAuthoritiesResponseBodyData> data{};

  ListDataServiceApiAuthoritiesResponseBody() {}

  explicit ListDataServiceApiAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataServiceApiAuthoritiesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataServiceApiAuthoritiesResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListDataServiceApiAuthoritiesResponseBody() = default;
};
class ListDataServiceApiAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDataServiceApiAuthoritiesResponseBody> body{};

  ListDataServiceApiAuthoritiesResponse() {}

  explicit ListDataServiceApiAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataServiceApiAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataServiceApiAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataServiceApiAuthoritiesResponse() = default;
};
class ListDataServiceApisRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiNameKeyword{};
  shared_ptr<string> apiPathKeyword{};
  shared_ptr<string> creatorId{};

  ListDataServiceApisRequest() {}

  explicit ListDataServiceApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiNameKeyword) {
      res["ApiNameKeyword"] = boost::any(*apiNameKeyword);
    }
    if (apiPathKeyword) {
      res["ApiPathKeyword"] = boost::any(*apiPathKeyword);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiNameKeyword") != m.end() && !m["ApiNameKeyword"].empty()) {
      apiNameKeyword = make_shared<string>(boost::any_cast<string>(m["ApiNameKeyword"]));
    }
    if (m.find("ApiPathKeyword") != m.end() && !m["ApiPathKeyword"].empty()) {
      apiPathKeyword = make_shared<string>(boost::any_cast<string>(m["ApiPathKeyword"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
  }


  virtual ~ListDataServiceApisRequest() = default;
};
class ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorSolution{};

  ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes() {}

  explicit ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes() = default;
};
class ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};

  ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters() {}

  explicit ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters() = default;
};
class ListDataServiceApisResponseBodyDataApisRegistrationDetails : public Darabonba::Model {
public:
  shared_ptr<string> serviceHost{};
  shared_ptr<long> serviceContentType{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<string> failedResultSample{};
  shared_ptr<string> serviceRequestBodyDescription{};
  shared_ptr<vector<ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes>> registrationErrorCodes{};
  shared_ptr<vector<ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters>> registrationRequestParameters{};

  ListDataServiceApisResponseBodyDataApisRegistrationDetails() {}

  explicit ListDataServiceApisResponseBodyDataApisRegistrationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceHost) {
      res["ServiceHost"] = boost::any(*serviceHost);
    }
    if (serviceContentType) {
      res["ServiceContentType"] = boost::any(*serviceContentType);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (serviceRequestBodyDescription) {
      res["ServiceRequestBodyDescription"] = boost::any(*serviceRequestBodyDescription);
    }
    if (registrationErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*registrationErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationErrorCodes"] = boost::any(temp1);
    }
    if (registrationRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*registrationRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationRequestParameters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceHost") != m.end() && !m["ServiceHost"].empty()) {
      serviceHost = make_shared<string>(boost::any_cast<string>(m["ServiceHost"]));
    }
    if (m.find("ServiceContentType") != m.end() && !m["ServiceContentType"].empty()) {
      serviceContentType = make_shared<long>(boost::any_cast<long>(m["ServiceContentType"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("ServiceRequestBodyDescription") != m.end() && !m["ServiceRequestBodyDescription"].empty()) {
      serviceRequestBodyDescription = make_shared<string>(boost::any_cast<string>(m["ServiceRequestBodyDescription"]));
    }
    if (m.find("RegistrationErrorCodes") != m.end() && !m["RegistrationErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationErrorCodes"].type()) {
        vector<ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationErrorCodes = make_shared<vector<ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes>>(expect1);
      }
    }
    if (m.find("RegistrationRequestParameters") != m.end() && !m["RegistrationRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationRequestParameters"].type()) {
        vector<ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationRequestParameters = make_shared<vector<ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisRegistrationDetails() = default;
};
class ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};

  ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters() {}

  explicit ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters() = default;
};
class ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> columnName{};
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> exampleValue{};

  ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters() {}

  explicit ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters() = default;
};
class ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<long> connectionId{};

  ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection() {}

  explicit ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection() = default;
};
class ListDataServiceApisResponseBodyDataApisScriptDetails : public Darabonba::Model {
public:
  shared_ptr<string> script{};
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<vector<ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters>> scriptRequestParameters{};
  shared_ptr<vector<ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters>> scriptResponseParameters{};
  shared_ptr<ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection> scriptConnection{};

  ListDataServiceApisResponseBodyDataApisScriptDetails() {}

  explicit ListDataServiceApisResponseBodyDataApisScriptDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (scriptRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptRequestParameters"] = boost::any(temp1);
    }
    if (scriptResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptResponseParameters"] = boost::any(temp1);
    }
    if (scriptConnection) {
      res["ScriptConnection"] = scriptConnection ? boost::any(scriptConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("ScriptRequestParameters") != m.end() && !m["ScriptRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptRequestParameters"].type()) {
        vector<ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptRequestParameters = make_shared<vector<ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters>>(expect1);
      }
    }
    if (m.find("ScriptResponseParameters") != m.end() && !m["ScriptResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptResponseParameters"].type()) {
        vector<ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptResponseParameters = make_shared<vector<ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters>>(expect1);
      }
    }
    if (m.find("ScriptConnection") != m.end() && !m["ScriptConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptConnection"].type()) {
        ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptConnection"]));
        scriptConnection = make_shared<ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection>(model1);
      }
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisScriptDetails() = default;
};
class ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};

  ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters() {}

  explicit ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters() = default;
};
class ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> columnName{};
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> exampleValue{};

  ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters() {}

  explicit ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters() = default;
};
class ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<long> connectionId{};

  ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection() {}

  explicit ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection() = default;
};
class ListDataServiceApisResponseBodyDataApisWizardDetails : public Darabonba::Model {
public:
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<vector<ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters>> wizardRequestParameters{};
  shared_ptr<vector<ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters>> wizardResponseParameters{};
  shared_ptr<ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection> wizardConnection{};

  ListDataServiceApisResponseBodyDataApisWizardDetails() {}

  explicit ListDataServiceApisResponseBodyDataApisWizardDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (wizardRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardRequestParameters"] = boost::any(temp1);
    }
    if (wizardResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardResponseParameters"] = boost::any(temp1);
    }
    if (wizardConnection) {
      res["WizardConnection"] = wizardConnection ? boost::any(wizardConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("WizardRequestParameters") != m.end() && !m["WizardRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardRequestParameters"].type()) {
        vector<ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardRequestParameters = make_shared<vector<ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters>>(expect1);
      }
    }
    if (m.find("WizardResponseParameters") != m.end() && !m["WizardResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardResponseParameters"].type()) {
        vector<ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardResponseParameters = make_shared<vector<ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters>>(expect1);
      }
    }
    if (m.find("WizardConnection") != m.end() && !m["WizardConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardConnection"].type()) {
        ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardConnection"]));
        wizardConnection = make_shared<ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection>(model1);
      }
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApisWizardDetails() = default;
};
class ListDataServiceApisResponseBodyDataApis : public Darabonba::Model {
public:
  shared_ptr<long> timeout{};
  shared_ptr<long> status{};
  shared_ptr<long> apiId{};
  shared_ptr<long> apiMode{};
  shared_ptr<long> projectId{};
  shared_ptr<long> responseContentType{};
  shared_ptr<string> creatorId{};
  shared_ptr<long> visibleRange{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> description{};
  shared_ptr<long> folderId{};
  shared_ptr<long> requestMethod{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> apiName{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiPath{};
  shared_ptr<vector<long>> protocols{};
  shared_ptr<ListDataServiceApisResponseBodyDataApisRegistrationDetails> registrationDetails{};
  shared_ptr<ListDataServiceApisResponseBodyDataApisScriptDetails> scriptDetails{};
  shared_ptr<ListDataServiceApisResponseBodyDataApisWizardDetails> wizardDetails{};

  ListDataServiceApisResponseBodyDataApis() {}

  explicit ListDataServiceApisResponseBodyDataApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMode) {
      res["ApiMode"] = boost::any(*apiMode);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = registrationDetails ? boost::any(registrationDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptDetails) {
      res["ScriptDetails"] = scriptDetails ? boost::any(scriptDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wizardDetails) {
      res["WizardDetails"] = wizardDetails ? boost::any(wizardDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiMode") != m.end() && !m["ApiMode"].empty()) {
      apiMode = make_shared<long>(boost::any_cast<long>(m["ApiMode"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<long>(boost::any_cast<long>(m["ResponseContentType"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<long>(boost::any_cast<long>(m["VisibleRange"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<long>(boost::any_cast<long>(m["RequestMethod"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      protocols = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegistrationDetails"].type()) {
        ListDataServiceApisResponseBodyDataApisRegistrationDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegistrationDetails"]));
        registrationDetails = make_shared<ListDataServiceApisResponseBodyDataApisRegistrationDetails>(model1);
      }
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptDetails"].type()) {
        ListDataServiceApisResponseBodyDataApisScriptDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptDetails"]));
        scriptDetails = make_shared<ListDataServiceApisResponseBodyDataApisScriptDetails>(model1);
      }
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardDetails"].type()) {
        ListDataServiceApisResponseBodyDataApisWizardDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardDetails"]));
        wizardDetails = make_shared<ListDataServiceApisResponseBodyDataApisWizardDetails>(model1);
      }
    }
  }


  virtual ~ListDataServiceApisResponseBodyDataApis() = default;
};
class ListDataServiceApisResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListDataServiceApisResponseBodyDataApis>> apis{};

  ListDataServiceApisResponseBodyData() {}

  explicit ListDataServiceApisResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (apis) {
      vector<boost::any> temp1;
      for(auto item1:*apis){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apis"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Apis") != m.end() && !m["Apis"].empty()) {
      if (typeid(vector<boost::any>) == m["Apis"].type()) {
        vector<ListDataServiceApisResponseBodyDataApis> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apis"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApisResponseBodyDataApis model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apis = make_shared<vector<ListDataServiceApisResponseBodyDataApis>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceApisResponseBodyData() = default;
};
class ListDataServiceApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<ListDataServiceApisResponseBodyData> data{};

  ListDataServiceApisResponseBody() {}

  explicit ListDataServiceApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataServiceApisResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataServiceApisResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListDataServiceApisResponseBody() = default;
};
class ListDataServiceApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDataServiceApisResponseBody> body{};

  ListDataServiceApisResponse() {}

  explicit ListDataServiceApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataServiceApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataServiceApisResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataServiceApisResponse() = default;
};
class ListDataServiceApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectIdList{};
  shared_ptr<long> tenantId{};

  ListDataServiceApplicationsRequest() {}

  explicit ListDataServiceApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectIdList) {
      res["ProjectIdList"] = boost::any(*projectIdList);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectIdList") != m.end() && !m["ProjectIdList"].empty()) {
      projectIdList = make_shared<string>(boost::any_cast<string>(m["ProjectIdList"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListDataServiceApplicationsRequest() = default;
};
class ListDataServiceApplicationsResponseBodyDataApplications : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<long> applicationId{};
  shared_ptr<long> projectId{};

  ListDataServiceApplicationsResponseBodyDataApplications() {}

  explicit ListDataServiceApplicationsResponseBodyDataApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<long>(boost::any_cast<long>(m["ApplicationId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListDataServiceApplicationsResponseBodyDataApplications() = default;
};
class ListDataServiceApplicationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListDataServiceApplicationsResponseBodyDataApplications>> applications{};

  ListDataServiceApplicationsResponseBodyData() {}

  explicit ListDataServiceApplicationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Applications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(vector<boost::any>) == m["Applications"].type()) {
        vector<ListDataServiceApplicationsResponseBodyDataApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceApplicationsResponseBodyDataApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<ListDataServiceApplicationsResponseBodyDataApplications>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceApplicationsResponseBodyData() = default;
};
class ListDataServiceApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<ListDataServiceApplicationsResponseBodyData> data{};

  ListDataServiceApplicationsResponseBody() {}

  explicit ListDataServiceApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataServiceApplicationsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataServiceApplicationsResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListDataServiceApplicationsResponseBody() = default;
};
class ListDataServiceApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDataServiceApplicationsResponseBody> body{};

  ListDataServiceApplicationsResponse() {}

  explicit ListDataServiceApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataServiceApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataServiceApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataServiceApplicationsResponse() = default;
};
class ListDataServiceAuthorizedApisRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiNameKeyword{};

  ListDataServiceAuthorizedApisRequest() {}

  explicit ListDataServiceAuthorizedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiNameKeyword) {
      res["ApiNameKeyword"] = boost::any(*apiNameKeyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiNameKeyword") != m.end() && !m["ApiNameKeyword"].empty()) {
      apiNameKeyword = make_shared<string>(boost::any_cast<string>(m["ApiNameKeyword"]));
    }
  }


  virtual ~ListDataServiceAuthorizedApisRequest() = default;
};
class ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList : public Darabonba::Model {
public:
  shared_ptr<long> apiId{};
  shared_ptr<long> apiStatus{};
  shared_ptr<string> grantOperatorId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> grantEndTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> grantCreatedTime{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> apiName{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiPath{};

  ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList() {}

  explicit ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (grantOperatorId) {
      res["GrantOperatorId"] = boost::any(*grantOperatorId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (grantEndTime) {
      res["GrantEndTime"] = boost::any(*grantEndTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (grantCreatedTime) {
      res["GrantCreatedTime"] = boost::any(*grantCreatedTime);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<long>(boost::any_cast<long>(m["ApiStatus"]));
    }
    if (m.find("GrantOperatorId") != m.end() && !m["GrantOperatorId"].empty()) {
      grantOperatorId = make_shared<string>(boost::any_cast<string>(m["GrantOperatorId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("GrantEndTime") != m.end() && !m["GrantEndTime"].empty()) {
      grantEndTime = make_shared<string>(boost::any_cast<string>(m["GrantEndTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GrantCreatedTime") != m.end() && !m["GrantCreatedTime"].empty()) {
      grantCreatedTime = make_shared<string>(boost::any_cast<string>(m["GrantCreatedTime"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
  }


  virtual ~ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList() = default;
};
class ListDataServiceAuthorizedApisResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList>> apiAuthorizedList{};

  ListDataServiceAuthorizedApisResponseBodyData() {}

  explicit ListDataServiceAuthorizedApisResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (apiAuthorizedList) {
      vector<boost::any> temp1;
      for(auto item1:*apiAuthorizedList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiAuthorizedList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ApiAuthorizedList") != m.end() && !m["ApiAuthorizedList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiAuthorizedList"].type()) {
        vector<ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiAuthorizedList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiAuthorizedList = make_shared<vector<ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceAuthorizedApisResponseBodyData() = default;
};
class ListDataServiceAuthorizedApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<ListDataServiceAuthorizedApisResponseBodyData> data{};

  ListDataServiceAuthorizedApisResponseBody() {}

  explicit ListDataServiceAuthorizedApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataServiceAuthorizedApisResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataServiceAuthorizedApisResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListDataServiceAuthorizedApisResponseBody() = default;
};
class ListDataServiceAuthorizedApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDataServiceAuthorizedApisResponseBody> body{};

  ListDataServiceAuthorizedApisResponse() {}

  explicit ListDataServiceAuthorizedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataServiceAuthorizedApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataServiceAuthorizedApisResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataServiceAuthorizedApisResponse() = default;
};
class ListDataServiceFoldersRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> folderNameKeyword{};

  ListDataServiceFoldersRequest() {}

  explicit ListDataServiceFoldersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (folderNameKeyword) {
      res["FolderNameKeyword"] = boost::any(*folderNameKeyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("FolderNameKeyword") != m.end() && !m["FolderNameKeyword"].empty()) {
      folderNameKeyword = make_shared<string>(boost::any_cast<string>(m["FolderNameKeyword"]));
    }
  }


  virtual ~ListDataServiceFoldersRequest() = default;
};
class ListDataServiceFoldersResponseBodyFolderPagingResultFolders : public Darabonba::Model {
public:
  shared_ptr<long> parentId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> groupId{};
  shared_ptr<long> folderId{};
  shared_ptr<string> folderName{};
  shared_ptr<long> projectId{};
  shared_ptr<string> createdTime{};
  shared_ptr<long> tenantId{};

  ListDataServiceFoldersResponseBodyFolderPagingResultFolders() {}

  explicit ListDataServiceFoldersResponseBodyFolderPagingResultFolders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<long>(boost::any_cast<long>(m["FolderId"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListDataServiceFoldersResponseBodyFolderPagingResultFolders() = default;
};
class ListDataServiceFoldersResponseBodyFolderPagingResult : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListDataServiceFoldersResponseBodyFolderPagingResultFolders>> folders{};

  ListDataServiceFoldersResponseBodyFolderPagingResult() {}

  explicit ListDataServiceFoldersResponseBodyFolderPagingResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (folders) {
      vector<boost::any> temp1;
      for(auto item1:*folders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Folders"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Folders") != m.end() && !m["Folders"].empty()) {
      if (typeid(vector<boost::any>) == m["Folders"].type()) {
        vector<ListDataServiceFoldersResponseBodyFolderPagingResultFolders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Folders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceFoldersResponseBodyFolderPagingResultFolders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        folders = make_shared<vector<ListDataServiceFoldersResponseBodyFolderPagingResultFolders>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceFoldersResponseBodyFolderPagingResult() = default;
};
class ListDataServiceFoldersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListDataServiceFoldersResponseBodyFolderPagingResult> folderPagingResult{};

  ListDataServiceFoldersResponseBody() {}

  explicit ListDataServiceFoldersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (folderPagingResult) {
      res["FolderPagingResult"] = folderPagingResult ? boost::any(folderPagingResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FolderPagingResult") != m.end() && !m["FolderPagingResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["FolderPagingResult"].type()) {
        ListDataServiceFoldersResponseBodyFolderPagingResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FolderPagingResult"]));
        folderPagingResult = make_shared<ListDataServiceFoldersResponseBodyFolderPagingResult>(model1);
      }
    }
  }


  virtual ~ListDataServiceFoldersResponseBody() = default;
};
class ListDataServiceFoldersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDataServiceFoldersResponseBody> body{};

  ListDataServiceFoldersResponse() {}

  explicit ListDataServiceFoldersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataServiceFoldersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataServiceFoldersResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataServiceFoldersResponse() = default;
};
class ListDataServiceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> groupNameKeyword{};

  ListDataServiceGroupsRequest() {}

  explicit ListDataServiceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (groupNameKeyword) {
      res["GroupNameKeyword"] = boost::any(*groupNameKeyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("GroupNameKeyword") != m.end() && !m["GroupNameKeyword"].empty()) {
      groupNameKeyword = make_shared<string>(boost::any_cast<string>(m["GroupNameKeyword"]));
    }
  }


  virtual ~ListDataServiceGroupsRequest() = default;
};
class ListDataServiceGroupsResponseBodyGroupPagingResultGroups : public Darabonba::Model {
public:
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> apiGatewayGroupId{};
  shared_ptr<string> creatorId{};
  shared_ptr<string> createdTime{};
  shared_ptr<long> tenantId{};

  ListDataServiceGroupsResponseBodyGroupPagingResultGroups() {}

  explicit ListDataServiceGroupsResponseBodyGroupPagingResultGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiGatewayGroupId) {
      res["ApiGatewayGroupId"] = boost::any(*apiGatewayGroupId);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiGatewayGroupId") != m.end() && !m["ApiGatewayGroupId"].empty()) {
      apiGatewayGroupId = make_shared<string>(boost::any_cast<string>(m["ApiGatewayGroupId"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListDataServiceGroupsResponseBodyGroupPagingResultGroups() = default;
};
class ListDataServiceGroupsResponseBodyGroupPagingResult : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListDataServiceGroupsResponseBodyGroupPagingResultGroups>> groups{};

  ListDataServiceGroupsResponseBodyGroupPagingResult() {}

  explicit ListDataServiceGroupsResponseBodyGroupPagingResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<ListDataServiceGroupsResponseBodyGroupPagingResultGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServiceGroupsResponseBodyGroupPagingResultGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<ListDataServiceGroupsResponseBodyGroupPagingResultGroups>>(expect1);
      }
    }
  }


  virtual ~ListDataServiceGroupsResponseBodyGroupPagingResult() = default;
};
class ListDataServiceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListDataServiceGroupsResponseBodyGroupPagingResult> groupPagingResult{};

  ListDataServiceGroupsResponseBody() {}

  explicit ListDataServiceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (groupPagingResult) {
      res["GroupPagingResult"] = groupPagingResult ? boost::any(groupPagingResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("GroupPagingResult") != m.end() && !m["GroupPagingResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupPagingResult"].type()) {
        ListDataServiceGroupsResponseBodyGroupPagingResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupPagingResult"]));
        groupPagingResult = make_shared<ListDataServiceGroupsResponseBodyGroupPagingResult>(model1);
      }
    }
  }


  virtual ~ListDataServiceGroupsResponseBody() = default;
};
class ListDataServiceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDataServiceGroupsResponseBody> body{};

  ListDataServiceGroupsResponse() {}

  explicit ListDataServiceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataServiceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataServiceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataServiceGroupsResponse() = default;
};
class ListDataServicePublishedApisRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiNameKeyword{};
  shared_ptr<string> apiPathKeyword{};
  shared_ptr<string> creatorId{};

  ListDataServicePublishedApisRequest() {}

  explicit ListDataServicePublishedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiNameKeyword) {
      res["ApiNameKeyword"] = boost::any(*apiNameKeyword);
    }
    if (apiPathKeyword) {
      res["ApiPathKeyword"] = boost::any(*apiPathKeyword);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiNameKeyword") != m.end() && !m["ApiNameKeyword"].empty()) {
      apiNameKeyword = make_shared<string>(boost::any_cast<string>(m["ApiNameKeyword"]));
    }
    if (m.find("ApiPathKeyword") != m.end() && !m["ApiPathKeyword"].empty()) {
      apiPathKeyword = make_shared<string>(boost::any_cast<string>(m["ApiPathKeyword"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
  }


  virtual ~ListDataServicePublishedApisRequest() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorSolution{};

  ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<string> exampleValue{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<bool> isRequiredParameter{};

  ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails : public Darabonba::Model {
public:
  shared_ptr<string> serviceHost{};
  shared_ptr<long> serviceContentType{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<string> failedResultSample{};
  shared_ptr<string> serviceRequestBodyDescription{};
  shared_ptr<vector<ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes>> registrationErrorCodes{};
  shared_ptr<vector<ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters>> registrationRequestParameters{};

  ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceHost) {
      res["ServiceHost"] = boost::any(*serviceHost);
    }
    if (serviceContentType) {
      res["ServiceContentType"] = boost::any(*serviceContentType);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (serviceRequestBodyDescription) {
      res["ServiceRequestBodyDescription"] = boost::any(*serviceRequestBodyDescription);
    }
    if (registrationErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*registrationErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationErrorCodes"] = boost::any(temp1);
    }
    if (registrationRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*registrationRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegistrationRequestParameters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceHost") != m.end() && !m["ServiceHost"].empty()) {
      serviceHost = make_shared<string>(boost::any_cast<string>(m["ServiceHost"]));
    }
    if (m.find("ServiceContentType") != m.end() && !m["ServiceContentType"].empty()) {
      serviceContentType = make_shared<long>(boost::any_cast<long>(m["ServiceContentType"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("ServiceRequestBodyDescription") != m.end() && !m["ServiceRequestBodyDescription"].empty()) {
      serviceRequestBodyDescription = make_shared<string>(boost::any_cast<string>(m["ServiceRequestBodyDescription"]));
    }
    if (m.find("RegistrationErrorCodes") != m.end() && !m["RegistrationErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationErrorCodes"].type()) {
        vector<ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationErrorCodes = make_shared<vector<ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes>>(expect1);
      }
    }
    if (m.find("RegistrationRequestParameters") != m.end() && !m["RegistrationRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["RegistrationRequestParameters"].type()) {
        vector<ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegistrationRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        registrationRequestParameters = make_shared<vector<ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters>>(expect1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorSolution{};

  ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<string> exampleValue{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<bool> isRequiredParameter{};

  ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> exampleValue{};
  shared_ptr<long> parameterDataType{};

  ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<long> connectionId{};

  ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisScriptDetails : public Darabonba::Model {
public:
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<string> failedResultSample{};
  shared_ptr<string> script{};
  shared_ptr<vector<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes>> scriptErrorCodes{};
  shared_ptr<vector<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters>> scriptRequestParameters{};
  shared_ptr<vector<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters>> scriptResponseParameters{};
  shared_ptr<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection> scriptConnection{};

  ListDataServicePublishedApisResponseBodyDataApisScriptDetails() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisScriptDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (scriptErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*scriptErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptErrorCodes"] = boost::any(temp1);
    }
    if (scriptRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptRequestParameters"] = boost::any(temp1);
    }
    if (scriptResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptResponseParameters"] = boost::any(temp1);
    }
    if (scriptConnection) {
      res["ScriptConnection"] = scriptConnection ? boost::any(scriptConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("ScriptErrorCodes") != m.end() && !m["ScriptErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptErrorCodes"].type()) {
        vector<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptErrorCodes = make_shared<vector<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes>>(expect1);
      }
    }
    if (m.find("ScriptRequestParameters") != m.end() && !m["ScriptRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptRequestParameters"].type()) {
        vector<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptRequestParameters = make_shared<vector<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters>>(expect1);
      }
    }
    if (m.find("ScriptResponseParameters") != m.end() && !m["ScriptResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptResponseParameters"].type()) {
        vector<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptResponseParameters = make_shared<vector<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters>>(expect1);
      }
    }
    if (m.find("ScriptConnection") != m.end() && !m["ScriptConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptConnection"].type()) {
        ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptConnection"]));
        scriptConnection = make_shared<ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection>(model1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisScriptDetails() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorSolution{};

  ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorSolution) {
      res["ErrorSolution"] = boost::any(*errorSolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorSolution") != m.end() && !m["ErrorSolution"].empty()) {
      errorSolution = make_shared<string>(boost::any_cast<string>(m["ErrorSolution"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterName{};
  shared_ptr<long> parameterPosition{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> parameterOperator{};
  shared_ptr<string> exampleValue{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<bool> isRequiredParameter{};

  ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterPosition) {
      res["ParameterPosition"] = boost::any(*parameterPosition);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (parameterOperator) {
      res["ParameterOperator"] = boost::any(*parameterOperator);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterPosition") != m.end() && !m["ParameterPosition"].empty()) {
      parameterPosition = make_shared<long>(boost::any_cast<long>(m["ParameterPosition"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("ParameterOperator") != m.end() && !m["ParameterOperator"].empty()) {
      parameterOperator = make_shared<long>(boost::any_cast<long>(m["ParameterOperator"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> exampleValue{};
  shared_ptr<long> parameterDataType{};

  ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<long> connectionId{};

  ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection() = default;
};
class ListDataServicePublishedApisResponseBodyDataApisWizardDetails : public Darabonba::Model {
public:
  shared_ptr<bool> isPagedResponse{};
  shared_ptr<string> successfulResultSample{};
  shared_ptr<string> failedResultSample{};
  shared_ptr<vector<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes>> wizardErrorCodes{};
  shared_ptr<vector<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters>> wizardRequestParameters{};
  shared_ptr<vector<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters>> wizardResponseParameters{};
  shared_ptr<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection> wizardConnection{};

  ListDataServicePublishedApisResponseBodyDataApisWizardDetails() {}

  explicit ListDataServicePublishedApisResponseBodyDataApisWizardDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPagedResponse) {
      res["IsPagedResponse"] = boost::any(*isPagedResponse);
    }
    if (successfulResultSample) {
      res["SuccessfulResultSample"] = boost::any(*successfulResultSample);
    }
    if (failedResultSample) {
      res["FailedResultSample"] = boost::any(*failedResultSample);
    }
    if (wizardErrorCodes) {
      vector<boost::any> temp1;
      for(auto item1:*wizardErrorCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardErrorCodes"] = boost::any(temp1);
    }
    if (wizardRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardRequestParameters"] = boost::any(temp1);
    }
    if (wizardResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*wizardResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WizardResponseParameters"] = boost::any(temp1);
    }
    if (wizardConnection) {
      res["WizardConnection"] = wizardConnection ? boost::any(wizardConnection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPagedResponse") != m.end() && !m["IsPagedResponse"].empty()) {
      isPagedResponse = make_shared<bool>(boost::any_cast<bool>(m["IsPagedResponse"]));
    }
    if (m.find("SuccessfulResultSample") != m.end() && !m["SuccessfulResultSample"].empty()) {
      successfulResultSample = make_shared<string>(boost::any_cast<string>(m["SuccessfulResultSample"]));
    }
    if (m.find("FailedResultSample") != m.end() && !m["FailedResultSample"].empty()) {
      failedResultSample = make_shared<string>(boost::any_cast<string>(m["FailedResultSample"]));
    }
    if (m.find("WizardErrorCodes") != m.end() && !m["WizardErrorCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardErrorCodes"].type()) {
        vector<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardErrorCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardErrorCodes = make_shared<vector<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes>>(expect1);
      }
    }
    if (m.find("WizardRequestParameters") != m.end() && !m["WizardRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardRequestParameters"].type()) {
        vector<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardRequestParameters = make_shared<vector<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters>>(expect1);
      }
    }
    if (m.find("WizardResponseParameters") != m.end() && !m["WizardResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["WizardResponseParameters"].type()) {
        vector<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WizardResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wizardResponseParameters = make_shared<vector<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters>>(expect1);
      }
    }
    if (m.find("WizardConnection") != m.end() && !m["WizardConnection"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardConnection"].type()) {
        ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardConnection"]));
        wizardConnection = make_shared<ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection>(model1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApisWizardDetails() = default;
};
class ListDataServicePublishedApisResponseBodyDataApis : public Darabonba::Model {
public:
  shared_ptr<long> timeout{};
  shared_ptr<long> status{};
  shared_ptr<long> apiId{};
  shared_ptr<long> apiMode{};
  shared_ptr<long> projectId{};
  shared_ptr<long> responseContentType{};
  shared_ptr<string> creatorId{};
  shared_ptr<long> visibleRange{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> operatorId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> description{};
  shared_ptr<long> requestMethod{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> apiName{};
  shared_ptr<long> tenantId{};
  shared_ptr<string> apiPath{};
  shared_ptr<vector<long>> protocols{};
  shared_ptr<ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails> registrationDetails{};
  shared_ptr<ListDataServicePublishedApisResponseBodyDataApisScriptDetails> scriptDetails{};
  shared_ptr<ListDataServicePublishedApisResponseBodyDataApisWizardDetails> wizardDetails{};

  ListDataServicePublishedApisResponseBodyDataApis() {}

  explicit ListDataServicePublishedApisResponseBodyDataApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMode) {
      res["ApiMode"] = boost::any(*apiMode);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (creatorId) {
      res["CreatorId"] = boost::any(*creatorId);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (operatorId) {
      res["OperatorId"] = boost::any(*operatorId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = registrationDetails ? boost::any(registrationDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scriptDetails) {
      res["ScriptDetails"] = scriptDetails ? boost::any(scriptDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wizardDetails) {
      res["WizardDetails"] = wizardDetails ? boost::any(wizardDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiMode") != m.end() && !m["ApiMode"].empty()) {
      apiMode = make_shared<long>(boost::any_cast<long>(m["ApiMode"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<long>(boost::any_cast<long>(m["ResponseContentType"]));
    }
    if (m.find("CreatorId") != m.end() && !m["CreatorId"].empty()) {
      creatorId = make_shared<string>(boost::any_cast<string>(m["CreatorId"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<long>(boost::any_cast<long>(m["VisibleRange"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OperatorId") != m.end() && !m["OperatorId"].empty()) {
      operatorId = make_shared<string>(boost::any_cast<string>(m["OperatorId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<long>(boost::any_cast<long>(m["RequestMethod"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      protocols = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegistrationDetails"].type()) {
        ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegistrationDetails"]));
        registrationDetails = make_shared<ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails>(model1);
      }
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptDetails"].type()) {
        ListDataServicePublishedApisResponseBodyDataApisScriptDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptDetails"]));
        scriptDetails = make_shared<ListDataServicePublishedApisResponseBodyDataApisScriptDetails>(model1);
      }
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["WizardDetails"].type()) {
        ListDataServicePublishedApisResponseBodyDataApisWizardDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WizardDetails"]));
        wizardDetails = make_shared<ListDataServicePublishedApisResponseBodyDataApisWizardDetails>(model1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyDataApis() = default;
};
class ListDataServicePublishedApisResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListDataServicePublishedApisResponseBodyDataApis>> apis{};

  ListDataServicePublishedApisResponseBodyData() {}

  explicit ListDataServicePublishedApisResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (apis) {
      vector<boost::any> temp1;
      for(auto item1:*apis){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apis"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Apis") != m.end() && !m["Apis"].empty()) {
      if (typeid(vector<boost::any>) == m["Apis"].type()) {
        vector<ListDataServicePublishedApisResponseBodyDataApis> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apis"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataServicePublishedApisResponseBodyDataApis model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apis = make_shared<vector<ListDataServicePublishedApisResponseBodyDataApis>>(expect1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponseBodyData() = default;
};
class ListDataServicePublishedApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<ListDataServicePublishedApisResponseBodyData> data{};

  ListDataServicePublishedApisResponseBody() {}

  explicit ListDataServicePublishedApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataServicePublishedApisResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataServicePublishedApisResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponseBody() = default;
};
class ListDataServicePublishedApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDataServicePublishedApisResponseBody> body{};

  ListDataServicePublishedApisResponse() {}

  explicit ListDataServicePublishedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataServicePublishedApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataServicePublishedApisResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataServicePublishedApisResponse() = default;
};
class ListDataSourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> subType{};
  shared_ptr<string> status{};
  shared_ptr<long> envType{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  ListDataSourcesRequest() {}

  explicit ListDataSourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~ListDataSourcesRequest() = default;
};
class ListDataSourcesResponseBodyDataDataSources : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> projectId{};
  shared_ptr<string> subType{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> envType{};
  shared_ptr<long> connectStatus{};
  shared_ptr<long> sequence{};
  shared_ptr<string> description{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<bool> defaultEngine{};
  shared_ptr<bool> shared{};
  shared_ptr<string> operator_{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<long> bindingCalcEngineId{};
  shared_ptr<long> tenantId{};

  ListDataSourcesResponseBodyDataDataSources() {}

  explicit ListDataSourcesResponseBodyDataDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (connectStatus) {
      res["ConnectStatus"] = boost::any(*connectStatus);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (defaultEngine) {
      res["DefaultEngine"] = boost::any(*defaultEngine);
    }
    if (shared) {
      res["Shared"] = boost::any(*shared);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (bindingCalcEngineId) {
      res["BindingCalcEngineId"] = boost::any(*bindingCalcEngineId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("ConnectStatus") != m.end() && !m["ConnectStatus"].empty()) {
      connectStatus = make_shared<long>(boost::any_cast<long>(m["ConnectStatus"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<long>(boost::any_cast<long>(m["Sequence"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("DefaultEngine") != m.end() && !m["DefaultEngine"].empty()) {
      defaultEngine = make_shared<bool>(boost::any_cast<bool>(m["DefaultEngine"]));
    }
    if (m.find("Shared") != m.end() && !m["Shared"].empty()) {
      shared = make_shared<bool>(boost::any_cast<bool>(m["Shared"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("BindingCalcEngineId") != m.end() && !m["BindingCalcEngineId"].empty()) {
      bindingCalcEngineId = make_shared<long>(boost::any_cast<long>(m["BindingCalcEngineId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListDataSourcesResponseBodyDataDataSources() = default;
};
class ListDataSourcesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListDataSourcesResponseBodyDataDataSources>> dataSources{};

  ListDataSourcesResponseBodyData() {}

  explicit ListDataSourcesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataSources) {
      vector<boost::any> temp1;
      for(auto item1:*dataSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataSources") != m.end() && !m["DataSources"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSources"].type()) {
        vector<ListDataSourcesResponseBodyDataDataSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourcesResponseBodyDataDataSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSources = make_shared<vector<ListDataSourcesResponseBodyDataDataSources>>(expect1);
      }
    }
  }


  virtual ~ListDataSourcesResponseBodyData() = default;
};
class ListDataSourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<ListDataSourcesResponseBodyData> data{};

  ListDataSourcesResponseBody() {}

  explicit ListDataSourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataSourcesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataSourcesResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListDataSourcesResponseBody() = default;
};
class ListDataSourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDataSourcesResponseBody> body{};

  ListDataSourcesResponse() {}

  explicit ListDataSourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataSourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataSourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataSourcesResponse() = default;
};
class ListDISyncTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> taskType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListDISyncTasksRequest() {}

  explicit ListDISyncTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListDISyncTasksRequest() = default;
};
class ListDISyncTasksResponseBodyTaskListRealTimeSolutionList : public Darabonba::Model {
public:
  shared_ptr<string> processName{};
  shared_ptr<string> taskType{};
  shared_ptr<long> processId{};
  shared_ptr<string> taskStatus{};
  shared_ptr<long> createTime{};

  ListDISyncTasksResponseBodyTaskListRealTimeSolutionList() {}

  explicit ListDISyncTasksResponseBodyTaskListRealTimeSolutionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (processName) {
      res["ProcessName"] = boost::any(*processName);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (processId) {
      res["ProcessId"] = boost::any(*processId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProcessName") != m.end() && !m["ProcessName"].empty()) {
      processName = make_shared<string>(boost::any_cast<string>(m["ProcessName"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("ProcessId") != m.end() && !m["ProcessId"].empty()) {
      processId = make_shared<long>(boost::any_cast<long>(m["ProcessId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
  }


  virtual ~ListDISyncTasksResponseBodyTaskListRealTimeSolutionList() = default;
};
class ListDISyncTasksResponseBodyTaskList : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListDISyncTasksResponseBodyTaskListRealTimeSolutionList>> realTimeSolutionList{};

  ListDISyncTasksResponseBodyTaskList() {}

  explicit ListDISyncTasksResponseBodyTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (realTimeSolutionList) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeSolutionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeSolutionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RealTimeSolutionList") != m.end() && !m["RealTimeSolutionList"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeSolutionList"].type()) {
        vector<ListDISyncTasksResponseBodyTaskListRealTimeSolutionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeSolutionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDISyncTasksResponseBodyTaskListRealTimeSolutionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeSolutionList = make_shared<vector<ListDISyncTasksResponseBodyTaskListRealTimeSolutionList>>(expect1);
      }
    }
  }


  virtual ~ListDISyncTasksResponseBodyTaskList() = default;
};
class ListDISyncTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};
  shared_ptr<ListDISyncTasksResponseBodyTaskList> taskList{};

  ListDISyncTasksResponseBody() {}

  explicit ListDISyncTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskList) {
      res["TaskList"] = taskList ? boost::any(taskList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskList"].type()) {
        ListDISyncTasksResponseBodyTaskList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskList"]));
        taskList = make_shared<ListDISyncTasksResponseBodyTaskList>(model1);
      }
    }
  }


  virtual ~ListDISyncTasksResponseBody() = default;
};
class ListDISyncTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDISyncTasksResponseBody> body{};

  ListDISyncTasksResponse() {}

  explicit ListDISyncTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDISyncTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDISyncTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListDISyncTasksResponse() = default;
};
class ListFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> keyword{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> useType{};
  shared_ptr<string> fileTypes{};
  shared_ptr<string> owner{};

  ListFilesRequest() {}

  explicit ListFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    if (fileTypes) {
      res["FileTypes"] = boost::any(*fileTypes);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
    if (m.find("FileTypes") != m.end() && !m["FileTypes"].empty()) {
      fileTypes = make_shared<string>(boost::any_cast<string>(m["FileTypes"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
  }


  virtual ~ListFilesRequest() = default;
};
class ListFilesResponseBodyDataFiles : public Darabonba::Model {
public:
  shared_ptr<long> commitStatus{};
  shared_ptr<bool> autoParsing{};
  shared_ptr<string> owner{};
  shared_ptr<long> createTime{};
  shared_ptr<long> fileType{};
  shared_ptr<long> currentVersion{};
  shared_ptr<long> bizId{};
  shared_ptr<string> lastEditUser{};
  shared_ptr<string> fileName{};
  shared_ptr<string> connectionName{};
  shared_ptr<string> useType{};
  shared_ptr<string> fileFolderId{};
  shared_ptr<long> fileId{};
  shared_ptr<long> parentId{};
  shared_ptr<string> createUser{};
  shared_ptr<bool> isMaxCompute{};
  shared_ptr<long> businessId{};
  shared_ptr<string> fileDescription{};
  shared_ptr<long> lastEditTime{};
  shared_ptr<string> content{};
  shared_ptr<long> nodeId{};

  ListFilesResponseBodyDataFiles() {}

  explicit ListFilesResponseBodyDataFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitStatus) {
      res["CommitStatus"] = boost::any(*commitStatus);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (currentVersion) {
      res["CurrentVersion"] = boost::any(*currentVersion);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (lastEditUser) {
      res["LastEditUser"] = boost::any(*lastEditUser);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    if (fileFolderId) {
      res["FileFolderId"] = boost::any(*fileFolderId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (isMaxCompute) {
      res["IsMaxCompute"] = boost::any(*isMaxCompute);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (lastEditTime) {
      res["LastEditTime"] = boost::any(*lastEditTime);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommitStatus") != m.end() && !m["CommitStatus"].empty()) {
      commitStatus = make_shared<long>(boost::any_cast<long>(m["CommitStatus"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("CurrentVersion") != m.end() && !m["CurrentVersion"].empty()) {
      currentVersion = make_shared<long>(boost::any_cast<long>(m["CurrentVersion"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<long>(boost::any_cast<long>(m["BizId"]));
    }
    if (m.find("LastEditUser") != m.end() && !m["LastEditUser"].empty()) {
      lastEditUser = make_shared<string>(boost::any_cast<string>(m["LastEditUser"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
    if (m.find("FileFolderId") != m.end() && !m["FileFolderId"].empty()) {
      fileFolderId = make_shared<string>(boost::any_cast<string>(m["FileFolderId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("IsMaxCompute") != m.end() && !m["IsMaxCompute"].empty()) {
      isMaxCompute = make_shared<bool>(boost::any_cast<bool>(m["IsMaxCompute"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("LastEditTime") != m.end() && !m["LastEditTime"].empty()) {
      lastEditTime = make_shared<long>(boost::any_cast<long>(m["LastEditTime"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListFilesResponseBodyDataFiles() = default;
};
class ListFilesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListFilesResponseBodyDataFiles>> files{};

  ListFilesResponseBodyData() {}

  explicit ListFilesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<ListFilesResponseBodyDataFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFilesResponseBodyDataFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<ListFilesResponseBodyDataFiles>>(expect1);
      }
    }
  }


  virtual ~ListFilesResponseBodyData() = default;
};
class ListFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListFilesResponseBodyData> data{};

  ListFilesResponseBody() {}

  explicit ListFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFilesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFilesResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListFilesResponseBody() = default;
};
class ListFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFilesResponseBody> body{};

  ListFilesResponse() {}

  explicit ListFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFilesResponse() = default;
};
class ListFileTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> keyword{};
  shared_ptr<string> locale{};

  ListFileTypeRequest() {}

  explicit ListFileTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (locale) {
      res["Locale"] = boost::any(*locale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Locale") != m.end() && !m["Locale"].empty()) {
      locale = make_shared<string>(boost::any_cast<string>(m["Locale"]));
    }
  }


  virtual ~ListFileTypeRequest() = default;
};
class ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo : public Darabonba::Model {
public:
  shared_ptr<string> nodeTypeName{};
  shared_ptr<long> nodeType{};

  ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo() {}

  explicit ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeTypeName) {
      res["NodeTypeName"] = boost::any(*nodeTypeName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeTypeName") != m.end() && !m["NodeTypeName"].empty()) {
      nodeTypeName = make_shared<string>(boost::any_cast<string>(m["NodeTypeName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<long>(boost::any_cast<long>(m["NodeType"]));
    }
  }


  virtual ~ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo() = default;
};
class ListFileTypeResponseBodyNodeTypeInfoList : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo>> nodeTypeInfo{};

  ListFileTypeResponseBodyNodeTypeInfoList() {}

  explicit ListFileTypeResponseBodyNodeTypeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nodeTypeInfo) {
      vector<boost::any> temp1;
      for(auto item1:*nodeTypeInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeTypeInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NodeTypeInfo") != m.end() && !m["NodeTypeInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeTypeInfo"].type()) {
        vector<ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeTypeInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeTypeInfo = make_shared<vector<ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo>>(expect1);
      }
    }
  }


  virtual ~ListFileTypeResponseBodyNodeTypeInfoList() = default;
};
class ListFileTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListFileTypeResponseBodyNodeTypeInfoList> nodeTypeInfoList{};

  ListFileTypeResponseBody() {}

  explicit ListFileTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (nodeTypeInfoList) {
      res["NodeTypeInfoList"] = nodeTypeInfoList ? boost::any(nodeTypeInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("NodeTypeInfoList") != m.end() && !m["NodeTypeInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeTypeInfoList"].type()) {
        ListFileTypeResponseBodyNodeTypeInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeTypeInfoList"]));
        nodeTypeInfoList = make_shared<ListFileTypeResponseBodyNodeTypeInfoList>(model1);
      }
    }
  }


  virtual ~ListFileTypeResponseBody() = default;
};
class ListFileTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFileTypeResponseBody> body{};

  ListFileTypeResponse() {}

  explicit ListFileTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFileTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFileTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ListFileTypeResponse() = default;
};
class ListFileVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListFileVersionsRequest() {}

  explicit ListFileVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFileVersionsRequest() = default;
};
class ListFileVersionsResponseBodyDataFileVersions : public Darabonba::Model {
public:
  shared_ptr<string> fileContent{};
  shared_ptr<string> status{};
  shared_ptr<bool> isCurrentProd{};
  shared_ptr<string> commitUser{};
  shared_ptr<string> nodeContent{};
  shared_ptr<string> comment{};
  shared_ptr<string> filePropertyContent{};
  shared_ptr<string> fileName{};
  shared_ptr<string> useType{};
  shared_ptr<string> changeType{};
  shared_ptr<long> fileVersion{};
  shared_ptr<long> commitTime{};
  shared_ptr<long> nodeId{};

  ListFileVersionsResponseBodyDataFileVersions() {}

  explicit ListFileVersionsResponseBodyDataFileVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileContent) {
      res["FileContent"] = boost::any(*fileContent);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (isCurrentProd) {
      res["IsCurrentProd"] = boost::any(*isCurrentProd);
    }
    if (commitUser) {
      res["CommitUser"] = boost::any(*commitUser);
    }
    if (nodeContent) {
      res["NodeContent"] = boost::any(*nodeContent);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (filePropertyContent) {
      res["FilePropertyContent"] = boost::any(*filePropertyContent);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (useType) {
      res["UseType"] = boost::any(*useType);
    }
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (fileVersion) {
      res["FileVersion"] = boost::any(*fileVersion);
    }
    if (commitTime) {
      res["CommitTime"] = boost::any(*commitTime);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileContent") != m.end() && !m["FileContent"].empty()) {
      fileContent = make_shared<string>(boost::any_cast<string>(m["FileContent"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("IsCurrentProd") != m.end() && !m["IsCurrentProd"].empty()) {
      isCurrentProd = make_shared<bool>(boost::any_cast<bool>(m["IsCurrentProd"]));
    }
    if (m.find("CommitUser") != m.end() && !m["CommitUser"].empty()) {
      commitUser = make_shared<string>(boost::any_cast<string>(m["CommitUser"]));
    }
    if (m.find("NodeContent") != m.end() && !m["NodeContent"].empty()) {
      nodeContent = make_shared<string>(boost::any_cast<string>(m["NodeContent"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("FilePropertyContent") != m.end() && !m["FilePropertyContent"].empty()) {
      filePropertyContent = make_shared<string>(boost::any_cast<string>(m["FilePropertyContent"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("UseType") != m.end() && !m["UseType"].empty()) {
      useType = make_shared<string>(boost::any_cast<string>(m["UseType"]));
    }
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
    if (m.find("FileVersion") != m.end() && !m["FileVersion"].empty()) {
      fileVersion = make_shared<long>(boost::any_cast<long>(m["FileVersion"]));
    }
    if (m.find("CommitTime") != m.end() && !m["CommitTime"].empty()) {
      commitTime = make_shared<long>(boost::any_cast<long>(m["CommitTime"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListFileVersionsResponseBodyDataFileVersions() = default;
};
class ListFileVersionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListFileVersionsResponseBodyDataFileVersions>> fileVersions{};

  ListFileVersionsResponseBodyData() {}

  explicit ListFileVersionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (fileVersions) {
      vector<boost::any> temp1;
      for(auto item1:*fileVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileVersions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("FileVersions") != m.end() && !m["FileVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["FileVersions"].type()) {
        vector<ListFileVersionsResponseBodyDataFileVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFileVersionsResponseBodyDataFileVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileVersions = make_shared<vector<ListFileVersionsResponseBodyDataFileVersions>>(expect1);
      }
    }
  }


  virtual ~ListFileVersionsResponseBodyData() = default;
};
class ListFileVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListFileVersionsResponseBodyData> data{};

  ListFileVersionsResponseBody() {}

  explicit ListFileVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFileVersionsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFileVersionsResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListFileVersionsResponseBody() = default;
};
class ListFileVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFileVersionsResponseBody> body{};

  ListFileVersionsResponse() {}

  explicit ListFileVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFileVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFileVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFileVersionsResponse() = default;
};
class ListFoldersRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> parentFolderPath{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListFoldersRequest() {}

  explicit ListFoldersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (parentFolderPath) {
      res["ParentFolderPath"] = boost::any(*parentFolderPath);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("ParentFolderPath") != m.end() && !m["ParentFolderPath"].empty()) {
      parentFolderPath = make_shared<string>(boost::any_cast<string>(m["ParentFolderPath"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFoldersRequest() = default;
};
class ListFoldersResponseBodyDataFolders : public Darabonba::Model {
public:
  shared_ptr<string> folderPath{};
  shared_ptr<string> folderId{};

  ListFoldersResponseBodyDataFolders() {}

  explicit ListFoldersResponseBodyDataFolders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (folderPath) {
      res["FolderPath"] = boost::any(*folderPath);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FolderPath") != m.end() && !m["FolderPath"].empty()) {
      folderPath = make_shared<string>(boost::any_cast<string>(m["FolderPath"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
  }


  virtual ~ListFoldersResponseBodyDataFolders() = default;
};
class ListFoldersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListFoldersResponseBodyDataFolders>> folders{};

  ListFoldersResponseBodyData() {}

  explicit ListFoldersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (folders) {
      vector<boost::any> temp1;
      for(auto item1:*folders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Folders"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Folders") != m.end() && !m["Folders"].empty()) {
      if (typeid(vector<boost::any>) == m["Folders"].type()) {
        vector<ListFoldersResponseBodyDataFolders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Folders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFoldersResponseBodyDataFolders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        folders = make_shared<vector<ListFoldersResponseBodyDataFolders>>(expect1);
      }
    }
  }


  virtual ~ListFoldersResponseBodyData() = default;
};
class ListFoldersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListFoldersResponseBodyData> data{};

  ListFoldersResponseBody() {}

  explicit ListFoldersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListFoldersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListFoldersResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListFoldersResponseBody() = default;
};
class ListFoldersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFoldersResponseBody> body{};

  ListFoldersResponse() {}

  explicit ListFoldersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFoldersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFoldersResponseBody>(model1);
      }
    }
  }


  virtual ~ListFoldersResponse() = default;
};
class ListInstanceAmountRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> beginDate{};
  shared_ptr<string> endDate{};

  ListInstanceAmountRequest() {}

  explicit ListInstanceAmountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (beginDate) {
      res["BeginDate"] = boost::any(*beginDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BeginDate") != m.end() && !m["BeginDate"].empty()) {
      beginDate = make_shared<string>(boost::any_cast<string>(m["BeginDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
  }


  virtual ~ListInstanceAmountRequest() = default;
};
class ListInstanceAmountResponseBodyInstanceCounts : public Darabonba::Model {
public:
  shared_ptr<long> date{};
  shared_ptr<long> count{};

  ListInstanceAmountResponseBodyInstanceCounts() {}

  explicit ListInstanceAmountResponseBodyInstanceCounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (date) {
      res["Date"] = boost::any(*date);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Date") != m.end() && !m["Date"].empty()) {
      date = make_shared<long>(boost::any_cast<long>(m["Date"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~ListInstanceAmountResponseBodyInstanceCounts() = default;
};
class ListInstanceAmountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListInstanceAmountResponseBodyInstanceCounts>> instanceCounts{};

  ListInstanceAmountResponseBody() {}

  explicit ListInstanceAmountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceCounts) {
      vector<boost::any> temp1;
      for(auto item1:*instanceCounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceCounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceCounts") != m.end() && !m["InstanceCounts"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceCounts"].type()) {
        vector<ListInstanceAmountResponseBodyInstanceCounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceCounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceAmountResponseBodyInstanceCounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceCounts = make_shared<vector<ListInstanceAmountResponseBodyInstanceCounts>>(expect1);
      }
    }
  }


  virtual ~ListInstanceAmountResponseBody() = default;
};
class ListInstanceAmountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListInstanceAmountResponseBody> body{};

  ListInstanceAmountResponse() {}

  explicit ListInstanceAmountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceAmountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceAmountResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceAmountResponse() = default;
};
class ListInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> owner{};
  shared_ptr<long> projectId{};
  shared_ptr<string> bizName{};
  shared_ptr<string> programType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> dagId{};
  shared_ptr<string> bizdate{};
  shared_ptr<string> beginBizdate{};
  shared_ptr<string> endBizdate{};

  ListInstancesRequest() {}

  explicit ListInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (beginBizdate) {
      res["BeginBizdate"] = boost::any(*beginBizdate);
    }
    if (endBizdate) {
      res["EndBizdate"] = boost::any(*endBizdate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("BeginBizdate") != m.end() && !m["BeginBizdate"].empty()) {
      beginBizdate = make_shared<string>(boost::any_cast<string>(m["BeginBizdate"]));
    }
    if (m.find("EndBizdate") != m.end() && !m["EndBizdate"].empty()) {
      endBizdate = make_shared<string>(boost::any_cast<string>(m["EndBizdate"]));
    }
  }


  virtual ~ListInstancesRequest() = default;
};
class ListInstancesResponseBodyDataInstances : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> cycTime{};
  shared_ptr<long> beginRunningTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> createTime{};
  shared_ptr<long> dagId{};
  shared_ptr<long> priority{};
  shared_ptr<string> taskType{};
  shared_ptr<string> paramValues{};
  shared_ptr<string> connection{};
  shared_ptr<long> baselineId{};
  shared_ptr<long> dqcType{};
  shared_ptr<string> dagType{};
  shared_ptr<long> taskRerunTime{};
  shared_ptr<long> modifyTime{};
  shared_ptr<bool> repeatability{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> beginWaitResTime{};
  shared_ptr<long> relatedFlowId{};
  shared_ptr<long> bizdate{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> beginWaitTimeTime{};
  shared_ptr<string> dqcDescription{};
  shared_ptr<long> nodeId{};

  ListInstancesResponseBodyDataInstances() {}

  explicit ListInstancesResponseBodyDataInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (cycTime) {
      res["CycTime"] = boost::any(*cycTime);
    }
    if (beginRunningTime) {
      res["BeginRunningTime"] = boost::any(*beginRunningTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (connection) {
      res["Connection"] = boost::any(*connection);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (dqcType) {
      res["DqcType"] = boost::any(*dqcType);
    }
    if (dagType) {
      res["DagType"] = boost::any(*dagType);
    }
    if (taskRerunTime) {
      res["TaskRerunTime"] = boost::any(*taskRerunTime);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (beginWaitResTime) {
      res["BeginWaitResTime"] = boost::any(*beginWaitResTime);
    }
    if (relatedFlowId) {
      res["RelatedFlowId"] = boost::any(*relatedFlowId);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (beginWaitTimeTime) {
      res["BeginWaitTimeTime"] = boost::any(*beginWaitTimeTime);
    }
    if (dqcDescription) {
      res["DqcDescription"] = boost::any(*dqcDescription);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CycTime") != m.end() && !m["CycTime"].empty()) {
      cycTime = make_shared<long>(boost::any_cast<long>(m["CycTime"]));
    }
    if (m.find("BeginRunningTime") != m.end() && !m["BeginRunningTime"].empty()) {
      beginRunningTime = make_shared<long>(boost::any_cast<long>(m["BeginRunningTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("Connection") != m.end() && !m["Connection"].empty()) {
      connection = make_shared<string>(boost::any_cast<string>(m["Connection"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("DqcType") != m.end() && !m["DqcType"].empty()) {
      dqcType = make_shared<long>(boost::any_cast<long>(m["DqcType"]));
    }
    if (m.find("DagType") != m.end() && !m["DagType"].empty()) {
      dagType = make_shared<string>(boost::any_cast<string>(m["DagType"]));
    }
    if (m.find("TaskRerunTime") != m.end() && !m["TaskRerunTime"].empty()) {
      taskRerunTime = make_shared<long>(boost::any_cast<long>(m["TaskRerunTime"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("BeginWaitResTime") != m.end() && !m["BeginWaitResTime"].empty()) {
      beginWaitResTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitResTime"]));
    }
    if (m.find("RelatedFlowId") != m.end() && !m["RelatedFlowId"].empty()) {
      relatedFlowId = make_shared<long>(boost::any_cast<long>(m["RelatedFlowId"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<long>(boost::any_cast<long>(m["Bizdate"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("BeginWaitTimeTime") != m.end() && !m["BeginWaitTimeTime"].empty()) {
      beginWaitTimeTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitTimeTime"]));
    }
    if (m.find("DqcDescription") != m.end() && !m["DqcDescription"].empty()) {
      dqcDescription = make_shared<string>(boost::any_cast<string>(m["DqcDescription"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListInstancesResponseBodyDataInstances() = default;
};
class ListInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListInstancesResponseBodyDataInstances>> instances{};

  ListInstancesResponseBodyData() {}

  explicit ListInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListInstancesResponseBodyDataInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyDataInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListInstancesResponseBodyDataInstances>>(expect1);
      }
    }
  }


  virtual ~ListInstancesResponseBodyData() = default;
};
class ListInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListInstancesResponseBodyData> data{};

  ListInstancesResponseBody() {}

  explicit ListInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListInstancesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListInstancesResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListInstancesResponseBody() = default;
};
class ListInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListInstancesResponseBody> body{};

  ListInstancesResponse() {}

  explicit ListInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesResponse() = default;
};
class ListManualDagInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> projectName{};
  shared_ptr<string> dagId{};

  ListManualDagInstancesRequest() {}

  explicit ListManualDagInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<string>(boost::any_cast<string>(m["DagId"]));
    }
  }


  virtual ~ListManualDagInstancesRequest() = default;
};
class ListManualDagInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> beginRunningTime{};
  shared_ptr<long> bizDate{};
  shared_ptr<long> cycTime{};
  shared_ptr<long> finishTime{};
  shared_ptr<long> createTime{};
  shared_ptr<long> dagId{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> beginWaitResTime{};
  shared_ptr<string> taskType{};
  shared_ptr<string> paramValues{};
  shared_ptr<string> dagType{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> beginWaitTimeTime{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> modifyTime{};

  ListManualDagInstancesResponseBodyInstances() {}

  explicit ListManualDagInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (beginRunningTime) {
      res["BeginRunningTime"] = boost::any(*beginRunningTime);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (cycTime) {
      res["CycTime"] = boost::any(*cycTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (beginWaitResTime) {
      res["BeginWaitResTime"] = boost::any(*beginWaitResTime);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (dagType) {
      res["DagType"] = boost::any(*dagType);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (beginWaitTimeTime) {
      res["BeginWaitTimeTime"] = boost::any(*beginWaitTimeTime);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("BeginRunningTime") != m.end() && !m["BeginRunningTime"].empty()) {
      beginRunningTime = make_shared<long>(boost::any_cast<long>(m["BeginRunningTime"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("CycTime") != m.end() && !m["CycTime"].empty()) {
      cycTime = make_shared<long>(boost::any_cast<long>(m["CycTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<long>(boost::any_cast<long>(m["FinishTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("BeginWaitResTime") != m.end() && !m["BeginWaitResTime"].empty()) {
      beginWaitResTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitResTime"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("DagType") != m.end() && !m["DagType"].empty()) {
      dagType = make_shared<string>(boost::any_cast<string>(m["DagType"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("BeginWaitTimeTime") != m.end() && !m["BeginWaitTimeTime"].empty()) {
      beginWaitTimeTime = make_shared<long>(boost::any_cast<long>(m["BeginWaitTimeTime"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
  }


  virtual ~ListManualDagInstancesResponseBodyInstances() = default;
};
class ListManualDagInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListManualDagInstancesResponseBodyInstances>> instances{};

  ListManualDagInstancesResponseBody() {}

  explicit ListManualDagInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListManualDagInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListManualDagInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListManualDagInstancesResponseBodyInstances>>(expect1);
      }
    }
  }


  virtual ~ListManualDagInstancesResponseBody() = default;
};
class ListManualDagInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListManualDagInstancesResponseBody> body{};

  ListManualDagInstancesResponse() {}

  explicit ListManualDagInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListManualDagInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListManualDagInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListManualDagInstancesResponse() = default;
};
class ListMetaDBRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> dataSourceType{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  ListMetaDBRequest() {}

  explicit ListMetaDBRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListMetaDBRequest() = default;
};
class ListMetaDBResponseBodyDatabaseInfoDbList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> createTimeStamp{};
  shared_ptr<string> UUID{};
  shared_ptr<long> modifiedTimeStamp{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> location{};

  ListMetaDBResponseBodyDatabaseInfoDbList() {}

  explicit ListMetaDBResponseBodyDatabaseInfoDbList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (createTimeStamp) {
      res["CreateTimeStamp"] = boost::any(*createTimeStamp);
    }
    if (UUID) {
      res["UUID"] = boost::any(*UUID);
    }
    if (modifiedTimeStamp) {
      res["ModifiedTimeStamp"] = boost::any(*modifiedTimeStamp);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("CreateTimeStamp") != m.end() && !m["CreateTimeStamp"].empty()) {
      createTimeStamp = make_shared<long>(boost::any_cast<long>(m["CreateTimeStamp"]));
    }
    if (m.find("UUID") != m.end() && !m["UUID"].empty()) {
      UUID = make_shared<string>(boost::any_cast<string>(m["UUID"]));
    }
    if (m.find("ModifiedTimeStamp") != m.end() && !m["ModifiedTimeStamp"].empty()) {
      modifiedTimeStamp = make_shared<long>(boost::any_cast<long>(m["ModifiedTimeStamp"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~ListMetaDBResponseBodyDatabaseInfoDbList() = default;
};
class ListMetaDBResponseBodyDatabaseInfo : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListMetaDBResponseBodyDatabaseInfoDbList>> dbList{};

  ListMetaDBResponseBodyDatabaseInfo() {}

  explicit ListMetaDBResponseBodyDatabaseInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dbList) {
      vector<boost::any> temp1;
      for(auto item1:*dbList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DbList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DbList") != m.end() && !m["DbList"].empty()) {
      if (typeid(vector<boost::any>) == m["DbList"].type()) {
        vector<ListMetaDBResponseBodyDatabaseInfoDbList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DbList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMetaDBResponseBodyDatabaseInfoDbList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dbList = make_shared<vector<ListMetaDBResponseBodyDatabaseInfoDbList>>(expect1);
      }
    }
  }


  virtual ~ListMetaDBResponseBodyDatabaseInfo() = default;
};
class ListMetaDBResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMetaDBResponseBodyDatabaseInfo> databaseInfo{};

  ListMetaDBResponseBody() {}

  explicit ListMetaDBResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (databaseInfo) {
      res["DatabaseInfo"] = databaseInfo ? boost::any(databaseInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DatabaseInfo") != m.end() && !m["DatabaseInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatabaseInfo"].type()) {
        ListMetaDBResponseBodyDatabaseInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatabaseInfo"]));
        databaseInfo = make_shared<ListMetaDBResponseBodyDatabaseInfo>(model1);
      }
    }
  }


  virtual ~ListMetaDBResponseBody() = default;
};
class ListMetaDBResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMetaDBResponseBody> body{};

  ListMetaDBResponse() {}

  explicit ListMetaDBResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMetaDBResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMetaDBResponseBody>(model1);
      }
    }
  }


  virtual ~ListMetaDBResponse() = default;
};
class ListNodeInputOrOutputRequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> projectEnv{};
  shared_ptr<string> ioType{};

  ListNodeInputOrOutputRequest() {}

  explicit ListNodeInputOrOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (ioType) {
      res["IoType"] = boost::any(*ioType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("IoType") != m.end() && !m["IoType"].empty()) {
      ioType = make_shared<string>(boost::any_cast<string>(m["IoType"]));
    }
  }


  virtual ~ListNodeInputOrOutputRequest() = default;
};
class ListNodeInputOrOutputResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> data{};
  shared_ptr<long> nodeId{};

  ListNodeInputOrOutputResponseBodyData() {}

  explicit ListNodeInputOrOutputResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListNodeInputOrOutputResponseBodyData() = default;
};
class ListNodeInputOrOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListNodeInputOrOutputResponseBodyData>> data{};

  ListNodeInputOrOutputResponseBody() {}

  explicit ListNodeInputOrOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListNodeInputOrOutputResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeInputOrOutputResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListNodeInputOrOutputResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~ListNodeInputOrOutputResponseBody() = default;
};
class ListNodeInputOrOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListNodeInputOrOutputResponseBody> body{};

  ListNodeInputOrOutputResponse() {}

  explicit ListNodeInputOrOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodeInputOrOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodeInputOrOutputResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodeInputOrOutputResponse() = default;
};
class ListNodeIORequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<string> projectEnv{};
  shared_ptr<string> ioType{};

  ListNodeIORequest() {}

  explicit ListNodeIORequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (ioType) {
      res["IoType"] = boost::any(*ioType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("IoType") != m.end() && !m["IoType"].empty()) {
      ioType = make_shared<string>(boost::any_cast<string>(m["IoType"]));
    }
  }


  virtual ~ListNodeIORequest() = default;
};
class ListNodeIOResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> data{};
  shared_ptr<long> nodeId{};

  ListNodeIOResponseBodyData() {}

  explicit ListNodeIOResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListNodeIOResponseBodyData() = default;
};
class ListNodeIOResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListNodeIOResponseBodyData>> data{};

  ListNodeIOResponseBody() {}

  explicit ListNodeIOResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListNodeIOResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeIOResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListNodeIOResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~ListNodeIOResponseBody() = default;
};
class ListNodeIOResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListNodeIOResponseBody> body{};

  ListNodeIOResponse() {}

  explicit ListNodeIOResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodeIOResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodeIOResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodeIOResponse() = default;
};
class ListNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> bizName{};
  shared_ptr<string> programType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectEnv{};
  shared_ptr<string> nodeName{};

  ListNodesRequest() {}

  explicit ListNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~ListNodesRequest() = default;
};
class ListNodesResponseBodyDataNodes : public Darabonba::Model {
public:
  shared_ptr<string> schedulerType{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<bool> repeatability{};
  shared_ptr<long> projectId{};
  shared_ptr<string> programType{};
  shared_ptr<long> priority{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> connection{};
  shared_ptr<string> paramValues{};
  shared_ptr<long> relatedFlowId{};
  shared_ptr<long> dqcType{};
  shared_ptr<long> baselineId{};
  shared_ptr<string> description{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> resGroupName{};
  shared_ptr<string> dqcDescription{};
  shared_ptr<string> cronExpress{};
  shared_ptr<long> nodeId{};

  ListNodesResponseBodyDataNodes() {}

  explicit ListNodesResponseBodyDataNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (connection) {
      res["Connection"] = boost::any(*connection);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (relatedFlowId) {
      res["RelatedFlowId"] = boost::any(*relatedFlowId);
    }
    if (dqcType) {
      res["DqcType"] = boost::any(*dqcType);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (resGroupName) {
      res["ResGroupName"] = boost::any(*resGroupName);
    }
    if (dqcDescription) {
      res["DqcDescription"] = boost::any(*dqcDescription);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Connection") != m.end() && !m["Connection"].empty()) {
      connection = make_shared<string>(boost::any_cast<string>(m["Connection"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("RelatedFlowId") != m.end() && !m["RelatedFlowId"].empty()) {
      relatedFlowId = make_shared<long>(boost::any_cast<long>(m["RelatedFlowId"]));
    }
    if (m.find("DqcType") != m.end() && !m["DqcType"].empty()) {
      dqcType = make_shared<long>(boost::any_cast<long>(m["DqcType"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ResGroupName") != m.end() && !m["ResGroupName"].empty()) {
      resGroupName = make_shared<string>(boost::any_cast<string>(m["ResGroupName"]));
    }
    if (m.find("DqcDescription") != m.end() && !m["DqcDescription"].empty()) {
      dqcDescription = make_shared<string>(boost::any_cast<string>(m["DqcDescription"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListNodesResponseBodyDataNodes() = default;
};
class ListNodesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListNodesResponseBodyDataNodes>> nodes{};

  ListNodesResponseBodyData() {}

  explicit ListNodesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<ListNodesResponseBodyDataNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyDataNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<ListNodesResponseBodyDataNodes>>(expect1);
      }
    }
  }


  virtual ~ListNodesResponseBodyData() = default;
};
class ListNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListNodesResponseBodyData> data{};

  ListNodesResponseBody() {}

  explicit ListNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListNodesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListNodesResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListNodesResponseBody() = default;
};
class ListNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListNodesResponseBody> body{};

  ListNodesResponse() {}

  explicit ListNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodesResponse() = default;
};
class ListNodesByBaselineRequest : public Darabonba::Model {
public:
  shared_ptr<long> baselineId{};

  ListNodesByBaselineRequest() {}

  explicit ListNodesByBaselineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
  }


  virtual ~ListNodesByBaselineRequest() = default;
};
class ListNodesByBaselineResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> projectId{};

  ListNodesByBaselineResponseBodyData() {}

  explicit ListNodesByBaselineResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListNodesByBaselineResponseBodyData() = default;
};
class ListNodesByBaselineResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> success{};
  shared_ptr<vector<ListNodesByBaselineResponseBodyData>> data{};

  ListNodesByBaselineResponseBody() {}

  explicit ListNodesByBaselineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListNodesByBaselineResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesByBaselineResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListNodesByBaselineResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~ListNodesByBaselineResponseBody() = default;
};
class ListNodesByBaselineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListNodesByBaselineResponseBody> body{};

  ListNodesByBaselineResponse() {}

  explicit ListNodesByBaselineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodesByBaselineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodesByBaselineResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodesByBaselineResponse() = default;
};
class ListNodesByOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> outputs{};

  ListNodesByOutputRequest() {}

  explicit ListNodesByOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (outputs) {
      res["Outputs"] = boost::any(*outputs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
  }


  virtual ~ListNodesByOutputRequest() = default;
};
class ListNodesByOutputResponseBodyDataNodeList : public Darabonba::Model {
public:
  shared_ptr<string> schedulerType{};
  shared_ptr<long> repeatInterval{};
  shared_ptr<bool> repeatability{};
  shared_ptr<string> fileType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> programType{};
  shared_ptr<long> priority{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> connection{};
  shared_ptr<string> paramValues{};
  shared_ptr<long> relatedFlowId{};
  shared_ptr<long> dqcType{};
  shared_ptr<long> baselineId{};
  shared_ptr<string> description{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> resGroupName{};
  shared_ptr<string> dqcDescription{};
  shared_ptr<string> cronExpress{};
  shared_ptr<long> nodeId{};

  ListNodesByOutputResponseBodyDataNodeList() {}

  explicit ListNodesByOutputResponseBodyDataNodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    if (repeatInterval) {
      res["RepeatInterval"] = boost::any(*repeatInterval);
    }
    if (repeatability) {
      res["Repeatability"] = boost::any(*repeatability);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (connection) {
      res["Connection"] = boost::any(*connection);
    }
    if (paramValues) {
      res["ParamValues"] = boost::any(*paramValues);
    }
    if (relatedFlowId) {
      res["RelatedFlowId"] = boost::any(*relatedFlowId);
    }
    if (dqcType) {
      res["DqcType"] = boost::any(*dqcType);
    }
    if (baselineId) {
      res["BaselineId"] = boost::any(*baselineId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (resGroupName) {
      res["ResGroupName"] = boost::any(*resGroupName);
    }
    if (dqcDescription) {
      res["DqcDescription"] = boost::any(*dqcDescription);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<string>(boost::any_cast<string>(m["SchedulerType"]));
    }
    if (m.find("RepeatInterval") != m.end() && !m["RepeatInterval"].empty()) {
      repeatInterval = make_shared<long>(boost::any_cast<long>(m["RepeatInterval"]));
    }
    if (m.find("Repeatability") != m.end() && !m["Repeatability"].empty()) {
      repeatability = make_shared<bool>(boost::any_cast<bool>(m["Repeatability"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Connection") != m.end() && !m["Connection"].empty()) {
      connection = make_shared<string>(boost::any_cast<string>(m["Connection"]));
    }
    if (m.find("ParamValues") != m.end() && !m["ParamValues"].empty()) {
      paramValues = make_shared<string>(boost::any_cast<string>(m["ParamValues"]));
    }
    if (m.find("RelatedFlowId") != m.end() && !m["RelatedFlowId"].empty()) {
      relatedFlowId = make_shared<long>(boost::any_cast<long>(m["RelatedFlowId"]));
    }
    if (m.find("DqcType") != m.end() && !m["DqcType"].empty()) {
      dqcType = make_shared<long>(boost::any_cast<long>(m["DqcType"]));
    }
    if (m.find("BaselineId") != m.end() && !m["BaselineId"].empty()) {
      baselineId = make_shared<long>(boost::any_cast<long>(m["BaselineId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ResGroupName") != m.end() && !m["ResGroupName"].empty()) {
      resGroupName = make_shared<string>(boost::any_cast<string>(m["ResGroupName"]));
    }
    if (m.find("DqcDescription") != m.end() && !m["DqcDescription"].empty()) {
      dqcDescription = make_shared<string>(boost::any_cast<string>(m["DqcDescription"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListNodesByOutputResponseBodyDataNodeList() = default;
};
class ListNodesByOutputResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> output{};
  shared_ptr<vector<ListNodesByOutputResponseBodyDataNodeList>> nodeList{};

  ListNodesByOutputResponseBodyData() {}

  explicit ListNodesByOutputResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (nodeList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("NodeList") != m.end() && !m["NodeList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeList"].type()) {
        vector<ListNodesByOutputResponseBodyDataNodeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesByOutputResponseBodyDataNodeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeList = make_shared<vector<ListNodesByOutputResponseBodyDataNodeList>>(expect1);
      }
    }
  }


  virtual ~ListNodesByOutputResponseBodyData() = default;
};
class ListNodesByOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListNodesByOutputResponseBodyData>> data{};

  ListNodesByOutputResponseBody() {}

  explicit ListNodesByOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListNodesByOutputResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesByOutputResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListNodesByOutputResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~ListNodesByOutputResponseBody() = default;
};
class ListNodesByOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListNodesByOutputResponseBody> body{};

  ListNodesByOutputResponse() {}

  explicit ListNodesByOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodesByOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodesByOutputResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodesByOutputResponse() = default;
};
class ListPermissionApplyOrdersRequest : public Darabonba::Model {
public:
  shared_ptr<long> flowStatus{};
  shared_ptr<long> workspaceId{};
  shared_ptr<long> orderType{};
  shared_ptr<string> maxComputeProjectName{};
  shared_ptr<string> tableName{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> engineType{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> queryType{};

  ListPermissionApplyOrdersRequest() {}

  explicit ListPermissionApplyOrdersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowStatus) {
      res["FlowStatus"] = boost::any(*flowStatus);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (maxComputeProjectName) {
      res["MaxComputeProjectName"] = boost::any(*maxComputeProjectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (engineType) {
      res["EngineType"] = boost::any(*engineType);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowStatus") != m.end() && !m["FlowStatus"].empty()) {
      flowStatus = make_shared<long>(boost::any_cast<long>(m["FlowStatus"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<long>(boost::any_cast<long>(m["WorkspaceId"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<long>(boost::any_cast<long>(m["OrderType"]));
    }
    if (m.find("MaxComputeProjectName") != m.end() && !m["MaxComputeProjectName"].empty()) {
      maxComputeProjectName = make_shared<string>(boost::any_cast<string>(m["MaxComputeProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EngineType") != m.end() && !m["EngineType"].empty()) {
      engineType = make_shared<string>(boost::any_cast<string>(m["EngineType"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<long>(boost::any_cast<long>(m["QueryType"]));
    }
  }


  virtual ~ListPermissionApplyOrdersRequest() = default;
};
class ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList : public Darabonba::Model {
public:
  shared_ptr<string> objectName{};
  shared_ptr<vector<string>> actions{};

  ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList() {}

  explicit ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (actions) {
      res["Actions"] = boost::any(*actions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Actions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Actions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      actions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList() = default;
};
class ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta : public Darabonba::Model {
public:
  shared_ptr<string> workspaceName{};
  shared_ptr<vector<ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList>> objectMetaList{};

  ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta() {}

  explicit ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workspaceName) {
      res["WorkspaceName"] = boost::any(*workspaceName);
    }
    if (objectMetaList) {
      vector<boost::any> temp1;
      for(auto item1:*objectMetaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ObjectMetaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkspaceName") != m.end() && !m["WorkspaceName"].empty()) {
      workspaceName = make_shared<string>(boost::any_cast<string>(m["WorkspaceName"]));
    }
    if (m.find("ObjectMetaList") != m.end() && !m["ObjectMetaList"].empty()) {
      if (typeid(vector<boost::any>) == m["ObjectMetaList"].type()) {
        vector<ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ObjectMetaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        objectMetaList = make_shared<vector<ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList>>(expect1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta() = default;
};
class ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent : public Darabonba::Model {
public:
  shared_ptr<string> applyReason{};
  shared_ptr<long> orderType{};
  shared_ptr<ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta> projectMeta{};

  ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent() {}

  explicit ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyReason) {
      res["ApplyReason"] = boost::any(*applyReason);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (projectMeta) {
      res["ProjectMeta"] = projectMeta ? boost::any(projectMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyReason") != m.end() && !m["ApplyReason"].empty()) {
      applyReason = make_shared<string>(boost::any_cast<string>(m["ApplyReason"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<long>(boost::any_cast<long>(m["OrderType"]));
    }
    if (m.find("ProjectMeta") != m.end() && !m["ProjectMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectMeta"].type()) {
        ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectMeta"]));
        projectMeta = make_shared<ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta>(model1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent() = default;
};
class ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder : public Darabonba::Model {
public:
  shared_ptr<string> applyBaseId{};
  shared_ptr<long> applyTimestamp{};
  shared_ptr<string> flowId{};
  shared_ptr<long> flowStatus{};
  shared_ptr<ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent> approveContent{};

  ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder() {}

  explicit ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyBaseId) {
      res["ApplyBaseId"] = boost::any(*applyBaseId);
    }
    if (applyTimestamp) {
      res["ApplyTimestamp"] = boost::any(*applyTimestamp);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowStatus) {
      res["FlowStatus"] = boost::any(*flowStatus);
    }
    if (approveContent) {
      res["ApproveContent"] = approveContent ? boost::any(approveContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyBaseId") != m.end() && !m["ApplyBaseId"].empty()) {
      applyBaseId = make_shared<string>(boost::any_cast<string>(m["ApplyBaseId"]));
    }
    if (m.find("ApplyTimestamp") != m.end() && !m["ApplyTimestamp"].empty()) {
      applyTimestamp = make_shared<long>(boost::any_cast<long>(m["ApplyTimestamp"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowStatus") != m.end() && !m["FlowStatus"].empty()) {
      flowStatus = make_shared<long>(boost::any_cast<long>(m["FlowStatus"]));
    }
    if (m.find("ApproveContent") != m.end() && !m["ApproveContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApproveContent"].type()) {
        ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApproveContent"]));
        approveContent = make_shared<ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent>(model1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder() = default;
};
class ListPermissionApplyOrdersResponseBodyApplyOrders : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder>> applyOrder{};

  ListPermissionApplyOrdersResponseBodyApplyOrders() {}

  explicit ListPermissionApplyOrdersResponseBodyApplyOrders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (applyOrder) {
      vector<boost::any> temp1;
      for(auto item1:*applyOrder){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyOrder"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ApplyOrder") != m.end() && !m["ApplyOrder"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyOrder"].type()) {
        vector<ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyOrder"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyOrder = make_shared<vector<ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder>>(expect1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponseBodyApplyOrders() = default;
};
class ListPermissionApplyOrdersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListPermissionApplyOrdersResponseBodyApplyOrders> applyOrders{};

  ListPermissionApplyOrdersResponseBody() {}

  explicit ListPermissionApplyOrdersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (applyOrders) {
      res["ApplyOrders"] = applyOrders ? boost::any(applyOrders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ApplyOrders") != m.end() && !m["ApplyOrders"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplyOrders"].type()) {
        ListPermissionApplyOrdersResponseBodyApplyOrders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplyOrders"]));
        applyOrders = make_shared<ListPermissionApplyOrdersResponseBodyApplyOrders>(model1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponseBody() = default;
};
class ListPermissionApplyOrdersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListPermissionApplyOrdersResponseBody> body{};

  ListPermissionApplyOrdersResponse() {}

  explicit ListPermissionApplyOrdersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPermissionApplyOrdersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPermissionApplyOrdersResponseBody>(model1);
      }
    }
  }


  virtual ~ListPermissionApplyOrdersResponse() = default;
};
class ListProgramTypeCountRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectEnv{};

  ListProgramTypeCountRequest() {}

  explicit ListProgramTypeCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~ListProgramTypeCountRequest() = default;
};
class ListProgramTypeCountResponseBodyProgramTypeAndCounts : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> programType{};

  ListProgramTypeCountResponseBodyProgramTypeAndCounts() {}

  explicit ListProgramTypeCountResponseBodyProgramTypeAndCounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<string>(boost::any_cast<string>(m["ProgramType"]));
    }
  }


  virtual ~ListProgramTypeCountResponseBodyProgramTypeAndCounts() = default;
};
class ListProgramTypeCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListProgramTypeCountResponseBodyProgramTypeAndCounts>> programTypeAndCounts{};

  ListProgramTypeCountResponseBody() {}

  explicit ListProgramTypeCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (programTypeAndCounts) {
      vector<boost::any> temp1;
      for(auto item1:*programTypeAndCounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProgramTypeAndCounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProgramTypeAndCounts") != m.end() && !m["ProgramTypeAndCounts"].empty()) {
      if (typeid(vector<boost::any>) == m["ProgramTypeAndCounts"].type()) {
        vector<ListProgramTypeCountResponseBodyProgramTypeAndCounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProgramTypeAndCounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProgramTypeCountResponseBodyProgramTypeAndCounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programTypeAndCounts = make_shared<vector<ListProgramTypeCountResponseBodyProgramTypeAndCounts>>(expect1);
      }
    }
  }


  virtual ~ListProgramTypeCountResponseBody() = default;
};
class ListProgramTypeCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListProgramTypeCountResponseBody> body{};

  ListProgramTypeCountResponse() {}

  explicit ListProgramTypeCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProgramTypeCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProgramTypeCountResponseBody>(model1);
      }
    }
  }


  virtual ~ListProgramTypeCountResponse() = default;
};
class ListProjectMembersRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListProjectMembersRequest() {}

  explicit ListProjectMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListProjectMembersRequest() = default;
};
class ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList : public Darabonba::Model {
public:
  shared_ptr<long> projectRoleId{};
  shared_ptr<string> projectRoleType{};
  shared_ptr<string> projectRoleName{};
  shared_ptr<string> projectRoleCode{};

  ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList() {}

  explicit ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectRoleId) {
      res["ProjectRoleId"] = boost::any(*projectRoleId);
    }
    if (projectRoleType) {
      res["ProjectRoleType"] = boost::any(*projectRoleType);
    }
    if (projectRoleName) {
      res["ProjectRoleName"] = boost::any(*projectRoleName);
    }
    if (projectRoleCode) {
      res["ProjectRoleCode"] = boost::any(*projectRoleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectRoleId") != m.end() && !m["ProjectRoleId"].empty()) {
      projectRoleId = make_shared<long>(boost::any_cast<long>(m["ProjectRoleId"]));
    }
    if (m.find("ProjectRoleType") != m.end() && !m["ProjectRoleType"].empty()) {
      projectRoleType = make_shared<string>(boost::any_cast<string>(m["ProjectRoleType"]));
    }
    if (m.find("ProjectRoleName") != m.end() && !m["ProjectRoleName"].empty()) {
      projectRoleName = make_shared<string>(boost::any_cast<string>(m["ProjectRoleName"]));
    }
    if (m.find("ProjectRoleCode") != m.end() && !m["ProjectRoleCode"].empty()) {
      projectRoleCode = make_shared<string>(boost::any_cast<string>(m["ProjectRoleCode"]));
    }
  }


  virtual ~ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList() = default;
};
class ListProjectMembersResponseBodyDataProjectMemberList : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> projectMemberId{};
  shared_ptr<string> nick{};
  shared_ptr<string> projectMemberName{};
  shared_ptr<string> projectMemberType{};
  shared_ptr<vector<ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList>> projectRoleList{};

  ListProjectMembersResponseBodyDataProjectMemberList() {}

  explicit ListProjectMembersResponseBodyDataProjectMemberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (projectMemberId) {
      res["ProjectMemberId"] = boost::any(*projectMemberId);
    }
    if (nick) {
      res["Nick"] = boost::any(*nick);
    }
    if (projectMemberName) {
      res["ProjectMemberName"] = boost::any(*projectMemberName);
    }
    if (projectMemberType) {
      res["ProjectMemberType"] = boost::any(*projectMemberType);
    }
    if (projectRoleList) {
      vector<boost::any> temp1;
      for(auto item1:*projectRoleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectRoleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProjectMemberId") != m.end() && !m["ProjectMemberId"].empty()) {
      projectMemberId = make_shared<string>(boost::any_cast<string>(m["ProjectMemberId"]));
    }
    if (m.find("Nick") != m.end() && !m["Nick"].empty()) {
      nick = make_shared<string>(boost::any_cast<string>(m["Nick"]));
    }
    if (m.find("ProjectMemberName") != m.end() && !m["ProjectMemberName"].empty()) {
      projectMemberName = make_shared<string>(boost::any_cast<string>(m["ProjectMemberName"]));
    }
    if (m.find("ProjectMemberType") != m.end() && !m["ProjectMemberType"].empty()) {
      projectMemberType = make_shared<string>(boost::any_cast<string>(m["ProjectMemberType"]));
    }
    if (m.find("ProjectRoleList") != m.end() && !m["ProjectRoleList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectRoleList"].type()) {
        vector<ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectRoleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectRoleList = make_shared<vector<ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList>>(expect1);
      }
    }
  }


  virtual ~ListProjectMembersResponseBodyDataProjectMemberList() = default;
};
class ListProjectMembersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListProjectMembersResponseBodyDataProjectMemberList>> projectMemberList{};

  ListProjectMembersResponseBodyData() {}

  explicit ListProjectMembersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (projectMemberList) {
      vector<boost::any> temp1;
      for(auto item1:*projectMemberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectMemberList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ProjectMemberList") != m.end() && !m["ProjectMemberList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectMemberList"].type()) {
        vector<ListProjectMembersResponseBodyDataProjectMemberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectMemberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectMembersResponseBodyDataProjectMemberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectMemberList = make_shared<vector<ListProjectMembersResponseBodyDataProjectMemberList>>(expect1);
      }
    }
  }


  virtual ~ListProjectMembersResponseBodyData() = default;
};
class ListProjectMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListProjectMembersResponseBodyData> data{};

  ListProjectMembersResponseBody() {}

  explicit ListProjectMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListProjectMembersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListProjectMembersResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListProjectMembersResponseBody() = default;
};
class ListProjectMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListProjectMembersResponseBody> body{};

  ListProjectMembersResponse() {}

  explicit ListProjectMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectMembersResponse() = default;
};
class ListProjectRolesRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  ListProjectRolesRequest() {}

  explicit ListProjectRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListProjectRolesRequest() = default;
};
class ListProjectRolesResponseBodyProjectRoleList : public Darabonba::Model {
public:
  shared_ptr<long> projectRoleId{};
  shared_ptr<string> projectRoleType{};
  shared_ptr<string> projectRoleName{};
  shared_ptr<string> projectRoleCode{};

  ListProjectRolesResponseBodyProjectRoleList() {}

  explicit ListProjectRolesResponseBodyProjectRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectRoleId) {
      res["ProjectRoleId"] = boost::any(*projectRoleId);
    }
    if (projectRoleType) {
      res["ProjectRoleType"] = boost::any(*projectRoleType);
    }
    if (projectRoleName) {
      res["ProjectRoleName"] = boost::any(*projectRoleName);
    }
    if (projectRoleCode) {
      res["ProjectRoleCode"] = boost::any(*projectRoleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectRoleId") != m.end() && !m["ProjectRoleId"].empty()) {
      projectRoleId = make_shared<long>(boost::any_cast<long>(m["ProjectRoleId"]));
    }
    if (m.find("ProjectRoleType") != m.end() && !m["ProjectRoleType"].empty()) {
      projectRoleType = make_shared<string>(boost::any_cast<string>(m["ProjectRoleType"]));
    }
    if (m.find("ProjectRoleName") != m.end() && !m["ProjectRoleName"].empty()) {
      projectRoleName = make_shared<string>(boost::any_cast<string>(m["ProjectRoleName"]));
    }
    if (m.find("ProjectRoleCode") != m.end() && !m["ProjectRoleCode"].empty()) {
      projectRoleCode = make_shared<string>(boost::any_cast<string>(m["ProjectRoleCode"]));
    }
  }


  virtual ~ListProjectRolesResponseBodyProjectRoleList() = default;
};
class ListProjectRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListProjectRolesResponseBodyProjectRoleList>> projectRoleList{};

  ListProjectRolesResponseBody() {}

  explicit ListProjectRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (projectRoleList) {
      vector<boost::any> temp1;
      for(auto item1:*projectRoleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectRoleList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProjectRoleList") != m.end() && !m["ProjectRoleList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectRoleList"].type()) {
        vector<ListProjectRolesResponseBodyProjectRoleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectRoleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectRolesResponseBodyProjectRoleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectRoleList = make_shared<vector<ListProjectRolesResponseBodyProjectRoleList>>(expect1);
      }
    }
  }


  virtual ~ListProjectRolesResponseBody() = default;
};
class ListProjectRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListProjectRolesResponseBody> body{};

  ListProjectRolesResponse() {}

  explicit ListProjectRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectRolesResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectRolesResponse() = default;
};
class ListProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListProjectsRequest() {}

  explicit ListProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListProjectsRequest() = default;
};
class ListProjectsResponseBodyPageResultProjectList : public Darabonba::Model {
public:
  shared_ptr<string> projectStatusCode{};
  shared_ptr<long> projectStatus{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectOwnerBaseId{};

  ListProjectsResponseBodyPageResultProjectList() {}

  explicit ListProjectsResponseBodyPageResultProjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectStatusCode) {
      res["ProjectStatusCode"] = boost::any(*projectStatusCode);
    }
    if (projectStatus) {
      res["ProjectStatus"] = boost::any(*projectStatus);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectOwnerBaseId) {
      res["ProjectOwnerBaseId"] = boost::any(*projectOwnerBaseId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectStatusCode") != m.end() && !m["ProjectStatusCode"].empty()) {
      projectStatusCode = make_shared<string>(boost::any_cast<string>(m["ProjectStatusCode"]));
    }
    if (m.find("ProjectStatus") != m.end() && !m["ProjectStatus"].empty()) {
      projectStatus = make_shared<long>(boost::any_cast<long>(m["ProjectStatus"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectOwnerBaseId") != m.end() && !m["ProjectOwnerBaseId"].empty()) {
      projectOwnerBaseId = make_shared<string>(boost::any_cast<string>(m["ProjectOwnerBaseId"]));
    }
  }


  virtual ~ListProjectsResponseBodyPageResultProjectList() = default;
};
class ListProjectsResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListProjectsResponseBodyPageResultProjectList>> projectList{};

  ListProjectsResponseBodyPageResult() {}

  explicit ListProjectsResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (projectList) {
      vector<boost::any> temp1;
      for(auto item1:*projectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ProjectList") != m.end() && !m["ProjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectList"].type()) {
        vector<ListProjectsResponseBodyPageResultProjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyPageResultProjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectList = make_shared<vector<ListProjectsResponseBodyPageResultProjectList>>(expect1);
      }
    }
  }


  virtual ~ListProjectsResponseBodyPageResult() = default;
};
class ListProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListProjectsResponseBodyPageResult> pageResult{};

  ListProjectsResponseBody() {}

  explicit ListProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListProjectsResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListProjectsResponseBodyPageResult>(model1);
      }
    }
  }


  virtual ~ListProjectsResponseBody() = default;
};
class ListProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListProjectsResponseBody> body{};

  ListProjectsResponse() {}

  explicit ListProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectsResponse() = default;
};
class ListQualityResultsByEntityRequest : public Darabonba::Model {
public:
  shared_ptr<long> entityId{};
  shared_ptr<string> startDate{};
  shared_ptr<string> endDate{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> projectName{};

  ListQualityResultsByEntityRequest() {}

  explicit ListQualityResultsByEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ListQualityResultsByEntityRequest() = default;
};
class ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue : public Darabonba::Model {
public:
  shared_ptr<string> discreteProperty{};
  shared_ptr<double> value{};
  shared_ptr<string> bizDate{};
  shared_ptr<long> singleCheckResult{};
  shared_ptr<double> threshold{};

  ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue() {}

  explicit ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discreteProperty) {
      res["DiscreteProperty"] = boost::any(*discreteProperty);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (singleCheckResult) {
      res["SingleCheckResult"] = boost::any(*singleCheckResult);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscreteProperty") != m.end() && !m["DiscreteProperty"].empty()) {
      discreteProperty = make_shared<string>(boost::any_cast<string>(m["DiscreteProperty"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("SingleCheckResult") != m.end() && !m["SingleCheckResult"].empty()) {
      singleCheckResult = make_shared<long>(boost::any_cast<long>(m["SingleCheckResult"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue() = default;
};
class ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue : public Darabonba::Model {
public:
  shared_ptr<string> discreteProperty{};
  shared_ptr<string> bizDate{};
  shared_ptr<double> value{};

  ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue() {}

  explicit ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discreteProperty) {
      res["DiscreteProperty"] = boost::any(*discreteProperty);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscreteProperty") != m.end() && !m["DiscreteProperty"].empty()) {
      discreteProperty = make_shared<string>(boost::any_cast<string>(m["DiscreteProperty"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue() = default;
};
class ListQualityResultsByEntityResponseBodyDataRuleChecks : public Darabonba::Model {
public:
  shared_ptr<long> blockType{};
  shared_ptr<double> warningThreshold{};
  shared_ptr<string> property{};
  shared_ptr<string> tableName{};
  shared_ptr<string> comment{};
  shared_ptr<long> checkResultStatus{};
  shared_ptr<string> templateName{};
  shared_ptr<string> checkerName{};
  shared_ptr<long> ruleId{};
  shared_ptr<bool> fixedCheck{};
  shared_ptr<string> op{};
  shared_ptr<double> upperValue{};
  shared_ptr<string> actualExpression{};
  shared_ptr<string> externalId{};
  shared_ptr<string> timeCost{};
  shared_ptr<string> trend{};
  shared_ptr<string> externalType{};
  shared_ptr<long> bizDate{};
  shared_ptr<long> checkResult{};
  shared_ptr<string> resultString{};
  shared_ptr<string> matchExpression{};
  shared_ptr<long> checkerType{};
  shared_ptr<string> projectName{};
  shared_ptr<long> beginTime{};
  shared_ptr<string> dateType{};
  shared_ptr<double> criticalThreshold{};
  shared_ptr<bool> isPrediction{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> checkerId{};
  shared_ptr<bool> discreteCheck{};
  shared_ptr<long> endTime{};
  shared_ptr<string> methodName{};
  shared_ptr<double> lowerValue{};
  shared_ptr<long> entityId{};
  shared_ptr<string> whereCondition{};
  shared_ptr<double> expectValue{};
  shared_ptr<long> templateId{};
  shared_ptr<string> taskId{};
  shared_ptr<long> id{};
  shared_ptr<vector<ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue>> referenceValue{};
  shared_ptr<vector<ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue>> sampleValue{};

  ListQualityResultsByEntityResponseBodyDataRuleChecks() {}

  explicit ListQualityResultsByEntityResponseBodyDataRuleChecks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (checkResultStatus) {
      res["CheckResultStatus"] = boost::any(*checkResultStatus);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (checkerName) {
      res["CheckerName"] = boost::any(*checkerName);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (fixedCheck) {
      res["FixedCheck"] = boost::any(*fixedCheck);
    }
    if (op) {
      res["Op"] = boost::any(*op);
    }
    if (upperValue) {
      res["UpperValue"] = boost::any(*upperValue);
    }
    if (actualExpression) {
      res["ActualExpression"] = boost::any(*actualExpression);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (externalType) {
      res["ExternalType"] = boost::any(*externalType);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (resultString) {
      res["ResultString"] = boost::any(*resultString);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (checkerType) {
      res["CheckerType"] = boost::any(*checkerType);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (dateType) {
      res["DateType"] = boost::any(*dateType);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (isPrediction) {
      res["IsPrediction"] = boost::any(*isPrediction);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (checkerId) {
      res["CheckerId"] = boost::any(*checkerId);
    }
    if (discreteCheck) {
      res["DiscreteCheck"] = boost::any(*discreteCheck);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (lowerValue) {
      res["LowerValue"] = boost::any(*lowerValue);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (whereCondition) {
      res["WhereCondition"] = boost::any(*whereCondition);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (referenceValue) {
      vector<boost::any> temp1;
      for(auto item1:*referenceValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReferenceValue"] = boost::any(temp1);
    }
    if (sampleValue) {
      vector<boost::any> temp1;
      for(auto item1:*sampleValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SampleValue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<long>(boost::any_cast<long>(m["BlockType"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<double>(boost::any_cast<double>(m["WarningThreshold"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CheckResultStatus") != m.end() && !m["CheckResultStatus"].empty()) {
      checkResultStatus = make_shared<long>(boost::any_cast<long>(m["CheckResultStatus"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("CheckerName") != m.end() && !m["CheckerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["CheckerName"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("FixedCheck") != m.end() && !m["FixedCheck"].empty()) {
      fixedCheck = make_shared<bool>(boost::any_cast<bool>(m["FixedCheck"]));
    }
    if (m.find("Op") != m.end() && !m["Op"].empty()) {
      op = make_shared<string>(boost::any_cast<string>(m["Op"]));
    }
    if (m.find("UpperValue") != m.end() && !m["UpperValue"].empty()) {
      upperValue = make_shared<double>(boost::any_cast<double>(m["UpperValue"]));
    }
    if (m.find("ActualExpression") != m.end() && !m["ActualExpression"].empty()) {
      actualExpression = make_shared<string>(boost::any_cast<string>(m["ActualExpression"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<string>(boost::any_cast<string>(m["TimeCost"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("ExternalType") != m.end() && !m["ExternalType"].empty()) {
      externalType = make_shared<string>(boost::any_cast<string>(m["ExternalType"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<long>(boost::any_cast<long>(m["CheckResult"]));
    }
    if (m.find("ResultString") != m.end() && !m["ResultString"].empty()) {
      resultString = make_shared<string>(boost::any_cast<string>(m["ResultString"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("CheckerType") != m.end() && !m["CheckerType"].empty()) {
      checkerType = make_shared<long>(boost::any_cast<long>(m["CheckerType"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("DateType") != m.end() && !m["DateType"].empty()) {
      dateType = make_shared<string>(boost::any_cast<string>(m["DateType"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<double>(boost::any_cast<double>(m["CriticalThreshold"]));
    }
    if (m.find("IsPrediction") != m.end() && !m["IsPrediction"].empty()) {
      isPrediction = make_shared<bool>(boost::any_cast<bool>(m["IsPrediction"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("CheckerId") != m.end() && !m["CheckerId"].empty()) {
      checkerId = make_shared<long>(boost::any_cast<long>(m["CheckerId"]));
    }
    if (m.find("DiscreteCheck") != m.end() && !m["DiscreteCheck"].empty()) {
      discreteCheck = make_shared<bool>(boost::any_cast<bool>(m["DiscreteCheck"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("LowerValue") != m.end() && !m["LowerValue"].empty()) {
      lowerValue = make_shared<double>(boost::any_cast<double>(m["LowerValue"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("WhereCondition") != m.end() && !m["WhereCondition"].empty()) {
      whereCondition = make_shared<string>(boost::any_cast<string>(m["WhereCondition"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<double>(boost::any_cast<double>(m["ExpectValue"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ReferenceValue") != m.end() && !m["ReferenceValue"].empty()) {
      if (typeid(vector<boost::any>) == m["ReferenceValue"].type()) {
        vector<ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReferenceValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        referenceValue = make_shared<vector<ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue>>(expect1);
      }
    }
    if (m.find("SampleValue") != m.end() && !m["SampleValue"].empty()) {
      if (typeid(vector<boost::any>) == m["SampleValue"].type()) {
        vector<ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SampleValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sampleValue = make_shared<vector<ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue>>(expect1);
      }
    }
  }


  virtual ~ListQualityResultsByEntityResponseBodyDataRuleChecks() = default;
};
class ListQualityResultsByEntityResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListQualityResultsByEntityResponseBodyDataRuleChecks>> ruleChecks{};

  ListQualityResultsByEntityResponseBodyData() {}

  explicit ListQualityResultsByEntityResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (ruleChecks) {
      vector<boost::any> temp1;
      for(auto item1:*ruleChecks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleChecks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RuleChecks") != m.end() && !m["RuleChecks"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleChecks"].type()) {
        vector<ListQualityResultsByEntityResponseBodyDataRuleChecks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleChecks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByEntityResponseBodyDataRuleChecks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleChecks = make_shared<vector<ListQualityResultsByEntityResponseBodyDataRuleChecks>>(expect1);
      }
    }
  }


  virtual ~ListQualityResultsByEntityResponseBodyData() = default;
};
class ListQualityResultsByEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<ListQualityResultsByEntityResponseBodyData> data{};

  ListQualityResultsByEntityResponseBody() {}

  explicit ListQualityResultsByEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListQualityResultsByEntityResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListQualityResultsByEntityResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListQualityResultsByEntityResponseBody() = default;
};
class ListQualityResultsByEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListQualityResultsByEntityResponseBody> body{};

  ListQualityResultsByEntityResponse() {}

  explicit ListQualityResultsByEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListQualityResultsByEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListQualityResultsByEntityResponseBody>(model1);
      }
    }
  }


  virtual ~ListQualityResultsByEntityResponse() = default;
};
class ListQualityResultsByRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};
  shared_ptr<string> startDate{};
  shared_ptr<string> endDate{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> projectName{};

  ListQualityResultsByRuleRequest() {}

  explicit ListQualityResultsByRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ListQualityResultsByRuleRequest() = default;
};
class ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue : public Darabonba::Model {
public:
  shared_ptr<string> discreteProperty{};
  shared_ptr<double> value{};
  shared_ptr<string> bizDate{};
  shared_ptr<long> singleCheckResult{};
  shared_ptr<double> threshold{};

  ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue() {}

  explicit ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discreteProperty) {
      res["DiscreteProperty"] = boost::any(*discreteProperty);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (singleCheckResult) {
      res["SingleCheckResult"] = boost::any(*singleCheckResult);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscreteProperty") != m.end() && !m["DiscreteProperty"].empty()) {
      discreteProperty = make_shared<string>(boost::any_cast<string>(m["DiscreteProperty"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("SingleCheckResult") != m.end() && !m["SingleCheckResult"].empty()) {
      singleCheckResult = make_shared<long>(boost::any_cast<long>(m["SingleCheckResult"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue() = default;
};
class ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue : public Darabonba::Model {
public:
  shared_ptr<string> discreteProperty{};
  shared_ptr<string> bizDate{};
  shared_ptr<double> value{};

  ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue() {}

  explicit ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discreteProperty) {
      res["DiscreteProperty"] = boost::any(*discreteProperty);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscreteProperty") != m.end() && !m["DiscreteProperty"].empty()) {
      discreteProperty = make_shared<string>(boost::any_cast<string>(m["DiscreteProperty"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue() = default;
};
class ListQualityResultsByRuleResponseBodyDataRuleChecks : public Darabonba::Model {
public:
  shared_ptr<long> blockType{};
  shared_ptr<double> warningThreshold{};
  shared_ptr<string> property{};
  shared_ptr<string> tableName{};
  shared_ptr<string> comment{};
  shared_ptr<long> checkResultStatus{};
  shared_ptr<string> templateName{};
  shared_ptr<string> checkerName{};
  shared_ptr<long> ruleId{};
  shared_ptr<bool> fixedCheck{};
  shared_ptr<string> op{};
  shared_ptr<double> upperValue{};
  shared_ptr<string> actualExpression{};
  shared_ptr<string> externalId{};
  shared_ptr<string> timeCost{};
  shared_ptr<string> trend{};
  shared_ptr<string> externalType{};
  shared_ptr<long> bizDate{};
  shared_ptr<long> checkResult{};
  shared_ptr<string> resultString{};
  shared_ptr<string> matchExpression{};
  shared_ptr<long> checkerType{};
  shared_ptr<string> projectName{};
  shared_ptr<long> beginTime{};
  shared_ptr<string> dateType{};
  shared_ptr<double> criticalThreshold{};
  shared_ptr<bool> isPrediction{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> checkerId{};
  shared_ptr<bool> discreteCheck{};
  shared_ptr<long> endTime{};
  shared_ptr<string> methodName{};
  shared_ptr<double> lowerValue{};
  shared_ptr<long> entityId{};
  shared_ptr<string> whereCondition{};
  shared_ptr<double> expectValue{};
  shared_ptr<long> templateId{};
  shared_ptr<string> taskId{};
  shared_ptr<long> id{};
  shared_ptr<vector<ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue>> referenceValue{};
  shared_ptr<vector<ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue>> sampleValue{};

  ListQualityResultsByRuleResponseBodyDataRuleChecks() {}

  explicit ListQualityResultsByRuleResponseBodyDataRuleChecks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (checkResultStatus) {
      res["CheckResultStatus"] = boost::any(*checkResultStatus);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (checkerName) {
      res["CheckerName"] = boost::any(*checkerName);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (fixedCheck) {
      res["FixedCheck"] = boost::any(*fixedCheck);
    }
    if (op) {
      res["Op"] = boost::any(*op);
    }
    if (upperValue) {
      res["UpperValue"] = boost::any(*upperValue);
    }
    if (actualExpression) {
      res["ActualExpression"] = boost::any(*actualExpression);
    }
    if (externalId) {
      res["ExternalId"] = boost::any(*externalId);
    }
    if (timeCost) {
      res["TimeCost"] = boost::any(*timeCost);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (externalType) {
      res["ExternalType"] = boost::any(*externalType);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (checkResult) {
      res["CheckResult"] = boost::any(*checkResult);
    }
    if (resultString) {
      res["ResultString"] = boost::any(*resultString);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (checkerType) {
      res["CheckerType"] = boost::any(*checkerType);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (dateType) {
      res["DateType"] = boost::any(*dateType);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (isPrediction) {
      res["IsPrediction"] = boost::any(*isPrediction);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (checkerId) {
      res["CheckerId"] = boost::any(*checkerId);
    }
    if (discreteCheck) {
      res["DiscreteCheck"] = boost::any(*discreteCheck);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (lowerValue) {
      res["LowerValue"] = boost::any(*lowerValue);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (whereCondition) {
      res["WhereCondition"] = boost::any(*whereCondition);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (referenceValue) {
      vector<boost::any> temp1;
      for(auto item1:*referenceValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReferenceValue"] = boost::any(temp1);
    }
    if (sampleValue) {
      vector<boost::any> temp1;
      for(auto item1:*sampleValue){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SampleValue"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<long>(boost::any_cast<long>(m["BlockType"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<double>(boost::any_cast<double>(m["WarningThreshold"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CheckResultStatus") != m.end() && !m["CheckResultStatus"].empty()) {
      checkResultStatus = make_shared<long>(boost::any_cast<long>(m["CheckResultStatus"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("CheckerName") != m.end() && !m["CheckerName"].empty()) {
      checkerName = make_shared<string>(boost::any_cast<string>(m["CheckerName"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("FixedCheck") != m.end() && !m["FixedCheck"].empty()) {
      fixedCheck = make_shared<bool>(boost::any_cast<bool>(m["FixedCheck"]));
    }
    if (m.find("Op") != m.end() && !m["Op"].empty()) {
      op = make_shared<string>(boost::any_cast<string>(m["Op"]));
    }
    if (m.find("UpperValue") != m.end() && !m["UpperValue"].empty()) {
      upperValue = make_shared<double>(boost::any_cast<double>(m["UpperValue"]));
    }
    if (m.find("ActualExpression") != m.end() && !m["ActualExpression"].empty()) {
      actualExpression = make_shared<string>(boost::any_cast<string>(m["ActualExpression"]));
    }
    if (m.find("ExternalId") != m.end() && !m["ExternalId"].empty()) {
      externalId = make_shared<string>(boost::any_cast<string>(m["ExternalId"]));
    }
    if (m.find("TimeCost") != m.end() && !m["TimeCost"].empty()) {
      timeCost = make_shared<string>(boost::any_cast<string>(m["TimeCost"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("ExternalType") != m.end() && !m["ExternalType"].empty()) {
      externalType = make_shared<string>(boost::any_cast<string>(m["ExternalType"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("CheckResult") != m.end() && !m["CheckResult"].empty()) {
      checkResult = make_shared<long>(boost::any_cast<long>(m["CheckResult"]));
    }
    if (m.find("ResultString") != m.end() && !m["ResultString"].empty()) {
      resultString = make_shared<string>(boost::any_cast<string>(m["ResultString"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("CheckerType") != m.end() && !m["CheckerType"].empty()) {
      checkerType = make_shared<long>(boost::any_cast<long>(m["CheckerType"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("DateType") != m.end() && !m["DateType"].empty()) {
      dateType = make_shared<string>(boost::any_cast<string>(m["DateType"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<double>(boost::any_cast<double>(m["CriticalThreshold"]));
    }
    if (m.find("IsPrediction") != m.end() && !m["IsPrediction"].empty()) {
      isPrediction = make_shared<bool>(boost::any_cast<bool>(m["IsPrediction"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("CheckerId") != m.end() && !m["CheckerId"].empty()) {
      checkerId = make_shared<long>(boost::any_cast<long>(m["CheckerId"]));
    }
    if (m.find("DiscreteCheck") != m.end() && !m["DiscreteCheck"].empty()) {
      discreteCheck = make_shared<bool>(boost::any_cast<bool>(m["DiscreteCheck"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("LowerValue") != m.end() && !m["LowerValue"].empty()) {
      lowerValue = make_shared<double>(boost::any_cast<double>(m["LowerValue"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("WhereCondition") != m.end() && !m["WhereCondition"].empty()) {
      whereCondition = make_shared<string>(boost::any_cast<string>(m["WhereCondition"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<double>(boost::any_cast<double>(m["ExpectValue"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ReferenceValue") != m.end() && !m["ReferenceValue"].empty()) {
      if (typeid(vector<boost::any>) == m["ReferenceValue"].type()) {
        vector<ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReferenceValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        referenceValue = make_shared<vector<ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue>>(expect1);
      }
    }
    if (m.find("SampleValue") != m.end() && !m["SampleValue"].empty()) {
      if (typeid(vector<boost::any>) == m["SampleValue"].type()) {
        vector<ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SampleValue"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sampleValue = make_shared<vector<ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue>>(expect1);
      }
    }
  }


  virtual ~ListQualityResultsByRuleResponseBodyDataRuleChecks() = default;
};
class ListQualityResultsByRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListQualityResultsByRuleResponseBodyDataRuleChecks>> ruleChecks{};

  ListQualityResultsByRuleResponseBodyData() {}

  explicit ListQualityResultsByRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (ruleChecks) {
      vector<boost::any> temp1;
      for(auto item1:*ruleChecks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleChecks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RuleChecks") != m.end() && !m["RuleChecks"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleChecks"].type()) {
        vector<ListQualityResultsByRuleResponseBodyDataRuleChecks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleChecks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityResultsByRuleResponseBodyDataRuleChecks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleChecks = make_shared<vector<ListQualityResultsByRuleResponseBodyDataRuleChecks>>(expect1);
      }
    }
  }


  virtual ~ListQualityResultsByRuleResponseBodyData() = default;
};
class ListQualityResultsByRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListQualityResultsByRuleResponseBodyData> data{};

  ListQualityResultsByRuleResponseBody() {}

  explicit ListQualityResultsByRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListQualityResultsByRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListQualityResultsByRuleResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListQualityResultsByRuleResponseBody() = default;
};
class ListQualityResultsByRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListQualityResultsByRuleResponseBody> body{};

  ListQualityResultsByRuleResponse() {}

  explicit ListQualityResultsByRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListQualityResultsByRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListQualityResultsByRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ListQualityResultsByRuleResponse() = default;
};
class ListQualityRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> entityId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListQualityRulesRequest() {}

  explicit ListQualityRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListQualityRulesRequest() = default;
};
class ListQualityRulesResponseBodyDataRules : public Darabonba::Model {
public:
  shared_ptr<long> blockType{};
  shared_ptr<string> onDutyAccountName{};
  shared_ptr<string> property{};
  shared_ptr<string> warningThreshold{};
  shared_ptr<string> tableName{};
  shared_ptr<string> onDuty{};
  shared_ptr<string> comment{};
  shared_ptr<long> ruleCheckerRelationId{};
  shared_ptr<bool> fixCheck{};
  shared_ptr<long> methodId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> trend{};
  shared_ptr<string> historyWarningThreshold{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> matchExpression{};
  shared_ptr<string> projectName{};
  shared_ptr<string> propertyKey{};
  shared_ptr<string> criticalThreshold{};
  shared_ptr<string> historyCriticalThreshold{};
  shared_ptr<string> methodName{};
  shared_ptr<long> checkerId{};
  shared_ptr<long> entityId{};
  shared_ptr<string> expectValue{};
  shared_ptr<long> templateId{};
  shared_ptr<long> id{};

  ListQualityRulesResponseBodyDataRules() {}

  explicit ListQualityRulesResponseBodyDataRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (onDutyAccountName) {
      res["OnDutyAccountName"] = boost::any(*onDutyAccountName);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (onDuty) {
      res["OnDuty"] = boost::any(*onDuty);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (ruleCheckerRelationId) {
      res["RuleCheckerRelationId"] = boost::any(*ruleCheckerRelationId);
    }
    if (fixCheck) {
      res["FixCheck"] = boost::any(*fixCheck);
    }
    if (methodId) {
      res["MethodId"] = boost::any(*methodId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (historyWarningThreshold) {
      res["HistoryWarningThreshold"] = boost::any(*historyWarningThreshold);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (matchExpression) {
      res["MatchExpression"] = boost::any(*matchExpression);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (propertyKey) {
      res["PropertyKey"] = boost::any(*propertyKey);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (historyCriticalThreshold) {
      res["HistoryCriticalThreshold"] = boost::any(*historyCriticalThreshold);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (checkerId) {
      res["CheckerId"] = boost::any(*checkerId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<long>(boost::any_cast<long>(m["BlockType"]));
    }
    if (m.find("OnDutyAccountName") != m.end() && !m["OnDutyAccountName"].empty()) {
      onDutyAccountName = make_shared<string>(boost::any_cast<string>(m["OnDutyAccountName"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<string>(boost::any_cast<string>(m["WarningThreshold"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("OnDuty") != m.end() && !m["OnDuty"].empty()) {
      onDuty = make_shared<string>(boost::any_cast<string>(m["OnDuty"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("RuleCheckerRelationId") != m.end() && !m["RuleCheckerRelationId"].empty()) {
      ruleCheckerRelationId = make_shared<long>(boost::any_cast<long>(m["RuleCheckerRelationId"]));
    }
    if (m.find("FixCheck") != m.end() && !m["FixCheck"].empty()) {
      fixCheck = make_shared<bool>(boost::any_cast<bool>(m["FixCheck"]));
    }
    if (m.find("MethodId") != m.end() && !m["MethodId"].empty()) {
      methodId = make_shared<long>(boost::any_cast<long>(m["MethodId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("HistoryWarningThreshold") != m.end() && !m["HistoryWarningThreshold"].empty()) {
      historyWarningThreshold = make_shared<string>(boost::any_cast<string>(m["HistoryWarningThreshold"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("MatchExpression") != m.end() && !m["MatchExpression"].empty()) {
      matchExpression = make_shared<string>(boost::any_cast<string>(m["MatchExpression"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("PropertyKey") != m.end() && !m["PropertyKey"].empty()) {
      propertyKey = make_shared<string>(boost::any_cast<string>(m["PropertyKey"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<string>(boost::any_cast<string>(m["CriticalThreshold"]));
    }
    if (m.find("HistoryCriticalThreshold") != m.end() && !m["HistoryCriticalThreshold"].empty()) {
      historyCriticalThreshold = make_shared<string>(boost::any_cast<string>(m["HistoryCriticalThreshold"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("CheckerId") != m.end() && !m["CheckerId"].empty()) {
      checkerId = make_shared<long>(boost::any_cast<long>(m["CheckerId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<string>(boost::any_cast<string>(m["ExpectValue"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListQualityRulesResponseBodyDataRules() = default;
};
class ListQualityRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListQualityRulesResponseBodyDataRules>> rules{};

  ListQualityRulesResponseBodyData() {}

  explicit ListQualityRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ListQualityRulesResponseBodyDataRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListQualityRulesResponseBodyDataRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ListQualityRulesResponseBodyDataRules>>(expect1);
      }
    }
  }


  virtual ~ListQualityRulesResponseBodyData() = default;
};
class ListQualityRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<ListQualityRulesResponseBodyData> data{};

  ListQualityRulesResponseBody() {}

  explicit ListQualityRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListQualityRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListQualityRulesResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListQualityRulesResponseBody() = default;
};
class ListQualityRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListQualityRulesResponseBody> body{};

  ListQualityRulesResponse() {}

  explicit ListQualityRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListQualityRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListQualityRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListQualityRulesResponse() = default;
};
class ListRemindsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> founder{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> remindTypes{};
  shared_ptr<string> alertTarget{};
  shared_ptr<string> searchText{};

  ListRemindsRequest() {}

  explicit ListRemindsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (founder) {
      res["Founder"] = boost::any(*founder);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (remindTypes) {
      res["RemindTypes"] = boost::any(*remindTypes);
    }
    if (alertTarget) {
      res["AlertTarget"] = boost::any(*alertTarget);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Founder") != m.end() && !m["Founder"].empty()) {
      founder = make_shared<string>(boost::any_cast<string>(m["Founder"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("RemindTypes") != m.end() && !m["RemindTypes"].empty()) {
      remindTypes = make_shared<string>(boost::any_cast<string>(m["RemindTypes"]));
    }
    if (m.find("AlertTarget") != m.end() && !m["AlertTarget"].empty()) {
      alertTarget = make_shared<string>(boost::any_cast<string>(m["AlertTarget"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
  }


  virtual ~ListRemindsRequest() = default;
};
class ListRemindsResponseBodyDataReminds : public Darabonba::Model {
public:
  shared_ptr<string> founder{};
  shared_ptr<long> remindId{};
  shared_ptr<string> alertUnit{};
  shared_ptr<string> remindType{};
  shared_ptr<string> dndEnd{};
  shared_ptr<string> dndStart{};
  shared_ptr<string> remindUnit{};
  shared_ptr<bool> useflag{};
  shared_ptr<string> remindName{};
  shared_ptr<vector<string>> alertTargets{};
  shared_ptr<vector<long>> nodeIds{};
  shared_ptr<vector<long>> bizProcessIds{};
  shared_ptr<vector<long>> projectIds{};
  shared_ptr<vector<long>> baselineIds{};
  shared_ptr<vector<string>> alertMethods{};

  ListRemindsResponseBodyDataReminds() {}

  explicit ListRemindsResponseBodyDataReminds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (founder) {
      res["Founder"] = boost::any(*founder);
    }
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    if (alertUnit) {
      res["AlertUnit"] = boost::any(*alertUnit);
    }
    if (remindType) {
      res["RemindType"] = boost::any(*remindType);
    }
    if (dndEnd) {
      res["DndEnd"] = boost::any(*dndEnd);
    }
    if (dndStart) {
      res["DndStart"] = boost::any(*dndStart);
    }
    if (remindUnit) {
      res["RemindUnit"] = boost::any(*remindUnit);
    }
    if (useflag) {
      res["Useflag"] = boost::any(*useflag);
    }
    if (remindName) {
      res["RemindName"] = boost::any(*remindName);
    }
    if (alertTargets) {
      res["AlertTargets"] = boost::any(*alertTargets);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (bizProcessIds) {
      res["BizProcessIds"] = boost::any(*bizProcessIds);
    }
    if (projectIds) {
      res["ProjectIds"] = boost::any(*projectIds);
    }
    if (baselineIds) {
      res["BaselineIds"] = boost::any(*baselineIds);
    }
    if (alertMethods) {
      res["AlertMethods"] = boost::any(*alertMethods);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Founder") != m.end() && !m["Founder"].empty()) {
      founder = make_shared<string>(boost::any_cast<string>(m["Founder"]));
    }
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
    if (m.find("AlertUnit") != m.end() && !m["AlertUnit"].empty()) {
      alertUnit = make_shared<string>(boost::any_cast<string>(m["AlertUnit"]));
    }
    if (m.find("RemindType") != m.end() && !m["RemindType"].empty()) {
      remindType = make_shared<string>(boost::any_cast<string>(m["RemindType"]));
    }
    if (m.find("DndEnd") != m.end() && !m["DndEnd"].empty()) {
      dndEnd = make_shared<string>(boost::any_cast<string>(m["DndEnd"]));
    }
    if (m.find("DndStart") != m.end() && !m["DndStart"].empty()) {
      dndStart = make_shared<string>(boost::any_cast<string>(m["DndStart"]));
    }
    if (m.find("RemindUnit") != m.end() && !m["RemindUnit"].empty()) {
      remindUnit = make_shared<string>(boost::any_cast<string>(m["RemindUnit"]));
    }
    if (m.find("Useflag") != m.end() && !m["Useflag"].empty()) {
      useflag = make_shared<bool>(boost::any_cast<bool>(m["Useflag"]));
    }
    if (m.find("RemindName") != m.end() && !m["RemindName"].empty()) {
      remindName = make_shared<string>(boost::any_cast<string>(m["RemindName"]));
    }
    if (m.find("AlertTargets") != m.end() && !m["AlertTargets"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertTargets"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertTargets"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertTargets = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      nodeIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("BizProcessIds") != m.end() && !m["BizProcessIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BizProcessIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizProcessIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      bizProcessIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("ProjectIds") != m.end() && !m["ProjectIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      projectIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("BaselineIds") != m.end() && !m["BaselineIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BaselineIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BaselineIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      baselineIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("AlertMethods") != m.end() && !m["AlertMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertMethods = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListRemindsResponseBodyDataReminds() = default;
};
class ListRemindsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListRemindsResponseBodyDataReminds>> reminds{};

  ListRemindsResponseBodyData() {}

  explicit ListRemindsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (reminds) {
      vector<boost::any> temp1;
      for(auto item1:*reminds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Reminds"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Reminds") != m.end() && !m["Reminds"].empty()) {
      if (typeid(vector<boost::any>) == m["Reminds"].type()) {
        vector<ListRemindsResponseBodyDataReminds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Reminds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRemindsResponseBodyDataReminds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reminds = make_shared<vector<ListRemindsResponseBodyDataReminds>>(expect1);
      }
    }
  }


  virtual ~ListRemindsResponseBodyData() = default;
};
class ListRemindsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListRemindsResponseBodyData> data{};

  ListRemindsResponseBody() {}

  explicit ListRemindsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRemindsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRemindsResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListRemindsResponseBody() = default;
};
class ListRemindsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRemindsResponseBody> body{};

  ListRemindsResponse() {}

  explicit ListRemindsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRemindsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRemindsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRemindsResponse() = default;
};
class ListResourceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> resourceGroupType{};
  shared_ptr<string> keyword{};
  shared_ptr<string> bizExtKey{};

  ListResourceGroupsRequest() {}

  explicit ListResourceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceGroupType) {
      res["ResourceGroupType"] = boost::any(*resourceGroupType);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (bizExtKey) {
      res["BizExtKey"] = boost::any(*bizExtKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceGroupType") != m.end() && !m["ResourceGroupType"].empty()) {
      resourceGroupType = make_shared<long>(boost::any_cast<long>(m["ResourceGroupType"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("BizExtKey") != m.end() && !m["BizExtKey"].empty()) {
      bizExtKey = make_shared<string>(boost::any_cast<string>(m["BizExtKey"]));
    }
  }


  virtual ~ListResourceGroupsRequest() = default;
};
class ListResourceGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> updateTime{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> cluster{};
  shared_ptr<bool> enableKp{};
  shared_ptr<string> resourceGroupType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> identifier{};
  shared_ptr<string> mode{};
  shared_ptr<string> bizExtKey{};
  shared_ptr<long> sequence{};
  shared_ptr<map<string, boost::any>> specs{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<long> tenantId{};

  ListResourceGroupsResponseBodyData() {}

  explicit ListResourceGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (cluster) {
      res["Cluster"] = boost::any(*cluster);
    }
    if (enableKp) {
      res["EnableKp"] = boost::any(*enableKp);
    }
    if (resourceGroupType) {
      res["ResourceGroupType"] = boost::any(*resourceGroupType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (bizExtKey) {
      res["BizExtKey"] = boost::any(*bizExtKey);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (specs) {
      res["Specs"] = boost::any(*specs);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      cluster = make_shared<string>(boost::any_cast<string>(m["Cluster"]));
    }
    if (m.find("EnableKp") != m.end() && !m["EnableKp"].empty()) {
      enableKp = make_shared<bool>(boost::any_cast<bool>(m["EnableKp"]));
    }
    if (m.find("ResourceGroupType") != m.end() && !m["ResourceGroupType"].empty()) {
      resourceGroupType = make_shared<string>(boost::any_cast<string>(m["ResourceGroupType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("BizExtKey") != m.end() && !m["BizExtKey"].empty()) {
      bizExtKey = make_shared<string>(boost::any_cast<string>(m["BizExtKey"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<long>(boost::any_cast<long>(m["Sequence"]));
    }
    if (m.find("Specs") != m.end() && !m["Specs"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Specs"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      specs = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListResourceGroupsResponseBodyData() = default;
};
class ListResourceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<ListResourceGroupsResponseBodyData>> data{};

  ListResourceGroupsResponseBody() {}

  explicit ListResourceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListResourceGroupsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourceGroupsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListResourceGroupsResponseBodyData>>(expect1);
      }
    }
  }


  virtual ~ListResourceGroupsResponseBody() = default;
};
class ListResourceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListResourceGroupsResponseBody> body{};

  ListResourceGroupsResponse() {}

  explicit ListResourceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourceGroupsResponse() = default;
};
class ListSuccessInstanceAmountRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  ListSuccessInstanceAmountRequest() {}

  explicit ListSuccessInstanceAmountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListSuccessInstanceAmountRequest() = default;
};
class ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend : public Darabonba::Model {
public:
  shared_ptr<string> timePoint{};
  shared_ptr<long> count{};

  ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend() {}

  explicit ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend() = default;
};
class ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend : public Darabonba::Model {
public:
  shared_ptr<string> timePoint{};
  shared_ptr<long> count{};

  ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend() {}

  explicit ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend() = default;
};
class ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend : public Darabonba::Model {
public:
  shared_ptr<string> timePoint{};
  shared_ptr<long> count{};

  ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend() {}

  explicit ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timePoint) {
      res["TimePoint"] = boost::any(*timePoint);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimePoint") != m.end() && !m["TimePoint"].empty()) {
      timePoint = make_shared<string>(boost::any_cast<string>(m["TimePoint"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend() = default;
};
class ListSuccessInstanceAmountResponseBodyInstanceStatusTrend : public Darabonba::Model {
public:
  shared_ptr<vector<ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend>> todayTrend{};
  shared_ptr<vector<ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend>> yesterdayTrend{};
  shared_ptr<vector<ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend>> avgTrend{};

  ListSuccessInstanceAmountResponseBodyInstanceStatusTrend() {}

  explicit ListSuccessInstanceAmountResponseBodyInstanceStatusTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (todayTrend) {
      vector<boost::any> temp1;
      for(auto item1:*todayTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TodayTrend"] = boost::any(temp1);
    }
    if (yesterdayTrend) {
      vector<boost::any> temp1;
      for(auto item1:*yesterdayTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["YesterdayTrend"] = boost::any(temp1);
    }
    if (avgTrend) {
      vector<boost::any> temp1;
      for(auto item1:*avgTrend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvgTrend"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TodayTrend") != m.end() && !m["TodayTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["TodayTrend"].type()) {
        vector<ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TodayTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        todayTrend = make_shared<vector<ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend>>(expect1);
      }
    }
    if (m.find("YesterdayTrend") != m.end() && !m["YesterdayTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["YesterdayTrend"].type()) {
        vector<ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["YesterdayTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        yesterdayTrend = make_shared<vector<ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend>>(expect1);
      }
    }
    if (m.find("AvgTrend") != m.end() && !m["AvgTrend"].empty()) {
      if (typeid(vector<boost::any>) == m["AvgTrend"].type()) {
        vector<ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvgTrend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        avgTrend = make_shared<vector<ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend>>(expect1);
      }
    }
  }


  virtual ~ListSuccessInstanceAmountResponseBodyInstanceStatusTrend() = default;
};
class ListSuccessInstanceAmountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListSuccessInstanceAmountResponseBodyInstanceStatusTrend> instanceStatusTrend{};

  ListSuccessInstanceAmountResponseBody() {}

  explicit ListSuccessInstanceAmountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceStatusTrend) {
      res["InstanceStatusTrend"] = instanceStatusTrend ? boost::any(instanceStatusTrend->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceStatusTrend") != m.end() && !m["InstanceStatusTrend"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceStatusTrend"].type()) {
        ListSuccessInstanceAmountResponseBodyInstanceStatusTrend model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceStatusTrend"]));
        instanceStatusTrend = make_shared<ListSuccessInstanceAmountResponseBodyInstanceStatusTrend>(model1);
      }
    }
  }


  virtual ~ListSuccessInstanceAmountResponseBody() = default;
};
class ListSuccessInstanceAmountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSuccessInstanceAmountResponseBody> body{};

  ListSuccessInstanceAmountResponse() {}

  explicit ListSuccessInstanceAmountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSuccessInstanceAmountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSuccessInstanceAmountResponseBody>(model1);
      }
    }
  }


  virtual ~ListSuccessInstanceAmountResponse() = default;
};
class ListTableLevelRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> levelType{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  ListTableLevelRequest() {}

  explicit ListTableLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (levelType) {
      res["LevelType"] = boost::any(*levelType);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("LevelType") != m.end() && !m["LevelType"].empty()) {
      levelType = make_shared<long>(boost::any_cast<long>(m["LevelType"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListTableLevelRequest() = default;
};
class ListTableLevelResponseBodyTableLevelInfoLevelList : public Darabonba::Model {
public:
  shared_ptr<long> levelType{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<long> levelId{};

  ListTableLevelResponseBodyTableLevelInfoLevelList() {}

  explicit ListTableLevelResponseBodyTableLevelInfoLevelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (levelType) {
      res["LevelType"] = boost::any(*levelType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LevelType") != m.end() && !m["LevelType"].empty()) {
      levelType = make_shared<long>(boost::any_cast<long>(m["LevelType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
  }


  virtual ~ListTableLevelResponseBodyTableLevelInfoLevelList() = default;
};
class ListTableLevelResponseBodyTableLevelInfo : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListTableLevelResponseBodyTableLevelInfoLevelList>> levelList{};

  ListTableLevelResponseBodyTableLevelInfo() {}

  explicit ListTableLevelResponseBodyTableLevelInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (levelList) {
      vector<boost::any> temp1;
      for(auto item1:*levelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LevelList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("LevelList") != m.end() && !m["LevelList"].empty()) {
      if (typeid(vector<boost::any>) == m["LevelList"].type()) {
        vector<ListTableLevelResponseBodyTableLevelInfoLevelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LevelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTableLevelResponseBodyTableLevelInfoLevelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        levelList = make_shared<vector<ListTableLevelResponseBodyTableLevelInfoLevelList>>(expect1);
      }
    }
  }


  virtual ~ListTableLevelResponseBodyTableLevelInfo() = default;
};
class ListTableLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<ListTableLevelResponseBodyTableLevelInfo> tableLevelInfo{};

  ListTableLevelResponseBody() {}

  explicit ListTableLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (tableLevelInfo) {
      res["TableLevelInfo"] = tableLevelInfo ? boost::any(tableLevelInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("TableLevelInfo") != m.end() && !m["TableLevelInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableLevelInfo"].type()) {
        ListTableLevelResponseBodyTableLevelInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableLevelInfo"]));
        tableLevelInfo = make_shared<ListTableLevelResponseBodyTableLevelInfo>(model1);
      }
    }
  }


  virtual ~ListTableLevelResponseBody() = default;
};
class ListTableLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTableLevelResponseBody> body{};

  ListTableLevelResponse() {}

  explicit ListTableLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTableLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTableLevelResponseBody>(model1);
      }
    }
  }


  virtual ~ListTableLevelResponse() = default;
};
class ListTableThemeRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> parentId{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  ListTableThemeRequest() {}

  explicit ListTableThemeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListTableThemeRequest() = default;
};
class ListTableThemeResponseBodyDataThemeList : public Darabonba::Model {
public:
  shared_ptr<long> createTimeStamp{};
  shared_ptr<long> parentId{};
  shared_ptr<long> themeId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<long> level{};
  shared_ptr<string> creator{};

  ListTableThemeResponseBodyDataThemeList() {}

  explicit ListTableThemeResponseBodyDataThemeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeStamp) {
      res["CreateTimeStamp"] = boost::any(*createTimeStamp);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeStamp") != m.end() && !m["CreateTimeStamp"].empty()) {
      createTimeStamp = make_shared<long>(boost::any_cast<long>(m["CreateTimeStamp"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
  }


  virtual ~ListTableThemeResponseBodyDataThemeList() = default;
};
class ListTableThemeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListTableThemeResponseBodyDataThemeList>> themeList{};

  ListTableThemeResponseBodyData() {}

  explicit ListTableThemeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (themeList) {
      vector<boost::any> temp1;
      for(auto item1:*themeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ThemeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("ThemeList") != m.end() && !m["ThemeList"].empty()) {
      if (typeid(vector<boost::any>) == m["ThemeList"].type()) {
        vector<ListTableThemeResponseBodyDataThemeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ThemeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTableThemeResponseBodyDataThemeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        themeList = make_shared<vector<ListTableThemeResponseBodyDataThemeList>>(expect1);
      }
    }
  }


  virtual ~ListTableThemeResponseBodyData() = default;
};
class ListTableThemeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<ListTableThemeResponseBodyData> data{};

  ListTableThemeResponseBody() {}

  explicit ListTableThemeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTableThemeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTableThemeResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListTableThemeResponseBody() = default;
};
class ListTableThemeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTableThemeResponseBody> body{};

  ListTableThemeResponse() {}

  explicit ListTableThemeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTableThemeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTableThemeResponseBody>(model1);
      }
    }
  }


  virtual ~ListTableThemeResponse() = default;
};
class ListTopicsRequest : public Darabonba::Model {
public:
  shared_ptr<string> beginTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> topicTypes{};
  shared_ptr<string> topicStatuses{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> owner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListTopicsRequest() {}

  explicit ListTopicsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (topicTypes) {
      res["TopicTypes"] = boost::any(*topicTypes);
    }
    if (topicStatuses) {
      res["TopicStatuses"] = boost::any(*topicStatuses);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("TopicTypes") != m.end() && !m["TopicTypes"].empty()) {
      topicTypes = make_shared<string>(boost::any_cast<string>(m["TopicTypes"]));
    }
    if (m.find("TopicStatuses") != m.end() && !m["TopicStatuses"].empty()) {
      topicStatuses = make_shared<string>(boost::any_cast<string>(m["TopicStatuses"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListTopicsRequest() = default;
};
class ListTopicsResponseBodyDataTopics : public Darabonba::Model {
public:
  shared_ptr<string> topicName{};
  shared_ptr<long> projectId{};
  shared_ptr<string> nodeOwner{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> fixTime{};
  shared_ptr<string> topicType{};
  shared_ptr<string> topicStatus{};
  shared_ptr<long> happenTime{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> topicId{};
  shared_ptr<long> addTime{};
  shared_ptr<long> nodeId{};

  ListTopicsResponseBodyDataTopics() {}

  explicit ListTopicsResponseBodyDataTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (nodeOwner) {
      res["NodeOwner"] = boost::any(*nodeOwner);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (fixTime) {
      res["FixTime"] = boost::any(*fixTime);
    }
    if (topicType) {
      res["TopicType"] = boost::any(*topicType);
    }
    if (topicStatus) {
      res["TopicStatus"] = boost::any(*topicStatus);
    }
    if (happenTime) {
      res["HappenTime"] = boost::any(*happenTime);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (addTime) {
      res["AddTime"] = boost::any(*addTime);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<string>(boost::any_cast<string>(m["TopicName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("NodeOwner") != m.end() && !m["NodeOwner"].empty()) {
      nodeOwner = make_shared<string>(boost::any_cast<string>(m["NodeOwner"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("FixTime") != m.end() && !m["FixTime"].empty()) {
      fixTime = make_shared<long>(boost::any_cast<long>(m["FixTime"]));
    }
    if (m.find("TopicType") != m.end() && !m["TopicType"].empty()) {
      topicType = make_shared<string>(boost::any_cast<string>(m["TopicType"]));
    }
    if (m.find("TopicStatus") != m.end() && !m["TopicStatus"].empty()) {
      topicStatus = make_shared<string>(boost::any_cast<string>(m["TopicStatus"]));
    }
    if (m.find("HappenTime") != m.end() && !m["HappenTime"].empty()) {
      happenTime = make_shared<long>(boost::any_cast<long>(m["HappenTime"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<long>(boost::any_cast<long>(m["TopicId"]));
    }
    if (m.find("AddTime") != m.end() && !m["AddTime"].empty()) {
      addTime = make_shared<long>(boost::any_cast<long>(m["AddTime"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
  }


  virtual ~ListTopicsResponseBodyDataTopics() = default;
};
class ListTopicsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListTopicsResponseBodyDataTopics>> topics{};

  ListTopicsResponseBodyData() {}

  explicit ListTopicsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (topics) {
      vector<boost::any> temp1;
      for(auto item1:*topics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Topics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<ListTopicsResponseBodyDataTopics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Topics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTopicsResponseBodyDataTopics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topics = make_shared<vector<ListTopicsResponseBodyDataTopics>>(expect1);
      }
    }
  }


  virtual ~ListTopicsResponseBodyData() = default;
};
class ListTopicsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};
  shared_ptr<ListTopicsResponseBodyData> data{};

  ListTopicsResponseBody() {}

  explicit ListTopicsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListTopicsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListTopicsResponseBodyData>(model1);
      }
    }
  }


  virtual ~ListTopicsResponseBody() = default;
};
class ListTopicsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTopicsResponseBody> body{};

  ListTopicsResponse() {}

  explicit ListTopicsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTopicsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTopicsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTopicsResponse() = default;
};
class PublishDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};

  PublishDataServiceApiRequest() {}

  explicit PublishDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
  }


  virtual ~PublishDataServiceApiRequest() = default;
};
class PublishDataServiceApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  PublishDataServiceApiResponseBody() {}

  explicit PublishDataServiceApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishDataServiceApiResponseBody() = default;
};
class PublishDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PublishDataServiceApiResponseBody> body{};

  PublishDataServiceApiResponse() {}

  explicit PublishDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishDataServiceApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishDataServiceApiResponseBody>(model1);
      }
    }
  }


  virtual ~PublishDataServiceApiResponse() = default;
};
class QueryPublicModelEngineRequest : public Darabonba::Model {
public:
  shared_ptr<string> text{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> projectId{};

  QueryPublicModelEngineRequest() {}

  explicit QueryPublicModelEngineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~QueryPublicModelEngineRequest() = default;
};
class QueryPublicModelEngineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> returnValue{};

  QueryPublicModelEngineResponseBody() {}

  explicit QueryPublicModelEngineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (returnValue) {
      res["ReturnValue"] = boost::any(*returnValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ReturnValue") != m.end() && !m["ReturnValue"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["ReturnValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReturnValue"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      returnValue = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~QueryPublicModelEngineResponseBody() = default;
};
class QueryPublicModelEngineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryPublicModelEngineResponseBody> body{};

  QueryPublicModelEngineResponse() {}

  explicit QueryPublicModelEngineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPublicModelEngineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPublicModelEngineResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPublicModelEngineResponse() = default;
};
class RemoveProjectMemberFromRoleRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> userId{};
  shared_ptr<string> roleCode{};

  RemoveProjectMemberFromRoleRequest() {}

  explicit RemoveProjectMemberFromRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (roleCode) {
      res["RoleCode"] = boost::any(*roleCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("RoleCode") != m.end() && !m["RoleCode"].empty()) {
      roleCode = make_shared<string>(boost::any_cast<string>(m["RoleCode"]));
    }
  }


  virtual ~RemoveProjectMemberFromRoleRequest() = default;
};
class RemoveProjectMemberFromRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveProjectMemberFromRoleResponseBody() {}

  explicit RemoveProjectMemberFromRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveProjectMemberFromRoleResponseBody() = default;
};
class RemoveProjectMemberFromRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveProjectMemberFromRoleResponseBody> body{};

  RemoveProjectMemberFromRoleResponse() {}

  explicit RemoveProjectMemberFromRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveProjectMemberFromRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveProjectMemberFromRoleResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveProjectMemberFromRoleResponse() = default;
};
class RestartInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  RestartInstanceRequest() {}

  explicit RestartInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~RestartInstanceRequest() = default;
};
class RestartInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  RestartInstanceResponseBody() {}

  explicit RestartInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RestartInstanceResponseBody() = default;
};
class RestartInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RestartInstanceResponseBody> body{};

  RestartInstanceResponse() {}

  explicit RestartInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RestartInstanceResponse() = default;
};
class ResumeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  ResumeInstanceRequest() {}

  explicit ResumeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~ResumeInstanceRequest() = default;
};
class ResumeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  ResumeInstanceResponseBody() {}

  explicit ResumeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResumeInstanceResponseBody() = default;
};
class ResumeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResumeInstanceResponseBody> body{};

  ResumeInstanceResponse() {}

  explicit ResumeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeInstanceResponse() = default;
};
class RevokeColumnPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> workspaceId{};
  shared_ptr<string> maxComputeProjectName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> columns{};
  shared_ptr<string> revokeUserName{};
  shared_ptr<string> revokeUserId{};

  RevokeColumnPermissionRequest() {}

  explicit RevokeColumnPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (maxComputeProjectName) {
      res["MaxComputeProjectName"] = boost::any(*maxComputeProjectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (revokeUserName) {
      res["RevokeUserName"] = boost::any(*revokeUserName);
    }
    if (revokeUserId) {
      res["RevokeUserId"] = boost::any(*revokeUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<long>(boost::any_cast<long>(m["WorkspaceId"]));
    }
    if (m.find("MaxComputeProjectName") != m.end() && !m["MaxComputeProjectName"].empty()) {
      maxComputeProjectName = make_shared<string>(boost::any_cast<string>(m["MaxComputeProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      columns = make_shared<string>(boost::any_cast<string>(m["Columns"]));
    }
    if (m.find("RevokeUserName") != m.end() && !m["RevokeUserName"].empty()) {
      revokeUserName = make_shared<string>(boost::any_cast<string>(m["RevokeUserName"]));
    }
    if (m.find("RevokeUserId") != m.end() && !m["RevokeUserId"].empty()) {
      revokeUserId = make_shared<string>(boost::any_cast<string>(m["RevokeUserId"]));
    }
  }


  virtual ~RevokeColumnPermissionRequest() = default;
};
class RevokeColumnPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> revokeSuccess{};
  shared_ptr<string> requestId{};

  RevokeColumnPermissionResponseBody() {}

  explicit RevokeColumnPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (revokeSuccess) {
      res["RevokeSuccess"] = boost::any(*revokeSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RevokeSuccess") != m.end() && !m["RevokeSuccess"].empty()) {
      revokeSuccess = make_shared<bool>(boost::any_cast<bool>(m["RevokeSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeColumnPermissionResponseBody() = default;
};
class RevokeColumnPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeColumnPermissionResponseBody> body{};

  RevokeColumnPermissionResponse() {}

  explicit RevokeColumnPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeColumnPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeColumnPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeColumnPermissionResponse() = default;
};
class RevokeTablePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> workspaceId{};
  shared_ptr<string> maxComputeProjectName{};
  shared_ptr<string> tableName{};
  shared_ptr<string> actions{};
  shared_ptr<string> revokeUserName{};
  shared_ptr<string> revokeUserId{};

  RevokeTablePermissionRequest() {}

  explicit RevokeTablePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (maxComputeProjectName) {
      res["MaxComputeProjectName"] = boost::any(*maxComputeProjectName);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (actions) {
      res["Actions"] = boost::any(*actions);
    }
    if (revokeUserName) {
      res["RevokeUserName"] = boost::any(*revokeUserName);
    }
    if (revokeUserId) {
      res["RevokeUserId"] = boost::any(*revokeUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<long>(boost::any_cast<long>(m["WorkspaceId"]));
    }
    if (m.find("MaxComputeProjectName") != m.end() && !m["MaxComputeProjectName"].empty()) {
      maxComputeProjectName = make_shared<string>(boost::any_cast<string>(m["MaxComputeProjectName"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      actions = make_shared<string>(boost::any_cast<string>(m["Actions"]));
    }
    if (m.find("RevokeUserName") != m.end() && !m["RevokeUserName"].empty()) {
      revokeUserName = make_shared<string>(boost::any_cast<string>(m["RevokeUserName"]));
    }
    if (m.find("RevokeUserId") != m.end() && !m["RevokeUserId"].empty()) {
      revokeUserId = make_shared<string>(boost::any_cast<string>(m["RevokeUserId"]));
    }
  }


  virtual ~RevokeTablePermissionRequest() = default;
};
class RevokeTablePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> revokeSuccess{};
  shared_ptr<string> requestId{};

  RevokeTablePermissionResponseBody() {}

  explicit RevokeTablePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (revokeSuccess) {
      res["RevokeSuccess"] = boost::any(*revokeSuccess);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RevokeSuccess") != m.end() && !m["RevokeSuccess"].empty()) {
      revokeSuccess = make_shared<bool>(boost::any_cast<bool>(m["RevokeSuccess"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeTablePermissionResponseBody() = default;
};
class RevokeTablePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeTablePermissionResponseBody> body{};

  RevokeTablePermissionResponse() {}

  explicit RevokeTablePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeTablePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeTablePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeTablePermissionResponse() = default;
};
class RunCycleDagNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> startBizDate{};
  shared_ptr<string> name{};
  shared_ptr<long> rootNodeId{};
  shared_ptr<string> includeNodeIds{};
  shared_ptr<string> excludeNodeIds{};
  shared_ptr<string> bizBeginTime{};
  shared_ptr<string> bizEndTime{};
  shared_ptr<bool> parallelism{};
  shared_ptr<string> endBizDate{};
  shared_ptr<string> nodeParams{};

  RunCycleDagNodesRequest() {}

  explicit RunCycleDagNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (startBizDate) {
      res["StartBizDate"] = boost::any(*startBizDate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rootNodeId) {
      res["RootNodeId"] = boost::any(*rootNodeId);
    }
    if (includeNodeIds) {
      res["IncludeNodeIds"] = boost::any(*includeNodeIds);
    }
    if (excludeNodeIds) {
      res["ExcludeNodeIds"] = boost::any(*excludeNodeIds);
    }
    if (bizBeginTime) {
      res["BizBeginTime"] = boost::any(*bizBeginTime);
    }
    if (bizEndTime) {
      res["BizEndTime"] = boost::any(*bizEndTime);
    }
    if (parallelism) {
      res["Parallelism"] = boost::any(*parallelism);
    }
    if (endBizDate) {
      res["EndBizDate"] = boost::any(*endBizDate);
    }
    if (nodeParams) {
      res["NodeParams"] = boost::any(*nodeParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("StartBizDate") != m.end() && !m["StartBizDate"].empty()) {
      startBizDate = make_shared<string>(boost::any_cast<string>(m["StartBizDate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RootNodeId") != m.end() && !m["RootNodeId"].empty()) {
      rootNodeId = make_shared<long>(boost::any_cast<long>(m["RootNodeId"]));
    }
    if (m.find("IncludeNodeIds") != m.end() && !m["IncludeNodeIds"].empty()) {
      includeNodeIds = make_shared<string>(boost::any_cast<string>(m["IncludeNodeIds"]));
    }
    if (m.find("ExcludeNodeIds") != m.end() && !m["ExcludeNodeIds"].empty()) {
      excludeNodeIds = make_shared<string>(boost::any_cast<string>(m["ExcludeNodeIds"]));
    }
    if (m.find("BizBeginTime") != m.end() && !m["BizBeginTime"].empty()) {
      bizBeginTime = make_shared<string>(boost::any_cast<string>(m["BizBeginTime"]));
    }
    if (m.find("BizEndTime") != m.end() && !m["BizEndTime"].empty()) {
      bizEndTime = make_shared<string>(boost::any_cast<string>(m["BizEndTime"]));
    }
    if (m.find("Parallelism") != m.end() && !m["Parallelism"].empty()) {
      parallelism = make_shared<bool>(boost::any_cast<bool>(m["Parallelism"]));
    }
    if (m.find("EndBizDate") != m.end() && !m["EndBizDate"].empty()) {
      endBizDate = make_shared<string>(boost::any_cast<string>(m["EndBizDate"]));
    }
    if (m.find("NodeParams") != m.end() && !m["NodeParams"].empty()) {
      nodeParams = make_shared<string>(boost::any_cast<string>(m["NodeParams"]));
    }
  }


  virtual ~RunCycleDagNodesRequest() = default;
};
class RunCycleDagNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<vector<long>> data{};

  RunCycleDagNodesResponseBody() {}

  explicit RunCycleDagNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      data = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~RunCycleDagNodesResponseBody() = default;
};
class RunCycleDagNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RunCycleDagNodesResponseBody> body{};

  RunCycleDagNodesResponse() {}

  explicit RunCycleDagNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunCycleDagNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunCycleDagNodesResponseBody>(model1);
      }
    }
  }


  virtual ~RunCycleDagNodesResponse() = default;
};
class RunManualDagNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> projectName{};
  shared_ptr<string> flowName{};
  shared_ptr<string> bizDate{};
  shared_ptr<string> nodeParameters{};
  shared_ptr<string> dagParameters{};

  RunManualDagNodesRequest() {}

  explicit RunManualDagNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (nodeParameters) {
      res["NodeParameters"] = boost::any(*nodeParameters);
    }
    if (dagParameters) {
      res["DagParameters"] = boost::any(*dagParameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("NodeParameters") != m.end() && !m["NodeParameters"].empty()) {
      nodeParameters = make_shared<string>(boost::any_cast<string>(m["NodeParameters"]));
    }
    if (m.find("DagParameters") != m.end() && !m["DagParameters"].empty()) {
      dagParameters = make_shared<string>(boost::any_cast<string>(m["DagParameters"]));
    }
  }


  virtual ~RunManualDagNodesRequest() = default;
};
class RunManualDagNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> dagId{};
  shared_ptr<string> requestId{};

  RunManualDagNodesResponseBody() {}

  explicit RunManualDagNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<long>(boost::any_cast<long>(m["DagId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunManualDagNodesResponseBody() = default;
};
class RunManualDagNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RunManualDagNodesResponseBody> body{};

  RunManualDagNodesResponse() {}

  explicit RunManualDagNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunManualDagNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunManualDagNodesResponseBody>(model1);
      }
    }
  }


  virtual ~RunManualDagNodesResponse() = default;
};
class RunSmokeTestRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> bizdate{};
  shared_ptr<string> name{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> nodeParams{};

  RunSmokeTestRequest() {}

  explicit RunSmokeTestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (bizdate) {
      res["Bizdate"] = boost::any(*bizdate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeParams) {
      res["NodeParams"] = boost::any(*nodeParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("Bizdate") != m.end() && !m["Bizdate"].empty()) {
      bizdate = make_shared<string>(boost::any_cast<string>(m["Bizdate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("NodeParams") != m.end() && !m["NodeParams"].empty()) {
      nodeParams = make_shared<string>(boost::any_cast<string>(m["NodeParams"]));
    }
  }


  virtual ~RunSmokeTestRequest() = default;
};
class RunSmokeTestResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  RunSmokeTestResponseBody() {}

  explicit RunSmokeTestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RunSmokeTestResponseBody() = default;
};
class RunSmokeTestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RunSmokeTestResponseBody> body{};

  RunSmokeTestResponse() {}

  explicit RunSmokeTestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunSmokeTestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunSmokeTestResponseBody>(model1);
      }
    }
  }


  virtual ~RunSmokeTestResponse() = default;
};
class RunTriggerNodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeId{};
  shared_ptr<long> cycleTime{};
  shared_ptr<long> bizDate{};
  shared_ptr<long> appId{};

  RunTriggerNodeRequest() {}

  explicit RunTriggerNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (cycleTime) {
      res["CycleTime"] = boost::any(*cycleTime);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("CycleTime") != m.end() && !m["CycleTime"].empty()) {
      cycleTime = make_shared<long>(boost::any_cast<long>(m["CycleTime"]));
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
  }


  virtual ~RunTriggerNodeRequest() = default;
};
class RunTriggerNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};

  RunTriggerNodeResponseBody() {}

  explicit RunTriggerNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunTriggerNodeResponseBody() = default;
};
class RunTriggerNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RunTriggerNodeResponseBody> body{};

  RunTriggerNodeResponse() {}

  explicit RunTriggerNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunTriggerNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunTriggerNodeResponseBody>(model1);
      }
    }
  }


  virtual ~RunTriggerNodeResponse() = default;
};
class ScanSensitiveDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};

  ScanSensitiveDataRequest() {}

  explicit ScanSensitiveDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ScanSensitiveDataRequest() = default;
};
class ScanSensitiveDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> sensitives{};
  shared_ptr<string> requestId{};

  ScanSensitiveDataResponseBody() {}

  explicit ScanSensitiveDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sensitives) {
      res["Sensitives"] = boost::any(*sensitives);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sensitives") != m.end() && !m["Sensitives"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Sensitives"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      sensitives = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ScanSensitiveDataResponseBody() = default;
};
class ScanSensitiveDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ScanSensitiveDataResponseBody> body{};

  ScanSensitiveDataResponse() {}

  explicit ScanSensitiveDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ScanSensitiveDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ScanSensitiveDataResponseBody>(model1);
      }
    }
  }


  virtual ~ScanSensitiveDataResponse() = default;
};
class SearchMetaTablesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> appGuid{};
  shared_ptr<string> keyword{};
  shared_ptr<long> entityType{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> dataSourceType{};

  SearchMetaTablesRequest() {}

  explicit SearchMetaTablesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dataSourceType) {
      res["DataSourceType"] = boost::any(*dataSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<long>(boost::any_cast<long>(m["EntityType"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DataSourceType") != m.end() && !m["DataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["DataSourceType"]));
    }
  }


  virtual ~SearchMetaTablesRequest() = default;
};
class SearchMetaTablesResponseBodyDataDataEntityList : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};
  shared_ptr<string> databaseName{};
  shared_ptr<long> entityType{};
  shared_ptr<string> projectName{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> envType{};
  shared_ptr<long> tenantId{};

  SearchMetaTablesResponseBodyDataDataEntityList() {}

  explicit SearchMetaTablesResponseBodyDataDataEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (entityType) {
      res["EntityType"] = boost::any(*entityType);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("EntityType") != m.end() && !m["EntityType"].empty()) {
      entityType = make_shared<long>(boost::any_cast<long>(m["EntityType"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~SearchMetaTablesResponseBodyDataDataEntityList() = default;
};
class SearchMetaTablesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<SearchMetaTablesResponseBodyDataDataEntityList>> dataEntityList{};

  SearchMetaTablesResponseBodyData() {}

  explicit SearchMetaTablesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (dataEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*dataEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataEntityList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("DataEntityList") != m.end() && !m["DataEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataEntityList"].type()) {
        vector<SearchMetaTablesResponseBodyDataDataEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMetaTablesResponseBodyDataDataEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataEntityList = make_shared<vector<SearchMetaTablesResponseBodyDataDataEntityList>>(expect1);
      }
    }
  }


  virtual ~SearchMetaTablesResponseBodyData() = default;
};
class SearchMetaTablesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};
  shared_ptr<SearchMetaTablesResponseBodyData> data{};

  SearchMetaTablesResponseBody() {}

  explicit SearchMetaTablesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SearchMetaTablesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SearchMetaTablesResponseBodyData>(model1);
      }
    }
  }


  virtual ~SearchMetaTablesResponseBody() = default;
};
class SearchMetaTablesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SearchMetaTablesResponseBody> body{};

  SearchMetaTablesResponse() {}

  explicit SearchMetaTablesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMetaTablesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMetaTablesResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMetaTablesResponse() = default;
};
class SearchNodesByOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<string> outputs{};

  SearchNodesByOutputRequest() {}

  explicit SearchNodesByOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (outputs) {
      res["Outputs"] = boost::any(*outputs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      outputs = make_shared<string>(boost::any_cast<string>(m["Outputs"]));
    }
  }


  virtual ~SearchNodesByOutputRequest() = default;
};
class SearchNodesByOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  SearchNodesByOutputResponseBody() {}

  explicit SearchNodesByOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~SearchNodesByOutputResponseBody() = default;
};
class SearchNodesByOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SearchNodesByOutputResponseBody> body{};

  SearchNodesByOutputResponse() {}

  explicit SearchNodesByOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchNodesByOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchNodesByOutputResponseBody>(model1);
      }
    }
  }


  virtual ~SearchNodesByOutputResponse() = default;
};
class SetSuccessInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  SetSuccessInstanceRequest() {}

  explicit SetSuccessInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~SetSuccessInstanceRequest() = default;
};
class SetSuccessInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  SetSuccessInstanceResponseBody() {}

  explicit SetSuccessInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetSuccessInstanceResponseBody() = default;
};
class SetSuccessInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetSuccessInstanceResponseBody> body{};

  SetSuccessInstanceResponse() {}

  explicit SetSuccessInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetSuccessInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetSuccessInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~SetSuccessInstanceResponse() = default;
};
class StartMigrationRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> migrationId{};

  StartMigrationRequest() {}

  explicit StartMigrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (migrationId) {
      res["MigrationId"] = boost::any(*migrationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("MigrationId") != m.end() && !m["MigrationId"].empty()) {
      migrationId = make_shared<long>(boost::any_cast<long>(m["MigrationId"]));
    }
  }


  virtual ~StartMigrationRequest() = default;
};
class StartMigrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  StartMigrationResponseBody() {}

  explicit StartMigrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartMigrationResponseBody() = default;
};
class StartMigrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartMigrationResponseBody> body{};

  StartMigrationResponse() {}

  explicit StartMigrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartMigrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartMigrationResponseBody>(model1);
      }
    }
  }


  virtual ~StartMigrationResponse() = default;
};
class StopInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  StopInstanceRequest() {}

  explicit StopInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~StopInstanceRequest() = default;
};
class StopInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  StopInstanceResponseBody() {}

  explicit StopInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StopInstanceResponseBody() = default;
};
class StopInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopInstanceResponseBody> body{};

  StopInstanceResponse() {}

  explicit StopInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StopInstanceResponse() = default;
};
class SubmitFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileId{};
  shared_ptr<string> comment{};

  SubmitFileRequest() {}

  explicit SubmitFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
  }


  virtual ~SubmitFileRequest() = default;
};
class SubmitFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  SubmitFileResponseBody() {}

  explicit SubmitFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~SubmitFileResponseBody() = default;
};
class SubmitFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitFileResponseBody> body{};

  SubmitFileResponse() {}

  explicit SubmitFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFileResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFileResponse() = default;
};
class SuspendInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> projectEnv{};

  SuspendInstanceRequest() {}

  explicit SuspendInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
  }


  virtual ~SuspendInstanceRequest() = default;
};
class SuspendInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  SuspendInstanceResponseBody() {}

  explicit SuspendInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SuspendInstanceResponseBody() = default;
};
class SuspendInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SuspendInstanceResponseBody> body{};

  SuspendInstanceResponse() {}

  explicit SuspendInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendInstanceResponse() = default;
};
class TopTenElapsedTimeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> businessDate{};

  TopTenElapsedTimeInstanceRequest() {}

  explicit TopTenElapsedTimeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (businessDate) {
      res["BusinessDate"] = boost::any(*businessDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BusinessDate") != m.end() && !m["BusinessDate"].empty()) {
      businessDate = make_shared<string>(boost::any_cast<string>(m["BusinessDate"]));
    }
  }


  virtual ~TopTenElapsedTimeInstanceRequest() = default;
};
class TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> businessDate{};
  shared_ptr<long> programType{};
  shared_ptr<long> instanceId{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> consumed{};

  TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank() {}

  explicit TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (businessDate) {
      res["BusinessDate"] = boost::any(*businessDate);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (consumed) {
      res["Consumed"] = boost::any(*consumed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("BusinessDate") != m.end() && !m["BusinessDate"].empty()) {
      businessDate = make_shared<long>(boost::any_cast<long>(m["BusinessDate"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<long>(boost::any_cast<long>(m["ProgramType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["InstanceId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Consumed") != m.end() && !m["Consumed"].empty()) {
      consumed = make_shared<long>(boost::any_cast<long>(m["Consumed"]));
    }
  }


  virtual ~TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank() = default;
};
class TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<vector<TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank>> consumeTimeRank{};

  TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank() {}

  explicit TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (consumeTimeRank) {
      vector<boost::any> temp1;
      for(auto item1:*consumeTimeRank){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsumeTimeRank"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("ConsumeTimeRank") != m.end() && !m["ConsumeTimeRank"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsumeTimeRank"].type()) {
        vector<TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsumeTimeRank"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consumeTimeRank = make_shared<vector<TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank>>(expect1);
      }
    }
  }


  virtual ~TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank() = default;
};
class TopTenElapsedTimeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank> instanceConsumeTimeRank{};

  TopTenElapsedTimeInstanceResponseBody() {}

  explicit TopTenElapsedTimeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceConsumeTimeRank) {
      res["InstanceConsumeTimeRank"] = instanceConsumeTimeRank ? boost::any(instanceConsumeTimeRank->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceConsumeTimeRank") != m.end() && !m["InstanceConsumeTimeRank"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceConsumeTimeRank"].type()) {
        TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceConsumeTimeRank"]));
        instanceConsumeTimeRank = make_shared<TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank>(model1);
      }
    }
  }


  virtual ~TopTenElapsedTimeInstanceResponseBody() = default;
};
class TopTenElapsedTimeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TopTenElapsedTimeInstanceResponseBody> body{};

  TopTenElapsedTimeInstanceResponse() {}

  explicit TopTenElapsedTimeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TopTenElapsedTimeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TopTenElapsedTimeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~TopTenElapsedTimeInstanceResponse() = default;
};
class TopTenErrorTimesInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};

  TopTenErrorTimesInstanceRequest() {}

  explicit TopTenErrorTimesInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~TopTenErrorTimesInstanceRequest() = default;
};
class TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank : public Darabonba::Model {
public:
  shared_ptr<string> owner{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> projectId{};
  shared_ptr<long> programType{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> count{};

  TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank() {}

  explicit TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (programType) {
      res["ProgramType"] = boost::any(*programType);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProgramType") != m.end() && !m["ProgramType"].empty()) {
      programType = make_shared<long>(boost::any_cast<long>(m["ProgramType"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank() = default;
};
class TopTenErrorTimesInstanceResponseBodyInstanceErrorRank : public Darabonba::Model {
public:
  shared_ptr<long> updateTime{};
  shared_ptr<vector<TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank>> errorRank{};

  TopTenErrorTimesInstanceResponseBodyInstanceErrorRank() {}

  explicit TopTenErrorTimesInstanceResponseBodyInstanceErrorRank(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (errorRank) {
      vector<boost::any> temp1;
      for(auto item1:*errorRank){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorRank"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("ErrorRank") != m.end() && !m["ErrorRank"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorRank"].type()) {
        vector<TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorRank"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorRank = make_shared<vector<TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank>>(expect1);
      }
    }
  }


  virtual ~TopTenErrorTimesInstanceResponseBodyInstanceErrorRank() = default;
};
class TopTenErrorTimesInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<TopTenErrorTimesInstanceResponseBodyInstanceErrorRank> instanceErrorRank{};

  TopTenErrorTimesInstanceResponseBody() {}

  explicit TopTenErrorTimesInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceErrorRank) {
      res["InstanceErrorRank"] = instanceErrorRank ? boost::any(instanceErrorRank->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceErrorRank") != m.end() && !m["InstanceErrorRank"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceErrorRank"].type()) {
        TopTenErrorTimesInstanceResponseBodyInstanceErrorRank model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceErrorRank"]));
        instanceErrorRank = make_shared<TopTenErrorTimesInstanceResponseBodyInstanceErrorRank>(model1);
      }
    }
  }


  virtual ~TopTenErrorTimesInstanceResponseBody() = default;
};
class TopTenErrorTimesInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TopTenErrorTimesInstanceResponseBody> body{};

  TopTenErrorTimesInstanceResponse() {}

  explicit TopTenErrorTimesInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TopTenErrorTimesInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TopTenErrorTimesInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~TopTenErrorTimesInstanceResponse() = default;
};
class UpdateBusinessRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> businessName{};
  shared_ptr<string> description{};
  shared_ptr<string> owner{};
  shared_ptr<long> businessId{};

  UpdateBusinessRequest() {}

  explicit UpdateBusinessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (businessName) {
      res["BusinessName"] = boost::any(*businessName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (businessId) {
      res["BusinessId"] = boost::any(*businessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("BusinessName") != m.end() && !m["BusinessName"].empty()) {
      businessName = make_shared<string>(boost::any_cast<string>(m["BusinessName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("BusinessId") != m.end() && !m["BusinessId"].empty()) {
      businessId = make_shared<long>(boost::any_cast<long>(m["BusinessId"]));
    }
  }


  virtual ~UpdateBusinessRequest() = default;
};
class UpdateBusinessResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  UpdateBusinessResponseBody() {}

  explicit UpdateBusinessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateBusinessResponseBody() = default;
};
class UpdateBusinessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateBusinessResponseBody> body{};

  UpdateBusinessResponse() {}

  explicit UpdateBusinessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBusinessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBusinessResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBusinessResponse() = default;
};
class UpdateConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> envType{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<long> connectionId{};

  UpdateConnectionRequest() {}

  explicit UpdateConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (connectionId) {
      res["ConnectionId"] = boost::any(*connectionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ConnectionId") != m.end() && !m["ConnectionId"].empty()) {
      connectionId = make_shared<long>(boost::any_cast<long>(m["ConnectionId"]));
    }
  }


  virtual ~UpdateConnectionRequest() = default;
};
class UpdateConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateConnectionResponseBody() {}

  explicit UpdateConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateConnectionResponseBody() = default;
};
class UpdateConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateConnectionResponseBody> body{};

  UpdateConnectionResponse() {}

  explicit UpdateConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConnectionResponse() = default;
};
class UpdateDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> apiId{};
  shared_ptr<long> requestMethod{};
  shared_ptr<long> responseContentType{};
  shared_ptr<long> timeout{};
  shared_ptr<long> visibleRange{};
  shared_ptr<string> protocols{};
  shared_ptr<string> wizardDetails{};
  shared_ptr<string> scriptDetails{};
  shared_ptr<string> registrationDetails{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> apiDescription{};

  UpdateDataServiceApiRequest() {}

  explicit UpdateDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (responseContentType) {
      res["ResponseContentType"] = boost::any(*responseContentType);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (visibleRange) {
      res["VisibleRange"] = boost::any(*visibleRange);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (wizardDetails) {
      res["WizardDetails"] = boost::any(*wizardDetails);
    }
    if (scriptDetails) {
      res["ScriptDetails"] = boost::any(*scriptDetails);
    }
    if (registrationDetails) {
      res["RegistrationDetails"] = boost::any(*registrationDetails);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (apiDescription) {
      res["ApiDescription"] = boost::any(*apiDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<long>(boost::any_cast<long>(m["RequestMethod"]));
    }
    if (m.find("ResponseContentType") != m.end() && !m["ResponseContentType"].empty()) {
      responseContentType = make_shared<long>(boost::any_cast<long>(m["ResponseContentType"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("VisibleRange") != m.end() && !m["VisibleRange"].empty()) {
      visibleRange = make_shared<long>(boost::any_cast<long>(m["VisibleRange"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      protocols = make_shared<string>(boost::any_cast<string>(m["Protocols"]));
    }
    if (m.find("WizardDetails") != m.end() && !m["WizardDetails"].empty()) {
      wizardDetails = make_shared<string>(boost::any_cast<string>(m["WizardDetails"]));
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      scriptDetails = make_shared<string>(boost::any_cast<string>(m["ScriptDetails"]));
    }
    if (m.find("RegistrationDetails") != m.end() && !m["RegistrationDetails"].empty()) {
      registrationDetails = make_shared<string>(boost::any_cast<string>(m["RegistrationDetails"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("ApiDescription") != m.end() && !m["ApiDescription"].empty()) {
      apiDescription = make_shared<string>(boost::any_cast<string>(m["ApiDescription"]));
    }
  }


  virtual ~UpdateDataServiceApiRequest() = default;
};
class UpdateDataServiceApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  UpdateDataServiceApiResponseBody() {}

  explicit UpdateDataServiceApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataServiceApiResponseBody() = default;
};
class UpdateDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateDataServiceApiResponseBody> body{};

  UpdateDataServiceApiResponse() {}

  explicit UpdateDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataServiceApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataServiceApiResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataServiceApiResponse() = default;
};
class UpdateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> envType{};
  shared_ptr<string> content{};
  shared_ptr<string> status{};
  shared_ptr<long> dataSourceId{};

  UpdateDataSourceRequest() {}

  explicit UpdateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
  }


  virtual ~UpdateDataSourceRequest() = default;
};
class UpdateDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataSourceResponseBody() {}

  explicit UpdateDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataSourceResponseBody() = default;
};
class UpdateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateDataSourceResponseBody> body{};

  UpdateDataSourceResponse() {}

  explicit UpdateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataSourceResponse() = default;
};
class UpdateFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> content{};
  shared_ptr<long> autoRerunTimes{};
  shared_ptr<long> autoRerunIntervalMillis{};
  shared_ptr<string> rerunMode{};
  shared_ptr<bool> stop{};
  shared_ptr<string> paraValue{};
  shared_ptr<long> startEffectDate{};
  shared_ptr<long> endEffectDate{};
  shared_ptr<string> cronExpress{};
  shared_ptr<string> cycleType{};
  shared_ptr<string> dependentType{};
  shared_ptr<string> dependentNodeIdList{};
  shared_ptr<string> inputList{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<long> fileId{};
  shared_ptr<string> outputList{};
  shared_ptr<string> resourceGroupIdentifier{};
  shared_ptr<string> connectionName{};
  shared_ptr<string> owner{};
  shared_ptr<bool> autoParsing{};

  UpdateFileRequest() {}

  explicit UpdateFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (autoRerunTimes) {
      res["AutoRerunTimes"] = boost::any(*autoRerunTimes);
    }
    if (autoRerunIntervalMillis) {
      res["AutoRerunIntervalMillis"] = boost::any(*autoRerunIntervalMillis);
    }
    if (rerunMode) {
      res["RerunMode"] = boost::any(*rerunMode);
    }
    if (stop) {
      res["Stop"] = boost::any(*stop);
    }
    if (paraValue) {
      res["ParaValue"] = boost::any(*paraValue);
    }
    if (startEffectDate) {
      res["StartEffectDate"] = boost::any(*startEffectDate);
    }
    if (endEffectDate) {
      res["EndEffectDate"] = boost::any(*endEffectDate);
    }
    if (cronExpress) {
      res["CronExpress"] = boost::any(*cronExpress);
    }
    if (cycleType) {
      res["CycleType"] = boost::any(*cycleType);
    }
    if (dependentType) {
      res["DependentType"] = boost::any(*dependentType);
    }
    if (dependentNodeIdList) {
      res["DependentNodeIdList"] = boost::any(*dependentNodeIdList);
    }
    if (inputList) {
      res["InputList"] = boost::any(*inputList);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (outputList) {
      res["OutputList"] = boost::any(*outputList);
    }
    if (resourceGroupIdentifier) {
      res["ResourceGroupIdentifier"] = boost::any(*resourceGroupIdentifier);
    }
    if (connectionName) {
      res["ConnectionName"] = boost::any(*connectionName);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (autoParsing) {
      res["AutoParsing"] = boost::any(*autoParsing);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("AutoRerunTimes") != m.end() && !m["AutoRerunTimes"].empty()) {
      autoRerunTimes = make_shared<long>(boost::any_cast<long>(m["AutoRerunTimes"]));
    }
    if (m.find("AutoRerunIntervalMillis") != m.end() && !m["AutoRerunIntervalMillis"].empty()) {
      autoRerunIntervalMillis = make_shared<long>(boost::any_cast<long>(m["AutoRerunIntervalMillis"]));
    }
    if (m.find("RerunMode") != m.end() && !m["RerunMode"].empty()) {
      rerunMode = make_shared<string>(boost::any_cast<string>(m["RerunMode"]));
    }
    if (m.find("Stop") != m.end() && !m["Stop"].empty()) {
      stop = make_shared<bool>(boost::any_cast<bool>(m["Stop"]));
    }
    if (m.find("ParaValue") != m.end() && !m["ParaValue"].empty()) {
      paraValue = make_shared<string>(boost::any_cast<string>(m["ParaValue"]));
    }
    if (m.find("StartEffectDate") != m.end() && !m["StartEffectDate"].empty()) {
      startEffectDate = make_shared<long>(boost::any_cast<long>(m["StartEffectDate"]));
    }
    if (m.find("EndEffectDate") != m.end() && !m["EndEffectDate"].empty()) {
      endEffectDate = make_shared<long>(boost::any_cast<long>(m["EndEffectDate"]));
    }
    if (m.find("CronExpress") != m.end() && !m["CronExpress"].empty()) {
      cronExpress = make_shared<string>(boost::any_cast<string>(m["CronExpress"]));
    }
    if (m.find("CycleType") != m.end() && !m["CycleType"].empty()) {
      cycleType = make_shared<string>(boost::any_cast<string>(m["CycleType"]));
    }
    if (m.find("DependentType") != m.end() && !m["DependentType"].empty()) {
      dependentType = make_shared<string>(boost::any_cast<string>(m["DependentType"]));
    }
    if (m.find("DependentNodeIdList") != m.end() && !m["DependentNodeIdList"].empty()) {
      dependentNodeIdList = make_shared<string>(boost::any_cast<string>(m["DependentNodeIdList"]));
    }
    if (m.find("InputList") != m.end() && !m["InputList"].empty()) {
      inputList = make_shared<string>(boost::any_cast<string>(m["InputList"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("OutputList") != m.end() && !m["OutputList"].empty()) {
      outputList = make_shared<string>(boost::any_cast<string>(m["OutputList"]));
    }
    if (m.find("ResourceGroupIdentifier") != m.end() && !m["ResourceGroupIdentifier"].empty()) {
      resourceGroupIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceGroupIdentifier"]));
    }
    if (m.find("ConnectionName") != m.end() && !m["ConnectionName"].empty()) {
      connectionName = make_shared<string>(boost::any_cast<string>(m["ConnectionName"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("AutoParsing") != m.end() && !m["AutoParsing"].empty()) {
      autoParsing = make_shared<bool>(boost::any_cast<bool>(m["AutoParsing"]));
    }
  }


  virtual ~UpdateFileRequest() = default;
};
class UpdateFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  UpdateFileResponseBody() {}

  explicit UpdateFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateFileResponseBody() = default;
};
class UpdateFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateFileResponseBody> body{};

  UpdateFileResponse() {}

  explicit UpdateFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFileResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFileResponse() = default;
};
class UpdateFolderRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> folderId{};
  shared_ptr<string> folderName{};

  UpdateFolderRequest() {}

  explicit UpdateFolderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (folderId) {
      res["FolderId"] = boost::any(*folderId);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FolderId") != m.end() && !m["FolderId"].empty()) {
      folderId = make_shared<string>(boost::any_cast<string>(m["FolderId"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
  }


  virtual ~UpdateFolderRequest() = default;
};
class UpdateFolderResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  UpdateFolderResponseBody() {}

  explicit UpdateFolderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateFolderResponseBody() = default;
};
class UpdateFolderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateFolderResponseBody> body{};

  UpdateFolderResponse() {}

  explicit UpdateFolderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFolderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFolderResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFolderResponse() = default;
};
class UpdateMetaCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> comment{};
  shared_ptr<long> categoryId{};

  UpdateMetaCategoryRequest() {}

  explicit UpdateMetaCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
  }


  virtual ~UpdateMetaCategoryRequest() = default;
};
class UpdateMetaCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  UpdateMetaCategoryResponseBody() {}

  explicit UpdateMetaCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMetaCategoryResponseBody() = default;
};
class UpdateMetaCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMetaCategoryResponseBody> body{};

  UpdateMetaCategoryResponse() {}

  explicit UpdateMetaCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMetaCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMetaCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMetaCategoryResponse() = default;
};
class UpdateMetaTableRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> tableName{};
  shared_ptr<long> envType{};
  shared_ptr<string> tableGuid{};
  shared_ptr<string> newOwnerId{};
  shared_ptr<string> addedLabels{};
  shared_ptr<string> removedLabels{};
  shared_ptr<long> categoryId{};
  shared_ptr<long> visibility{};
  shared_ptr<string> caption{};

  UpdateMetaTableRequest() {}

  explicit UpdateMetaTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (newOwnerId) {
      res["NewOwnerId"] = boost::any(*newOwnerId);
    }
    if (addedLabels) {
      res["AddedLabels"] = boost::any(*addedLabels);
    }
    if (removedLabels) {
      res["RemovedLabels"] = boost::any(*removedLabels);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (caption) {
      res["Caption"] = boost::any(*caption);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("NewOwnerId") != m.end() && !m["NewOwnerId"].empty()) {
      newOwnerId = make_shared<string>(boost::any_cast<string>(m["NewOwnerId"]));
    }
    if (m.find("AddedLabels") != m.end() && !m["AddedLabels"].empty()) {
      addedLabels = make_shared<string>(boost::any_cast<string>(m["AddedLabels"]));
    }
    if (m.find("RemovedLabels") != m.end() && !m["RemovedLabels"].empty()) {
      removedLabels = make_shared<string>(boost::any_cast<string>(m["RemovedLabels"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<long>(boost::any_cast<long>(m["Visibility"]));
    }
    if (m.find("Caption") != m.end() && !m["Caption"].empty()) {
      caption = make_shared<string>(boost::any_cast<string>(m["Caption"]));
    }
  }


  virtual ~UpdateMetaTableRequest() = default;
};
class UpdateMetaTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> updateResult{};
  shared_ptr<string> requestId{};

  UpdateMetaTableResponseBody() {}

  explicit UpdateMetaTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateResult) {
      res["UpdateResult"] = boost::any(*updateResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      updateResult = make_shared<bool>(boost::any_cast<bool>(m["UpdateResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMetaTableResponseBody() = default;
};
class UpdateMetaTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMetaTableResponseBody> body{};

  UpdateMetaTableResponse() {}

  explicit UpdateMetaTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMetaTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMetaTableResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMetaTableResponse() = default;
};
class UpdateMetaTableIntroWikiRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<string> content{};

  UpdateMetaTableIntroWikiRequest() {}

  explicit UpdateMetaTableIntroWikiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~UpdateMetaTableIntroWikiRequest() = default;
};
class UpdateMetaTableIntroWikiResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> updateResult{};
  shared_ptr<string> requestId{};

  UpdateMetaTableIntroWikiResponseBody() {}

  explicit UpdateMetaTableIntroWikiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateResult) {
      res["UpdateResult"] = boost::any(*updateResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      updateResult = make_shared<bool>(boost::any_cast<bool>(m["UpdateResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMetaTableIntroWikiResponseBody() = default;
};
class UpdateMetaTableIntroWikiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateMetaTableIntroWikiResponseBody> body{};

  UpdateMetaTableIntroWikiResponse() {}

  explicit UpdateMetaTableIntroWikiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMetaTableIntroWikiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMetaTableIntroWikiResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMetaTableIntroWikiResponse() = default;
};
class UpdateNodeOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<long> nodeId{};
  shared_ptr<string> userId{};

  UpdateNodeOwnerRequest() {}

  explicit UpdateNodeOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateNodeOwnerRequest() = default;
};
class UpdateNodeOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};

  UpdateNodeOwnerResponseBody() {}

  explicit UpdateNodeOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateNodeOwnerResponseBody() = default;
};
class UpdateNodeOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateNodeOwnerResponseBody> body{};

  UpdateNodeOwnerResponse() {}

  explicit UpdateNodeOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNodeOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNodeOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNodeOwnerResponse() = default;
};
class UpdateNodeRunModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectEnv{};
  shared_ptr<long> nodeId{};
  shared_ptr<long> schedulerType{};

  UpdateNodeRunModeRequest() {}

  explicit UpdateNodeRunModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectEnv) {
      res["ProjectEnv"] = boost::any(*projectEnv);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (schedulerType) {
      res["SchedulerType"] = boost::any(*schedulerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectEnv") != m.end() && !m["ProjectEnv"].empty()) {
      projectEnv = make_shared<string>(boost::any_cast<string>(m["ProjectEnv"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<long>(boost::any_cast<long>(m["NodeId"]));
    }
    if (m.find("SchedulerType") != m.end() && !m["SchedulerType"].empty()) {
      schedulerType = make_shared<long>(boost::any_cast<long>(m["SchedulerType"]));
    }
  }


  virtual ~UpdateNodeRunModeRequest() = default;
};
class UpdateNodeRunModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> success{};
  shared_ptr<string> requestId{};

  UpdateNodeRunModeResponseBody() {}

  explicit UpdateNodeRunModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateNodeRunModeResponseBody() = default;
};
class UpdateNodeRunModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateNodeRunModeResponseBody> body{};

  UpdateNodeRunModeResponse() {}

  explicit UpdateNodeRunModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNodeRunModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNodeRunModeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNodeRunModeResponse() = default;
};
class UpdateQualityFollowerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<long> followerId{};
  shared_ptr<string> follower{};
  shared_ptr<long> alarmMode{};

  UpdateQualityFollowerRequest() {}

  explicit UpdateQualityFollowerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (followerId) {
      res["FollowerId"] = boost::any(*followerId);
    }
    if (follower) {
      res["Follower"] = boost::any(*follower);
    }
    if (alarmMode) {
      res["AlarmMode"] = boost::any(*alarmMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("FollowerId") != m.end() && !m["FollowerId"].empty()) {
      followerId = make_shared<long>(boost::any_cast<long>(m["FollowerId"]));
    }
    if (m.find("Follower") != m.end() && !m["Follower"].empty()) {
      follower = make_shared<string>(boost::any_cast<string>(m["Follower"]));
    }
    if (m.find("AlarmMode") != m.end() && !m["AlarmMode"].empty()) {
      alarmMode = make_shared<long>(boost::any_cast<long>(m["AlarmMode"]));
    }
  }


  virtual ~UpdateQualityFollowerRequest() = default;
};
class UpdateQualityFollowerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  UpdateQualityFollowerResponseBody() {}

  explicit UpdateQualityFollowerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateQualityFollowerResponseBody() = default;
};
class UpdateQualityFollowerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateQualityFollowerResponseBody> body{};

  UpdateQualityFollowerResponse() {}

  explicit UpdateQualityFollowerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateQualityFollowerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateQualityFollowerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateQualityFollowerResponse() = default;
};
class UpdateQualityRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> blockType{};
  shared_ptr<long> entityId{};
  shared_ptr<string> comment{};
  shared_ptr<long> checker{};
  shared_ptr<string> expectValue{};
  shared_ptr<long> id{};
  shared_ptr<string> trend{};
  shared_ptr<string> methodName{};
  shared_ptr<string> operator_{};
  shared_ptr<string> projectName{};
  shared_ptr<string> property{};
  shared_ptr<string> propertyType{};
  shared_ptr<long> ruleType{};
  shared_ptr<string> whereCondition{};
  shared_ptr<string> criticalThreshold{};
  shared_ptr<string> warningThreshold{};
  shared_ptr<long> templateId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> predictType{};

  UpdateQualityRuleRequest() {}

  explicit UpdateQualityRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockType) {
      res["BlockType"] = boost::any(*blockType);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (checker) {
      res["Checker"] = boost::any(*checker);
    }
    if (expectValue) {
      res["ExpectValue"] = boost::any(*expectValue);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (trend) {
      res["Trend"] = boost::any(*trend);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    if (propertyType) {
      res["PropertyType"] = boost::any(*propertyType);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (whereCondition) {
      res["WhereCondition"] = boost::any(*whereCondition);
    }
    if (criticalThreshold) {
      res["CriticalThreshold"] = boost::any(*criticalThreshold);
    }
    if (warningThreshold) {
      res["WarningThreshold"] = boost::any(*warningThreshold);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (predictType) {
      res["PredictType"] = boost::any(*predictType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockType") != m.end() && !m["BlockType"].empty()) {
      blockType = make_shared<long>(boost::any_cast<long>(m["BlockType"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<long>(boost::any_cast<long>(m["EntityId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Checker") != m.end() && !m["Checker"].empty()) {
      checker = make_shared<long>(boost::any_cast<long>(m["Checker"]));
    }
    if (m.find("ExpectValue") != m.end() && !m["ExpectValue"].empty()) {
      expectValue = make_shared<string>(boost::any_cast<string>(m["ExpectValue"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      trend = make_shared<string>(boost::any_cast<string>(m["Trend"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
    if (m.find("PropertyType") != m.end() && !m["PropertyType"].empty()) {
      propertyType = make_shared<string>(boost::any_cast<string>(m["PropertyType"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<long>(boost::any_cast<long>(m["RuleType"]));
    }
    if (m.find("WhereCondition") != m.end() && !m["WhereCondition"].empty()) {
      whereCondition = make_shared<string>(boost::any_cast<string>(m["WhereCondition"]));
    }
    if (m.find("CriticalThreshold") != m.end() && !m["CriticalThreshold"].empty()) {
      criticalThreshold = make_shared<string>(boost::any_cast<string>(m["CriticalThreshold"]));
    }
    if (m.find("WarningThreshold") != m.end() && !m["WarningThreshold"].empty()) {
      warningThreshold = make_shared<string>(boost::any_cast<string>(m["WarningThreshold"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("PredictType") != m.end() && !m["PredictType"].empty()) {
      predictType = make_shared<long>(boost::any_cast<long>(m["PredictType"]));
    }
  }


  virtual ~UpdateQualityRuleRequest() = default;
};
class UpdateQualityRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  UpdateQualityRuleResponseBody() {}

  explicit UpdateQualityRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateQualityRuleResponseBody() = default;
};
class UpdateQualityRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateQualityRuleResponseBody> body{};

  UpdateQualityRuleResponse() {}

  explicit UpdateQualityRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateQualityRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateQualityRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateQualityRuleResponse() = default;
};
class UpdateRemindRequest : public Darabonba::Model {
public:
  shared_ptr<long> remindId{};
  shared_ptr<string> remindName{};
  shared_ptr<string> dndEnd{};
  shared_ptr<string> remindUnit{};
  shared_ptr<string> nodeIds{};
  shared_ptr<string> baselineIds{};
  shared_ptr<long> projectId{};
  shared_ptr<string> bizProcessIds{};
  shared_ptr<string> remindType{};
  shared_ptr<long> maxAlertTimes{};
  shared_ptr<long> alertInterval{};
  shared_ptr<string> detail{};
  shared_ptr<string> alertUnit{};
  shared_ptr<string> alertMethods{};
  shared_ptr<string> alertTargets{};
  shared_ptr<bool> useFlag{};
  shared_ptr<string> robotUrls{};

  UpdateRemindRequest() {}

  explicit UpdateRemindRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remindId) {
      res["RemindId"] = boost::any(*remindId);
    }
    if (remindName) {
      res["RemindName"] = boost::any(*remindName);
    }
    if (dndEnd) {
      res["DndEnd"] = boost::any(*dndEnd);
    }
    if (remindUnit) {
      res["RemindUnit"] = boost::any(*remindUnit);
    }
    if (nodeIds) {
      res["NodeIds"] = boost::any(*nodeIds);
    }
    if (baselineIds) {
      res["BaselineIds"] = boost::any(*baselineIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (bizProcessIds) {
      res["BizProcessIds"] = boost::any(*bizProcessIds);
    }
    if (remindType) {
      res["RemindType"] = boost::any(*remindType);
    }
    if (maxAlertTimes) {
      res["MaxAlertTimes"] = boost::any(*maxAlertTimes);
    }
    if (alertInterval) {
      res["AlertInterval"] = boost::any(*alertInterval);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (alertUnit) {
      res["AlertUnit"] = boost::any(*alertUnit);
    }
    if (alertMethods) {
      res["AlertMethods"] = boost::any(*alertMethods);
    }
    if (alertTargets) {
      res["AlertTargets"] = boost::any(*alertTargets);
    }
    if (useFlag) {
      res["UseFlag"] = boost::any(*useFlag);
    }
    if (robotUrls) {
      res["RobotUrls"] = boost::any(*robotUrls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemindId") != m.end() && !m["RemindId"].empty()) {
      remindId = make_shared<long>(boost::any_cast<long>(m["RemindId"]));
    }
    if (m.find("RemindName") != m.end() && !m["RemindName"].empty()) {
      remindName = make_shared<string>(boost::any_cast<string>(m["RemindName"]));
    }
    if (m.find("DndEnd") != m.end() && !m["DndEnd"].empty()) {
      dndEnd = make_shared<string>(boost::any_cast<string>(m["DndEnd"]));
    }
    if (m.find("RemindUnit") != m.end() && !m["RemindUnit"].empty()) {
      remindUnit = make_shared<string>(boost::any_cast<string>(m["RemindUnit"]));
    }
    if (m.find("NodeIds") != m.end() && !m["NodeIds"].empty()) {
      nodeIds = make_shared<string>(boost::any_cast<string>(m["NodeIds"]));
    }
    if (m.find("BaselineIds") != m.end() && !m["BaselineIds"].empty()) {
      baselineIds = make_shared<string>(boost::any_cast<string>(m["BaselineIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("BizProcessIds") != m.end() && !m["BizProcessIds"].empty()) {
      bizProcessIds = make_shared<string>(boost::any_cast<string>(m["BizProcessIds"]));
    }
    if (m.find("RemindType") != m.end() && !m["RemindType"].empty()) {
      remindType = make_shared<string>(boost::any_cast<string>(m["RemindType"]));
    }
    if (m.find("MaxAlertTimes") != m.end() && !m["MaxAlertTimes"].empty()) {
      maxAlertTimes = make_shared<long>(boost::any_cast<long>(m["MaxAlertTimes"]));
    }
    if (m.find("AlertInterval") != m.end() && !m["AlertInterval"].empty()) {
      alertInterval = make_shared<long>(boost::any_cast<long>(m["AlertInterval"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("AlertUnit") != m.end() && !m["AlertUnit"].empty()) {
      alertUnit = make_shared<string>(boost::any_cast<string>(m["AlertUnit"]));
    }
    if (m.find("AlertMethods") != m.end() && !m["AlertMethods"].empty()) {
      alertMethods = make_shared<string>(boost::any_cast<string>(m["AlertMethods"]));
    }
    if (m.find("AlertTargets") != m.end() && !m["AlertTargets"].empty()) {
      alertTargets = make_shared<string>(boost::any_cast<string>(m["AlertTargets"]));
    }
    if (m.find("UseFlag") != m.end() && !m["UseFlag"].empty()) {
      useFlag = make_shared<bool>(boost::any_cast<bool>(m["UseFlag"]));
    }
    if (m.find("RobotUrls") != m.end() && !m["RobotUrls"].empty()) {
      robotUrls = make_shared<string>(boost::any_cast<string>(m["RobotUrls"]));
    }
  }


  virtual ~UpdateRemindRequest() = default;
};
class UpdateRemindResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<bool> data{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> errorCode{};

  UpdateRemindResponseBody() {}

  explicit UpdateRemindResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
  }


  virtual ~UpdateRemindResponseBody() = default;
};
class UpdateRemindResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateRemindResponseBody> body{};

  UpdateRemindResponse() {}

  explicit UpdateRemindResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRemindResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRemindResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRemindResponse() = default;
};
class UpdateTableRequestColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnNameCn{};
  shared_ptr<string> columnName{};
  shared_ptr<string> comment{};
  shared_ptr<string> columnType{};
  shared_ptr<long> seqNumber{};
  shared_ptr<long> length{};
  shared_ptr<bool> isPartitionCol{};

  UpdateTableRequestColumns() {}

  explicit UpdateTableRequestColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnNameCn) {
      res["ColumnNameCn"] = boost::any(*columnNameCn);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (seqNumber) {
      res["SeqNumber"] = boost::any(*seqNumber);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (isPartitionCol) {
      res["IsPartitionCol"] = boost::any(*isPartitionCol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnNameCn") != m.end() && !m["ColumnNameCn"].empty()) {
      columnNameCn = make_shared<string>(boost::any_cast<string>(m["ColumnNameCn"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("SeqNumber") != m.end() && !m["SeqNumber"].empty()) {
      seqNumber = make_shared<long>(boost::any_cast<long>(m["SeqNumber"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("IsPartitionCol") != m.end() && !m["IsPartitionCol"].empty()) {
      isPartitionCol = make_shared<bool>(boost::any_cast<bool>(m["IsPartitionCol"]));
    }
  }


  virtual ~UpdateTableRequestColumns() = default;
};
class UpdateTableRequestThemes : public Darabonba::Model {
public:
  shared_ptr<long> themeId{};
  shared_ptr<long> themeLevel{};

  UpdateTableRequestThemes() {}

  explicit UpdateTableRequestThemes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    if (themeLevel) {
      res["ThemeLevel"] = boost::any(*themeLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
    if (m.find("ThemeLevel") != m.end() && !m["ThemeLevel"].empty()) {
      themeLevel = make_shared<long>(boost::any_cast<long>(m["ThemeLevel"]));
    }
  }


  virtual ~UpdateTableRequestThemes() = default;
};
class UpdateTableRequest : public Darabonba::Model {
public:
  shared_ptr<long> isView{};
  shared_ptr<long> visibility{};
  shared_ptr<long> lifeCycle{};
  shared_ptr<long> categoryId{};
  shared_ptr<long> logicalLevelId{};
  shared_ptr<long> physicsLevelId{};
  shared_ptr<string> externalTableType{};
  shared_ptr<string> location{};
  shared_ptr<long> projectId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> endpoint{};
  shared_ptr<long> envType{};
  shared_ptr<string> appGuid{};
  shared_ptr<bool> createIfNotExists{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> hasPart{};
  shared_ptr<string> comment{};
  shared_ptr<vector<UpdateTableRequestColumns>> columns{};
  shared_ptr<vector<UpdateTableRequestThemes>> themes{};

  UpdateTableRequest() {}

  explicit UpdateTableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isView) {
      res["IsView"] = boost::any(*isView);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (lifeCycle) {
      res["LifeCycle"] = boost::any(*lifeCycle);
    }
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (logicalLevelId) {
      res["LogicalLevelId"] = boost::any(*logicalLevelId);
    }
    if (physicsLevelId) {
      res["PhysicsLevelId"] = boost::any(*physicsLevelId);
    }
    if (externalTableType) {
      res["ExternalTableType"] = boost::any(*externalTableType);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (envType) {
      res["EnvType"] = boost::any(*envType);
    }
    if (appGuid) {
      res["AppGuid"] = boost::any(*appGuid);
    }
    if (createIfNotExists) {
      res["CreateIfNotExists"] = boost::any(*createIfNotExists);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (hasPart) {
      res["HasPart"] = boost::any(*hasPart);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (themes) {
      vector<boost::any> temp1;
      for(auto item1:*themes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Themes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsView") != m.end() && !m["IsView"].empty()) {
      isView = make_shared<long>(boost::any_cast<long>(m["IsView"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<long>(boost::any_cast<long>(m["Visibility"]));
    }
    if (m.find("LifeCycle") != m.end() && !m["LifeCycle"].empty()) {
      lifeCycle = make_shared<long>(boost::any_cast<long>(m["LifeCycle"]));
    }
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<long>(boost::any_cast<long>(m["CategoryId"]));
    }
    if (m.find("LogicalLevelId") != m.end() && !m["LogicalLevelId"].empty()) {
      logicalLevelId = make_shared<long>(boost::any_cast<long>(m["LogicalLevelId"]));
    }
    if (m.find("PhysicsLevelId") != m.end() && !m["PhysicsLevelId"].empty()) {
      physicsLevelId = make_shared<long>(boost::any_cast<long>(m["PhysicsLevelId"]));
    }
    if (m.find("ExternalTableType") != m.end() && !m["ExternalTableType"].empty()) {
      externalTableType = make_shared<string>(boost::any_cast<string>(m["ExternalTableType"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EnvType") != m.end() && !m["EnvType"].empty()) {
      envType = make_shared<long>(boost::any_cast<long>(m["EnvType"]));
    }
    if (m.find("AppGuid") != m.end() && !m["AppGuid"].empty()) {
      appGuid = make_shared<string>(boost::any_cast<string>(m["AppGuid"]));
    }
    if (m.find("CreateIfNotExists") != m.end() && !m["CreateIfNotExists"].empty()) {
      createIfNotExists = make_shared<bool>(boost::any_cast<bool>(m["CreateIfNotExists"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("HasPart") != m.end() && !m["HasPart"].empty()) {
      hasPart = make_shared<long>(boost::any_cast<long>(m["HasPart"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<UpdateTableRequestColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTableRequestColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<UpdateTableRequestColumns>>(expect1);
      }
    }
    if (m.find("Themes") != m.end() && !m["Themes"].empty()) {
      if (typeid(vector<boost::any>) == m["Themes"].type()) {
        vector<UpdateTableRequestThemes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Themes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTableRequestThemes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        themes = make_shared<vector<UpdateTableRequestThemes>>(expect1);
      }
    }
  }


  virtual ~UpdateTableRequest() = default;
};
class UpdateTableResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};

  UpdateTableResponseBodyTaskInfo() {}

  explicit UpdateTableResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~UpdateTableResponseBodyTaskInfo() = default;
};
class UpdateTableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateTableResponseBodyTaskInfo> taskInfo{};

  UpdateTableResponseBody() {}

  explicit UpdateTableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        UpdateTableResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<UpdateTableResponseBodyTaskInfo>(model1);
      }
    }
  }


  virtual ~UpdateTableResponseBody() = default;
};
class UpdateTableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateTableResponseBody> body{};

  UpdateTableResponse() {}

  explicit UpdateTableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTableResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTableResponse() = default;
};
class UpdateTableAddColumnRequestColumn : public Darabonba::Model {
public:
  shared_ptr<string> columnNameCn{};
  shared_ptr<string> columnName{};
  shared_ptr<string> comment{};
  shared_ptr<string> columnType{};

  UpdateTableAddColumnRequestColumn() {}

  explicit UpdateTableAddColumnRequestColumn(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnNameCn) {
      res["ColumnNameCn"] = boost::any(*columnNameCn);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnNameCn") != m.end() && !m["ColumnNameCn"].empty()) {
      columnNameCn = make_shared<string>(boost::any_cast<string>(m["ColumnNameCn"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
  }


  virtual ~UpdateTableAddColumnRequestColumn() = default;
};
class UpdateTableAddColumnRequest : public Darabonba::Model {
public:
  shared_ptr<string> tableGuid{};
  shared_ptr<vector<UpdateTableAddColumnRequestColumn>> column{};

  UpdateTableAddColumnRequest() {}

  explicit UpdateTableAddColumnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (column) {
      vector<boost::any> temp1;
      for(auto item1:*column){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Column"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("Column") != m.end() && !m["Column"].empty()) {
      if (typeid(vector<boost::any>) == m["Column"].type()) {
        vector<UpdateTableAddColumnRequestColumn> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Column"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTableAddColumnRequestColumn model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        column = make_shared<vector<UpdateTableAddColumnRequestColumn>>(expect1);
      }
    }
  }


  virtual ~UpdateTableAddColumnRequest() = default;
};
class UpdateTableAddColumnResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> nextTaskId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> content{};

  UpdateTableAddColumnResponseBodyTaskInfo() {}

  explicit UpdateTableAddColumnResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (nextTaskId) {
      res["NextTaskId"] = boost::any(*nextTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("NextTaskId") != m.end() && !m["NextTaskId"].empty()) {
      nextTaskId = make_shared<string>(boost::any_cast<string>(m["NextTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~UpdateTableAddColumnResponseBodyTaskInfo() = default;
};
class UpdateTableAddColumnResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateTableAddColumnResponseBodyTaskInfo> taskInfo{};

  UpdateTableAddColumnResponseBody() {}

  explicit UpdateTableAddColumnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        UpdateTableAddColumnResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<UpdateTableAddColumnResponseBodyTaskInfo>(model1);
      }
    }
  }


  virtual ~UpdateTableAddColumnResponseBody() = default;
};
class UpdateTableAddColumnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateTableAddColumnResponseBody> body{};

  UpdateTableAddColumnResponse() {}

  explicit UpdateTableAddColumnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTableAddColumnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTableAddColumnResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTableAddColumnResponse() = default;
};
class UpdateTableLevelRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<long> levelType{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<long> levelId{};

  UpdateTableLevelRequest() {}

  explicit UpdateTableLevelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (levelType) {
      res["LevelType"] = boost::any(*levelType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("LevelType") != m.end() && !m["LevelType"].empty()) {
      levelType = make_shared<long>(boost::any_cast<long>(m["LevelType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
  }


  virtual ~UpdateTableLevelRequest() = default;
};
class UpdateTableLevelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> updateResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  UpdateTableLevelResponseBody() {}

  explicit UpdateTableLevelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (updateResult) {
      res["UpdateResult"] = boost::any(*updateResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      updateResult = make_shared<bool>(boost::any_cast<bool>(m["UpdateResult"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTableLevelResponseBody() = default;
};
class UpdateTableLevelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateTableLevelResponseBody> body{};

  UpdateTableLevelResponse() {}

  explicit UpdateTableLevelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTableLevelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTableLevelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTableLevelResponse() = default;
};
class UpdateTableModelInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> firstLevelThemeId{};
  shared_ptr<long> secondLevelThemeId{};
  shared_ptr<long> levelId{};
  shared_ptr<string> tableGuid{};
  shared_ptr<long> levelType{};

  UpdateTableModelInfoRequest() {}

  explicit UpdateTableModelInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstLevelThemeId) {
      res["FirstLevelThemeId"] = boost::any(*firstLevelThemeId);
    }
    if (secondLevelThemeId) {
      res["SecondLevelThemeId"] = boost::any(*secondLevelThemeId);
    }
    if (levelId) {
      res["LevelId"] = boost::any(*levelId);
    }
    if (tableGuid) {
      res["TableGuid"] = boost::any(*tableGuid);
    }
    if (levelType) {
      res["LevelType"] = boost::any(*levelType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstLevelThemeId") != m.end() && !m["FirstLevelThemeId"].empty()) {
      firstLevelThemeId = make_shared<long>(boost::any_cast<long>(m["FirstLevelThemeId"]));
    }
    if (m.find("SecondLevelThemeId") != m.end() && !m["SecondLevelThemeId"].empty()) {
      secondLevelThemeId = make_shared<long>(boost::any_cast<long>(m["SecondLevelThemeId"]));
    }
    if (m.find("LevelId") != m.end() && !m["LevelId"].empty()) {
      levelId = make_shared<long>(boost::any_cast<long>(m["LevelId"]));
    }
    if (m.find("TableGuid") != m.end() && !m["TableGuid"].empty()) {
      tableGuid = make_shared<string>(boost::any_cast<string>(m["TableGuid"]));
    }
    if (m.find("LevelType") != m.end() && !m["LevelType"].empty()) {
      levelType = make_shared<long>(boost::any_cast<long>(m["LevelType"]));
    }
  }


  virtual ~UpdateTableModelInfoRequest() = default;
};
class UpdateTableModelInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> updateResult{};
  shared_ptr<string> requestId{};

  UpdateTableModelInfoResponseBody() {}

  explicit UpdateTableModelInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (updateResult) {
      res["UpdateResult"] = boost::any(*updateResult);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      updateResult = make_shared<bool>(boost::any_cast<bool>(m["UpdateResult"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateTableModelInfoResponseBody() = default;
};
class UpdateTableModelInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateTableModelInfoResponseBody> body{};

  UpdateTableModelInfoResponse() {}

  explicit UpdateTableModelInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTableModelInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTableModelInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTableModelInfoResponse() = default;
};
class UpdateTableThemeRequest : public Darabonba::Model {
public:
  shared_ptr<long> projectId{};
  shared_ptr<string> name{};
  shared_ptr<long> themeId{};

  UpdateTableThemeRequest() {}

  explicit UpdateTableThemeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (themeId) {
      res["ThemeId"] = boost::any(*themeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ThemeId") != m.end() && !m["ThemeId"].empty()) {
      themeId = make_shared<long>(boost::any_cast<long>(m["ThemeId"]));
    }
  }


  virtual ~UpdateTableThemeRequest() = default;
};
class UpdateTableThemeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorMessage{};
  shared_ptr<bool> updateResult{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  UpdateTableThemeResponseBody() {}

  explicit UpdateTableThemeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (updateResult) {
      res["UpdateResult"] = boost::any(*updateResult);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      updateResult = make_shared<bool>(boost::any_cast<bool>(m["UpdateResult"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTableThemeResponseBody() = default;
};
class UpdateTableThemeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateTableThemeResponseBody> body{};

  UpdateTableThemeResponse() {}

  explicit UpdateTableThemeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTableThemeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTableThemeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTableThemeResponse() = default;
};
class UpdateUdfFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileFolderPath{};
  shared_ptr<long> projectId{};
  shared_ptr<string> functionType{};
  shared_ptr<string> className{};
  shared_ptr<string> resources{};
  shared_ptr<string> udfDescription{};
  shared_ptr<string> cmdDescription{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> returnValue{};
  shared_ptr<string> example{};
  shared_ptr<string> projectIdentifier{};
  shared_ptr<string> fileId{};

  UpdateUdfFileRequest() {}

  explicit UpdateUdfFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileFolderPath) {
      res["FileFolderPath"] = boost::any(*fileFolderPath);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (functionType) {
      res["FunctionType"] = boost::any(*functionType);
    }
    if (className) {
      res["ClassName"] = boost::any(*className);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (udfDescription) {
      res["UdfDescription"] = boost::any(*udfDescription);
    }
    if (cmdDescription) {
      res["CmdDescription"] = boost::any(*cmdDescription);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (returnValue) {
      res["ReturnValue"] = boost::any(*returnValue);
    }
    if (example) {
      res["Example"] = boost::any(*example);
    }
    if (projectIdentifier) {
      res["ProjectIdentifier"] = boost::any(*projectIdentifier);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileFolderPath") != m.end() && !m["FileFolderPath"].empty()) {
      fileFolderPath = make_shared<string>(boost::any_cast<string>(m["FileFolderPath"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("FunctionType") != m.end() && !m["FunctionType"].empty()) {
      functionType = make_shared<string>(boost::any_cast<string>(m["FunctionType"]));
    }
    if (m.find("ClassName") != m.end() && !m["ClassName"].empty()) {
      className = make_shared<string>(boost::any_cast<string>(m["ClassName"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("UdfDescription") != m.end() && !m["UdfDescription"].empty()) {
      udfDescription = make_shared<string>(boost::any_cast<string>(m["UdfDescription"]));
    }
    if (m.find("CmdDescription") != m.end() && !m["CmdDescription"].empty()) {
      cmdDescription = make_shared<string>(boost::any_cast<string>(m["CmdDescription"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ReturnValue") != m.end() && !m["ReturnValue"].empty()) {
      returnValue = make_shared<string>(boost::any_cast<string>(m["ReturnValue"]));
    }
    if (m.find("Example") != m.end() && !m["Example"].empty()) {
      example = make_shared<string>(boost::any_cast<string>(m["Example"]));
    }
    if (m.find("ProjectIdentifier") != m.end() && !m["ProjectIdentifier"].empty()) {
      projectIdentifier = make_shared<string>(boost::any_cast<string>(m["ProjectIdentifier"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
  }


  virtual ~UpdateUdfFileRequest() = default;
};
class UpdateUdfFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<string> errorCode{};
  shared_ptr<bool> success{};

  UpdateUdfFileResponseBody() {}

  explicit UpdateUdfFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateUdfFileResponseBody() = default;
};
class UpdateUdfFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateUdfFileResponseBody> body{};

  UpdateUdfFileResponse() {}

  explicit UpdateUdfFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUdfFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUdfFileResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUdfFileResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbolishDataServiceApiResponse abolishDataServiceApiWithOptions(shared_ptr<AbolishDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbolishDataServiceApiResponse abolishDataServiceApi(shared_ptr<AbolishDataServiceApiRequest> request);
  AddProjectMemberToRoleResponse addProjectMemberToRoleWithOptions(shared_ptr<AddProjectMemberToRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddProjectMemberToRoleResponse addProjectMemberToRole(shared_ptr<AddProjectMemberToRoleRequest> request);
  AddToMetaCategoryResponse addToMetaCategoryWithOptions(shared_ptr<AddToMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddToMetaCategoryResponse addToMetaCategory(shared_ptr<AddToMetaCategoryRequest> request);
  ApprovePermissionApplyOrderResponse approvePermissionApplyOrderWithOptions(shared_ptr<ApprovePermissionApplyOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApprovePermissionApplyOrderResponse approvePermissionApplyOrder(shared_ptr<ApprovePermissionApplyOrderRequest> request);
  CheckFileDeploymentResponse checkFileDeploymentWithOptions(shared_ptr<CheckFileDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckFileDeploymentResponse checkFileDeployment(shared_ptr<CheckFileDeploymentRequest> request);
  CheckMetaPartitionResponse checkMetaPartitionWithOptions(shared_ptr<CheckMetaPartitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckMetaPartitionResponse checkMetaPartition(shared_ptr<CheckMetaPartitionRequest> request);
  CheckMetaTableResponse checkMetaTableWithOptions(shared_ptr<CheckMetaTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckMetaTableResponse checkMetaTable(shared_ptr<CheckMetaTableRequest> request);
  CreateBusinessResponse createBusinessWithOptions(shared_ptr<CreateBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBusinessResponse createBusiness(shared_ptr<CreateBusinessRequest> request);
  CreateConnectionResponse createConnectionWithOptions(shared_ptr<CreateConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConnectionResponse createConnection(shared_ptr<CreateConnectionRequest> request);
  CreateDagComplementResponse createDagComplementWithOptions(shared_ptr<CreateDagComplementRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDagComplementResponse createDagComplement(shared_ptr<CreateDagComplementRequest> request);
  CreateDagTestResponse createDagTestWithOptions(shared_ptr<CreateDagTestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDagTestResponse createDagTest(shared_ptr<CreateDagTestRequest> request);
  CreateDataServiceApiResponse createDataServiceApiWithOptions(shared_ptr<CreateDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataServiceApiResponse createDataServiceApi(shared_ptr<CreateDataServiceApiRequest> request);
  CreateDataServiceApiAuthorityResponse createDataServiceApiAuthorityWithOptions(shared_ptr<CreateDataServiceApiAuthorityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataServiceApiAuthorityResponse createDataServiceApiAuthority(shared_ptr<CreateDataServiceApiAuthorityRequest> request);
  CreateDataServiceFolderResponse createDataServiceFolderWithOptions(shared_ptr<CreateDataServiceFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataServiceFolderResponse createDataServiceFolder(shared_ptr<CreateDataServiceFolderRequest> request);
  CreateDataServiceGroupResponse createDataServiceGroupWithOptions(shared_ptr<CreateDataServiceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataServiceGroupResponse createDataServiceGroup(shared_ptr<CreateDataServiceGroupRequest> request);
  CreateDataSourceResponse createDataSourceWithOptions(shared_ptr<CreateDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataSourceResponse createDataSource(shared_ptr<CreateDataSourceRequest> request);
  CreateFileResponse createFileWithOptions(shared_ptr<CreateFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFileResponse createFile(shared_ptr<CreateFileRequest> request);
  CreateFolderResponse createFolderWithOptions(shared_ptr<CreateFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFolderResponse createFolder(shared_ptr<CreateFolderRequest> request);
  CreateImportMigrationResponse createImportMigrationWithOptions(shared_ptr<CreateImportMigrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImportMigrationResponse createImportMigration(shared_ptr<CreateImportMigrationRequest> request);
  CreateImportMigrationResponse createImportMigrationAdvance(shared_ptr<CreateImportMigrationAdvanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateManualDagResponse createManualDagWithOptions(shared_ptr<CreateManualDagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateManualDagResponse createManualDag(shared_ptr<CreateManualDagRequest> request);
  CreateMetaCategoryResponse createMetaCategoryWithOptions(shared_ptr<CreateMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMetaCategoryResponse createMetaCategory(shared_ptr<CreateMetaCategoryRequest> request);
  CreatePermissionApplyOrderResponse createPermissionApplyOrderWithOptions(shared_ptr<CreatePermissionApplyOrderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePermissionApplyOrderResponse createPermissionApplyOrder(shared_ptr<CreatePermissionApplyOrderRequest> request);
  CreateProjectMemberResponse createProjectMemberWithOptions(shared_ptr<CreateProjectMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectMemberResponse createProjectMember(shared_ptr<CreateProjectMemberRequest> request);
  CreateQualityEntityResponse createQualityEntityWithOptions(shared_ptr<CreateQualityEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQualityEntityResponse createQualityEntity(shared_ptr<CreateQualityEntityRequest> request);
  CreateQualityFollowerResponse createQualityFollowerWithOptions(shared_ptr<CreateQualityFollowerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQualityFollowerResponse createQualityFollower(shared_ptr<CreateQualityFollowerRequest> request);
  CreateQualityRelativeNodeResponse createQualityRelativeNodeWithOptions(shared_ptr<CreateQualityRelativeNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQualityRelativeNodeResponse createQualityRelativeNode(shared_ptr<CreateQualityRelativeNodeRequest> request);
  CreateQualityRuleResponse createQualityRuleWithOptions(shared_ptr<CreateQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQualityRuleResponse createQualityRule(shared_ptr<CreateQualityRuleRequest> request);
  CreateRemindResponse createRemindWithOptions(shared_ptr<CreateRemindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRemindResponse createRemind(shared_ptr<CreateRemindRequest> request);
  CreateTableResponse createTableWithOptions(shared_ptr<CreateTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTableResponse createTable(shared_ptr<CreateTableRequest> request);
  CreateTableLevelResponse createTableLevelWithOptions(shared_ptr<CreateTableLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTableLevelResponse createTableLevel(shared_ptr<CreateTableLevelRequest> request);
  CreateTableThemeResponse createTableThemeWithOptions(shared_ptr<CreateTableThemeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTableThemeResponse createTableTheme(shared_ptr<CreateTableThemeRequest> request);
  CreateUdfFileResponse createUdfFileWithOptions(shared_ptr<CreateUdfFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUdfFileResponse createUdfFile(shared_ptr<CreateUdfFileRequest> request);
  CreateViewResponse createViewWithOptions(shared_ptr<CreateViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateViewResponse createView(shared_ptr<CreateViewRequest> request);
  DeleteBusinessResponse deleteBusinessWithOptions(shared_ptr<DeleteBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBusinessResponse deleteBusiness(shared_ptr<DeleteBusinessRequest> request);
  DeleteConnectionResponse deleteConnectionWithOptions(shared_ptr<DeleteConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConnectionResponse deleteConnection(shared_ptr<DeleteConnectionRequest> request);
  DeleteDataServiceApiResponse deleteDataServiceApiWithOptions(shared_ptr<DeleteDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataServiceApiResponse deleteDataServiceApi(shared_ptr<DeleteDataServiceApiRequest> request);
  DeleteDataServiceApiAuthorityResponse deleteDataServiceApiAuthorityWithOptions(shared_ptr<DeleteDataServiceApiAuthorityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataServiceApiAuthorityResponse deleteDataServiceApiAuthority(shared_ptr<DeleteDataServiceApiAuthorityRequest> request);
  DeleteDataSourceResponse deleteDataSourceWithOptions(shared_ptr<DeleteDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataSourceResponse deleteDataSource(shared_ptr<DeleteDataSourceRequest> request);
  DeleteFileResponse deleteFileWithOptions(shared_ptr<DeleteFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFileResponse deleteFile(shared_ptr<DeleteFileRequest> request);
  DeleteFolderResponse deleteFolderWithOptions(shared_ptr<DeleteFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFolderResponse deleteFolder(shared_ptr<DeleteFolderRequest> request);
  DeleteFromMetaCategoryResponse deleteFromMetaCategoryWithOptions(shared_ptr<DeleteFromMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFromMetaCategoryResponse deleteFromMetaCategory(shared_ptr<DeleteFromMetaCategoryRequest> request);
  DeleteMetaCategoryResponse deleteMetaCategoryWithOptions(shared_ptr<DeleteMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMetaCategoryResponse deleteMetaCategory(shared_ptr<DeleteMetaCategoryRequest> request);
  DeleteProjectMemberResponse deleteProjectMemberWithOptions(shared_ptr<DeleteProjectMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectMemberResponse deleteProjectMember(shared_ptr<DeleteProjectMemberRequest> request);
  DeleteQualityEntityResponse deleteQualityEntityWithOptions(shared_ptr<DeleteQualityEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQualityEntityResponse deleteQualityEntity(shared_ptr<DeleteQualityEntityRequest> request);
  DeleteQualityFollowerResponse deleteQualityFollowerWithOptions(shared_ptr<DeleteQualityFollowerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQualityFollowerResponse deleteQualityFollower(shared_ptr<DeleteQualityFollowerRequest> request);
  DeleteQualityRelativeNodeResponse deleteQualityRelativeNodeWithOptions(shared_ptr<DeleteQualityRelativeNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQualityRelativeNodeResponse deleteQualityRelativeNode(shared_ptr<DeleteQualityRelativeNodeRequest> request);
  DeleteQualityRuleResponse deleteQualityRuleWithOptions(shared_ptr<DeleteQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQualityRuleResponse deleteQualityRule(shared_ptr<DeleteQualityRuleRequest> request);
  DeleteRemindResponse deleteRemindWithOptions(shared_ptr<DeleteRemindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRemindResponse deleteRemind(shared_ptr<DeleteRemindRequest> request);
  DeleteTableResponse deleteTableWithOptions(shared_ptr<DeleteTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTableResponse deleteTable(shared_ptr<DeleteTableRequest> request);
  DeleteTableLevelResponse deleteTableLevelWithOptions(shared_ptr<DeleteTableLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTableLevelResponse deleteTableLevel(shared_ptr<DeleteTableLevelRequest> request);
  DeleteTableThemeResponse deleteTableThemeWithOptions(shared_ptr<DeleteTableThemeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTableThemeResponse deleteTableTheme(shared_ptr<DeleteTableThemeRequest> request);
  DeleteViewResponse deleteViewWithOptions(shared_ptr<DeleteViewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteViewResponse deleteView(shared_ptr<DeleteViewRequest> request);
  DeployFileResponse deployFileWithOptions(shared_ptr<DeployFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployFileResponse deployFile(shared_ptr<DeployFileRequest> request);
  DesensitizeDataResponse desensitizeDataWithOptions(shared_ptr<DesensitizeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DesensitizeDataResponse desensitizeData(shared_ptr<DesensitizeDataRequest> request);
  EstablishRelationTableToBusinessResponse establishRelationTableToBusinessWithOptions(shared_ptr<EstablishRelationTableToBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EstablishRelationTableToBusinessResponse establishRelationTableToBusiness(shared_ptr<EstablishRelationTableToBusinessRequest> request);
  ExportDISyncTasksResponse exportDISyncTasksWithOptions(shared_ptr<ExportDISyncTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportDISyncTasksResponse exportDISyncTasks(shared_ptr<ExportDISyncTasksRequest> request);
  GetBaselineConfigResponse getBaselineConfigWithOptions(shared_ptr<GetBaselineConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBaselineConfigResponse getBaselineConfig(shared_ptr<GetBaselineConfigRequest> request);
  GetBaselineKeyPathResponse getBaselineKeyPathWithOptions(shared_ptr<GetBaselineKeyPathRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBaselineKeyPathResponse getBaselineKeyPath(shared_ptr<GetBaselineKeyPathRequest> request);
  GetBaselineStatusResponse getBaselineStatusWithOptions(shared_ptr<GetBaselineStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBaselineStatusResponse getBaselineStatus(shared_ptr<GetBaselineStatusRequest> request);
  GetBusinessResponse getBusinessWithOptions(shared_ptr<GetBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBusinessResponse getBusiness(shared_ptr<GetBusinessRequest> request);
  GetDagResponse getDagWithOptions(shared_ptr<GetDagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDagResponse getDag(shared_ptr<GetDagRequest> request);
  GetDataServiceApiResponse getDataServiceApiWithOptions(shared_ptr<GetDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataServiceApiResponse getDataServiceApi(shared_ptr<GetDataServiceApiRequest> request);
  GetDataServiceApplicationResponse getDataServiceApplicationWithOptions(shared_ptr<GetDataServiceApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataServiceApplicationResponse getDataServiceApplication(shared_ptr<GetDataServiceApplicationRequest> request);
  GetDataServiceFolderResponse getDataServiceFolderWithOptions(shared_ptr<GetDataServiceFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataServiceFolderResponse getDataServiceFolder(shared_ptr<GetDataServiceFolderRequest> request);
  GetDataServiceGroupResponse getDataServiceGroupWithOptions(shared_ptr<GetDataServiceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataServiceGroupResponse getDataServiceGroup(shared_ptr<GetDataServiceGroupRequest> request);
  GetDataServicePublishedApiResponse getDataServicePublishedApiWithOptions(shared_ptr<GetDataServicePublishedApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataServicePublishedApiResponse getDataServicePublishedApi(shared_ptr<GetDataServicePublishedApiRequest> request);
  GetDDLJobStatusResponse getDDLJobStatusWithOptions(shared_ptr<GetDDLJobStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDDLJobStatusResponse getDDLJobStatus(shared_ptr<GetDDLJobStatusRequest> request);
  GetDeploymentResponse getDeploymentWithOptions(shared_ptr<GetDeploymentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeploymentResponse getDeployment(shared_ptr<GetDeploymentRequest> request);
  GetFileResponse getFileWithOptions(shared_ptr<GetFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileResponse getFile(shared_ptr<GetFileRequest> request);
  GetFileTypeStatisticResponse getFileTypeStatisticWithOptions(shared_ptr<GetFileTypeStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileTypeStatisticResponse getFileTypeStatistic(shared_ptr<GetFileTypeStatisticRequest> request);
  GetFileVersionResponse getFileVersionWithOptions(shared_ptr<GetFileVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileVersionResponse getFileVersion(shared_ptr<GetFileVersionRequest> request);
  GetFolderResponse getFolderWithOptions(shared_ptr<GetFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFolderResponse getFolder(shared_ptr<GetFolderRequest> request);
  GetInstanceResponse getInstanceWithOptions(shared_ptr<GetInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceResponse getInstance(shared_ptr<GetInstanceRequest> request);
  GetInstanceConsumeTimeRankResponse getInstanceConsumeTimeRankWithOptions(shared_ptr<GetInstanceConsumeTimeRankRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceConsumeTimeRankResponse getInstanceConsumeTimeRank(shared_ptr<GetInstanceConsumeTimeRankRequest> request);
  GetInstanceCountTrendResponse getInstanceCountTrendWithOptions(shared_ptr<GetInstanceCountTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceCountTrendResponse getInstanceCountTrend(shared_ptr<GetInstanceCountTrendRequest> request);
  GetInstanceErrorRankResponse getInstanceErrorRankWithOptions(shared_ptr<GetInstanceErrorRankRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceErrorRankResponse getInstanceErrorRank(shared_ptr<GetInstanceErrorRankRequest> request);
  GetInstanceLogResponse getInstanceLogWithOptions(shared_ptr<GetInstanceLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceLogResponse getInstanceLog(shared_ptr<GetInstanceLogRequest> request);
  GetInstanceStatusCountResponse getInstanceStatusCountWithOptions(shared_ptr<GetInstanceStatusCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceStatusCountResponse getInstanceStatusCount(shared_ptr<GetInstanceStatusCountRequest> request);
  GetInstanceStatusStatisticResponse getInstanceStatusStatisticWithOptions(shared_ptr<GetInstanceStatusStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceStatusStatisticResponse getInstanceStatusStatistic(shared_ptr<GetInstanceStatusStatisticRequest> request);
  GetManualDagInstancesResponse getManualDagInstancesWithOptions(shared_ptr<GetManualDagInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetManualDagInstancesResponse getManualDagInstances(shared_ptr<GetManualDagInstancesRequest> request);
  GetMetaCategoryResponse getMetaCategoryWithOptions(shared_ptr<GetMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaCategoryResponse getMetaCategory(shared_ptr<GetMetaCategoryRequest> request);
  GetMetaColumnLineageResponse getMetaColumnLineageWithOptions(shared_ptr<GetMetaColumnLineageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaColumnLineageResponse getMetaColumnLineage(shared_ptr<GetMetaColumnLineageRequest> request);
  GetMetaDBInfoResponse getMetaDBInfoWithOptions(shared_ptr<GetMetaDBInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaDBInfoResponse getMetaDBInfo(shared_ptr<GetMetaDBInfoRequest> request);
  GetMetaDBTableListResponse getMetaDBTableListWithOptions(shared_ptr<GetMetaDBTableListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaDBTableListResponse getMetaDBTableList(shared_ptr<GetMetaDBTableListRequest> request);
  GetMetaTableBasicInfoResponse getMetaTableBasicInfoWithOptions(shared_ptr<GetMetaTableBasicInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableBasicInfoResponse getMetaTableBasicInfo(shared_ptr<GetMetaTableBasicInfoRequest> request);
  GetMetaTableChangeLogResponse getMetaTableChangeLogWithOptions(shared_ptr<GetMetaTableChangeLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableChangeLogResponse getMetaTableChangeLog(shared_ptr<GetMetaTableChangeLogRequest> request);
  GetMetaTableColumnResponse getMetaTableColumnWithOptions(shared_ptr<GetMetaTableColumnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableColumnResponse getMetaTableColumn(shared_ptr<GetMetaTableColumnRequest> request);
  GetMetaTableFullInfoResponse getMetaTableFullInfoWithOptions(shared_ptr<GetMetaTableFullInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableFullInfoResponse getMetaTableFullInfo(shared_ptr<GetMetaTableFullInfoRequest> request);
  GetMetaTableIntroWikiResponse getMetaTableIntroWikiWithOptions(shared_ptr<GetMetaTableIntroWikiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableIntroWikiResponse getMetaTableIntroWiki(shared_ptr<GetMetaTableIntroWikiRequest> request);
  GetMetaTableLineageResponse getMetaTableLineageWithOptions(shared_ptr<GetMetaTableLineageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableLineageResponse getMetaTableLineage(shared_ptr<GetMetaTableLineageRequest> request);
  GetMetaTableListByCategoryResponse getMetaTableListByCategoryWithOptions(shared_ptr<GetMetaTableListByCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableListByCategoryResponse getMetaTableListByCategory(shared_ptr<GetMetaTableListByCategoryRequest> request);
  GetMetaTableOutputResponse getMetaTableOutputWithOptions(shared_ptr<GetMetaTableOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableOutputResponse getMetaTableOutput(shared_ptr<GetMetaTableOutputRequest> request);
  GetMetaTablePartitionResponse getMetaTablePartitionWithOptions(shared_ptr<GetMetaTablePartitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTablePartitionResponse getMetaTablePartition(shared_ptr<GetMetaTablePartitionRequest> request);
  GetMetaTableThemeLevelResponse getMetaTableThemeLevelWithOptions(shared_ptr<GetMetaTableThemeLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMetaTableThemeLevelResponse getMetaTableThemeLevel(shared_ptr<GetMetaTableThemeLevelRequest> request);
  GetMigrationProcessResponse getMigrationProcessWithOptions(shared_ptr<GetMigrationProcessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMigrationProcessResponse getMigrationProcess(shared_ptr<GetMigrationProcessRequest> request);
  GetNodeResponse getNodeWithOptions(shared_ptr<GetNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeResponse getNode(shared_ptr<GetNodeRequest> request);
  GetNodeChildrenResponse getNodeChildrenWithOptions(shared_ptr<GetNodeChildrenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeChildrenResponse getNodeChildren(shared_ptr<GetNodeChildrenRequest> request);
  GetNodeCodeResponse getNodeCodeWithOptions(shared_ptr<GetNodeCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeCodeResponse getNodeCode(shared_ptr<GetNodeCodeRequest> request);
  GetNodeOnBaselineResponse getNodeOnBaselineWithOptions(shared_ptr<GetNodeOnBaselineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeOnBaselineResponse getNodeOnBaseline(shared_ptr<GetNodeOnBaselineRequest> request);
  GetNodeParentsResponse getNodeParentsWithOptions(shared_ptr<GetNodeParentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeParentsResponse getNodeParents(shared_ptr<GetNodeParentsRequest> request);
  GetNodeTypeListInfoResponse getNodeTypeListInfoWithOptions(shared_ptr<GetNodeTypeListInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeTypeListInfoResponse getNodeTypeListInfo(shared_ptr<GetNodeTypeListInfoRequest> request);
  GetOpRiskDataResponse getOpRiskDataWithOptions(shared_ptr<GetOpRiskDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOpRiskDataResponse getOpRiskData(shared_ptr<GetOpRiskDataRequest> request);
  GetOpSensitiveDataResponse getOpSensitiveDataWithOptions(shared_ptr<GetOpSensitiveDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOpSensitiveDataResponse getOpSensitiveData(shared_ptr<GetOpSensitiveDataRequest> request);
  GetPermissionApplyOrderDetailResponse getPermissionApplyOrderDetailWithOptions(shared_ptr<GetPermissionApplyOrderDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPermissionApplyOrderDetailResponse getPermissionApplyOrderDetail(shared_ptr<GetPermissionApplyOrderDetailRequest> request);
  GetProjectResponse getProjectWithOptions(shared_ptr<GetProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectResponse getProject(shared_ptr<GetProjectRequest> request);
  GetProjectDetailResponse getProjectDetailWithOptions(shared_ptr<GetProjectDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectDetailResponse getProjectDetail(shared_ptr<GetProjectDetailRequest> request);
  GetQualityEntityResponse getQualityEntityWithOptions(shared_ptr<GetQualityEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQualityEntityResponse getQualityEntity(shared_ptr<GetQualityEntityRequest> request);
  GetQualityFollowerResponse getQualityFollowerWithOptions(shared_ptr<GetQualityFollowerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQualityFollowerResponse getQualityFollower(shared_ptr<GetQualityFollowerRequest> request);
  GetQualityRuleResponse getQualityRuleWithOptions(shared_ptr<GetQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQualityRuleResponse getQualityRule(shared_ptr<GetQualityRuleRequest> request);
  GetRemindResponse getRemindWithOptions(shared_ptr<GetRemindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRemindResponse getRemind(shared_ptr<GetRemindRequest> request);
  GetSensitiveDataResponse getSensitiveDataWithOptions(shared_ptr<GetSensitiveDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSensitiveDataResponse getSensitiveData(shared_ptr<GetSensitiveDataRequest> request);
  GetSuccessInstanceTrendResponse getSuccessInstanceTrendWithOptions(shared_ptr<GetSuccessInstanceTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSuccessInstanceTrendResponse getSuccessInstanceTrend(shared_ptr<GetSuccessInstanceTrendRequest> request);
  GetTopicResponse getTopicWithOptions(shared_ptr<GetTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTopicResponse getTopic(shared_ptr<GetTopicRequest> request);
  GetTopicInfluenceResponse getTopicInfluenceWithOptions(shared_ptr<GetTopicInfluenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTopicInfluenceResponse getTopicInfluence(shared_ptr<GetTopicInfluenceRequest> request);
  ImportDISyncTasksResponse importDISyncTasksWithOptions(shared_ptr<ImportDISyncTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportDISyncTasksResponse importDISyncTasks(shared_ptr<ImportDISyncTasksRequest> request);
  ListAlertMessagesResponse listAlertMessagesWithOptions(shared_ptr<ListAlertMessagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertMessagesResponse listAlertMessages(shared_ptr<ListAlertMessagesRequest> request);
  ListBaselineConfigsResponse listBaselineConfigsWithOptions(shared_ptr<ListBaselineConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBaselineConfigsResponse listBaselineConfigs(shared_ptr<ListBaselineConfigsRequest> request);
  ListBaselineStatusesResponse listBaselineStatusesWithOptions(shared_ptr<ListBaselineStatusesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBaselineStatusesResponse listBaselineStatuses(shared_ptr<ListBaselineStatusesRequest> request);
  ListBusinessResponse listBusinessWithOptions(shared_ptr<ListBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBusinessResponse listBusiness(shared_ptr<ListBusinessRequest> request);
  ListCalcEnginesResponse listCalcEnginesWithOptions(shared_ptr<ListCalcEnginesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCalcEnginesResponse listCalcEngines(shared_ptr<ListCalcEnginesRequest> request);
  ListConnectionsResponse listConnectionsWithOptions(shared_ptr<ListConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConnectionsResponse listConnections(shared_ptr<ListConnectionsRequest> request);
  ListDataServiceApiAuthoritiesResponse listDataServiceApiAuthoritiesWithOptions(shared_ptr<ListDataServiceApiAuthoritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceApiAuthoritiesResponse listDataServiceApiAuthorities(shared_ptr<ListDataServiceApiAuthoritiesRequest> request);
  ListDataServiceApisResponse listDataServiceApisWithOptions(shared_ptr<ListDataServiceApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceApisResponse listDataServiceApis(shared_ptr<ListDataServiceApisRequest> request);
  ListDataServiceApplicationsResponse listDataServiceApplicationsWithOptions(shared_ptr<ListDataServiceApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceApplicationsResponse listDataServiceApplications(shared_ptr<ListDataServiceApplicationsRequest> request);
  ListDataServiceAuthorizedApisResponse listDataServiceAuthorizedApisWithOptions(shared_ptr<ListDataServiceAuthorizedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceAuthorizedApisResponse listDataServiceAuthorizedApis(shared_ptr<ListDataServiceAuthorizedApisRequest> request);
  ListDataServiceFoldersResponse listDataServiceFoldersWithOptions(shared_ptr<ListDataServiceFoldersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceFoldersResponse listDataServiceFolders(shared_ptr<ListDataServiceFoldersRequest> request);
  ListDataServiceGroupsResponse listDataServiceGroupsWithOptions(shared_ptr<ListDataServiceGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServiceGroupsResponse listDataServiceGroups(shared_ptr<ListDataServiceGroupsRequest> request);
  ListDataServicePublishedApisResponse listDataServicePublishedApisWithOptions(shared_ptr<ListDataServicePublishedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataServicePublishedApisResponse listDataServicePublishedApis(shared_ptr<ListDataServicePublishedApisRequest> request);
  ListDataSourcesResponse listDataSourcesWithOptions(shared_ptr<ListDataSourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataSourcesResponse listDataSources(shared_ptr<ListDataSourcesRequest> request);
  ListDISyncTasksResponse listDISyncTasksWithOptions(shared_ptr<ListDISyncTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDISyncTasksResponse listDISyncTasks(shared_ptr<ListDISyncTasksRequest> request);
  ListFilesResponse listFilesWithOptions(shared_ptr<ListFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFilesResponse listFiles(shared_ptr<ListFilesRequest> request);
  ListFileTypeResponse listFileTypeWithOptions(shared_ptr<ListFileTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFileTypeResponse listFileType(shared_ptr<ListFileTypeRequest> request);
  ListFileVersionsResponse listFileVersionsWithOptions(shared_ptr<ListFileVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFileVersionsResponse listFileVersions(shared_ptr<ListFileVersionsRequest> request);
  ListFoldersResponse listFoldersWithOptions(shared_ptr<ListFoldersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFoldersResponse listFolders(shared_ptr<ListFoldersRequest> request);
  ListInstanceAmountResponse listInstanceAmountWithOptions(shared_ptr<ListInstanceAmountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceAmountResponse listInstanceAmount(shared_ptr<ListInstanceAmountRequest> request);
  ListInstancesResponse listInstancesWithOptions(shared_ptr<ListInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesResponse listInstances(shared_ptr<ListInstancesRequest> request);
  ListManualDagInstancesResponse listManualDagInstancesWithOptions(shared_ptr<ListManualDagInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListManualDagInstancesResponse listManualDagInstances(shared_ptr<ListManualDagInstancesRequest> request);
  ListMetaDBResponse listMetaDBWithOptions(shared_ptr<ListMetaDBRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMetaDBResponse listMetaDB(shared_ptr<ListMetaDBRequest> request);
  ListNodeInputOrOutputResponse listNodeInputOrOutputWithOptions(shared_ptr<ListNodeInputOrOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodeInputOrOutputResponse listNodeInputOrOutput(shared_ptr<ListNodeInputOrOutputRequest> request);
  ListNodeIOResponse listNodeIOWithOptions(shared_ptr<ListNodeIORequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodeIOResponse listNodeIO(shared_ptr<ListNodeIORequest> request);
  ListNodesResponse listNodesWithOptions(shared_ptr<ListNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesResponse listNodes(shared_ptr<ListNodesRequest> request);
  ListNodesByBaselineResponse listNodesByBaselineWithOptions(shared_ptr<ListNodesByBaselineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesByBaselineResponse listNodesByBaseline(shared_ptr<ListNodesByBaselineRequest> request);
  ListNodesByOutputResponse listNodesByOutputWithOptions(shared_ptr<ListNodesByOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesByOutputResponse listNodesByOutput(shared_ptr<ListNodesByOutputRequest> request);
  ListPermissionApplyOrdersResponse listPermissionApplyOrdersWithOptions(shared_ptr<ListPermissionApplyOrdersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPermissionApplyOrdersResponse listPermissionApplyOrders(shared_ptr<ListPermissionApplyOrdersRequest> request);
  ListProgramTypeCountResponse listProgramTypeCountWithOptions(shared_ptr<ListProgramTypeCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProgramTypeCountResponse listProgramTypeCount(shared_ptr<ListProgramTypeCountRequest> request);
  ListProjectMembersResponse listProjectMembersWithOptions(shared_ptr<ListProjectMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectMembersResponse listProjectMembers(shared_ptr<ListProjectMembersRequest> request);
  ListProjectRolesResponse listProjectRolesWithOptions(shared_ptr<ListProjectRolesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectRolesResponse listProjectRoles(shared_ptr<ListProjectRolesRequest> request);
  ListProjectsResponse listProjectsWithOptions(shared_ptr<ListProjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectsResponse listProjects(shared_ptr<ListProjectsRequest> request);
  ListQualityResultsByEntityResponse listQualityResultsByEntityWithOptions(shared_ptr<ListQualityResultsByEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListQualityResultsByEntityResponse listQualityResultsByEntity(shared_ptr<ListQualityResultsByEntityRequest> request);
  ListQualityResultsByRuleResponse listQualityResultsByRuleWithOptions(shared_ptr<ListQualityResultsByRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListQualityResultsByRuleResponse listQualityResultsByRule(shared_ptr<ListQualityResultsByRuleRequest> request);
  ListQualityRulesResponse listQualityRulesWithOptions(shared_ptr<ListQualityRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListQualityRulesResponse listQualityRules(shared_ptr<ListQualityRulesRequest> request);
  ListRemindsResponse listRemindsWithOptions(shared_ptr<ListRemindsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRemindsResponse listReminds(shared_ptr<ListRemindsRequest> request);
  ListResourceGroupsResponse listResourceGroupsWithOptions(shared_ptr<ListResourceGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourceGroupsResponse listResourceGroups(shared_ptr<ListResourceGroupsRequest> request);
  ListSuccessInstanceAmountResponse listSuccessInstanceAmountWithOptions(shared_ptr<ListSuccessInstanceAmountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSuccessInstanceAmountResponse listSuccessInstanceAmount(shared_ptr<ListSuccessInstanceAmountRequest> request);
  ListTableLevelResponse listTableLevelWithOptions(shared_ptr<ListTableLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTableLevelResponse listTableLevel(shared_ptr<ListTableLevelRequest> request);
  ListTableThemeResponse listTableThemeWithOptions(shared_ptr<ListTableThemeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTableThemeResponse listTableTheme(shared_ptr<ListTableThemeRequest> request);
  ListTopicsResponse listTopicsWithOptions(shared_ptr<ListTopicsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTopicsResponse listTopics(shared_ptr<ListTopicsRequest> request);
  PublishDataServiceApiResponse publishDataServiceApiWithOptions(shared_ptr<PublishDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishDataServiceApiResponse publishDataServiceApi(shared_ptr<PublishDataServiceApiRequest> request);
  QueryPublicModelEngineResponse queryPublicModelEngineWithOptions(shared_ptr<QueryPublicModelEngineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPublicModelEngineResponse queryPublicModelEngine(shared_ptr<QueryPublicModelEngineRequest> request);
  RemoveProjectMemberFromRoleResponse removeProjectMemberFromRoleWithOptions(shared_ptr<RemoveProjectMemberFromRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveProjectMemberFromRoleResponse removeProjectMemberFromRole(shared_ptr<RemoveProjectMemberFromRoleRequest> request);
  RestartInstanceResponse restartInstanceWithOptions(shared_ptr<RestartInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartInstanceResponse restartInstance(shared_ptr<RestartInstanceRequest> request);
  ResumeInstanceResponse resumeInstanceWithOptions(shared_ptr<ResumeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeInstanceResponse resumeInstance(shared_ptr<ResumeInstanceRequest> request);
  RevokeColumnPermissionResponse revokeColumnPermissionWithOptions(shared_ptr<RevokeColumnPermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeColumnPermissionResponse revokeColumnPermission(shared_ptr<RevokeColumnPermissionRequest> request);
  RevokeTablePermissionResponse revokeTablePermissionWithOptions(shared_ptr<RevokeTablePermissionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeTablePermissionResponse revokeTablePermission(shared_ptr<RevokeTablePermissionRequest> request);
  RunCycleDagNodesResponse runCycleDagNodesWithOptions(shared_ptr<RunCycleDagNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunCycleDagNodesResponse runCycleDagNodes(shared_ptr<RunCycleDagNodesRequest> request);
  RunManualDagNodesResponse runManualDagNodesWithOptions(shared_ptr<RunManualDagNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunManualDagNodesResponse runManualDagNodes(shared_ptr<RunManualDagNodesRequest> request);
  RunSmokeTestResponse runSmokeTestWithOptions(shared_ptr<RunSmokeTestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunSmokeTestResponse runSmokeTest(shared_ptr<RunSmokeTestRequest> request);
  RunTriggerNodeResponse runTriggerNodeWithOptions(shared_ptr<RunTriggerNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunTriggerNodeResponse runTriggerNode(shared_ptr<RunTriggerNodeRequest> request);
  ScanSensitiveDataResponse scanSensitiveDataWithOptions(shared_ptr<ScanSensitiveDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ScanSensitiveDataResponse scanSensitiveData(shared_ptr<ScanSensitiveDataRequest> request);
  SearchMetaTablesResponse searchMetaTablesWithOptions(shared_ptr<SearchMetaTablesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMetaTablesResponse searchMetaTables(shared_ptr<SearchMetaTablesRequest> request);
  SearchNodesByOutputResponse searchNodesByOutputWithOptions(shared_ptr<SearchNodesByOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchNodesByOutputResponse searchNodesByOutput(shared_ptr<SearchNodesByOutputRequest> request);
  SetSuccessInstanceResponse setSuccessInstanceWithOptions(shared_ptr<SetSuccessInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetSuccessInstanceResponse setSuccessInstance(shared_ptr<SetSuccessInstanceRequest> request);
  StartMigrationResponse startMigrationWithOptions(shared_ptr<StartMigrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartMigrationResponse startMigration(shared_ptr<StartMigrationRequest> request);
  StopInstanceResponse stopInstanceWithOptions(shared_ptr<StopInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopInstanceResponse stopInstance(shared_ptr<StopInstanceRequest> request);
  SubmitFileResponse submitFileWithOptions(shared_ptr<SubmitFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFileResponse submitFile(shared_ptr<SubmitFileRequest> request);
  SuspendInstanceResponse suspendInstanceWithOptions(shared_ptr<SuspendInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendInstanceResponse suspendInstance(shared_ptr<SuspendInstanceRequest> request);
  TopTenElapsedTimeInstanceResponse topTenElapsedTimeInstanceWithOptions(shared_ptr<TopTenElapsedTimeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TopTenElapsedTimeInstanceResponse topTenElapsedTimeInstance(shared_ptr<TopTenElapsedTimeInstanceRequest> request);
  TopTenErrorTimesInstanceResponse topTenErrorTimesInstanceWithOptions(shared_ptr<TopTenErrorTimesInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TopTenErrorTimesInstanceResponse topTenErrorTimesInstance(shared_ptr<TopTenErrorTimesInstanceRequest> request);
  UpdateBusinessResponse updateBusinessWithOptions(shared_ptr<UpdateBusinessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBusinessResponse updateBusiness(shared_ptr<UpdateBusinessRequest> request);
  UpdateConnectionResponse updateConnectionWithOptions(shared_ptr<UpdateConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConnectionResponse updateConnection(shared_ptr<UpdateConnectionRequest> request);
  UpdateDataServiceApiResponse updateDataServiceApiWithOptions(shared_ptr<UpdateDataServiceApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataServiceApiResponse updateDataServiceApi(shared_ptr<UpdateDataServiceApiRequest> request);
  UpdateDataSourceResponse updateDataSourceWithOptions(shared_ptr<UpdateDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataSourceResponse updateDataSource(shared_ptr<UpdateDataSourceRequest> request);
  UpdateFileResponse updateFileWithOptions(shared_ptr<UpdateFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFileResponse updateFile(shared_ptr<UpdateFileRequest> request);
  UpdateFolderResponse updateFolderWithOptions(shared_ptr<UpdateFolderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFolderResponse updateFolder(shared_ptr<UpdateFolderRequest> request);
  UpdateMetaCategoryResponse updateMetaCategoryWithOptions(shared_ptr<UpdateMetaCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMetaCategoryResponse updateMetaCategory(shared_ptr<UpdateMetaCategoryRequest> request);
  UpdateMetaTableResponse updateMetaTableWithOptions(shared_ptr<UpdateMetaTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMetaTableResponse updateMetaTable(shared_ptr<UpdateMetaTableRequest> request);
  UpdateMetaTableIntroWikiResponse updateMetaTableIntroWikiWithOptions(shared_ptr<UpdateMetaTableIntroWikiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMetaTableIntroWikiResponse updateMetaTableIntroWiki(shared_ptr<UpdateMetaTableIntroWikiRequest> request);
  UpdateNodeOwnerResponse updateNodeOwnerWithOptions(shared_ptr<UpdateNodeOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNodeOwnerResponse updateNodeOwner(shared_ptr<UpdateNodeOwnerRequest> request);
  UpdateNodeRunModeResponse updateNodeRunModeWithOptions(shared_ptr<UpdateNodeRunModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNodeRunModeResponse updateNodeRunMode(shared_ptr<UpdateNodeRunModeRequest> request);
  UpdateQualityFollowerResponse updateQualityFollowerWithOptions(shared_ptr<UpdateQualityFollowerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateQualityFollowerResponse updateQualityFollower(shared_ptr<UpdateQualityFollowerRequest> request);
  UpdateQualityRuleResponse updateQualityRuleWithOptions(shared_ptr<UpdateQualityRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateQualityRuleResponse updateQualityRule(shared_ptr<UpdateQualityRuleRequest> request);
  UpdateRemindResponse updateRemindWithOptions(shared_ptr<UpdateRemindRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRemindResponse updateRemind(shared_ptr<UpdateRemindRequest> request);
  UpdateTableResponse updateTableWithOptions(shared_ptr<UpdateTableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableResponse updateTable(shared_ptr<UpdateTableRequest> request);
  UpdateTableAddColumnResponse updateTableAddColumnWithOptions(shared_ptr<UpdateTableAddColumnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableAddColumnResponse updateTableAddColumn(shared_ptr<UpdateTableAddColumnRequest> request);
  UpdateTableLevelResponse updateTableLevelWithOptions(shared_ptr<UpdateTableLevelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableLevelResponse updateTableLevel(shared_ptr<UpdateTableLevelRequest> request);
  UpdateTableModelInfoResponse updateTableModelInfoWithOptions(shared_ptr<UpdateTableModelInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableModelInfoResponse updateTableModelInfo(shared_ptr<UpdateTableModelInfoRequest> request);
  UpdateTableThemeResponse updateTableThemeWithOptions(shared_ptr<UpdateTableThemeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTableThemeResponse updateTableTheme(shared_ptr<UpdateTableThemeRequest> request);
  UpdateUdfFileResponse updateUdfFileWithOptions(shared_ptr<UpdateUdfFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUdfFileResponse updateUdfFile(shared_ptr<UpdateUdfFileRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Dataworks-public20200518

#endif
